{"pages":[],"posts":[{"title":"處理 Rack Server Error","text":"錯誤訊息：1initialize: Address already in use 解決方式：查詢程序ID 12$ lsof -iTCP:3000$ lsof |grep 3000 刪除卡住程序 1$ kill -9 00000 # 0000 = ID","link":"/2011/11/26/rack-server-error/"},{"title":"Backbone 簡介","text":"前言這篇文章不是要深入探討關於BackboneJS的使用，純粹是因為最近Javascript MVC Framework一直推陳出新。但像小弟資質愚鈍其實剛知道這東西的時候完全不知道她在干嘛。這篇文章只是大略用範例來做些基本的說明。 What is BackboneJS ?Backbone 是一個為前端設計的JavaScript框架。 不同於jQuery專注於簡化DOM的操作和事件繫結。Backbone 提供結構化來達到分離資料模型和DOM。就像是MVC框架分離View，Model，Controller。它讓複雜的JavaScript應用程式更簡單的開發和維護。 為什麼使用Backbone?在jQuery裡，我們可能會使用一連串的事件來指派資料到DOM像以下範例: 123456789//宣告一個資料物件var article = { author:&quot;Joe&quot;, content: &quot;testing&quot;};//透過jQuery Selector選到ID為article的DOM然後繫結事件放入資料等操作$('#article').click(function(event){ $(this).find('.content').text(article.content);}); 接著，看看Backbone. 它提供Model Class和View Class這兩個Backbone最主要的元素。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Hello Backbone&lt;/title&gt; &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://ajax.cdnjs.com/ajax/libs/json2/20110223/json2.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://ajax.cdnjs.com/ajax/libs/underscore.js/1.1.6/underscore-min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://ajax.cdnjs.com/ajax/libs/backbone.js/0.3.3/backbone-min.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot; media=&quot;screen&quot;&gt; .content{width:300px;display:block;border:1px solid #ccc;} #article{width:300px;display:block;} &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; $(function(){ //宣告一個Article的Model，概念上就好像設定 Article 是一個Class的感覺。 var Article = Backbone.Model; //new 一個 article 模型實體包含資料(內容當然可以取自JSON或其他來源) //其實上述的兩個步驟通常也可以用 Backbone.Model.extend 的寫法 var article = new Article({ author:&quot;Joe&quot;, content: &quot;testing&quot; }); /* 核心觀念 定義一個 ArticleView 概念上還是有點像是在設計ArticleView 這個Class */ var ArticleView = Backbone.View.extend({ //el = element 設定對應的DOM el: $('#article'), //初始化 initialize: 和 el: , events: 可以想成是new一個物件時的建構子等事件。 initialize: function(){ //將自訂動作的function和這個DOM綁定,意思就是當其他事件呼叫updateContent 它會自動去影響this //這邊有一點要先搞清楚這個功能是Underscore JS 提供的。 //這邊的功能是當綁定的事件被觸發會影響被綁定的物件。 _.bindAll(this,'updateContent'); //當Model改變時就呼叫updateContent. 可以試著將上面註解掉觀察其不同 this.model.bind('change',this.updateContent); }, //事件綁定 events: { &quot;click .content&quot; : &quot;updateContent&quot; }, //自訂函式 可以理解成操作的動作 updateContent: function(){ this.$('.content').text(this.model.get(&quot;content&quot;)); } }); //上面設計好的Class 就new 一個出來 帶入model資料。 var articleView = new ArticleView({model:article}); //這邊是測試直接改變model 顯示會不會改變 這邊可以把_.bindAll 註解觀察不同點. $('#fire').click(function(){ article.set({content: 'Change Model'}); }); }); &lt;/script&gt; &lt;div id=&quot;article&quot;&gt;Click Me &lt;div class=&quot;content&quot;&gt;Initialize&lt;/div&gt; &lt;/div&gt; &lt;button id=&quot;fire&quot;&gt;Change&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 結論到這邊為止,大致上對於Backbone做的事情有些概略的認識.簡單來說Backbone就是提供一個框架讓我們把既存的JavaScript Code 結構上可以寫成MVC的架構。對於功能單純的程式頁面來說這樣做好相反而會增加大量程式碼，但當頁面功能越來越複雜的時候。好處是其他接手維護的人可以用既定的規則去理解部分的功能。像最上面jQuery的寫法。可能免不了要重頭看到尾。","link":"/2012/01/07/backbone-introducation/"},{"title":"Get gem path","text":"取得Gem環境資訊1$ gem env 取得正在引入gem資訊1234require 'rubygems'require 'cucumber'gem_root = Gem.loaded_specs['cucumber'].full_gem_pathgem_lib = File.join(gem_root, 'lib')","link":"/2011/11/16/find-gem-path/"},{"title":"Sublime Text 2 小技巧：開啓Browser","text":"Open In Browser 設定Step 1開啓Preferences -&gt; Browse Packages… Step 2在HTML目錄底下建立OpenBrowserCommand.py檔案 程式碼貼入 1234567import sublime, sublime_pluginimport webbrowserclass OpenBrowserCommand(sublime_plugin.TextCommand): def run(self,edit): url = self.view.file_name() webbrowser.open_new(self.view.file_name()) Step 3在編輯HTML檔案時，Ctrl + P 開啓指令列輸入 1view.run_command('open_browser') 其他這邊小小記錄一下相關的小技巧，另外其實這個技巧可以找到其他文章是FOR開啓PHP等但因為小弟沒有這個需求，單純因為測試HTML每次都要打開Broswer點兩下感到不舒服＝ ＝","link":"/2012/01/15/sublime-text-2-tip/"},{"title":"Ec2 Note","text":"登入 Login1$ ssh -i /path/key/filename.pem ec2-user@xxx.xxx.xxx.xxx # OR DNS Pub Url 注意：/path/key/filename.pem的權限須為600。 變更登入不使用憑證1234#Edit /etc/ssh/sshd_config#Edit PasswordAuthentication no to yes$ sudo /sbin/service sshd restart #Restart sshd$ passwd ec2-user #Setting ec2-user password 快速安裝LAMP12$ yum groupinstall &quot;Web Server&quot;$ yum groupinstall &quot;MySQL Database&quot; 參考資源阿正老師教你免費玩Amazon EC2雲端主機(上)阿正老師教你免費玩Amazon EC2雲端主機(下)How to create an Amazon EC2 instance with Apache, PHP and MySQL (LAMP)快速安裝 Amazon EC2 LAMP 環境 (EC2 Console)","link":"/2012/03/01/ec2-note/"},{"title":"Model Binding Validation 資料模型的驗證機制","text":"資料模型的驗證機制在物件導向的世界裡有很多種方式可以驗證資料模型(Model Class) 。大部分的情況下我們可以在 Property的 setter 裡面作資料的確認。就是如下程式碼 123456789101112public class Car{ private int _id; public int Id { get{return _id;} set{ // validate here _id = value; } }} 主要的原因是後續使用這個物件的時候不會遇到不符合規則的資料導致物件出例外。第二個理由是 當我們要控制這個屬性的時候比較單純。任何資料要設定到物件的屬性上都是透過 setter 而且可以確保資料是正確符合規範的。事實上在 MVVM 架構下透過 setter 來處理例外和商業邏輯仍然是最簡單的選擇。但假如有一個 Car 類別包含 Color 屬性且資料是根據另一個 Type 類別提供的，然後您就會發現每當您使用 ORM 直接載入物件的時，如果想設定 Color 之前必須先設定 Type 的資料，因為驗證規則寫在 Type 的 setter。 在 ASP.NET MVC 架構下建議您不要直接在 setter 驗證。而是使用 ASP.NET MVC 內建的 ModelState ，它可以透過在 Model 屬性宣告規則或實作 IValidatableObject 然後當資料從 Form 表單透過 Http Request 傳入的時 Model Binding 機制會在繫結時幫您確認資料是否有正確。例如下面 Action， 1public ActionResult Edit(Car car){ ... ModelState 讓您可以在 Controller 的 Action 中判斷資料，在資料儲存之前可以判斷是否有錯誤，然後處理。 123456789101112[HttpPost]public ActionResult Edit(Car car){ if(ModelState.IsValid) { // Update code to be placed here return RedirectToAction(&quot;CarList&quot;); }else { return View(&quot;CarEdit&quot;, car); }} 上面的程式碼描述了關於編輯 Car 物件，程式碼的第一行 ModelState.IsValid 屬性會回傳 true/false 代表本次的驗證是否通過。如果如果模型繫結發生錯誤，或者有商業邏輯上的錯誤， ASP.NET MVC 會告知您或者也可以使用 IValidatable 這個介面實作 Validate Method 在這個 Method 裡面您需要自己實作商業邏輯。每當一個錯誤發生，你就要把錯誤訊息加入錯誤資訊集合然後回傳。下面是一個範例 1234567891011121314151617181920212223public class Car: IValidatableObject{ public int Id{get;set;} public string Name{get;set;} public string Type{get;set;} public string Color{get;set;} public IEnumerable&lt;ValidationResult&gt; Validate(ValidationContext validationContext) { if(string.IsNullOrEmpty(Name)) { yield return new ValidationResult(&quot;Name is mandatory&quot;, new[] {&quot;Name&quot;}); } if(string.IsNullOrEmpty(Type)) { yield return new ValidationResult(&quot;Type is mandatory&quot;, new[]{&quot;Type&quot;}); } if(string.IsNullOrEmpyt(Color)) { yield return new ValidationResult(&quot;Color is mandatory&quot;, new[] {&quot;Color&quot;}); } }} 上面我們看到有三種屬性的驗證規則如果錯誤會透過 yield 敘述式將資訊回傳到集合中。這個錯誤資訊集合是一個泛型，資料型別是 ValidationResult 這個類別讓您可以加入錯誤訊息。 123456789101112131415161718192021222324public class Car: IValidatableObject{ public int Id { get; set; } public string Name { get; set; } public string Type { get; set; } public string Color { get; set; } public IEnumerable&lt;ValidationResult&gt; Validate(ValidationContext validationContext) { if(string.IsNullOrEmpty(Name)) { yield return new ValidationResult(&quot;Name is mandatory&quot;, new[] {&quot;Name&quot;}); } if (string.IsNullOrEmpty(Type)) { yield return new ValidationResult(&quot;Type is mandatory&quot;, new[] { &quot;Type&quot; }); } if (string.IsNullOrEmpty(Color)) { yield return new ValidationResult(&quot;*&quot;, new[] { &quot;Color&quot; }); yield return new ValidationResult(&quot;Color is mandatory&quot;}); } }} 又或者您也可以使用 Data Annotation 的方式定義驗證規則 12345678910public class Car{ public int Id { get; set; } [Required] public string Name { get; set; } [Required] public string Type { get; set; } [Required] public string Color { get; set; }} 現在我們已經可以在執行資料模型繫結順便幫 Model 類別驗證，然後我們就在 Controller 的 Action 中控制整個流程。而且關於資料驗證的規則我們依然把它寫在 Model 裡面。 我們當然不希望任何人可以編輯一個不能用的資料。這時我們就可以在 Action 先做處理。如果該資料不存在或不能用了我們就使用 ModelState.AddModelError 追加錯誤訊息。 12345678910111213141516171819[HttpPost]public ActionResult Edit(Car car){ if(IsCarAvailable()) { ModelState.AddModelError(string.Empty,&quot;Car cannot be edited because not available anymore&quot;); } if(ModelState.IsValid) { //Update code to be placed here return RedirectToAction(&quot;CarList&quot;); } else { return View(&quot;CarEdit&quot;,car); }} 檢索所有的錯誤訊息； 1var allErrors = ModelState.Values.SelectMany(e =&gt; e.Errors).Select(gh =&gt; gh.ErrorMessage); 另外如果在 ASP.NET MVC 中我們也可以透過 Action 和 View 搭配檢查或實驗錯誤。我們先建立一個 Action 如下 123456public ActionResult EditCar(Car car){ // var errors = ModelState.Values.SelectMany(e =&gt; e.Errors).Select(gh =&gt; gh.ErrorMessage); ViewBag.Validation = ModelState.IsValid; return View();} 然後再對應的 View 使用 123456@ViewBag.Validation@foreach (ModelState modelState in ViewData.ModelState.Values) { foreach (ModelError error in modelState.Errors) { &lt;li&gt;@error.ErrorMessage&lt;/li&gt; }}","link":"/2013/03/13/model-binding-validation/"},{"title":"CSS 覆寫規則","text":"你是否曾經遇過這種情形，當您試著要套用某個 CSS 規則到元素的時候，它就是不產生變化。網頁看起來就是忽略了您的 CSS ，然後根本搞不清楚到底是為什麼。也許您使用了 !important 作為您最後的手段，這裡就有一個很好的機會來理解 CSS 選擇器的優先順序。 深入理解 CSS 優先順序可以幫助你減少 CSS 挫折，讓你的程式碼更加簡潔，更有組織，所以讓我們來看看三個控制 CSS 的規則。 選擇器的權重計算(Specificity) 繼承 CSS 規則的累加 精通這些規則將會帶領你進入 CSS 開發的下一個層次 選擇器的權重計算舉例來說您有一個 p 標籤包含著一段文字，設定如下 123456&lt;style&gt;p {font-size: 12px;}p.bio{font-size: 36px;}&lt;/style&gt;&lt;p class='bio'&gt;text here&lt;/p&gt; 您會猜測上面這個範例文字應該是 36px，第二句的選擇器 p.bio 更明確的指向該元素。 然而有些時候選擇器並不是那麼單純好分辨。 12345678&lt;div id='sidebar'&gt; &lt;p class='bio'&gt;text here&lt;/p&gt;&lt;/div&gt;&lt;style&gt;div p.bio {font-size: 14px;}#sidebar p {font-size: 12px;}&lt;/style&gt; 乍看之下第一句 CSS 看起來更明確的指定元素，但實際上顯示的樣式是第二行。 為什麼？ 要回答這個問題，我們需要考慮 CSS 的選擇器的權重計算。 關於 CSS 選擇器權重計算，是透過計算每個樣式的組成然後產生一組表達式(a,b,c,d) 元素，構造虛擬類別元素(a:root) =&gt; d = 1 // (0,0,0,1) class, 虛擬類別(a:hover), 屬性 =&gt; c = 1 // (0,0,1,0) Id =&gt; b = 1 // (0,1,0,0) Inline Style =&gt; a = 1 // (1,0,0,0) 你可以透過上述的規則開始計算選擇器的權重，算法就是每使用到一種就在該欄位(a,b,c,d) 加 1。注意：(0,0,1,0) 的明確性大於 (0,0,0,15) 範例如下： p: 1 element – (0,0,0,1) div: 1 element – (0,0,0,1) #sidebar: 1 id – (0,1,0,0) div#sidebar: 1 element, 1 id – (0,1,0,1) div#sidebar p: 2 elements, 1 id – (0,1,0,2) div#sidebar p.bio: 2 elements, 1 class, 1 id – (0,1,1,2) 所以上面 sidebar 的範例就會是如下 1234div p.bio{font-size: 14px;} //(0,0,1,2)#sidebar p{font-size: 12px;} //(0,1,0,1) 最後在我們繼續往下之前要先瞭解。!important 勝過 Specificity。 12div p.bio {font-size: 14px !important}#sidebar p {font-size: 12px} 事實上，如果你能明確知道規則的優先順序你應該是不需要使用 !important。 繼承繼承背後的想法是比較容易理解的。元素繼承父容器的樣式。如果你設置 body 標籤，color: red; 然後 body 內的所有元素的文本字體也將是紅色的，除非另外有其他設定。 但是並非所有的 CSS 屬性都是可繼承的。例如 margin 和 padding 是非繼承的屬性。如果您對一個 div 設置了 margin 和 padding 。你會發現 div 裡面的段落沒有繼承你的 div 設置 margin 和padding。該段將使用預設的瀏覽器margin 和 padding，直到有另外的設定。 你可以使用明確宣告設定屬性的繼承，從它的父容器繼承樣式： 1p {margin: inherit; padding: inherit} 然後 p 就會繼承包復他的父元素。 CSS 規則的累加CSS 規則的累加與優先順序的工作原理如下。 1. 找到所有的 css 宣告和對應的元素。2. 根據原始碼和優先權排序。3. !important 優先4. 頁面設定為優先12345678&lt;style&gt;p {font-size: 12px}&lt;/style&gt;~~~ #### 5. 外部載入~~~html&lt;link rel='stylesheet' href='style.css' /&gt; 6. 選擇器的權重計算(Specificity)7. 如果兩個規則相等則宣告的最後宣告的規則會覆寫。","link":"/2013/08/27/css-write-rules/"},{"title":"Linux&#x2F;Windows RSA Key 常用指令","text":"123$ ssh-keygen -t rsa -C &quot;youraccount@com.tw&quot; #建立金鑰$ ssh-add ~/.ssh/id_rsa #加入金鑰$ ssh-add -l #列出金鑰清單 Error狀況: Could not open a connection to your authentication agent 12$ ssh-agent bash$ ssh-add Permissions 0644 for ‘/c/Users/HelloWorld/.ssh/id_rsa’ are too open. 12$ cd ~/.ssh$ chmod 700 id_rsa","link":"/2011/11/16/authentication-agent/"},{"title":"viewport 與 media query","text":"簡易觀念整個 Responsive Web Design 最主要的就是靠 css 中的 media query 搭配 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; 這兩個部分來達成。 簡言之就是透過 1@media screen and (max-width:420px){ // css here } 來針對各種 size 的 width 做對應的設計，而裝置瀏覽器的解析度又可以使用 meta 來設定，就可以使用百分比來處理設計。原理的概念大致就如上敘述。 隨著智慧型手機上網越來越多的情況下 apple 率先在 safari 定義了一個 meta viewport 用來設定瀏覽器的解析度。預設來說，如果都不設定的情況 safari 會用 width = 980px 去解析網頁，Android 2.x 是 800px ，Android 3.0+ 為 980px。 注意螢幕解析度不一定等於 device-width，Nexus One 是螢幕解析度(800)不等於device-width(320)的典型例子，iPhone4也是 – 螢幕解析度(960)，但 device-width 傳回值為(320)。 原理這邊讓我們先回到影像處理的基本單位 pixel，一張 800*600 pixel 的數位影像 可以想成是 800*600 個”單色格子”組出這張圖片，這就是單純圖片像素的定義。 接著螢幕的呈像：例如設定 800*600 解析度，表示在你的螢幕上總共要顯示只要顯示這麼多格子，所以如果你螢幕很大。但是解析度設的很小（640*480） 就會看到影像變大了，因為一個”物理格子”變大了。換句話說 長跟寬各由 1024 及 768 個像素組合而成的長方形，面積共786432像素（長x寬）的顯像螢幕；此時，若有一個1024x768的圖檔，則它剛好可以填滿整個螢幕。 關於 viewport1&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1.0, width:device-width&quot; /&gt; viewport 的作用是告訴瀏覽器，讀取這個 html 時可視區域有多大，於是瀏覽器就會根據 viewport 的設定去調整。其中最重要的是 width＝device-width 等於是告訴瀏覽器，寬有幾個 pixel 他會覆寫本來預設是 980px 的預設值 所以會發現網站的圖片變大了。例如：本來設計的手機版網頁寬是 590px 就可以在 viewport 設定 width=590。如此一來整個網頁就會完整呈現，但視覺上會變小。延伸自適應網站設計的用法則是讓 width=device-width，再透過 CSS 去設計各種手機尺寸的版型 如 320 * 480。 屬性和值 width:[數字] 或 device-width height:[數字] 或 device-height initial-scale:最小0.25，最大5 minimum-scale:最小0.25，最大5 maximum-scale:最小0.25，最大5 user-scalable:1 或 0 (yes 或 no)","link":"/2013/08/28/viewport-with-media-query/"},{"title":"CSS 選擇器筆記","text":"* 通用選擇器 -&gt; 套用所有元素 1* {color: yellow;} 類型選擇器 1h1 {color: red;} id 1#container {color: skyblue;} class 1.span2 { color: hotpink;} 屬性 過濾對應標籤元素中的屬性 &lt;a rel=&quot;friend&quot; href=&quot;http://www.w3c.com/&quot;&gt;w3c&lt;/a&gt; a[rel='friend'] {color: blue;} a[attr=’value’] 全部都要符合。 a[attr*=’value’] 只要有包含 value 都會被選中。 a[attr^=’value’] 只要開頭有都會被選中。 a[attr$=’value’] 只要結尾有 value 都會中。 a[attr~=’value’] 以空格隔開的字串清單中，符合的就會中。 a[attr|=’value’] 以 - 隔開的字串清單中，如果開頭包含字串 value 。需要注意的是下圖 f 沒有被選中。 div p div 裡面的 p 都會被選中。 div &gt; p 只有 div 內第一階的子元素會被選中。 div + ul 跟 div 同階層並緊跟著 div 後面的 ul 才會被影響。 div ~ p div 同階層後面所有的 p。 a, em 套用同一個設定。","link":"/2013/08/28/css-selector-notes/"},{"title":"Box 屬性意義","text":"display: block : 前後會插入換行，寬會填滿父元素，高則是配合內容。可以用 width, height 設定。預設: h1, p, div display: inline : 不會換行，會連成一行。寬高都是依照內容，且不能使用 width, height。預設: span, a, em display: inline-block : 跟 inline 一樣，但能夠使用 width, height 設定寬高。 display: list-item : 變成 marker + block。 display: run-in : 如下圖 h2 被指定 run-in 它就會變成 inline 後續的元素如果是 block 就會如圖一樣合體。但是後續的元素如果是 inline 或者套用了 float, position ，那麼 h2 就會是 block。 註: Firefox 和 IE7 目前都不支援 run-in display: none : 隱藏 display: table : 表格 &lt;style type=&quot;text/css&quot;&gt; #container { overflow: hidden; display:table; width: 100%; } .row {display:table-row;} .row div {display: table-cell;} .a {background:#00ff00;} .b {background:#ff00ff;} .c {background:#0000ff;} &lt;/style&gt; &lt;div id=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;a&quot;&gt; test&lt;br /&gt;test&lt;br /&gt;test&lt;br /&gt;test&lt;br /&gt;test&lt;br /&gt;test&lt;br /&gt;test &lt;/div&gt; &lt;div class=&quot;b&quot;&gt; test &lt;/div&gt; &lt;div class=&quot;c&quot;&gt; test &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; display: compact : 可以插入在後續 block 的 margin 區域。","link":"/2013/08/29/meaning-box-properties/"},{"title":"Compass 整理筆記","text":"使用 Compass 之前需要先安裝 ruby，這裡我們可以透過官方的教學來安裝，建議使用 rvm 的方式來管理各種版本的 ruby。 rvm 安裝方式1$ \\curl -L https://get.rvm.io | bash -s stable --ruby 設定 ruby 環境123$ gem update --system$ gem install compass$ compass -v // 確認版本與安裝完成 建立專案12$ compass create Project1 // 單純使用 css$ compass create Project2 --syntax sass // 使用 sass 建立之後 compass 會提示訊息告訴你， Congratulations! Your compass project has been created.意思是恭喜，你的專案已經建立了。然後呢如果你是用 sass，你現在應該在 sass 的目錄底下開始新增和編輯你的 sass 檔案例如： style.sass注意：底線開頭的 sass 檔案叫做 partials 可以稱之為局部文件如 _member.sass，他們不會被編譯成單檔而是匯入其他 sass 檔案中使用。關於 sass 的設定都在 config.rb 裡面。當你做了任何修改，你都需要重新編譯。 編譯指令1$ compass compile [專案路徑] // 到目錄為止 開始編寫 sass在這之前呢， compass 會好心的提醒你需要把下面這段代碼引入到你的 html 中 1234567&lt;head&gt; &lt;link href=&quot;/stylesheets/screen.css&quot; media=&quot;screen, projection&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;link href=&quot;/stylesheets/print.css&quot; media=&quot;print&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;!--[if IE]&gt; &lt;link href=&quot;/stylesheets/ie.css&quot; media=&quot;screen, projection&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;![endif]--&gt;&lt;/head&gt; 如果你跟我一樣是使用 jade 的話則如下 1234567link(rel='stylesheet', href='/stylesheets/screen.css', media='screen, projection', type=&quot;text/css&quot;)link(rel='stylesheet', href='/stylesheets/print.css', media='print', type=&quot;text/css&quot;)//[if IE] link(rel='stylesheet', href='/path/project') &lt;![endif] 然後我們就可以試著在 sass 目錄加入自己的 style.sass並且輸入如下 12h2 color: red; 最後 compile 之後就可以看看了。","link":"/2013/08/30/compass/"},{"title":"Grunt 系列(1) 基礎教學","text":"Grunt 入門Grunt 和 Grunt 擴充套件 都是透過 npm 來安裝和管理。Grunt 這個工具大概就等於 Ruby 中的 rake ，它可以透過一些設定讓你輕鬆完成一些例行性的任務，例如壓縮檔案，編譯 coffee less，搬移到目標目錄，單元測試等等。之後就可以透過一個指令，就把所有的事情做好。 安裝為了能夠使用 Grunt 你必須安裝 grunt-cli 就是 Grunt 的 Command Line Interface 到您的系統。安裝過程可能會需要 sudo 或這在 windows 底下使用管理者身份執行。 1$ npm install -g grunt-cli 在 npm 使用 -g 就會把該套件裝至系統路徑，這樣您就可以在任何目錄使用 grunt-cli注意：安裝了 grunt-cli 並不是安裝 Grunt task runner。 grunt-cli 本身的任務非常單純，他就只是使用你已經安裝的 Grunt 版本去執行 Gruntfile.js。這樣你就可以在同一台機器，運行不同版本的 grunt 了。 CLI如何運作每一次執行 grunt，他會用require()去引入本地的 grunt，注意不是 cli。也因次你可以在不同專案目錄底下運行不同版本的 grunt。一旦 grunt 被載入了，接著就會載入 Gruntfile 然後根據裡面的設定去運行任務。如果你想理解原理可以閱讀程式碼 https://github.com/gruntjs/grunt-cli/blob/master/bin/grunt 如何使用已經存在的 Grunt 專案假如您的 cli 已經安裝了，並且有一個專案也已經設定好 package.json 和 Gruntfile.js。那你可以非常輕鬆地就開始使用 grunt 切換到專案的根目錄 使用 npm install 安裝相依的套件。 執行 grunt 就可以開始跑了。 如果你想瞭解更多關於 grunt 的命令，你可以使用 grunt --help 會列出例如：clean, coffee。這些都是靠 Grunfile 定義的。預設是空的沒有任何任務Sails 建立的 Gruntfile 建立一個新的 Grunt 專案要建立一個 Grunt 專案涉及到最重要的兩個檔案的建立 package.json 和 Gruntfile.js。 package.json : 這是 npm 用來儲存 matadata 的檔案，簡單說就是 npm 對於這個專案相關的設定擋。包含相依的套件，一旦在這邊設定，您就可以透過 npm install 來安裝相依的套件。一般在使用時，我們也會用 npm install --save 在安裝後順便把設定加到 package.json。你也會在這個檔案設定 grunt 和 grunt 套件相依的一些函式庫或元件。通常會像下面程式碼片段，指的是開發階段使用的套件。 &quot;devDependencies&quot;: { &quot;mocha&quot;: &quot;*&quot;, &quot;request&quot;: &quot;*&quot;, &quot;wrench&quot;: &quot;~1.5.1&quot; } Gruntfile : 這個檔案通常會是 Gruntfile.js 或者 Gruntfile.coffee 他被用來設定任務，載入外掛。 package.jsonpackage.json 通常和 Gruntfile 都在專案的根目錄。而且必須和你的專案一起被送交。在根目錄下 npm install 就會根據 package.json 去安裝相依的套件。而且還能指定版本。下面提供一些簡單的方式快速建立 package.json 大部份的 grunt-init 模版都會自動建立 package.json。而 grunt-init 這個指令是需要在安裝的。 npm init 直接執行 npm init 就會一步一步詢問你相關的參數，協助您建立 package.json 手動建立 { &quot;name&quot;: &quot;my-project-name&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;devDependencies&quot;: { &quot;grunt&quot;: &quot;~0.4.1&quot;, &quot;grunt-contrib-jshint&quot;: &quot;~0.6.3&quot;, &quot;grunt-contrib-nodeunit&quot;: &quot;~0.2.0&quot;, &quot;grunt-contrib-uglify&quot;: &quot;~0.2.2&quot; } } 安裝 Grunt 和 Grunt 套件安裝 Grunt 和 Grunt 套件並且加入 package.json 最簡單的方式就是執行 npm install &lt;module&gt; --save-dev它不只會安裝該套件模組還會新增或更新 package.json 。範例： npm install grunt –save-dev/* 測試透過 npm 安裝同一個套件，不同版本*/npm install jquery@1.7.2 –save-devnpm install jquery@1.8.3 –save-dev GruntfileGruntfile.js 或 Gruntfile.coffee 都必須是合法正確的 javascript 或 coffee 。他們通常放在專案的根目錄下。跟 package.json 同一層，也一樣必須要被提交。一個 Gruntfile 包含下面這幾個部分： 把所有動作包起來的 function 專案和任務的設定 載入的 Grunt 套件和任務(別人已經寫好的) 自訂的任務 Gruntfile 範例在下面的範例中，關於 project 的 metadata 等資料是透過讀取 package.json 取得，並在 grunt 中使用。使用 grunt-contrib-uglify 套件的uglify任務是用來設定壓縮檔案並根據專案的 metadata 產生一些註解。當 grunt 開始執行，預設就會執行 uglify 任務 module.exports = function(grunt) { // Project configuration. grunt.initConfig({ pkg: grunt.file.readJSON('package.json'), uglify: { options: { banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&gt; */\\n' }, build: { src: 'src/&lt;%= pkg.name %&gt;.js', dest: 'build/&lt;%= pkg.name %&gt;.min.js' } } }); // Load the plugin that provides the &quot;uglify&quot; task. grunt.loadNpmTasks('grunt-contrib-uglify'); // Default task(s). grunt.registerTask('default', ['uglify']); }; 整個 Gruntfile 大致上就如上面這樣，後續我們將一步一步介紹每個組成部份。 The “wrapper” function (把所有動作包起來的 function)每一個 Gruntfile 或者 Grunt 套件都使用這個基本的定義格式，而你所有要讓 Grunt 執行的程式碼都必須被包在這個 function 中。 module.exports = function(grunt){ // Do grunt-related things in here } 專案和任務設定絕大多數的 Grunt 任務都透過定義一個包含所有設定資料的物件，然後把物件傳給 grunt.initConfig 方法來設定的。在上面的範例中，grunt.file.readJSON('package.json') 匯入了一個 JSON 格式的檔案，JSON 讀取至 javascript 中便是一個 object。接著在 Gruntfile 中可以使用 &lt;% %&gt; 這樣的語法，中間可以帶入其他設定的屬性，例如檔案路徑。你可能會隨便存一些資料到設定裡面，只要屬性不要衝突即可，否則會被忽略。這其實也是因為在 Javascript 中，你不能去限制 JSON 就像大部份的任務，grunt-contrib-uglify 的 uglify 任務預計會在同名的屬性中取得設定，在下面的範例中，我們在 options 設定了 banner，然後設定了 build 裡面指定了 src 和 dest 。整段範例的意思就是取得 package.json 中的 name ，接著去 src 目錄中取得 name.js 檔案並且把它壓縮成 name.min.js 。到這邊為止的 code 都只是設定而已。 // Project configuration. grunt.initConfig({ pkg: grunt.file.readJSON('package.json'), uglify: { options: { banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&gt; */\\n' }, build: { src: 'src/&lt;%= pkg.name %&gt;.js', dest: 'build/&lt;%= pkg.name %&gt;.min.js' } } }); 載入 Grunt 和 Grunt 套件大部份的任務例如串聯檔案，壓縮，都已經有現成的套件可以使用了，只要在 package.json 中設定並安裝，就可以使用。安裝完之後，就是在 Gruntfile 中載入 // Load the plugin that provides the &quot;uglify&quot; task. grunt.loadNpmTasks('grunt-contrib-uglify'); 載入之後透過 grunt --help 就可以列出目前可以執行的任務，注意：initConfig 是在 grunt 初始化時針對任務做一些設定。於是真正在執行的時候就會去套用設定，例如上面我們載入了 grunt-contrib-uglify，之後我們就可以下達指令：grunt uglify。就會照著我們設定的把一支跟專案名稱一樣的 .js 壓縮成 .min.js。 自訂任務您可以在預設就讓 grunt 執行多個任務，只要透過 default 設定，接著我們執行 grunt 的時候就會照著預設任務去執行。如下範例，我們把 uglify 註冊到 default 。這樣我們就不用特別單獨執行 grunt uglify ，只要執行 grunt 或者 grunt default 就會執行下面壓縮檔案的這個任務。需要指定的任務可以加入下面程式碼 [‘uglify’] 中的這個陣列。它可以執行多個任務。 // Default task(s). grunt.registerTask('default', ['uglify']); 不過如果你想要執行的任務或需求並沒有任何 Grunt 套件，您也可以自訂在 Gruntfile 裡面 module.exports = function(grunt) { // A very basic default task. grunt.registerTask('default', 'Log some stuff.', function() { grunt.log.write('Logging some stuff...').ok(); }); }; 以上我們就完成了 Grunt 入門的使用了","link":"/2013/09/27/grunt/"},{"title":"HTML Tag","text":"&lt;h1&gt; - &lt;h6&gt; 標題 &lt;p&gt; 文字段落，注意在裡面的空白，無論連續幾個都會被當做一個。此時可以使用 &amp;nbsp; &lt;b&gt; 粗體 &lt;i&gt; 斜體 &lt;sup&gt; 文字一半，並往上半部移動 ex 數學 2 的平方 &lt;sub&gt; 文字一半，往下移動 ex 化學符號 &lt;br&gt; 換行 &lt;hr&gt; 加入橫線 &lt;strong&gt; 語意表示重要強調，視覺會變粗體。 &lt;em&gt; 強調，表示語氣轉變。視覺會變斜體。 &lt;blockquote&gt; 引用一整段文字。 &lt;q&gt; 短句或單字引用，視覺會出現 “ “ ，但是 IE 不會。 &lt;abbr title='description'&gt;Desc&lt;/abbr&gt; 縮寫，title 可以放入完整單字。 &lt;cite&gt; 引用，出處。視覺會變斜體。 &lt;dfn&gt; 定義專業術語。 &lt;address&gt; 作者資訊，可搭配 hCards 格式內容。範例如下： &lt;div id=&quot;hcard-Joe-Monkey&quot; class=&quot;vcard&quot;&gt; &lt;span class=&quot;fn&quot;&gt;Joe Monkey&lt;/span&gt; &lt;div class=&quot;org&quot;&gt;ACME Banana&lt;/div&gt; &lt;div class=&quot;adr&quot;&gt; &lt;span class=&quot;type&quot;&gt;Work&lt;/span&gt;: &lt;div class=&quot;street-address&quot;&gt;314 Monkey Avenue&lt;/div&gt; &lt;span class=&quot;locality&quot;&gt;Monkey Island&lt;/span&gt;, &lt;abbr class=&quot;region&quot; title=&quot;California&quot;&gt;CA&lt;/abbr&gt; &lt;span class=&quot;postal-code&quot;&gt;94301&lt;/span&gt; &lt;div class=&quot;country-name&quot;&gt;USA&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;tel&quot;&gt; &lt;span class=&quot;type&quot;&gt;Work&lt;/span&gt; +1-555-555-5555 &lt;/div&gt; &lt;div class=&quot;tel&quot;&gt; &lt;span class=&quot;type&quot;&gt;Fax&lt;/span&gt; +1-555-555-5555 &lt;/div&gt; &lt;div&gt;Email: &lt;span class=&quot;email&quot;&gt;joe@acmebanana.com&lt;/span&gt; &lt;/div&gt; &lt;a class=&quot;url&quot; href=&quot;aim:goim?screenname=monkeybites&quot;&gt;AIM&lt;/a&gt; &lt;/div&gt; &lt;ins&gt; 插入文字，會有底線。 &lt;del&gt; 刪除文字，中間會有橫線杠掉。 &lt;s&gt; 表示資料不再精確，跟 del 一樣會橫線杠掉，但這不代表刪除的語義。 &lt;a&gt; 有三種用法 一般網頁連結, 錨點, Email &lt;img&gt; &lt;figure&gt; &lt;figcaption&gt; &lt;table&gt; &lt;thead&gt; &lt;tbody&gt; &lt;tfooter&gt; &lt;tr&gt; &lt;td&gt; &lt;th&gt; &lt;ol&gt; &lt;ul&gt; &lt;li&gt; &lt;dl&gt; &lt;dt&gt; &lt;dd&gt; &lt;form&gt; &lt;input&gt; &lt;select&gt; &lt;textarea&gt;","link":"/2013/09/18/html-tag/"},{"title":"Entity Framework Code First Migration","text":"大綱本練習將介紹 Entity Framework Code First Migration 整個使用的概觀:主題包含: 啟動 Migrations. 建立與執行 Migrations. 自訂 Migrations. 資料遷移和使用SQL指令. 遷移指定的版本. 建立 SQL Script. 程式啟動時自動更新資料結構. 建置初始化Model和資料庫在我們開始介紹如何使用資料庫遷移(Migrations)之前我們需要一個專案和 Model。在這個練習中我們將模擬一個 Blog 建立 Blog 和 Post 的 Model。 新增主控台應用程式 (Console Project) 並命名為 MigrationsDemo。 透過 Nuget 安裝最新版的 EntityFramewrok。2-1. 工具 -&gt; 程式庫套件管理員 -&gt; 套件管理員主控台。2-2. 執行 Install-Package EntityFramework 指令。2-3. 加入一個 Model.cs 類別程式碼如下: 12345678910111213141516using System.Data.Entity;using System.Collections.Generic;using System.ComponentModel.DataAnnotations;using System.Data.Entity.Infrastructure;namespace MigrationsDemo{ public class BlogContext:DbContext { public DbSet&lt;Blog&gt; Blogs { get; set; } } public class Blog { public int BlogId { get; set; } public string Name { get; set; } }} 上面的程式碼定義了 Blog 類別和一個 BlogContext 類別 (BlogContext 類別繼承了 DbContext，而 DbContext，而 類別是簡化過的 Context 類別官方建議在Code first 模式下使用。)現在我們有了 Model 可以用它來執行資料存取，接著更新 Program.cs 程式碼如下: 1234567891011121314151617181920212223242526272829using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace MigrationsDemo{ class Program { static void Main(string[] args) { using (var db = new BlogContext()) { db.Blogs.Add(new Blog { Name=&quot;Another Blog&quot;}); db.SaveChanges(); foreach (var blog in db.Blogs) { Console.WriteLine(blog.Name); } Console.WriteLine(&quot;Press any key to exit...&quot;); Console.ReadKey(); } } }} 執行應用程式您將會看到 MigrationsDemo.BlogContext 被建立了。您可能會疑惑此時我們完全沒有設定任何相關的連線字串也沒有指定任何資料庫。如果您練習的電腦有安裝 SQL Express 則預設 Code First 機制會先搜尋本機的 .\\SQLEXPRESS。如果您沒有安裝 SQL Express 則 Code First 會嘗試使用(LocalDb)\\v11.0 來建立資料庫。一般來說 Visual Studio 2010 預設安裝會包含 SQL Express。而 Visual Studio 2012 則預設安裝包含 LocalDb。注意如果您兩個都有安裝的話 SQL Express 會優先使用。 啟動 Migrations在 Code First 模式下 Migrations 資料庫遷移指的是一種機制讓我們可以修改資料庫，資料表結構。 接著編輯 Model，在 Blog類別中加入一個 Url 的屬性(Property)。 1public string Url{ get; set; } 完成之後讓我們直接運行程式(F5)。這個時候您會得到一個 InvalidOperationException 例外。意思是 Model 已經變更了，因此無法跟已存在的資料庫對應。 此時例外的提示資訊會建議我們啟動 Code First Migrations 接著我們就在【套件管理員主控台】執行: 1Enable-Migrations 這個指令會加入一個 Migrations 目錄。裡面會新增兩個檔案: 設定類別 (Configuration.cs)這個類別可以讓您自訂一些資料庫遷移時的行為，意思就是當我們要變更資料結構時可以追加一些設定。例如: 使用 Seed() 在建立資料表時幫您補上預設的資料，或者幫欄位設定預設值。 資料遷移檔 ([時間戳記]_InitialCreate.cs)主要的資料遷移檔案是一個關於建立資料表，修改資料結構的 Script 。因為我們已經利用 Code First 幫我們建立了一個資料庫，所以這個遷移檔就會根據目前的資料庫結構產生一個對應的遷移檔。在我們這個範例中您會看到: 12345678CreateTable( &quot;dbo.Blogs&quot;, c =&gt; new { BlogId = c.Int(nullable: false, identity: true), Name = c.String(), }) .PrimaryKey(t =&gt; t.BlogId); 很明顯的我們看到程式建立了一張資料表 Blog 只包含 BlogId 和 Name 欄位。如果此時我們都沒有建立資料庫，這個遷移檔就不會被建立，直到我們第一次呼叫 Add-Migration 指令才會產生。另外當我們要做一次結構變更時就是使用: 1Add-Migration [name] 建立與執行 MigrationsCode First 的 Migrations 機制主要有兩個指令。這兩個指令很重要必須要熟悉它們。 Add-Migration會基於您這次對 Model 做得變更產生出新的資料遷移檔 (Migration) Update-Database就會把關於 Migration 和 Configuration 檔的內容對資料庫產生實際的變動。 現在我們需要對我們已經變更的 Model 產生一個 Migration 檔 1. 執行下面的指令1Add-Migration AddBlogUrl 2. 在 Migraions 目錄底下我們看到了一個新增的遷移檔。看看內容1234public override void Up(){ AddColumn(&quot;dbo.Blogs&quot;, &quot;Url&quot;, c =&gt; c.String());} 大概就可以知道資料遷移檔幫我們對 Table 新增了欄位。接著就可以執行: 1Update-Database Code First Migrations 機制就會幫我們去比對每一個資料庫遷移檔然後對資料庫做修改。 自訂 Migrations目前為止，我們建立並執行了 Migration 但我們並沒有改變任何關於遷移檔的設定。讓我們來看看如何修改預設產生的遷移檔。 1. 對 Model 修改，增加一個 Rating 屬性:1public int Rating { get; set; } 2. 接著再新增一個 Post 類別:12345678910public class Post { public int PostId { get; set; } [MaxLength(200)] public string Title { get; set; } public string Content { get; set; } public int BlogId { get; set; } public Blog Blog { get; set; } } 3. 建立完成後我們再對 Blog 類別增加:1public virtual List&lt;Post&gt; Posts { get; set; } 再次使用 Add-Migration 來替我們產生遷移檔執行 1Add-Migration AddPostClass Code Fist Migrations 機制很盡責地幫我們對應結構產生了 Migration 檔，但在這邊我們想要作一些改變。 1. Posts.Title 欄位不得重複(unique)1.Index(p =&gt; p.Title, unique: true); 2. 不得為 null我們也增加了一個不得為 null 的 Blogs.Rating 欄位。如果有任何資料已存在資料表中將會得到 CLR 資料型別的預設值，例如 Rating 是 int 如果 Blog 資料表已經有資料那這欄位就會得到 0 。在這邊我們也透過修改遷移檔把預設值變成 3 。完成的範例如下: 123456789101112131415161718192021222324252627282930313233343536namespace MigrationsDemo.Migrations{ using System; using System.Data.Entity.Migrations; public partial class AddPostClass : DbMigration { public override void Up() { CreateTable( &quot;dbo.Posts&quot;, c =&gt; new { PostId = c.Int(nullable: false, identity: true), Title = c.String(maxLength: 200), Content = c.String(), BlogId = c.Int(nullable: false), }) .PrimaryKey(t =&gt; t.PostId) .ForeignKey(&quot;dbo.Blogs&quot;, t =&gt; t.BlogId, cascadeDelete: true) .Index(t =&gt; t.BlogId) .Index(p =&gt; p.Title, unique: true); AddColumn(&quot;dbo.Blogs&quot;, &quot;Rating&quot;, c =&gt; c.Int(nullable: false, defaultValue: 3)); } public override void Down() { DropIndex(&quot;Posts&quot;, new[] { &quot;Title&quot; }); DropIndex(&quot;dbo.Posts&quot;, new[] { &quot;BlogId&quot; }); DropForeignKey(&quot;dbo.Posts&quot;, &quot;BlogId&quot;, &quot;dbo.Blogs&quot;); DropColumn(&quot;dbo.Blogs&quot;, &quot;Rating&quot;); DropTable(&quot;dbo.Posts&quot;); } }} 當我們完成所有的編輯就可以使用 Update-Database 去修改資料庫實際的表格結構，這一次我們使用 -Verbose 參數來看看實際執行Migration時的詳細資料: 1Update-Database -Verbose 當我們使用這個指令時就會看到: 1234567891011121314151617181920PM&gt; Update-database -verboseUsing StartUp project 'MigrationsDemo'.Using NuGet project 'MigrationsDemo'.Specify the '-Verbose' flag to view the SQL statements being applied to the target database.Target database is: 'MigrationsDemo.BlogContext' (DataSource: (localdb)\\v11.0, Provider: System.Data.SqlClient, Origin: Convention).Applying code-based migrations: [201303100605244_AddPostClass].Applying code-based migration: 201303100605244_AddPostClass.CREATE TABLE [dbo].[Posts] ( [PostId] [int] NOT NULL IDENTITY, [Title] [nvarchar](200), [Content] [nvarchar](max), [BlogId] [int] NOT NULL, CONSTRAINT [PK_dbo.Posts] PRIMARY KEY ([PostId]))CREATE INDEX [IX_BlogId] ON [dbo].[Posts]([BlogId])CREATE UNIQUE INDEX [IX_Title] ON [dbo].[Posts]([Title])ALTER TABLE [dbo].[Blogs] ADD [Rating] [int] NOT NULL DEFAULT 3ALTER TABLE [dbo].[Posts] ADD CONSTRAINT [FK_dbo.Posts_dbo.Blogs_BlogId] FOREIGN KEY ([BlogId]) REFERENCES [dbo].[Blogs] ([BlogId]) ON DELETE CASCADE[Inserting migration history record]Running Seed method. 資料遷移和使用SQL目前為止我們看過了關於資料遷移的操作，但我們並沒有改變或搬移任何資料，讓我們複習一下目前為止重要的指令: 123Enable-MigrationsAdd-Migration [name]Update-Database -Verbose 有些情況下我們需要搬移資料。目前 Migration 機制還沒有支援資料搬移，但我們可以透過使用 SQL 指令來完成這個任務。新增一個 Post.Abstract 1public string Abstract { get; set; } 然後我們想要預先為已存在的 Post 資料列填入 Abstract(摘要) 而且這些內容要從 Content 取得。編輯Model之後執行: 1Add-Migration AddPostAbstract 執行完 Add-Migration 之後遷移檔中就幫我們設定了關於資料表結構變更的程式但是我們想要預先將 Content 欄位中的前 100 個字元填入 Abstract接著讓我們修改遷移檔 12345678910111213141516171819namespace MigrationsDemo.Migrations{ using System; using System.Data.Entity.Migrations; public partial class AddPostAbstract : DbMigration { public override void Up() { AddColumn(&quot;dbo.Posts&quot;, &quot;Abstract&quot;, c =&gt; c.String()); Sql(&quot;UPDATE Posts SET Abstract = LEFT(Content, 100) WHERE Abstract IS NULL&quot;); } public override void Down() { DropColumn(&quot;dbo.Posts&quot;, &quot;Abstract&quot;); } }} 編輯完成之後讓我們再度執行 Update-Database 遷移指定的版本(包含降版)到這一小節我們都是升級最新的 Migration 檔，但有可能有些時候你想要升級/降級到特定的遷移檔。假設我們想要改變資料庫到 AddBlogUrl 這個遷移檔我們可以使用 TargetMigration 切換到降版 執行 1Update-Database –TargetMigration: AddBlogUrl 這個指令會執行程式中 Down() 的 Script 一路從 AddBlogAbstract 一直往下降版本，所以這邊要注意的是每一版和上一版之間的 Down() 如果有自訂的設定也要有對應的還原。 建立 SQL Script如果其他的開發者想要在他們的機器執行這些改變，他們只需要在版本控制系統取得每一次的改變(資料庫遷移檔)。每當我們更新他們就可以透過 Migration 檔案和 Update-Database 指令切換資料庫的結構。然而如果我們想要傳遞這些變更到測試伺服器並且模擬實際產品環境我們可能想要 SQL Script 如此我們就可以把工作交給DBA。 執行 Update-Database 不過這次我們帶入參數 -Script 1Update-Database -Script 接著就會產生 SQL Script 而且沒有變更資料庫，我們也可以指定一個 source 和一個 target 來產生特定條件的 SQL。 我們想要產生從空白資料庫到最新版的 Script 時 1Update-Database -Script -SourceMigration: $InitialDatabase -TargetMigration: AddPostAbstract 註: 如果你不指定 target Migration 將會使用最新的遷移檔。如果你不指定 source Migration會使用目前資料庫的狀態。 於程式啟動時自動更新資料結構如果你想要發佈的應用程式，當程式執行時自動更新資料庫您可以透過註冊 MigrateDatabaseToLatestVersion 初始化物件來辦到。一個資料庫初始化物件 (Database initializer) 只是用來確認資料庫目前是否設定正確。這些邏輯在第一次 Context 類別被使用的時候執行。當我們更新 Programs.cs 如下: 註: 注意您需要加入 System.Data.Entity 因為要使用 Database.SetInitializer()。當我們建立了一個初始化物件時我們需要指定 context type (BlogContext) 和 migration 的設定檔(Configuration)。Configuration 類別會在我們使用 Enable-Migrations 時一起被加入 Migrations 目錄程式碼如下: 123456789101112131415161718192021222324252627282930using System;using System.Collections.Generic;using System.Data.Entity;using System.Linq;using System.Text;using System.Threading.Tasks;namespace MigrationsDemo{ class Program { static void Main(string[] args) { Database.SetInitializer(new MigrateDatabaseToLatestVersion&lt;BlogContext, Migrations.Configuration&gt;); using (var db = new BlogContext()) { db.Blogs.Add(new Blog { Name=&quot;Another Blog&quot;}); db.SaveChanges(); foreach (var blog in db.Blogs) { Console.WriteLine(blog.Name); } Console.WriteLine(&quot;Press any key to exit...&quot;); Console.ReadKey(); } } }} 現在每當您的應用程式執行的時候就會先確認資料庫如果有變動就會自動 Migration 。 在這個練習你看到了如何設定結構，修改和使用程式來變更您的資料庫。您也學習到如何取得SQL Script和如何使用遷移檔。以及最後如何自動化變更資料庫。","link":"/2013/03/12/asp-net-mvc-migrations/"},{"title":"Bower 簡介","text":"Bower 是一套管理網頁套件的工具，他提供了一種通用且不受限制的方案來解決管理前端相關的套件如：jquery。支援的系統非常廣泛，並沒有太多相依性的東西。開發者也可以透過他管理套件的相依性和升級等等的問題。有了它，就不用到處去下載套件檔案(jquery, bootstrap)。 安裝Bower 相依於 Node 和 npm 安裝指令如下 1$ npm install -g bower 使用方法大部份的資訊，都可以在 bower help 提供的說明中找到，一旦安裝完成就可以開始使用了。Bower 是一組指令集，他們不需要使用 root 權限。如果你真的要限制權限則使用 --allow-root 安裝套件透過 bower.json 來安裝管理，bower.json 就像一組清單用來幫你記錄管理想要安裝的套件和版本，先把清單些完之後執行下面的指令就能一口氣安裝完畢。 1$ bower install 安裝在本地專案 12$ bower install &lt;package&gt;# ex: bower install jquery 指定版本 1$ bower install &lt;package&gt;#&lt;version&gt; 可以是下面任何一種值 套件名稱 ex: jquery。可以透過 bower search jquery 來尋找相關的套件名稱。 git 路徑 git://github.com/someone/some-package.git。 本地的 git 檔案庫。 縮寫的路徑 someone/some-package 預設是(github 上面的專案)。 網址指向一個 zip 或者 tar 檔案。 查詢已經安裝的套件1$ bower list 搜尋1$ boewr search [keyword] 安裝完後使用套件最簡單的方式就是直接使用預設路徑 1&lt;script src=&quot;/bower_components/jquery/index.js&quot;&gt;&lt;/script&gt; 對於更複雜的情況，你可能會需要使用腳本，或者使用一個載入模組。Bower 只是一個管理工具，此時可以使用其他的工具 - 如 RequireJS - 這將幫助你做到這一點。 移除1$ bower uninstall &lt;package-name&gt;","link":"/2013/08/29/bower-profile/"},{"title":"Grunt 系列(2) 設定","text":"這篇教學將會解釋如何使用 Gruntfile 為你的專案設定任務。如果你還不知道什麼是 Gruntfile 請回到上一篇 Grunt 入門 閱讀。 Grunt 設定關於任務，你可以把任務當作就是一連串需要被執行的動作，通常這些設定都在 Gruntfile 這個檔案的 grunt.initConfig 這個方法中。接著各個任務的設定都會在屬性名稱底下，換個說法， initConfig 需要你傳遞一個物件{}參數進去如下： grunt.initConfig({property:{ // task configuration here. }}); 之後這個物件的每一個屬性通常就對應著一個任務，這只是大部份的狀況，它有可能是任意的資料。只要屬性不衝突即可，一旦衝突就會被忽略。接著讓我們來看看一個比較完整的範例： grunt.initConfig({ concat: { // concat task configuration goes here. // 整合檔案的任務 }, uglify: { // uglify task configuration goes here. // 壓縮檔案的任務 }, // Arbitrary non-task-specific properties. // 任意的資料 my_property: 'whatever', my_src_files: ['foo/*.js', 'bar/*.js'], }); # 任務設定和目標(Targets) 當任務開始執行， Grunt 會去尋找設定檔裡面的同名屬性，不同的任務配合不同的屬性，屬性可以設定不同的任務目標。我們用下面的範例來說明： `concat` 任務有 `foo`, `bar` 兩個目標，`uglify` 任務有 `bar` 一個目標。 grunt.initConfig({ concat: { foo: { // concat task &quot;foo&quot; target options and files go here. }, bar: { // concat task &quot;bar&quot; target options and files go here. }, }, uglify: { bar: { // uglify task &quot;bar&quot; target options and files go here. }, }, }); 上一篇我們說過可以透過 grunt uglify 來執行任務，那當我們有不同的目標時就可以透過 grunt concat:foo 來執行該目標。不過在這邊要再次提醒上面範例只是設定，並無法拿來直接執行。如果直接下 grunt concat 則會把所有目標都執行一遍。這邊還有另一點要注意的是如果使用 grunt.renameTask 修改了任務的名稱，那 grunt 就會自動根據新名稱去找設定。 Options 在每一項任務設定中`options`屬性也許是用來覆寫內建的預設規則，此外每個`target`目標也可能會有一個 `options` 屬性。目標的 `options` 屬性會覆蓋任務的 `options` ，最後就是關於 `options` 這個屬性是可以省略的，他不是必須的。讓我們來看看範例： grunt.initConfig({ concat: { options: { // Task-level options may go here, overriding task defaults. // 任務等級的 options }, foo: { options: { // &quot;foo&quot; target options may go here, overriding task-level options. // 『目標』等級的 options 如果設定有重複，它會覆寫任務等級的設定。 }, }, bar: { // No options specified; this target will use task-level options. }, }, }); # 檔案 因為大部份的任務都涉及操作檔案， Grunt 對於檔案的定義宣告與操作有非常強及高度的抽象化。它提供了一些方法定義 `src-dest` (來源-目的地)如何對應 ，就是取得來源檔案，然後處理後產生至目的地目錄。提供了不同程度的操作，任何任務都會針對某種格式的檔案來做操作，編譯等等。你可以選擇你需要的格式。 所有的檔案格式都支援 src 和 dest 兩種屬性設定，不過簡潔格式和檔案陣列有一些額外的屬性可用。下面會說明什麼是簡潔格式和檔案陣列。額外支援的屬性如下： filter 任何一個 fs.States 的方法名稱如：stats.isFile()你可以用‘isFile’，或者任何一個 function 輸入src` 路徑後可以判斷回傳 true/false ，都可以拿來設定，用來過濾。 nonull 當一個比對沒有被找到的時候，就會回傳一個包含其 pattern 的列表，否則就會回傳一個空的列表。搭配 --verbose 可以用在關於檔案路徑的除錯。 dot 允許檔案名稱的匹配模式用 . 開始 ，即使設定沒有在開頭使用 . matchBase 一旦設定這種匹配模式就不會比對 / 舉例來說會變成 *.js 等於 **/*.js 簡單來說就是只比對最後檔名的部分。例如，a?b 會匹配 /xyz/123/acb 但不匹配 /xyz/acb/123。 expand 處理動態的 src 和 dest 檔案對應。 其他屬性都會傳入底層當作匹配的參數 # 簡潔格式 這種格式允許每一個『目標』設定單一屬性的對應，比較常用在讀取檔案，例如 [grunt-contrib-jshint](https://github.com/gruntjs/grunt-contrib-jshint) 只需要 `src` ，而不需要 `dest` 。看下面範例會更清楚。 grunt.initConfig({ jshint: { foo: { src: ['src/aa.js', 'src/aaa.js'] }, }, concat: { bar: { src: ['src/bb.js', 'src/bbb.js'], dest: 'dest/b.js', }, }, }); # 檔案物件格式 這種格式允許每個目標對應多個檔案，前面的屬性名稱會是目的地的檔案名稱。然後來源檔案可以是多個。可以用這種方式設定多組檔案的對應。一旦採用這種設定方式就不能再加入其他屬性了。看看下列程式碼： grunt.initConfig({ concat: { foo: { files: { 'dest/a.js': ['src/aa.js', 'src/aaa.js'], 'dest/a1.js': ['src/aa1.js', 'src/aaa1.js'], }, }, bar: { files: { 'dest/b.js': ['src/bb.js', 'src/bbb.js'], 'dest/b1.js': ['src/bb1.js', 'src/bbb1.js'], }, }, }, }); # 檔案陣列格式 這種方式一樣支援多組 `src-dest` 對應，但可以多加入其他屬性。就跟一開始說的一樣 `簡潔格式` 和 `檔案陣列` 格式可以增加其他的屬性。直接看範例比較清楚。 grunt.initConfig({ concat: { foo: { files: [ {src: ['src/aa.js', 'src/aaa.js'], dest: 'dest/a.js'}, {src: ['src/aa1.js', 'src/aaa1.js'], dest: 'dest/a1.js'}, ], }, bar: { files: [ {src: ['src/bb.js', 'src/bbb.js'], dest: 'dest/b/', nonull: true}, {src: ['src/bb1.js', 'src/bbb1.js'], dest: 'dest/b1/', filter: 'isFile'}, ], }, }, }); # 舊版的格式 直接在任務底下，就是沒有 `files` 屬性是舊版本在執行多檔案操作的一種過渡期的方式。直接讓最後目的地的路徑等於`目標`(target) 名稱，很不幸的因為目標名稱就是路徑，所以當你要執行 `grunt task:target` 的時候就顯得很糟糕。而且你也不能在設定 `目標等級` 的 `options` 或加入其他屬性。因此請儘量避免使用這種格式設定。 grunt.initConfig({ concat: { 'dest/a.js': ['src/aa.js', 'src/aaa.js'], 'dest/b.js': ['src/bb.js', 'src/bbb.js'], }, }); # 自訂過濾 Function `filter` 這個屬性可以讓你針對檔案設定更多細節，最簡單的方式就是使用 `fs.States｀ 的 method 名稱來設定，例如下面的程式碼我們就可以輕鬆的確認是否為一個實體檔案，然後把 `tmp` 暫存的檔案都清光。 grunt.initConfig({ clean: { foo: { src: ['tmp/**/*'], filter: 'isFile', }, }, }); 或者是你只要建立一個 function 回傳 true/false 就可以了 grunt.initConfig({ clean: { foo: { src: ['tmp/**/*'], filter: function(filepath) { return (grunt.file.isDir(filepath) &amp;&amp; require('fs').readdirSync(filepath).length === 0); }, }, }, }); # 模式匹配與符號說明(Global Pattern) 一般來說一個路徑一個路徑設定在實務上來說是不切實際的，非常麻煩。所以 Grunt 支援透過內建的函式庫來做檔名路徑的匹配，或者說透過設定 Pattern 規則來選取檔案。這並不是專門的模式匹配的教學，我們只需要學習常用的符號即可。 * 任意數量的字元，但不包含 /。 ? 單一字元，不包含 /。 ** 任何數量的字元，包含 / 只要是路徑的一部分就可以。 {} 用 , 分隔列出清單，只要其中一個符合即可(OR)。 ! 用在開頭，排除的意思。 大部份的人都知道 /foo/*.js 會選取到所有在 /foo 目錄底下的 js 檔案。但是 foo/**/*.js 則會包含任何在 /foo 目錄底下子目錄的 js 檔案。要注意 /foo/*.js 只有一層，就是在 /foo 底下，至於其它如 /foo/subfolider 就沒有。此外，為了簡化複雜的匹配， Grunt 也允許你使用檔案陣列的方式如 ['a.js', '/foo/b.js'] ，模式匹配是按照順序的，! 會排除匹配的檔案，其結果是唯一的。 // 指定單一檔案 {src: 'foo/this.js', dest: …} // 使用檔案陣列指定多個檔案 {src: ['foo/this.js', 'foo/that.js', 'foo/the-other.js'], dest: …} // 使用模式匹配來選取檔案 {src: 'foo/th*.js', dest: …} // node-glob 模式，對應 foo 目錄底下 a 或 b 開頭的 js {src: 'foo/{a,b}*.js', dest: …} // 上面的例子也可以這樣寫。 {src: ['foo/a*.js', 'foo/b*.js'], dest: …} // foo 目錄下所有的 .js ，但不包含子目錄下的 {src: ['foo/*.js'], dest: …} {src: ['foo/bar.js', 'foo/*.js'], dest: …} // 除了 bar.js 以外所有的 .js ，會按照字母排列。 {src: ['foo/*.js', '!foo/bar.js'], dest: …} // 所有的 .js 檔案， bar.js 先被排除後，又被加入了 {src: ['foo/*.js', '!foo/bar.js', 'foo/bar.js'], dest: …} // 模版也可以用在檔案路徑或模式匹配中。 {src: ['src/&lt;%= basename %&gt;.js'], dest: 'build/&lt;%= basename %&gt;.min.js'} // 也可以使用其他設定檔中配置的屬性值。 {src: ['foo/*.js', '&lt;%= jshint.all.src %&gt;'], dest: …} # 動態建立檔案物件 當你需要處理很多個別的檔案的時候，有些額外的屬性可以協助你動態的建立檔案清單。這些屬性都可以用在簡潔格式和檔案陣列格式中。 * `expand` 設成 `true` 用來啓用後面的屬性設定。 * `cwd` (Current Working Directory) 設定一個目標路徑，注意這個不是檔案路徑或者 Pattern。 * `src` 在根據上面的 `cwd` 做 Pattern 或檔案的選取。 * `dest` 目的地目錄 * `ext` 在 `dest` 目錄設定新的附檔名取代原始附檔名。 * `flatten` 移除 `dest` 設定的路徑，設定值為 true/false * `rename` 對每個符合規則的 `src` 檔案調用這個 function （在執行完 ext 和 flatten 之後）。接著傳遞 `dest` 和 `src` 的值給 function 最後回傳一個新的 `dest` 路徑。 对每个匹配的src文件调用这个函数(在执行ext和flatten之后)。传递dest和匹配的src路径给它，这个函数应该返回一个新的dest值。 如果相同的dest返回不止一次，每个使用它的src来源都将被添加到一个数组中。如果傳回的 dest 重複則會被加入 sources 的陣列。 下面是關於 minify 的例子，我們會看到 static_mappings 和 dynamic_mappings 目標雖然設定不同，卻處理了相同的檔案列表， static_mappings 是一條一條設定，而 dynamic_mappings 則是動態，先切換到一個路徑底下，再根據同樣的規則去執行。 grunt.initConfig({ minify: { static_mappings: { // 由於 src-dest 檔案路徑是寫死的, 每次新增或刪除，Gruntfile 都要更新。 files: [ {src: 'lib/a.js', dest: 'build/a.min.js'}, {src: 'lib/b.js', dest: 'build/b.min.js'}, {src: 'lib/subdir/c.js', dest: 'build/subdir/c.min.js'}, {src: 'lib/subdir/d.js', dest: 'build/subdir/d.min.js'} ] }, dynamic_mappings: { // 執行任務時 Grunt 會自動在當下的工作目錄 &quot;lib/&quot; 下搜尋 Pettern &quot;**/*.js&quot;, 接著建立 src-dest 檔案對應，因此你就不需要在新增或刪除檔案時更新 Gruntfile。 files: [ { expand: true, // 啓用動態對應 cwd: 'lib/', // 匹配切換成當前的工作目錄 lib src: '**/*.js', // 根據上面的目錄限制，套用 Pettern dest: 'build/', // 檔案產生目的地目錄 ext: '.min.js' // 取代原本的附檔名 } ] } } }); # 樣板（Templates） 直接翻譯為樣板可能不太恰當，主要的用法是可以透過 `` 嵌入變數，而這些變數可以是來自讀取設定檔的資料。模板本身會不斷遞回讀取變數直到裡面不再存在任何模板。 整個設定物件中由外到內的屬性都會被解析，此外 `grunt` 的方法或屬性都可以被嵌入樣板中。例如 `` &lt;%= prop.subprop %&gt; 取得 prop.subprop 設定屬性的值。只要正規的型別他都能使用，不僅是字串，陣列貨，物件也可以。這樣說明你可能會有點模糊，讓我們看下列的範例。 module.exports = function(grunt){ grunt.initConfig({ prop: {subprop:&quot;tmp/lib/&quot;}, clean: { src: &quot;&lt;%= prop.subprop %&gt;*.js&quot; } }); } &lt;% %&gt; 在分隔符號中您可以使用 Javascript。對於做一些基本的邏輯判斷是非常有用的。 讓我們來一些範例觀察，下面使用了 concat 任務來整合檔案，執行 grunt concat:sample ，透過 banner 會在檔案加入 /* abcde */ ，而這隻檔案是由 foo/*.js, bar/*.js, baz/*.js 這三個規則搜尋來的檔案組合而成，最後結合的檔案則生成 build/abcde.js 。 grunt.initConfig({ concat: { sample: { options: { banner: '/* &lt;%= baz %&gt; */\\n' // '/* abcde */\\n' }, src: ['&lt;%= qux %&gt;', 'baz/*.js'], // [['foo/*js', 'bar/*.js'], 'baz/*.js'] dest: 'build/&lt;%= baz %&gt;.js' } }, // 同樣在 initConfig 中可以直接存取屬性。 foo: 'c', bar: 'b&lt;%= foo %&gt;d', //'bcd' baz: 'a&lt;%= bar %&gt;e', //'abcde' qux: ['foo/*.js', 'bar/*.js'] }); # 匯入外部資料 在下面的 Gruntfile 中，專案本身的 metadata 可以透過 `package.json` 匯入到設定物件中。接著 `uglify` 任務就可以透過 pkg.name 取得該專案名稱的js。 src/`pkg.name`.js ，然後產生到 `dest` 中並加上 `.min.js`。 grunt.initConfig({ pkg: grunt.file.readJSON('package.json'), uglify: { options: { banner: '/* &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&gt; */\\n' }, dist: { src: 'src/&lt;%= pkg.name %&gt;.js', dest: 'dist/&lt;%= pkg.name %&gt;.min.js' } } }); # 實做練習 最後讓我們在透過一個簡單的清除檔案練習，加深對整個 Grunt 運作的觀念吧！ $ mkdir grunt-test $ cd grunt-test $ npm init $ npm install grunt grunt-contrib-clean --save $ vi Gruntfile.js Gruntfile 設定 module.exports = function(grunt){ // 設定關於 clean 的設定，清除 tmp/ 底下的 js 檔案 grunt.initConfig({ clean: { files:[ {src: 'tmp/*.js'} ], dynamic:{ files:[ { expand: true, cwd: '&lt;%= prop.andy %&gt;', src: ['**/*.js'] } ] } } }); // 載入套件 grunt.loadNpmTasks('grunt-contrib-clean'); // 註冊預設的任務 grunt.registerTask('default', ['clean']); } 接著執行 $ grunt --help // 查詢可用的指令 $ grunt clean // 執行指令清除 $ grunt clean:dynamic // 執行任務中的 dynamic 目標 # 參考資料 [官方文件](http://gruntjs.com/configuring-tasks) [官方手冊簡體翻譯](http://www.gruntjs.org/article/home.html) [Wiki](https://github.com/gruntjs/grunt/wiki/Configuring-tasks) [其他教學](http://www.cnblogs.com/chyingp/archive/2013/05/11/grunt_getting_started.html)","link":"/2013/09/29/grunt-set-2/"},{"title":"Grunt 系列(3) 範例實作","text":"下面我們將透過一個使用了 5 個常用套件的 Gruntfile 來實作練習並討論關於 Gruntfile。 grunt-contrib-uglify : 壓縮檔案 grunt-contrib-qunit : 單元測試 grunt-contrib-concat : 檔案合併 grunt-contrib-jshint : 檢查 Javascript 語法 grunt-contrib-watch : 觀察檔案變更 整個完整的 Gruntfile 在頁面的最下方，不過如果你按順序閱讀，這篇文章會一步一步的說明。 備註：通常在使用套件前，比較方便的方式是透過下面指令來安裝，這樣一來也順便會更新 package.json 。一般來說執行 grunt 都是在開發階段所以參數會使用 –save-dev 就是設定在 package.json 的 devDependencies 中。 1$ npm install grunt-contrib-uglify --save-dev 首先要說明的是關於 wrapper 函式，簡單的來說所有關於 grunt 該執行的任務和相關設定都會被封裝在這個 function中。如下程式碼 123module.exports = function(grunt) { // 所有任務設定都會在這。} 接著我們通常會在這個 function 中開始初始化我們的設定檔物件，就會透過 grunt.initConfig 把資料放到物件{}中，如下： 12345{% raw %}grunt.initConfig({ // 屬性: &quot;資料&quot;});{% endraw %} 為了能夠使用一些關於專案的資料，我們可以讀取 package.json 的資料到 pkg 屬性，於是我們就可以透過 pkg 來取得專案的資料，例如： pkg.name 就是我們在 package.json 設定的專案名稱。設定的方式如下 1pkg: grunt.file.readJSON('package.json'); 到目前為止的設定就會如下： 12345module.exports = function(grunt){ grunt.initConfig({ pkg: grunt.file.readJSON('package.json'); });} 現在，我們就可以針對每一個任務來作設定，在設定檔物件中，也就是在 grunt.initConfig(\\{\\}) 的 {} 中所有存在的任務通常會對應一個屬性，它是透過相同的名稱來對應的。所以例如 concat 任務的設定就會在 concat 屬性中設定。下面就是關於 concat 任務的設定： 123456789101112concat: { options:{ // 合併不同檔案時會在檔案和檔案之間加入 ; separator: ';' }, dist:{ // 要合併的檔案 src: ['src/**/*.js'], // 產生的檔案路徑 dest: 'dist/&lt;%= pkg.name %&gt;.js' }} 注意到這邊我們引用了專案名稱 name 屬性，透過 grunt.file.readJSON 我們把 package.json 讀入成為一個物件，並且賦予 pkg ，如此一來我們就可以很輕鬆地存取關於 package.josn 中的設定。 Grunt 內建一個簡單的樣板引擎，讓我們在設定檔中能夠輕鬆的內嵌變數，通常是屬性的值（例如 pkg.name）。上面任務的意思就是取得 src/ 目錄底下所有 .js 結尾的檔案，然後合併成一個 dist/[專案名稱].js 。 接著讓我們來看看 uglify 任務，它是用來壓縮 Javascript 的套件。 dist = Distribution 1234567891011121314uglify: { options: { // 產生一段 banner 文字並加入到將產生檔案的一開始 banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(&quot;dd-mm-yyyy&quot;) %&gt; */\\n' }, // 這邊的 dist 是任務底下的一個目標（target） // 一般情況下執行 grunt uglify 所有的目標都會被執行。 dist: { files: { // 回憶一下上一篇 dist:src 前面是目的路徑，後面是來源路徑，注意來源是 concat 的屬性 'dist/&lt;%= pkg.name %&gt;.min.js': ['&lt;%= concat.dist.dest %&gt;'] } }} 上面 uglify 任務取得 concat 合併後的檔案，並壓縮到 dist 目錄。讓我們復習一下上面 files 是使用檔案物件格式，檔案的設定方式有三種。 qunit 的設定則非常單純，只要把運行測試頁的位置設定即可。 123qunit: { files: ['test/**/*.html']} JSHint 的設定也很簡單如下 1234567891011121314{% raw %}jshint: { // 檢查的檔案 files: ['gruntfile.js', 'src/**/*.js', 'test/**/*.js'], // 設定 JSHint 屬性查詢文件(http://www.jshint.com/docs/options/) options: { globals: { jQuery: true, console: true, module: true } }}{% endraw %} JSHint 就是根據 files 的設定去檢查檔案，而 options 可以用來改寫預設的規則。如果你要使用預設值則不用設定。 最後我們還有一個 watch 任務 123456{% raw %}watch: { files: ['&lt;%= jshint.files %&gt;'], tasks: ['jshint', 'qunit']}{% endraw %} 當你使用 grunt watch 命令時，它就會去觀察 jshint.files 的檔案列表。就是 ['gruntfile.js', 'src/**/*.js', 'test/**/*.js'] 。當它偵測到指定的這些檔案有變更，他就會去執行任務 tasks 。在這邊我們設定了執行 hshint 和 qunit 兩個任務。 讓我們再次提醒，上面都是透過 grunt.initConfig 設定的組態，因此我們還是要載入這些套件。載入之前請先記得安裝。 12345grunt.loadNpmTasks('grunt-contrib-uglify');grunt.loadNpmTasks('grunt-contrib-jshint');grunt.loadNpmTasks('grunt-contrib-qunit');grunt.loadNpmTasks('grunt-contrib-watch');grunt.loadNpmTasks('grunt-contrib-concat'); 最後我們需要把常用的任務設定為 default 這樣一來我們以後只要下 grunt 指令就好，就不用在特別下 grunt uglify 之類的。 12345// 註冊 test 任務之後只要執行 &quot;grunt test&quot; 就會跑 jshint 和 qunitgrunt.registerTask('test', ['jshint', 'qunit']);// 註冊預設任務之後只要執行 &quot;grunt&quot; 就會跑下面陣列中的任務。grunt.registerTask('default', ['jshint', 'qunit', 'concat', 'uglify']); 下面就是完整的 Gruntfile ，通常我們使用 .js 或 .coffee 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051module.exports = function(grunt){ grunt.initConfig({ pkg: grunt.file.readJSON('package.json'), concat: { options: { separator: ';' }, dist: { src: ['src/**/*.js'], dest: 'dist/&lt;%= pkg.name %&gt;.js' } }, uglify: { options: { banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(&quot;dd-mm-yyyy&quot;) %&gt; */\\n' }, dist: { files: { 'dist/&lt;%= pkg.name %&gt;.min.js': ['&lt;%= concat.dist.dest %&gt;'] } } }, qunit: { files: ['test/**/*.html'] }, jshint: { files: ['gruntfile.js', 'src/**/*.js', 'test/**/*.js'], options: { globals: { jQuery: true, console: true, module: true, document: true } } }, watch: { files: ['&lt;%= jshint.files %&gt;'], tasks: ['jshint', 'qunit'] } }); grunt.loadNpmTasks('grunt-contrib-uglify'); grunt.loadNpmTasks('grunt-contrib-jshint'); grunt.loadNpmTasks('grunt-contrib-qunit'); grunt.loadNpmTasks('grunt-contrib-watch'); grunt.loadNpmTasks('grunt-contrib-concat'); grunt.registerTask('test', ['jshint', 'qunit']); grunt.registerTask('default', ['jshint', 'qunit', 'concat', 'uglify']);};","link":"/2013/10/01/grunt-series-3-example-implementations/"},{"title":"Sails 實作筆記","text":"何謂 sails.js [sails](http://balderdashy.github.io/sails/) 其實就跟 `Rails` ，`ASP.NET MVC` 類似，是一個 MVC 的 Web 框架。目標是協助您快速的用 nodejs 開發出企業等級的網站（註：由於開發團隊仍在開發中，所以要採用前請先審慎評估XDD）。所以就跟其他框架一樣，他讓我們不用再重新造輪子，整合一般網站開發常用的功能，並且重點是支援許多 nodejs 特有的強項，特別是在開發聊天室這類的應用程式更顯得出效能。本篇文章僅僅透過實作一些基礎，讓我們快速的感受一下 sails 。 安裝 sails.js $ npm -g install sails // -g：安裝到系統路徑 # 建立專案 $ sails new [project_name] $ sails new [project_name] --linker // 使用 linker 用來整和壓縮 css 和 js 的套件 $ sails new [project_name] --template=jade // 預設樣板引擎是 `ejs` 可以換成 `jade` # 安裝相依套件 $ cd [project_name] $ npm install $ npm install jade --save // 安裝 jade 並且更新 package.json # 啓動測試網站 $ sails lift 依照指示說明在瀏覽器輸入 `http://localhost:1337` 就可以看到預設畫面。 初識路由和目錄結構 路由設定在 `config/routes.js` ，打開該檔案我們會看到如下程式碼： module.exports.routes = { '/' : { view: 'home/index' } } 嘗試編輯 將 `view: 'home/index'` 改成 `view: 'static/index'` 。然後我們在 `views` 目錄底下建立一個 `static` 目錄，接著在裡面再建立一個 `index.ejs` 或 `index.jade` 。隨便輸入一些資料，例如 h2 Hello, This is our page using Jade 或者 &lt;h2&gt;Hello, This is our page using EJS&lt;/h2&gt; 注意：這邊我們先不做太多解釋與設定，純粹先實作讓大家感受一下 Sails 這個框架。如果使用 jade 請記得整個 view 應該是這樣： extends ../layout block body h2 Hello, This is our page using Jade 接著我們使用 sails lift 指令來觀看我們的修改。 加入 bootstrap 到目前為止我們只有使用到 view ，我們來嘗試組織一下專案加入 bootstrap。到 bootstrap3 官網下載 zip 並且把 `bootstrap.css` 放到 `assets/styles/` 目錄底下。 編輯 views/static/index.jade 或 views/static/index.ejs 加入 extends ../layout block body div.container div.jumbotron h1 activityOverlord h2 ...tracking app activity better than the NSA since 1899. a(href='/user/new', class='btn btn-lg btn-success') Sign up now! 或者 &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;jumbotron&quot;&gt; &lt;h1&gt;activityOverlord&lt;/h1&gt; &lt;h2&gt;...tracking app activity better than the NSA since 1899.&lt;/h2&gt; &lt;a href=&quot;/user/new&quot; class=&quot;btn btn-lg btn-success&quot;&gt;Sign up now!&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; # 修改 Layout 在 `Sails` 裡面跟其他 MVC 框架一樣預設都幫您提出一個 `layout` 樣板，而每個 view 則會嵌入到 `layout` 的 body 中。例如 jade 是 `block body` ， `ejs` 是 `` 。如此一來相同的部分我們就可以放入 `layout` 之後如果需要修改，就只要修改一次。 # layout.jade 如下 !!! html head title= title // Viewport mobile tag for sensible mobile support meta(name=&quot;viewport&quot;,content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;) link(rel=&quot;stylesheet&quot;,href=&quot;/styles/bootstrap.css&quot;) link(rel=&quot;stylesheet&quot;,href=&quot;/styles/custom.css&quot;) block styles body div.navbar.navbar-inverse.navbar-fixed-top div.container a.navbar-brand(href=&quot;/&quot;) Activity Overload block body div.container hr footer.footer.pull-right div a(href=&quot;http://sailsjs.com/&quot;) Sails.js div tutorial by irl nathan, with a bunch of help from cody, gabe, heather, mike, scott and zoli // A few key dependencies, linked in order // Bring in the socket.io client script(type=&quot;text/javascript&quot;, src=&quot;/js/socket.io.js&quot;) // then beef it up with some convenience logic for talking to Sails.js' script(type=&quot;text/javascript&quot;, src=&quot;/js/sails.io.js&quot;) // listen on socket.io for incoming messages script(type=&quot;text/javascript&quot;, src=&quot;/js/app.js&quot;) 其他 ejs 範例可以透過 [ActivityOverloadd範例](https://github.com/irlnathan/activityoverlord) 下載 原文影片教學在此 [連結](http://irlnathan.github.io/sailscasts/blog/archives/)，這篇文章讓我們先感受一下使用 Sails.js 這個 nodejs 框架使用起來的感覺。後續會補上教學。","link":"/2013/09/29/sails-real-1/"},{"title":"PHP 環境 OSX 10.9","text":"更新 Mavericks 小牛之後會發現 httpd.conf 被取代了。不過舊的檔案放在 /private/etc/apache2/httpd.conf.pre-update ApacheOSX 內建有 Apache 不過以前可以在 系統偏好設定-&gt;共享 開啟。但是在新版 10.9 這個部分被移除了。所以要開啟 Apache 必須要使用指令 123456789101112131415161718192021$ sudo apachectl start // 啓動$ sudo apachectl stop // 停止$ sudo apachectl restart // 重啟$ sudo apachectl -t // 測試 conf 是否正確{% endhighlight %}# 自定 Apache 設定預設的網站目錄在 `/Library/WebServer/Documents/`。在開啟 Apache 之後您可能會需要一些設定。* 建立一個 `/www` 目錄* 將測試網站檔案放在該目錄底下* 替工作區加入虛擬目錄* 設定一個本地端的測試網址首先建立一個 `/www` 目錄~~~bash$ cd /$ mkdir www // 這邊可能需要 sudo 權限 接著建立一個工作目錄 1$ mkdir local.example.com 設定 http.conf 這個檔案完整路徑 /private/etc/apache2/http.conf 是用來設定關於 Apache 的組態。這邊您可以使用 vi 或其他編輯器，我使用 Sublime Text 。 1$ subl /private/etc/apache2/http.conf 開啟檔案後有幾個地方要修改如下： 170 行將 DocumentRoot 修改為 1DocumentRoot &quot;/www&quot; 197 行修改目錄路徑 1&lt;Directory &quot;/www&quot;&gt; 217 行修改 AllowOverride 為 All 1AllowOverride All 429 行將匯入 http-vhosts.conf 註解移除 1Include /private/etc/apache2/extra/httpd-vhosts.conf 我們接著加入關於虛擬目錄的設定，設定檔的路徑在 /private/etc/apache2/extra/httpd-vhosts.conf 當你開啟這個檔案的時候會發現裡面已經有一些範例資料。下面是一個設定的範例，實際需求請自行修正。 123456&lt;VirtualHost *:80&gt; DocumentRoot &quot;/www/local.example.com&quot; ServerName local.example.com ErrorLog &quot;/private/var/log/apache2/local.example.com-error_log&quot; CustomLog &quot;/private/var/log/apache2/local.example.com-access_log&quot; common&lt;/VirtualHost&gt; 當你做完這些修正您可以使用 sudo apachectl -t 檢查一下是否有錯誤。最後我們修改 /private/etc/hosts 增加一個本地用的網址 127.0.0.1 local.example.com PHPPHP 也是已經內建在 OSX 10.9 只要修改 httpd.conf 就可以開啟功能。 1$ subl /private/etc/apache2/http.conf 118 行 解開載入模組的註解 1LoadModule php5_module libexec/apache2/libphp5.so 231 行 加入預設 index.php 1DirectoryIndex index.html index.php 最後呢，我們需要讓 Apache 知道要處理 .php , .phps 檔案格式。一樣打開 http.conf 在最下面加上程式碼片段 12345#PHP Settings&lt;IfModule php5_module&gt; AddType application/x-httpd-php .php AddType application/x-httpd-php-source .phps&lt;/IfModule&gt; 別忘記每當你變更 http.conf 都要重啟 Apache 才會生效。接著可以在剛建立的目錄底下建立一個 test.php 1&lt;?php phpinfo(); ?&gt; 測試環境是否成功。 MySQL安裝123456789$ brew install mysql$ unset TMPDIR$ mysql_install_db --verbose --user=`root` --basedir=&quot;$(brew --prefix mysql)&quot;$ mysql.server start$ mysqladmin -u root password 'newpassword'$ mkdir -p ~/Library/LaunchAgents$ cp /usr/local/Cellar/mysql/5.5.20/com.mysql.mysqld.plist ~/Library/LaunchAgents/$ launchctl load -w ~/Library/LaunchAgents/com.mysql.mysqld.plist 升級也許會覆蓋掉您原本 php.ini 的設定，為了取得 MySQL 的一些工作狀態，我們需要修改一些設定 478 行 開啟錯誤 1display_errors = On 986 行 加入 MySQL socket 路徑 1pdo_mysql.default_socket=/tmp/mysql.sock 參考連結Start mySQL server from command line on Mac OS LionGet Apache, MySQL, PHP and phpMyAdmin working on OSX 10.9 MavericksInstalling phpMyAdmin on Mac OSX 10.8 Mountain Lion &amp; 10.7, 10.6OS X Mavericks and Apache","link":"/2013/10/29/osx-php-environment-109/"},{"title":"grunt-init 使用教學與 grunt-init-simple-server","text":"在開始如何製作自己的 grunt-init 樣板的教學之前，先分享grunt-init-simple-server。由於小弟玩性太重三天兩頭就喜歡換 framework 所以才寫了這個簡單的 grunt task。可以方便在學習新的前端技術的時候快速地幫專案加上一個簡易地 server。 Grunt-init 是一個用來自動建立專案架構的工具，它協助我們根據目前的環境以及建立過程中詢問一些設定項目來建立整個專案的架構。就像我們使用 IDE 如 Visual Studio 建立專案一樣，透過詢問你一些選項後建立該專案。 安裝1$ npm install -g grunt-init 使用方式 grunt-init --help 列出已安裝可以使用的樣板。 grunt-init [TEMPLATE] 建立指定類型的專案。 grunt-init /path/to/TEMPLATE 建立指定路徑樣板的專案。 上面所謂的樣板（template）其實就是『專案類型』，更白話文的說就是指定的『目錄架構』注意：大部份的樣板都是產生檔案或目錄到目前所在的目錄，所以在使用的時候請確認這是一個新目錄或者目錄裡的檔案不會被複寫。 安裝樣板（專案類型）一般來說樣板會安裝在你的 ~/.grunt-init 目錄裡，在 Window 中是 %USERPROFILE%\\.grunt-init\\一旦安裝完成，接著你會透過 grunt-init [TEMPLATE] 來建立專案。這邊舉個例子安裝 jquery 專案類型的話就是執行 1$ git clone https://github.com/gruntjs/grunt-init-jquery.git ~/.grunt-init/jquery 通常我們會透過 git 來安裝。整體來說 template 只不過是事先將一些樣板產生的 script 放置在~/grunt-init 目錄底下，透過 git 來安裝的話，之後可以輕鬆的更新升級。 注意：如果你想要將樣板安裝到本地，並且可以透過 grunt-init --help 來列出已安裝的樣板的話。例如：你想指定專案類型為 foobarbaz ，那你只要把樣板目錄安裝到指定目錄 ~/grunt-init/foobarbaz 即可。 下面是一些官方維護的樣板專案，您可以試著安裝並使用看看： grunt-init-commonjs 建立 CommonJS 模組，包含 Nodeunit unit test。 grunt-init-gruntfile 單純透過詢問選項建立 Gruntfile，最單純也最實用的。 grunt-init-gruntplugin 建立一個 Grunt 套件。 grunt-init-jquery 建立 jQuery 套件專案，包含 QUnit unit test。 grunt-init-node 大部份的狀況下 grunt-init 幫我們處理掉許多初始專案的東西，如果沒有你可能要使用npm init，bower init，建立 Gruntfile.js ，當然如果你是使用 framework 如：Sails那它可能都幫你處理完這些項目。 自定樣板您當然可以自己建立客製化的樣板，但是你的樣板必須遵循上述一樣的結構。舉例來說一個基本的樣板叫 my-template 就必須遵循下面的檔案結構： my-template/template.js 主要的樣板檔案，所有的選項提問，處理複製哪些檔案都在這隻程式處理。 my-template/rename.js 更改一些檔案的名稱設定，所有的命名規則在這邊設定。 my-template/root/ 所有要被複製檔案都存放在這，就是在產生專案時大部份預設檔案都是從這邊來的。 假設上面說的這些檔案和目錄都已經在 /path/to/my-template 那你就可以使用 grunt-init /path/to/my-template 來建立專案了。此外，只要你這個目錄放在 ~/.grunt-init 目錄底下，那你可以直接使用 grunt-init my-template 來建立。 複製檔案 Copying files只要樣板使用 init.filesToCopy 和 init.copyAndProcess 方法，任何在 root/ 目錄底下的檔案都會被複製到目前的目錄。 注意：所有被複製的檔案都會被當作模板來處理。例如： grunt-init-jquery 專案裡 /root/src/name.js 檔案中的第五行 123{% raw %} Copyright (c) {%= grunt.template.today('yyyy') %} {%= author_name %}{% endraw %} 除非你使用了 noProcess 設定，不然所有檔案都會經過上面的處理。 修改檔案名稱或排除檔案關於 rename.json 是用來描述來源檔案路徑和目的檔案路徑變更檔名的對應規則。來源檔案名稱必須要對應于 root 目錄。你可以參考 [grunt-init-jqueryplugin](https://github.com/gruntjs/grunt-init-gruntplugin/blob/master/rename.json) 的 rename.json。 設定預設詢問項目答案每一個 prompt 詢問你的問題都會有一個預設值，它通常是設死的或者根據環境設定取得的值。如果你要設定這些預設值你可以在 ~/.grunt-init/defaults.json 裡面去設定。下面有一個簡單的範例： 12345{ &quot;author_name&quot;: &quot;\\&quot;Cowboy\\&quot; Andy You&quot;, &quot;author_email&quot;: &quot;none&quot;, &quot;author_url&quot;: &quot;http://passer.cc/&quot;} 定義初始化的資訊exports.description這是一個簡短的樣板描述，當使用者執行 grunt-init 會顯示在列表。 1exports.description = descriptionString; 注意：任何一個樣板有錯誤的時候會導致執行 grunt-init 產生錯誤訊息。 exports.note如果啟用此設定，當開始執行項目詢問時，將會增加額外的訊息描速。這裡是你可以給使用者一些有用的訊息的地方，例如：哪些欄位是必要的選項。 1exports.notes = notesString; exports.warnOn警告功能，利用萬用字元表示式或者陣列去比對目錄中已存在的檔案，一旦符合規則發現檔案存在就會中斷專案的建立。不過一旦使用者使用 --force 參數，將會繼續執行，這可能會覆蓋掉以存在的檔案。這個功能非常實用，可以協助避免覆蓋掉一些已存在的檔案。 1exports.warnOn = wildcarPattern; 最常見的方式是使用 * 去匹配大部分名稱的檔案。舉例來說 *.js 可以匹配目錄底下所有的 js 檔案。下面是一些常用的範例： 12345678910exports.warnOn = 'Gruntfile.js'; // Warn on a Gruntfile.js file.exports.warnOn = '*.js'; // Warn on any .js file.exports.warnOn = '*'; // Warn on any non-dotfile or non-dotdir.exports.warnOn = '.*'; // Warn on any dotfile or dotdir.exports.warnOn = '{.*,*}'; // Warn on any file or dir (dot or non-dot).exports.warnOn = '!*/**'; // Warn on any file (ignoring dirs).exports.warnOn = '*.{png,gif,jpg}'; // Warn on any image file.// This is another way of writing the last example.exports.warnOn = ['*.png', '*.gif', '*.jpg']; exports.templateexports 最重要的便是爲 template 這個屬性定義一個 function ，所有實際執行的初始化動作都寫在這個 function 裡面 。有三個你可以使用的參數分別是 grunt，init，done。grunt 參數參考至 grunt。包含了所有 grunt 你能使用的函式庫，例如：grunt.file.read()。 init 參數是一個物件，主要包含關於 template 相關的屬性和方法。done 是一個 function 當樣板建立的步驟執行完成的時候便呼叫他。 初始化樣板內部接下來這些 init.method 都是在 exports.template = function (grunt, init, done) 函式中執行的使用的。如果有些 method 文件寫得不清楚的話請直接參考原始碼 init.addLicenseFiles自動產生 License 檔案。如果你的專案不是 MIT 其他授權可以參考這邊的縮寫。 1234var files = {};var licenses = ['MIT'];init.addLicenseFiles(files, licenses);// files === {'LICENSE-MIT': 'licenses/LICENSE-MIT'} init.availableLicenses真正可用的 Licenses 可以使用這個 method 列表。 12var licenses = init.availableLicenses();// licenses === [ 'Apache-2.0', 'GPL-2.0', 'MIT', 'MPL-2.0' ] init.copy給定一個來源路徑（絕對/相對）和可選的相對目標路徑，就可以複製到目前的目錄下。至於 options 參數的用法直接參考 grunt.file.copy()。 1234567891011121314var options = { // If an encoding is not specified, default to grunt.file.defaultEncoding. // If null, the `process` function will receive a Buffer instead of String. encoding: encodingName, // The source file contents and file path are passed into this function, // whose return value will be used as the destination file's contents. If // this function returns `false`, the file copy will be aborted. process: processFunction, // These optional globbing patterns will be matched against the filepath // (not the filename) using grunt.file.isMatch. If any specified globbing // pattern matches, the file won't be processed via the `process` function. // If `true` is specified, processing will be prevented. noProcess: globbingPatterns}; init.copyAndProcess遍歷 files 物件然後一個一個傳遞處理，作用就是複製來源檔案到目的，並且處理內容。 1init.copyAndProcess(files, props[, options]) init.defaults使用者在 defaults.json 中設定的預設值。 init.destpath當前目錄的絕對路徑，也就是所謂目的地目錄的路徑。 init.expand用法和 grunt.file.expand 相同。傳回一個唯一的陣列，包含所有檔案，目錄的路徑，這些路徑會根據之前文章提到 grunt 處理檔案的匹配方式一樣。這個方法允許你使用 , 分隔萬用字元匹配表示式，或者使用一個陣列來存放這些匹配模式的表示式。另外如果使用 ! 會排除匹配成功的路徑。最後這些匹配模式是會照順序處理的，如果先被排除了後面就不會再被匹配到。 init.filesToCopy傳回一個包含欲複製檔案的絕對路徑和相對路徑的物件，並依照 rename.json 的規則重新命名。 1234567var files = init.filesToCopy(props);/* files === { '.gitignore': 'template/root/.gitignore, 'jshintrc': 'template/root/.jshintrc', 'Gruntfile.js': 'template/root/Gruntfile.js', 'README.md': 'template/root/README.md', 'test/test_test.js': 'template/root/test/name_test.js' } */ init.getFile取得一個任務檔案路徑。原始碼 init.getTemplates傳回一個包含現有可用的樣板資訊的物件。 init.initSearchDirs在初始化目錄中搜尋初始化樣板， template 指的是本機的樣板，通常包含 ~/.grunt-init 目錄和 grunt-init 中的核心初始化的任務。 init.process啟動初始化並開始輸入提示選項。 12345678910init.process(options, prompts, done);init.process({}, [ //Prompt for these values init.prompt('name'), init.prompt('description'), init.prompt('version')], function(err, props){ // All finished, do something with the properties}); init.prompt顯示一道問答項目選擇。 1init.prompt(name[, default]) init.prompts傳回一個包含所有 prompt 提示問答值的物件。 init.readDefaults從任務檔案中讀取預設 JSON ，整合他們至 data object。 init.renamesrename.json 的物件。 init.searchDirs搜尋樣板路徑目錄的陣列。 init.srcpath根據檔案名稱搜尋初始化模板並回傳一個絕對路徑。 init.userDir傳回用戶樣板目錄的絕對路徑 12var dir = init.userDir();// dir === '/Users/shama/.grunt-init' init.writePackageJSON在目的地目錄寫入一個 package.json。 callback 函式可以用於後來在處理屬性新增/刪除/其他操作。 內建提示author_emailpackage.json 中作者的 Email，預設情況下會嘗試從用戶的 git config 中找到預設值。 author_namepackage.json 作者全名。 authro_url作者相關的網址 bin專案根目錄中 cli script 的相對路徑。 bugs追蹤專案 bug 的公開 URL description專案描速 grunt_version項目有效的 grunt 版本 homepage專案的首頁網址 jquery_version如果是 jQuery 專案的話，表示所需要的 jquery 版本。 licenses授權協議，內建的有 MIT，MPL-2.0，GPL-2.0，Apache-2.0。 main專案的 entry point name專案名稱 node_version專案所需的 node 版本 npm_test專案執行測試的命令。 repository專案的 git title專案名稱 version版本","link":"/2014/01/26/grunt-init/"},{"title":"MongoDB Quick Notes","text":"Mac123456789101112131415$ brew update # 更新 brew$ brew install mongodb # 安裝 MongoDB$ brew upgrade mongodb # 更新 MongoDB$ mongod # 啟動 MongoDB Server$ mongo # 連線到 localhost:27017/test ，不需帳密。* 27017 預設 port* 28017 Web 界面 MongoDB Server 資訊類似 PHP Admin 。&lt;!--more--&gt;$ mkdir -p /data/db # 建立資料庫儲存的目錄。$ chown `id -u` /data/db # 授權當前使用者目錄權限。$ id -u # 列出當前使用者 uid$ sudo plutil -p /var/db/dslocal/nodes/Default/users/[YourAccount].plist # OSX 底下的 /etc/shadow 。$ mongod --dbpath /data/db # 設定資料庫資料目錄。 基本對照 SQL MongoDB database database table collection row(record) documents column field(key) value value Mongo shell db 當前使用的資料庫。 show dbs 資料庫列表。 show collections 資料表清單。 use [dbname] 切換使用目標資料庫。 db.getSlibingDB('dbname') 取得資料庫參考物件。 db.dropDatabase() # 移除資料庫。 db.addUser( { user: &quot;&lt;user&gt;&quot;, pwd: &quot;&lt;password&gt;&quot;, roles: [&lt;roles&gt;] } ) # 加入使用者 db.auth('id', 'pwd') # 登入認證身份。 printjson(obj) 將物件以 JSON 格式輸出。 db.createCollection(name, {capped: &lt;Boolean&gt;, autoIndexId: &lt;Boolean&gt;, size: &lt;number&gt;, max &lt;number&gt;} ) # 建立集合，主要的功能是用來開固定式集合，固定式集合不能刪除 Row，但可以移除整個資料表，一旦 capped 設為 true 就要指定 size，但如果要限制則必須在指定 max 。一旦超出 max 舊的資料就會被覆寫。 db.collection.drop() # 移除資料表。 db.collection.ensureIndex({name: [1|-1]}) # 建立索引 db.collection.getIndexes() # 取得索引 db.collection.dropIndex({name: 1}) # 移除索引 其他資料snapshotPerformanceMuninIndexesB+TreeDistributed SystemAggregateSQL 到 MongoDB 對應表 Basic toturial","link":"/2014/02/04/mongodb-quick-notes/"},{"title":"MongoDB 快速入門筆記","text":"安裝12$ brew update$ brew install mongodb 更新12$ brew update$ brew ugrade mongodb 啟動 mongodb1234$ mkdir -p /data/db /* 建立預設 `dbpath` */$ chown `id -u` /data/db /* 修改目錄權限 */$ mongod /* 啟動 */$ mongod --dbpath &lt;some alternate directory&gt; /* 使用替代路徑啟動 */ 停止Control+C 連線資料庫123$ mongo # 預設連限制 localhost:27017$ mongo --hostname 0.0.0.0 --port 27017 # 遠端連線$ mongo [hostname]:[port]/[dbname] # 遠端連線 注意：剛建立好時，沒有帳密限制。如果你只使用 mongo 連線至資料庫時，預設會使用 test 這個資料庫。在 mongo shell 環境下使用 db 指令可以尋當前的資料庫。 常用指令 db 列出當前的資料庫名稱。 show dbs 列出資料庫清單。 use mydb 切換資料庫。 db.auth('account', 'password') 登入身份。 help 顯示協助訊息。 show collections 列出資料表。 mongo &lt;dbname&gt; --eval &quot;db.dropDatabase()&quot; 移除 database。或者下面這種方式： 12$ use mydb;$ db.dropDatabase(); DBQuery.shellBatchSize = x 讀取資料時迭代一次取回幾筆資料。 printjson() 將 document 以 JSON 格式輸出。 提醒一個 MongoDB 的機制，包含預設連到的 test 或建立的新資料庫，只要裡面沒有資料，MongoDB 並不會永久地保存該資料庫。 建立一個集合(collection)並插入一筆資料(document)在第一次使用 MongoDB 的時候預設會在背後自動建立一個集合(collection)或稱為隱含方式建立，collection對應傳統關聯式資料庫的說法這就是一個 table。參考這篇文章也許可以幫助你快速從關聯式資料庫轉換到 MongoDB SQL 到 MongoDB 對應表。在你插入任何一筆資料之前你是不需要自己建立集合。又因為 MongoDB 是動態式架構(schema)。所以在建立一筆資料之前你也不需要事先定義 schema。這樣說可能有 SQL 經驗的人會覺得很抽象詭異。讓我們執行下面的實作例子： 在 mongo shell 環境下，執行 db，這時他應該要傳回 mydb 。 如果你之前並沒有照著上面文章執行那請使用 use mydb 來切換資料庫。 建立兩筆資料(document) j，k 12j = { name : &quot;mongo&quot; }k = { x : 3 } 將 j, k 兩筆資料插入 testData 集合(資料表) 12db.testData.insert(j);db.testData.insert(k); 當你建立資料的此刻， mongo 會自動幫你建立集合(testData)並且把資料寫入，此外你也可以透過 db.createCollection(&quot;testData&quot;) 明確的自己建立集合，或者稱之為資料表你會比較習慣。5. 驗證 testData 集合是否存在，列出資料表。 1$ show collections 此時你應該會看到兩個集合 system.indexes ，testData。 system.inidexs 是每個資料庫都會有的集合。6. 確認 testData 中是否有資料。 1db.testData.find(); 這個操作之後你應該會看到 12{ &quot;_id&quot; : ObjectId(&quot;4c2209f9f3924d31102bd84a&quot;), &quot;name&quot; : &quot;mongo&quot; }{ &quot;_id&quot; : ObjectId(&quot;4c2209fef3924d31102bd84b&quot;), &quot;x&quot; : 3 } 上面這個操作就等於 SQL 中的 select。mongo document或者說每一筆資料都會有 _id 他會有一個唯一的 hash 值。上面這些操作並沒有明確指定 _id 的值，所以 mongo 預設會替一個物件產生 id 。為了讓我們能夠實際的執行測試某些 mongo 指令，在官方文件提供了產生測試資料的教學 12for (var i = 1; i &lt;= 25; i++) db.testData.insert( { x : i } )db.testData.find() 在一般情況下我們會使用 db.tableName.insert() 然而 db 指的是目前所在的資料庫 。如果要快速在不同的資料庫，集合中建立資料，官方文件也提供 function 的方式： 1234567function insertData(dbName, colName, num) { var col = db.getSiblingDB(dbName).getCollection(colName); for (i = 0; i &lt; num; i++) { col.insert({x:i}); } print(col.count());} 一般 mongo shell 中使用查詢資料，並不是一次傳回所有的資料。 MongoDB 的運作機制是他會先傳回一個指標物件，這個物件一次只會先包含 20 筆資料，如果你要檢視更多資料則輸入 it 繼續。而這個 20 筆資料是可以設定的，執行 DBQuery.shellBatchSize 可以看到目前的值，要修改的話就給他一個值 DBQuery.shellBatchSize = 25。 讓我們直接透過官方教學的步驟來體驗一下 mongo 1. 在 mongo shell 環境下執行1var c = db.testData.find(); c 會取得一個指標物件。 2. 透過迴圈列出所有的資料1while ( c.hasNext() ) printjson( c.next() ) 另外當你只輸入 c 的時候會輸出這個指標物件的內容，接著會提示如果要繼續檢視下面的內容就輸入 it 。 3. 使用陣列方式操作指標物件12var c = db.testData.find();printjson( c [ 4 ] ); 查詢指定的記錄(documents)MongoDB 本身擁有非常豐富的查詢機制讓我們可以過濾找到需要資料。如果你本身已經俱有 SQL 相關技能那可以參考這兩篇教學SQL 到彙總(Aggregation)對應表SQL 到 MongoDB 對應表。透過傳遞一個物件參數，我們可以找到 testData 中的特定筆資料。例如： 1db.testData.find({ x : 18 }); 從集合中取得一筆資料1db.testData.findOne(); 限制查詢數量為了程式的效能問題你可以限制每次查詢傳回的資料數量。 1db.testData.find().limit(3); 資料文件(documents)在 MongoDB 中我們稱一筆資料為 documents 類似于關聯式資料庫中的一筆 record，MongoDB 儲存資料的格式類似 JSON，使用鍵值對應。 documents 類似程式語言中的 structures 關聯一個 key 和 value。透過 key 值就可以對應找到 value，在其他程式語言中也有類似功能的東西。例如 dictonaries, hashes, maps 等等。關於這個 document 正式的名稱稱為 BSON。它是一個二進制格式的 JSON 檔案。 集合(collections)接著 MongoDB 把這些 documents 存在一個 collections 裡面。一個 collection 是一個群組用來關聯這些 documents。它們共用一個通用的索引。collections 類似于關聯式資料庫的 table。 資料庫操作查詢讓我們直接透過一個實際的範例來大概了解關於 MongoDB 查詢一筆特定資料的語法： 1db.users.find({age: {$gt: 18}}).sort({age: 1}) db 目前使用的資料庫。users 資料表。find() 查詢 = select。{age: {$gt: 18}} 條件 = age 這個欄位要 &gt; 18 。sort 排序。{age:1} 使用 age 這個欄位來排序，1 的用意是正向排序 ASC，如果要反向排序則用 -1 DESC 。 有了整體基本架構的了解之後相信就能快速上手了。 資料修改資料修改包含了 CRUD 的操作就是新增，讀取，更新，刪除。在 MongoDB 中這些操作是針對單一集合。跟 SQL 一樣更新或刪除一樣是可以指定條件。例如下面的例子建立一筆資料： 1db.users.insert({name: 'Andy', age: 18});","link":"/2014/01/29/mongodb-notes/"},{"title":"KineticJS 建立範圍選取功能","text":"KineticJS 介紹KineticJS 是一套針對 canvas 設計的函式庫，使得我們在操作使用 canvas 的時候相對簡單易懂。這篇文章將會教您如何透過 KineticJS 在螢幕上（canvas）建立一些物件，然後可以透過拖拉選取範圍。 背景如果您還不了解 HTML5 canvas 標簽，請先閱讀HTML5 Canvas Tutorials。如果您還不知道什麼是 KineticJS 請先至官網 閱讀基本教學。這篇文章是針對 KineticJS v4.7.4。 程式碼說明在這個範例中，將會在 canvas 建立三個方塊，然後可以選取它們。首先呢，您必須在 html 中有一個 container 1&lt;div id='container'&gt;&lt;/div&gt; 接著建立 stage 和 layer ，這部分如果您不能理解請先參考基本教學。簡單的說明，透過 Kinetic 來操作 canvas我們一般會建立一個 stage 和 layer ，透過 layer 包含各種圖形物件，stage 包含 layer 分層的方式來組織 canvas 123456var stage = new Kinetic.Stage({ container: 'container', width: 100, height: 100});var layer = new Kinetic.Layer(); 為了完成我們的功能，第一個技巧是在整個 layer 放入一張全滿透明的方形物件，這物件是用來判斷當使用者點擊滑鼠的時候可以開始進行拖曳以及放開的時候做些對應的處理。 123456789var rectBackground = new Kinetic.Rect({ x: 0, y: 0, height: stage.attrs.height, width: stage.attrs.width, fill: 'transparent', draggable: false, name: 'rectBackground'}); 現在我們可以加入上面說的方形物件。 1234567891011121314151617181920212223242526272829303132333435363738394041DrawBlocks();function DrawBlocks() { var x, y, heigth; x = 90; y = 10; size = 40; CreateBlock(x, y, size, size, 'green'); x = 150; y = 80; CreateBlock(x, y, size + 20, size + 60, 'red'); x = 110; y = 170; CreateBlock(x, y, size, size, 'blue'); layer.draw();}function CreateBlock(x, y, height, width, color) { var grpBlk = new Kinetic.Group({ x: x, y: y, height: height, width: width, name: color, draggable: true }); var blk = new Kinetic.Rect({ x: x, y: y, height: height, width: width, fill: color, name: color + ' block' }); grpBlk.add(blk); blk.setAbsolutePosition(x, y); grpBlk.setAbsolutePosition(x, y); layer.add(grpBlk); return grpBlk;} 這個範例讓我們可以透過拖拉滑鼠建立一個選取方塊，為了做到這點我們需要一些變數的協助。 123456var arSelected = new Array(); // 陣列是用來保存被選取到的 block 的名稱。var bDragging = false; // 當程式正在透過滑鼠拖拉計算方塊的大小時避免程式又從新執行。var bHaveSelBox = false; var rectSel = null; // 最終看到的選取方形var initX = 0; // 初始的 x, y 坐標。var initY = 0; 現在我們需要介紹一些處理事件，第一件要做的事情是我們需要截取當滑鼠點擊的那一瞬間。 123rectBackground.on('mousedown', function(evt) { bDragging = true;} 接著，當滑鼠開始移動拖拉，我們需要重新產生選取方塊。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859stage.getContent().addEventListener('mousemove', function(e) { if (bDragging) { SetSelRectPosition(e); }});var bInHere = false; // 防止事件重新被執行。function SetSelRectPosition(e) { if (bDragging &amp;&amp; !bInHere) { bInHere = true; var canvas = layer.getCanvas(); var mousepos = stage.getPointerPosition(); var x = mousepos.x; var y = mousepos.y; if (!bHaveSelBox) { initX = x; initY = y; rectSel = new Kinetic.Rect({ x: initX, y: initY, height: 1, width: 1, fill: 'transparent', stroke: 'black', strokeWidth: 1 }); layer.add(rectSel); layer.draw(); bHaveSelBox = true; } else { var height = 0; var width = 0; var newX = 0; var newY = 0; if (x &gt; initX) newX = initX; else newX = x; if (y &gt; initY) newY = initY; else newY = y; height = Math.abs(Math.abs(y) - Math.abs(initY)); width = Math.abs(Math.abs(x) - Math.abs(initX)); rectSel.setHeight(height); rectSel.setWidth(width); rectSel.setX(newX); rectSel.setY(newY); layer.draw() } } bInHere = false;} 接著當使用者放掉滑鼠按鍵時，我們需要計算哪些物件被選取了然後把它們的名稱放到 arSelected 陣列。稍後我們就可以拿這個清單去做高亮等處理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263stage.getContent().addEventListener('mouseup', function(e) { if (bDragging) { bDragging = false; GetOverlapped(); if (rectSel != null) rectSel.remove(); rectSel = null; bHaveSelBox = false; layer.draw(); }});function GetOverlapped(){ if (rectSel == null) { return ; } var iHeight = 0; var iWidth = -1000; arSelected.length = 0; initX = 10; initY = 10; var arGroups = layer.getChildren(); for (var i=0; i&lt;arGroups.length; i++) { var grp = arGroups[i]; if (grp.attrs.name != rectSel.attrs.name &amp;&amp; grp.attrs.name != rectBackground.attrs.name grp.attrs.name != 'btn' &amp;&amp; grp.attrs.name != 'highlightBlock') { var pos = rectSel.getAbsolutePosition(); var selRecXStart = parseInt(pos.x); var selRecXEnd = parseInt(pos.x) + parseInt(rectSel.attrs.width); var selRecYStart = parseInt(pos.y); var selRecYEnd = parseInt(pos.y) + parseInt(rectSel.attrs.height); var grpXStart = parseInt(grp.attrs.x); var grpXEnd = parseInt(grp.attrs.x) + parseInt(grp.attrs.width); var grpYStart = parseInt(grp.attrs.y); var grpYEnd = parseInt(grp.attrs.y) + parseInt(grp.attrs.height); if ((selRecXStart &lt;= grpXStart &amp;&amp; selRecXEnd &gt;= grpXEnd) &amp;&amp; (selRecYStart &lt;= grpYStart &amp;&amp; selRecYEnd &gt;= grpYEnd)) { if (arSelected.indexOf(grp.getName()) &lt; 0) { arSelected.push(grp.getName()); var tmpX = parseInt(grp.attrs.x); var tmpY = parseInt(grp.attrs.y); var rectHighlight = new Kinetic.Rect({ x: tmpX, y: tmpY, height: grp.attrs.height, width: grp.attrs.width, fill: 'transparent', name: 'highlightBlock', stroke: '#41d6f3', strokeWidth: 3 }); layer.add(rectHighlight); } } } }} 最後當使用者在背景點一下要取消選取，或者選取單一方塊 1234567891011121314151617181920212223stage.getContent().addEventListener('mousedown', function(e) { if(arSelected.length &gt; 0) { var name = ''; if (e.shape != undefined) name = e.shape.attrs.name; if (e.targetNode != undefined) name = e.targetNode.attrs.name; if (name != 'btn') RemoveHighlights(); }});function RemoveHighlights(){ var arHighlights = layer.get('.highlightBlock'); while (arHighlights.length &gt; 0) { arHighlights[0].remove(); arHighlights = layer.get('.highlightBlock'); } arSelected.length = 0;} 在這個範例中我們會在增加一個按鈕可以用來取得關於被選取物件的資料 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758x = 85;y = 250;var grpGetSelectedButton = CreateButton(x, y, &quot;Get Selected&quot;);grpGetSelectedButton.on(&quot;click&quot;, function (evt) { ShowSelected(); });function CreateButton(x, y, text){ var grpButton = new Kinetic.Group({ x: x, y: y, height: 30, width: 135, name: 'btn', draggable: true }); var blkButton = new Kinetic.Rect({ x: x, y: y, height: 30, width: 135, fill: 'Violet', name: 'btn' }); var txtButton = new Kinetic.Text({ x: x + 2, y: y + 2, fontFamily: 'Calibri', fontSize: 22, text: text, fill: 'black', name: 'btn' }); grpButton.add(blkButton); grpButton.add(txtButton); grpButton.setAbsolutePosition(x, y); blkButton.setAbsolutePosition(x, y); txtButton.setAbsolutePosition(x + 2, y + 2); layer.add(grpButton); return grpButton;}function ShowSelected(){ var str = &quot;&quot;; for (var i = 0; i &lt; arSelected.length; i++) { str += arSelected[i] + &quot;, &quot;; } if (str != &quot;&quot;) str = str.substring(0, str.length - 2); alert(str);}","link":"/2013/11/28/kineticjs-establish-a-range-selection-function/"},{"title":"React 快速概覽","text":"入門開始學習了解 React 的方式就是使用 JSFiddle 來觀察實作的範例： Hello Worlds。 React JSFiddle React JSFiddle without JSX 下載入門套件下載入門範例與套件。 v0.8.0 解開壓縮檔後，在根目錄建立一個 helloworld.html 然後輸入下面的例子。 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=&quot;build/react.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;build/JSXTransformer.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;example&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/jsx&quot;&gt; /** @jsx React.DOM */ React.renderComponent( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('example') ); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在 Javascript 裡面使用 XML 格式的語法叫做 JSX，這種語法是官方推薦的寫法。可以參考學習更多關於 JSX 的用法。為了使 JSX 可以正確的轉換為 Javascript 我們會使用 &lt;script type='text/jsx'&gt; 標簽，以及記得要載入 JSXTransformer.js 以確保程式正確執行。在這邊我們會先提醒那些有程式開發經驗的學習者。不要忘記在一開始加入 /** @jsx React.DOM */，這不是一般註解，它是 React 用來定義要處理的 JSX 。如果你沒有加入這個片段，你的程式碼將不會被轉換。 獨立的檔案你的 React JSX 檔案可以是分開的獨立檔案。接著讓我們建立 src/helloworld.js 12345/** @jsx React.DOM */React.renderComponent( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('example')); 然後在 helloworld.html 加入 1&lt;script type=&quot;text/jsx&quot; src=&quot;src/helloworld.js&quot;&gt;&lt;/script&gt; 即使是分開檔案功能仍然可以運行，這在大型專案中將有助于 DRY 原則，同樣功能的元件應該抽離獨立。 離線轉換 JSX安裝這個指令轉換工具（command-line）需要先安裝 npm。 1$ npm install -g react-tools 然後轉換 src/helloworld.js 檔案為原生 Javascript。 1$ jsx --watch src/ build/ 看看自動產生的 build/helloworld.js 如下，因為使用了 --watch 參數，你可以直接修改 JSX ，然後工具就會自動更新。指令的語法是 jsx --watch &lt;source directory&gt; &lt;output directory&gt; ，所以請不要指定到檔案。 12345/** @jsx React.DOM */React.renderComponent( React.DOM.h1(null, 'Hello, world!'), document.getElementById('example')); 注意註解的解析器是非常嚴格的;為了能夠提取 @jsx 修飾子，兩件事情必須遵守： @jsx 註解區塊必須要在檔案或程式碼的開頭，也必須是第一段註解。 註解的開頭必須是 /** （/* 和 // 將會不正常）。如果解析器找不到 @jsx註解區塊 輸出時就不會執行轉換。 讓我們接著更新 HTML 如下： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Hello React!&lt;/title&gt; &lt;script src=&quot;build/react.js&quot;&gt;&lt;/script&gt; &lt;!-- No need for JSXTransformer! --&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;example&quot;&gt;&lt;/div&gt; &lt;script src=&quot;build/helloworld.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 注意： type='text/jsx' 要拿掉，否則無法運作。 使用 CommonJS如果你想要使用模組化的 React ， 請 fork 官方專案，然後執行 npm install 和 grunt，便可以產出遵循 CommonJS 規則模組化的程式碼。官方提供的 jsx 編譯工具可以整合可以簡單地整合到大部份的封裝系統。CommonJS 補充 下一步查閱官方教學和其他/examples範例目錄學習更多。","link":"/2014/02/05/reactjs-getting-started/"},{"title":"Gulp 初體驗","text":"Gulp 初體驗從轉用 Grunt 以來其實我沒有遇到太多問題，加上大部份的 Framework 都把 Task 寫得好好的，對我來說用就好了。特別要客製的地方大概也都是小改一下別人的 Gruntfile 。這篇記錄沒有要特別去分析 Gulp 。介紹在這篇The streaming build system Gulp就解釋得蠻清楚的了。只不過在這不想外出的下雨天稍微用看看 Gulp。以下記錄非常單純，只是透過 Gulp 來編譯 Coffee, Jade，使用一下 watch 功能體驗一下。 透過實作我覺得比較容易理解： 安裝1$ npm install -g gulp 建立一個簡單的測試專案123$ mkdir gulp-test # 建立目錄$ npm init # 建立 package.json$ npm install gulp gulp-util gulp-jade gulp-coffee gulp-watch 建立 gulpfile.js這隻檔案的功能跟 Grunt 的 Gruntfile.js 功能上是一樣的就是組織任務的地方。下面這段程式碼雖然已經被驗證有瑕疵，但在這邊只是為了體驗一下概念還是先保留後面會再補上比較好的做法。 1234567891011121314151617var gulp = require('gulp');var gutil = require('gulp-util');var jade = require('gulp-jade');var watch = require('gulp-watch');var coffee = require('gulp-coffee');gulp.task('default', function () { gulp.src('./*.coffee') .pipe(watch()) .pipe(coffee()) .pipe(gulp.dest('./')) , gulp.src('./*.jade') .pipe(watch()) .pipe(jade()) .pipe(gulp.dest('./'))}); 建立測試用 Jade1234567doctype htmlhtml head title Hello Gulp &amp; Jade script(src='test.js') body h1 Cool, Getting Started 列出可執行的任務1$ gulp -T 執行任務1$ gulp 比較好的做法根據官方的範例，其實 watch 應該是直接使用內建的 api 就好了。下面把試用的一段程式碼提供給大家參考 1234567891011121314151617181920212223242526272829303132333435363738394041// 載入函式庫var gulp = require('gulp');var gutil = require('gulp-util');var jade = require('gulp-jade');var watch = require('gulp-watch');var coffee = require('gulp-coffee');// 定義路徑var paths = { coffee: ['*.coffee'], jade: ['*.jade']};// 編譯 coffee script 任務gulp.task('coffee', function () { gulp.src(paths.coffee) .pipe(coffee()) .pipe(gulp.dest('./'))});// 編譯 jade 任務gulp.task('jade', function () { gulp.src(paths.jade) .pipe(jade()) .pipe(gulp.dest('./')) gutil.log('log here...ok') // 可以使用 gutil 輸出資料});var watcher = gulp.task('watch', function () { // 建立完成任務後的 callback var done = function (evt) { console.log('File ' + evt.path + ' was ' + evt.type + ', running tasks...'); }; var coffeer = gulp.watch(paths.coffee, ['coffee'], done); // 觸發時綁定一個 event coffeer.on('change', function () { gutil.log('start changing...'); }); gulp.watch(paths.jade, ['jade']);});gulp.task('default', ['coffee', 'jade', 'watch']); 心得用起來其實蠻直覺的，不過小試了一下覺得第一文件有點不完整。有些小細節沒有內建功能，例如 gulp -T 對於指令竟然沒有地方可以放描述(我在文件上沒找到)。寫起來很爽，不過我覺得對專案來說除了寫 gulpfile 以外的其他開發者應該會覺得這些 task 提示的訊息怎麼這麼少。當然這些是可以加的，只不過初步用起來會覺得少蠻多東西的。XD","link":"/2014/02/09/gulp-first-experience/"},{"title":"React 第一個實戰範例","text":"學習手冊本篇教學會協助你建立一個簡單，但是實用的留言框功能，你可以放置到你的 blog 中。類似于Disqus，LiveFyre，或者 Facebook comments。留言框提供下列功能： 留言框的界面(view)。 一個表單(form)可以送出留言。 為你的後端程式提供一個 Hooks ， Hooks 簡易說明：Hooks 英文翻譯為鉤子，在程式術語中所表達的是在程式特定位置埋入一段預留的程式碼，用來呼叫其他對應的程式碼。可以大略想成在某個片段先空出一個位置，這個位置可以在事後再放入動作，不放也沒關係。 同時也有下列的特點: 優化留言：留言在儲存到伺服器之前就出現在列表中，這會讓使用者有變快的感覺。 及時更新：當其他使用者留言時，我們將及時的取出他們的留言並放置到界面中，不用等使用者自己更新頁面。 Markdown 格式：使用者可以用 Markdown 格式來留言，這可使得留言的排版更多元整齊。 直接閱覽原始碼 Github 起步在這一篇教學中我們會使用預先建置好放置在 CDN 的 Javascript 檔案。開啟你最愛的文字編輯器例如：Sublime text 然後建立一個 HTML 文件如下： 1234567891011121314151617181920&lt;!-- template.html --&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Hello React&lt;/title&gt; &lt;script src=&quot;http://fb.me/react-0.8.0.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://fb.me/JSXTransformer-0.8.0.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://code.jquery.com/jquery-1.10.0.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;content&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/jsx&quot;&gt; /** * @jsx React.DOM */ // The above declaration must remain intact at the top of the script. // 上面的宣告註解仍然得維持在 &lt;script&gt; 標簽中的頂部。 // Your code here！您的程式碼。 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 為了完成教學剩下的部分，我們開始在 &lt;script&gt; 標簽內撰寫 Javascript。 第一個元件整個 React 本身就是在模組化和設計可組成的元件，例如這個留言框的範例接下來就會遵循元件的架構。 1234- CommentBox - CommentList - Comment - CommentForm 在使用 React 開發時一開始定義好整個架構可以協助您更快速準確的開發。讓我們來建立 CommentBox 留言框這個元件，它只需要一個簡單的 &lt;div&gt;： 1234567891011121314// tutorial1.jsvar CommentBox = React.createClass({ render: function() { return ( &lt;div className=&quot;commentBox&quot;&gt; Hello, world! I am a CommentBox. &lt;/div&gt; ); }});React.renderComponent( &lt;CommentBox /&gt;, document.getElementById('content')); 小提醒：在 React 中使用 JSX &lt;div&gt; 或 &lt;CommentBox /&gt; 的標簽時 / 結尾的關閉標簽一定要加，否則會造成錯誤。 JSX 語法首先就是你應該注意到那些在 Javascript 中類似 XML 的語法，這些特殊的 JSX 語法是為了讓我們更方便直覺的維護程式碼的糖衣語法，我們會需要使用預先編譯器負責去轉換這些糖衣語法為原生的 Javascript。 糖衣語法：指程式語言中添加的某種語法，這種語法對語言的功能並沒有影響，但是更方便程式設計師使用。通常來說使用語法糖能夠增加程序的可讀性，從而減少程序代碼出錯的機會。 事實上，如果不使用 JSX 你依然可以撰寫 React 。不過得改用原生的 React 物件去組織程式碼，而寫出來的程式碼和透過 JSXTransformer 轉換的語法基本上是會一樣的。如下範例： 123456789101112131415var CommentBox = React.createClass({ render: function () { reutrn ( React.DOM.div({ className: 'commentBox', children: 'Hello, world! I am a CommentBox.' }) ); }});React.renderComponent( CommentBox({}), document.getElementById('content')) 小提醒：開發時我們會使用 JSXTransformer 以方便開發，而當要部署 Production 的時候，建議要先行編譯轉換以提升效能。 JSX 不是一定要使用的，不過官方建議 JSX 的語法比純 Javascript 更簡潔易維護，如果你想了解更多可以閱讀 JSX Syntax。 剛剛我們做了什麼？React.createClass() 透過傳入一個 Javascript 物件包含一些方法(method)就可以建立新的 React 元件物件。在所有方法裡面最重要的就是 render() ，它會傳回一個 React 元件的樹狀結構，最後被輸出成 HTML 。在 JSX 裡面的 &lt;div&gt; 標簽並不是實際的 DOM 元素。他只是 React div 元件的實例物件(React.DOM.div)。你可以把它當成一種標記或者資料片段，他的功用只是讓 React 知道該怎麼處理這些標記，進而產生對應的 HTML。這也是 React 本身提供的一套安全機制。它並不會直接產生 HTML 字串，它是透過解析標記最後透過內部一套機制產生 DOM 物件 ，所以預設就可以防止關於 XSS 攻擊。因此你不需要撰寫一段標準完整的 HTML 語法，只要傳回一個你或其他人寫的元件結構。這就是 React 所謂『可組成』的概念，前端發展可維護性程式碼的核心概念之一。React.renderComponent() 這個方法是用來將根元件實例化，並且把 React 產生的標記注入到第二個參數指向的原始 HTML DOM 元素。以上例來說就是第一個參數是先初始化 &lt;CommentBox /&gt; 把它 new 出來後，再把 React 解析產生的 HTML (嚴格說是 DOM 元素)注入到 document.getElementById('content') 這個元素中。 組成元件讓我們來繼續建構 CommentList 和 CommentForm: 12345678910111213141516171819var CommentList = React.createClass({ render: function() { return ( &lt;div className=&quot;commentList&quot;&gt; Hello, world! I am a CommentList. &lt;/div&gt; ); }});var CommentForm = React.createClass({ render: function() { return ( &lt;div className=&quot;commentForm&quot;&gt; Hello, world! I am a CommentForm. &lt;/div&gt; ); }}); 接著修改 CommentBox 元件，使用我們剛剛完成的 CommentList 和 CommentForm。 1234567891011var CommentBox = React.createClass({ render: function() { return ( &lt;div className=&quot;commentBox&quot;&gt; &lt;h1&gt;Comments&lt;/h1&gt; &lt;CommentList /&gt; &lt;CommentForm /&gt; &lt;/div&gt; ); }}); 注意到我們在上面的範例混合了 HTML 的 &lt;h1&gt; 標簽和 &lt;CommentList&gt; 等元件，HTML 標簽是正規的 React 元件，就跟你定義的元件一樣，但這之中有一點點不同。 JSX 的編譯器會自動把 HTML 標簽轉成 React.DOM.tagName ，這是為了防止污染全域的命名空間。 補充：如果你對於不使用 JSX 的寫法比較有興趣下面列出一段大概的用法： 1234567891011var CommentBox = React.createClass({displayName: 'CommentBox', render: function () { return ( React.DOM.div( {className:&quot;commentBox&quot;}, React.DOM.h1(null, &quot;Comments&quot;), CommentList(null ), CommentForm(null ) ) ); }}); 元件屬性(Component Properties)建立 Comment 元件。我們想要顯示留言者的名字和訊息，並且重複使用相同的程式碼給每一則獨立的留言。讓我們加入一些留言到 CommentList： 12345678910var CommentList = React.createClass({ render: function() { return ( &lt;div className=&quot;commentList&quot;&gt; &lt;Comment author=&quot;Pete Hunt&quot;&gt;This is one comment&lt;/Comment&gt; &lt;Comment author=&quot;Jordan Walke&quot;&gt;This is *another* comment&lt;/Comment&gt; &lt;/div&gt; ); }}); 現在我們使用類似 XML 的語法格式在 CommentList 放入一些子元素 Comment 和一些資料到屬性。每一個 &lt;Comment&gt; 表示一則留言訊息。在結構上資料是透過父元素傳給子元素的，要完成把資料傳給子元素有一個重要的方式叫做 props 就是 Properties 的縮寫，或者說可以透過 props 取得父元素的資料。 小筆記：邏輯上 CommentList 是整個留言列表所以資料會繫結到這個元件上，再透過迭代的方式去產生底下的 Comment 元件。上面的範例我們先使用 hardcode 的方式讓讀者理解概念。 使用 props建立 Comment 元件類別，它將會從 CommentList 讀取資料然後渲染標記。再複習一次整個 React 的架構就是分別建立各個元件，然後透過組合的方式來實現 reuse 的原則，設計上我們通常會讓父元素取得資料，這樣就可以在內部直接迭代渲染輸出 HTML 。而在取得資料的部分，通常我們會使用 React 提供的 props 來實現 。如下面範例： 123456789101112var Comment = React.createClass({ render: function() { return ( &lt;div className=&quot;comment&quot;&gt; &lt;h2 className=&quot;commentAuthor&quot;&gt; {this.props.author} &lt;/h2&gt; {this.props.children} &lt;/div&gt; ); }}); 在 JSX 中透過大括號，你可以在裡面使用 Javascript 表示式（例如取得任何一個屬性或子元素）。你現在可以放入一些文字或 React 元件到這個結構中。然後我們可以透過屬性的名稱去存取資料，使用的方式是利用 this.props 或在這個巢狀結構下的任何元素 ex: this.props.children。 加入 Markdown 功能Markdown 是一種簡單的文字格式。舉個例子用 * 包圍的文字會變成斜體， HTML 中為強調語氣的語意。要增加這個功能我們可以使用第三方的函式庫 Showdown。透過這個函式庫可以把 Markdown 格式的文字轉換成 HTML。下面我們直接使用 CDN 上的檔案載入此函式庫。 1234567&lt;!-- template.html --&gt;&lt;head&gt; &lt;title&gt;Hello React&lt;/title&gt; &lt;script src=&quot;http://fb.me/react-0.8.0.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://fb.me/JSXTransformer-0.8.0.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://cdnjs.cloudflare.com/ajax/libs/showdown/0.3.1/showdown.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt; 接著就可以在程式碼中使用它 12345678910111213var converter = new Showdown.converter();var Comment = React.createClass({ render: function() { return ( &lt;div className=&quot;comment&quot;&gt; &lt;h2 className=&quot;commentAuthor&quot;&gt; {this.props.author} &lt;/h2&gt; {converter.makeHtml(this.props.children.toString())} &lt;/div&gt; ); }}); 這邊我們呼叫了 Showdown 的函式庫，我們需要轉換 this.props.children ，讓他從 React 的換行文字先轉成純文字，接著 Showdown 就可以轉換。在這個過程中，我們通常會明確的呼叫 toString()。但是這邊有一個問題，我們輸出的留言看起來會變成 &lt;p&gt;This is &lt;em&gt;another&lt;/em&gt; comment&lt;/p&gt;。我們希望這些標簽可以正確被的輸出成 HTML。這是 React 預設防止 XSS 攻擊的機制。這邊提供一種方式，但是框架會警告你不要使用它： 1234567891011121314var converter = new Showdown.converter();var Comment = React.createClass({ render: function() { var rawMarkup = converter.makeHtml(this.props.children.toString()); return ( &lt;div className=&quot;comment&quot;&gt; &lt;h2 className=&quot;commentAuthor&quot;&gt; {this.props.author} &lt;/h2&gt; &lt;span dangerouslySetInnerHTML={{__html: rawMarkup}} /&gt; &lt;/div&gt; ); }}); 這是一個特殊的 API 企圖讓寫入 HTML 變得比較困難一點，但因為 Showdown 需要輸出 HTML 的關係我們必須要開一個後門。 提醒：使用這個功能你必須依賴 Showdown 本身的安全性，以及確保被轉換的資料不會有風險。 連結資料模型到目前為止，我們已經在程式碼直接寫入了一些留言，實務上我們的資料通常會從資料庫來，這邊我們用一些 JSON 格式的資料來模擬實際的狀況。 1234var data = [ {author: &quot;Pete Hunt&quot;, text: &quot;This is one comment&quot;}, {author: &quot;Jordan Walke&quot;, text: &quot;This is *another* comment&quot;}]; 在這邊我們會透過模組化的方式去取得資料，實務上舉例就是通常我們會取得一批資料傳給 CommentList 透過程式去一筆一筆輸出。避免使用 hardcode 的方式像上面的例子 &lt;Comment&gt;。修改 CommentBox 和 renderComponent() ，換成使用 props 取得資料後傳給 CommentList。 12345678910111213141516var CommentBox = React.createClass({ render: function() { return ( &lt;div className=&quot;commentBox&quot;&gt; &lt;h1&gt;Comments&lt;/h1&gt; &lt;CommentList data={this.props.data} /&gt; &lt;CommentForm /&gt; &lt;/div&gt; ); }});React.renderComponent( &lt;CommentBox data={data} /&gt;, document.getElementById('content')); 現在資料已經是透過 JSON 格式來取得了並且和 CommentList 繫結，接著就讓我們動態的輸出這些留言吧。 小筆記：撰寫 React 的時候概念上我們可以把 createClass 就理解成是在建立一個類別，renderComponent() 就是在實例化物件，此時該傳入的資料(參數)我們就透過標簽屬性(attributes)帶入。 123456789101112var CommentList = React.createClass({ render: function() { var commentNodes = this.props.data.map(function (comment) { return &lt;Comment author={comment.author}&gt;{comment.text}&lt;/Comment&gt;; }); return ( &lt;div className=&quot;commentList&quot;&gt; {commentNodes} &lt;/div&gt; ); }}); 透過 map 函式去處理陣列，處理後的結果如下圖。從下面編譯過的程式碼，我們可以知道 React 會自動去迭代輸出陣列。 123456789101112var CommentList = React.createClass({displayName: 'CommentList', render: function() { var commentNodes = this.props.data.map(function (comment) { return Comment( {author:comment.author}, comment.text); }); return ( React.DOM.div( {className:&quot;commentList&quot;}, commentNodes ) ); }}); 範例到此相信有經驗的開發者已經能夠掌握 React 的核心概念了。我們在從範例的角度說明到目前為止我們做了什麼：首先，我們建立了 CommentBox，在裡面部署了 CommentList 和 CommentForm 物件，CommentList 透過 this.props.data 從父元素 CommentBox 那邊取得資料。這個屬性把資料繫結到此物件上。接著在 CommentList 類別裡面我們用得到的資料組合出 Comment 的陣列，並讓 Comment 這個元件去負責每一則留言的呈現。最後我們又用了 CommentForm 元件來實踐送出留言的功能。對於一些比較少OOP經驗的開發者，模組化剛開始可能會覺得有點亂。筆者透過一張圖大略的說明整個基本的流程： 從伺服器取得資料讓我們移除寫死的資料改用一些從伺服器端來的動態資料。在這一步我們會透過 url 來取得資料。 1234React.renderComponent( &lt;CommentBox url=&quot;comments.json&quot; /&gt;, document.getElementById('content')); 這個元件將跟之前的不一樣，因為它必須要自己重新載入並輸出。一開始這個元件並沒有任何資料，直到發出的 Request 從伺服器取得資料，這個時候元件就需要重新渲染。在上面範例中我們只是單純地取得某個 JSON 檔案。 狀態回應到目前為止每一個元件都根據自身的 props 取得的資料渲染了一次，props 本身是靜態不會變動的。它們從父元素取得，而且是父元素擁有的。為了完成互動功能，需要-元件的狀態屬性 this.state 。這個屬性本身是 private ，只能透過呼叫 this.setState() 去更改。當狀態改變的時候，元件就會重新渲染輸出。render() 是用來處理關於 this.props 和 this.state 的資料。我們會把資料放在 props 和 state 裡面接著透過 render() 去處理該如何呈現。整個框架必須確保所有資料和UI上呈現的是一致的。當伺服器獲得資料，我們就需要把我們有的資料新增或修改到留言框上。接著讓我們加入一個留言資料的陣列到 CommentBox 的狀態屬性上。 1234567891011121314var CommentBox = React.createClass({ getInitialState: function() { return {data: []}; }, render: function() { return ( &lt;div className=&quot;commentBox&quot;&gt; &lt;h1&gt;Comments&lt;/h1&gt; &lt;CommentList data={this.state.data} /&gt; &lt;CommentForm /&gt; &lt;/div&gt; ); }}); getInitialState() 這個方法再整個元件的生命週期中只會執行一次，目的是用來設定初始化 this.state 的資料。按上面的例子就是你傳回了一個 {data: []} 物件給 this.state 。之後便可以使用 this.state.data 取得這個陣列。 更新狀態當元件第一次被建立的時候，我們想透過 GET 方式從伺服器取得一些 JSON 格式的資料，替 state 更新對應的最新資料。在實務上這通常是動態從資料庫，API 或其他服務取得，不過在這個例子為了簡化我們使用靜態的 JSON 檔案。在根目錄建立一個 comments.json 如下 1234[ {&quot;author&quot;: &quot;Pete Hunt&quot;, &quot;text&quot;: &quot;This is one comment&quot;}, {&quot;author&quot;: &quot;Jordan Walke&quot;, &quot;text&quot;: &quot;This is *another* comment&quot;}] 我們會搭配使用 jQuery 來協助我們發出非同步請求給伺服器，以取得資料。注意：因為加入 jQuery 這已經是一個 AJAX 應用程式，你會使用網頁伺服器來執行這個範例，而不是單純在瀏覽器執行檔案。最簡單的方式是在目錄下執行 python -m SimpleHTTPServer，或者熟悉 Grunt 的開發者可以使用grunt-init-simple-server。 1234567891011121314151617181920212223242526var CommentBox = React.createClass({ getInitialState: function() { return {data: []}; }, componentWillMount: function() { $.ajax({ url: 'comments.json', dataType: 'json', success: function(data) { this.setState({data: data}); }.bind(this), error: function(xhr, status, err) { console.error(&quot;comments.json&quot;, status, err.toString()); }.bind(this) }); }, render: function() { return ( &lt;div className=&quot;commentBox&quot;&gt; &lt;h1&gt;Comments&lt;/h1&gt; &lt;CommentList data={this.state.data} /&gt; &lt;CommentForm /&gt; &lt;/div&gt; ); }}); componentWillMount 方法會在元件渲染前自動被呼叫執行。在這個例子裡動態更新的關鍵是呼叫 this.setState() 。我們把本來的陣列資料移除，取代用從伺服器取得資料的方式，這裡為了保持簡單是使用 comments.json 。為了展示這種及時反應的效果，這邊加了一段程式碼達到輪詢的功能，意思是程式本身會不斷的重複去查詢 comments.json 的資料。 實務上你應該使用 secket.io 才不會造成效能很糟糕。 1234567891011121314151617181920212223242526272829303132var CommentBox = React.createClass({ loadCommentsFromServer: function() { $.ajax({ url: this.props.url, dataType: 'json', success: function(data) { this.setState({data: data}); }.bind(this) }); }, getInitialState: function() { return {data: []}; }, componentWillMount: function() { this.loadCommentsFromServer(); setInterval(this.loadCommentsFromServer, this.props.pollInterval); }, render: function() { return ( &lt;div className=&quot;commentBox&quot;&gt; &lt;h1&gt;Comments&lt;/h1&gt; &lt;CommentList data={this.state.data} /&gt; &lt;CommentForm /&gt; &lt;/div&gt; ); }});React.renderComponent( &lt;CommentBox url=&quot;comments.json&quot; pollInterval={2000} /&gt;, document.getElementById('content')); 我們把 AJAX 取得資料的片段獨立成一個方法，然後第一次載入的時候會呼叫一次，接著設定每兩秒執行一次。 新增留言是時候來建置我們的留言表單了，這個留言表單元件應該要詢問使用者他的名字和留言訊息，接著提交給伺服器儲存留言。 1234567891011var CommentForm = React.createClass({ render: function() { return ( &lt;form className=&quot;commentForm&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Your name&quot; /&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Say something...&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;Post&quot; /&gt; &lt;/form&gt; ); }}); 表單運作的流程是：當使用者提交表單時，我們應該清除裡面的資料，接著發出一個 Reauest 給伺服器，最後更新留言列表。 1234567891011121314151617181920212223242526var CommentForm = React.createClass({ handleSubmit: function() { var author = this.refs.author.getDOMNode().value.trim(); var text = this.refs.text.getDOMNode().value.trim(); if (!text || !author) { return false; } // TODO: send request to the server this.refs.author.getDOMNode().value = ''; this.refs.text.getDOMNode().value = ''; return false; }, render: function() { return ( &lt;form className=&quot;commentForm&quot; onSubmit={this.handleSubmit}&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Your name&quot; ref=&quot;author&quot; /&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Say something...&quot; ref=&quot;text&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;Post&quot; /&gt; &lt;/form&gt; ); }}); 事件：React 在元件上繫結事件是用 camelCase 命名規則，當表單驗證過並提交時我們使用了一個 onSubmit 事件來處理。這裡我們永遠回傳一個 false 來阻止瀏覽器預設的提交行為。（如果你比較喜歡透過 event 參數使用 e.preventDefault()，你也可以用它來取代 return false） Refs：使用 ref 屬性只設定子元素的名稱，就可以透過 this.refs 參考到該元件。我們可以呼叫 getDOMNode() 來取得原生的 DOM 元素。 透過 props 使用 callback：當使用者送出一則留言，我們將需要更新留言列表加入新的訊息， 在 CommentBox 實作這些邏輯是比較合理的，因為 CommentBox 負責掌控整個元件的狀態 this.state。所以在這個範例裡，我們需要從子元素把資料傳給父元素 CommentBox ，讓 CommentBox 去更新狀態，為了完成這個目的，我們在 props 放入一個 callback 函式，如此一來子元素便能透過呼叫這個函式把資料帶給父元素。看到這邊可能會有些混亂，沒關係讓我們先直接看 CommentBox 的程式碼: 1234567891011121314151617181920212223242526272829303132var CommentBox = React.createClass({ loadCommentsFromServer: function() { $.ajax({ url: this.props.url, dataType: 'json', success: function(data) { this.setState({data: data}); }.bind(this) }); }, handleCommentSubmit: function(comment) { // TODO: submit to the server and refresh the list }, getInitialState: function() { return {data: []}; }, componentWillMount: function() { this.loadCommentsFromServer(); setInterval(this.loadCommentsFromServer, this.props.pollInterval); }, render: function() { return ( &lt;div className=&quot;commentBox&quot;&gt; &lt;h1&gt;Comments&lt;/h1&gt; &lt;CommentList data={this.state.data} /&gt; &lt;CommentForm onCommentSubmit={this.handleCommentSubmit} /&gt; &lt;/div&gt; ); }}); 然後在 CommentForm 呼叫 1234567891011121314151617181920212223var CommentForm = React.createClass({ handleSubmit: function() { var author = this.refs.author.getDOMNode().value.trim(); var text = this.refs.text.getDOMNode().value.trim(); this.props.onCommentSubmit({author: author, text: text}); this.refs.author.getDOMNode().value = ''; this.refs.text.getDOMNode().value = ''; return false; }, render: function() { return ( &lt;form className=&quot;commentForm&quot; onSubmit={this.handleSubmit}&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Your name&quot; ref=&quot;author&quot; /&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Say something...&quot; ref=&quot;text&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;Post&quot; /&gt; &lt;/form&gt; ); }}); 總結上面敘述就是我們應該把處理寫入留言(提交到伺服器)的邏輯和程式碼寫在 CommentBox 元件裡面，就是 handleCommentSubmit 這個方法，接著透過 &lt;CommentForm onCommentSubmit={this.handleCommentSubmit} /&gt; 的方式把方法傳給子元件 CommentForm ，CommentForm 有需要送出留言的時候就可以透過 this.props.onCommentSubmit() 去呼叫。資料統一都由父元素管理是比較合理的做法。到目前為止我們概略的了解關於狀態和資料還有處理的方法應該放在父元素，你可以在父元素裡面在放置其他元件，如果子元素需要動用父元素的功能或資料就透過屬性(attributes)帶入參數的方式傳進去。 現在讓我們來完成 callback 函式該執行的任務 12345678910111213141516171819202122232425262728293031323334353637383940var CommentBox = React.createClass({ loadCommentsFromServer: function() { $.ajax({ url: this.props.url, dataType: 'json', success: function(data) { this.setState({data: data}); }.bind(this) }); }, handleCommentSubmit: function(comment) { $.ajax({ url: this.props.url, dataType: 'json', type: 'POST', data: comment, success: function(data) { this.setState({data: data}); }.bind(this) }); }, getInitialState: function() { return {data: []}; }, componentWillMount: function() { this.loadCommentsFromServer(); setInterval(this.loadCommentsFromServer, this.props.pollInterval); }, render: function() { return ( &lt;div className=&quot;commentBox&quot;&gt; &lt;h1&gt;Comments&lt;/h1&gt; &lt;CommentList data={this.state.data} /&gt; &lt;CommentForm onCommentSubmit={this.handleCommentSubmit} /&gt; &lt;/div&gt; ); }}); 優化UI更新這個範例到這邊已經全部完成了(實際呼叫 AJAX 後端操作並沒有實作在範例裡)，但是感覺有點慢，因為我們必須要等待發出的 Request 完成處理留言才會出現。我們可以優化這個部分讓使用者感覺更快。 12345678910111213141516171819202122232425262728293031323334353637383940414243var CommentBox = React.createClass({ loadCommentsFromServer: function() { $.ajax({ url: this.props.url, dataType: 'json', success: function(data) { this.setState({data: data}); }.bind(this) }); }, handleCommentSubmit: function(comment) { var comments = this.state.data; var newComments = comments.concat([comment]); this.setState({data: newComments}); $.ajax({ url: this.props.url, dataType: 'json', type: 'POST', data: comment, success: function(data) { this.setState({data: data}); }.bind(this) }); }, getInitialState: function() { return {data: []}; }, componentWillMount: function() { this.loadCommentsFromServer(); setInterval(this.loadCommentsFromServer, this.props.pollInterval); }, render: function() { return ( &lt;div className=&quot;commentBox&quot;&gt; &lt;h1&gt;Comments&lt;/h1&gt; &lt;CommentList data={this.state.data} /&gt; &lt;CommentForm onCommentSubmit={this.handleCommentSubmit} /&gt; &lt;/div&gt; ); }}); 上面這段程式碼的重點在加入 123var comments = this.state.data;var newComments = comments.concat([comment]);this.setState({data: newComments}); 透過這段程式使用者的留言在送出時本地端就先更新了，再發出 Request 給伺服器。後續元件本身會自己在去跟伺服器讀取最新的資訊。 恭喜你已經完成建置這個留言框的功能，也初步對如何使用 React 有了認識，學習更多關於為什麼使用 React 或查閱 API 參考。 最後附上完成的範例程式碼： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135&lt;!-- template.html --&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Hello React&lt;/title&gt; &lt;script src=&quot;http://fb.me/react-0.8.0.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://fb.me/JSXTransformer-0.8.0.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://code.jquery.com/jquery-1.10.0.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://cdnjs.cloudflare.com/ajax/libs/showdown/0.3.1/showdown.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;content&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/jsx&quot;&gt; /** * @jsx React.DOM */ var converter = new Showdown.converter(); var data = [ {author: &quot;Pete Hunt&quot;, text: &quot;This is one comment&quot;}, {author: &quot;Jordan Walke&quot;, text: &quot;This is *another* comment&quot;} ]; var CommentBox = React.createClass({ loadCommentsFromServer: function () { $.ajax({ url: this.props.url, dataType: 'json', success: function (data) { this.setState({data: data}); }.bind(this), error: function (xhr, status, err) { console.error('comments.json', status, err.toString()); }.bind(this) }); }, handleCommentSubmit: function (comment) { var comments = this.state.data; var newComments = comments.concat([comment]); this.setState({data: newComments}); $.ajax({ url: this.props.url, dataType: 'json', type: 'POST', data: comment, success: function (data) { this.setState({data:data}); }.bind(this) }); }, getInitialState: function () { return {data: []}; }, componentWillMount: function () { this.loadCommentsFromServer(); setInterval(this.loadCommentsFromServer, this.props.pollInterval) }, render: function () { return ( &lt;div className='commentBox'&gt; &lt;h1&gt;Comments&lt;/h1&gt; &lt;CommentList data={this.state.data}/&gt; &lt;CommentForm onCommentSubmit={this.handleCommentSubmit}/&gt; &lt;/div&gt; ); } }); /* var CommentBox = React.createClass({ render: function () { return ( React.DOM.div({ className: 'commentBox', children: 'Hello, world! I am a CommentBox.!!!' }) ); } }); */ var CommentList = React.createClass({ render: function () { var commentNodes = this.props.data.map(function (comment) { return &lt;Comment author={comment.author}&gt;{comment.text}&lt;/Comment&gt; }); return ( &lt;div className='commentList'&gt; {commentNodes} &lt;/div&gt; ); } }); var CommentForm = React.createClass({ handleSubmit: function () { var author = this.refs.author.getDOMNode().value.trim(); var text = this.refs.text.getDOMNode().value.trim(); if (!text || !author) { return false; } this.props.onCommentSubmit({author: author, text: text}); this.refs.author.getDOMNode().value= ''; this.refs.text.getDOMNode().value = ''; return false; }, render: function () { return ( &lt;form className='commentForm' onSubmit={this.handleSubmit}&gt; &lt;input type='text' placeholder='Your name' ref='author' /&gt; &lt;input type='text' placeholder='Say something' ref='text' /&gt; &lt;input type='submit' value=&quot;Post&quot; /&gt; &lt;/form&gt; ); } }); var Comment = React.createClass({ render: function () { var rawMarkup = converter.makeHtml(this.props.children.toString()); return ( &lt;div className='comment'&gt; &lt;h3 className='commentAuthor'&gt; {this.props.author} &lt;/h3&gt; &lt;span dangerouslySetInnerHTML={{__html: rawMarkup}} /&gt; &lt;/div&gt; ); } }); React.renderComponent( &lt;CommentBox url='comments.json' pollInterval={2000} /&gt;, document.getElementById('content') ); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","link":"/2014/02/07/reactjs-tutorial/"},{"title":"JSX 常見的陷阱","text":"JSX 常見的陷阱JSX 看起來像 HTML 但有一些您應該知道關鍵性的差異。注意：對於和 DOM 之間的差異，例如行內式屬性設定(inline style)，請查閱這裡。 DOM 的差異：React 為了跨瀏覽器和提升效能的因素，實作一套和瀏覽器本身無關的 events 以及模擬 DOM 的機制。我們可以借由這個機制處理一些關於原始 DOM 設計上一些不足的地方。 所有的 DOM 屬性 Properties 和 Attributes (包含事件)都應該使用駝峰式命名 camelCased ，這和一般的 Javascrpt 程式碼風格一致。我們故意在這邊違背 html 規格 ，因此這和 html 規格是不同的。 style 屬性透過 Javascript 物件和駝峰式的屬性來設定，而不是 CSS 字串。所以設定 CSS 的語法風格會和 DOM, Javascrit 屬性一致，外加這麼做可以防止 XSS 攻擊。 所有在事件符合 W3C 規範，且所有事件(包含 submit)傳遞都遵照 W3C 規範，查閱 Event System 取得更多資訊。 關於 onChange 事件行為就跟你所期待的一樣，當一個表單欄位改變了，事件就會被觸發，而不是在 onblur 失去焦點的時候才觸發。 我們特意違背現有的瀏覽器行為，因為原始的 onChange 事件行為跟其名稱並不符合，React 需要正確的用到這個 Event ，當使用者輸入資料的同時 React 就會及時反應。查閱Forms得知更多資訊。 表單輸入的屬性例如 value checked 更多關於一些命名，用法，等請查閱 Forms 移除空白字元JSX 不像 HTML 在渲染時如果在同一個點重複空白字元會保留一個其他自動移除，關於這點 JSX 會移除所有在 { } 之間的空白。如果你需要加入空白字元則要使用 {' '}。 1&lt;div&gt;{this.props.name} {' '} {this.props.surname}&lt;/div&gt; 如果你對這個設計有什麼想法，歡迎加入Issue #65討論。 HTML 字元實體您可以插入 HTML 字元實體在 JSX 裡： 1&lt;div&gt;First &amp;middot; Second&lt;/div&gt; 如果你想要顯示一個 HTML 字元實體在動態的內容中，你會遇到重複跳脫字元的問題。因為 React 為了防止 XSS 會把所有要呈現的文字都先跳脫(escapes)。 12// 不好的示範: 會輸出 &quot;First &amp;middot; Second&quot;&lt;div&gt;{'First &amp;middot; Second'}&lt;/div&gt; 這裡有一些方式可以解決這個問題。最簡單的方式就是在 Javascript 直接寫 unicode，不過你需要確定檔案被存成 UTF-8 格式。 1&lt;div&gt;{'First · Second'}&lt;/div&gt; 一個更安全的替代方式式找到 unicode 對應的編碼 12&lt;div&gt;{'First \\u00b7 Second'}&lt;/div&gt;&lt;div&gt;{'First ' + String.fromCharCode(183) + ' Second'}&lt;/div&gt; 也可以把字串混合進陣列裡面 1&lt;div&gt;{['First ', &lt;span&gt;&amp;middot;&lt;/span&gt;, ' Second']}&lt;/div&gt; 當你要插入 HTML 的時候你可以用這最後一招 1&lt;div dangerouslySetInnerHTML={{__html: 'First &amp;middot; Second'}} /&gt; 自定 HTML 屬性如果你傳給 HTML 元素的屬性並不在 HTML 規範中，React 並不會渲染它。如果你想要自訂一個屬性(attribute)。你應該使用前綴詞 data-。 1&lt;div data-custom-attribute=&quot;foo&quot; /&gt; 無障礙網站的話屬性使用 aria- 開頭。 1&lt;div aria-hidden={true} /&gt;","link":"/2014/02/10/reactjs-jsx-common-pitfalls/"},{"title":"為什麼使用 React ?","text":"原文 為什麼使用 React ？React 是 Facebook 和 Instagram 用來建置使用者介面的函式庫。近來有許多人考慮使用 React 來處理 MVC 中的 V 的部分。Facebook 創造了 React 是為了解決構建一個大型且資料不斷變動的應用程式時遇到的問題。為了達到這個需求，React 採用了兩個主要的核心概念。 單純性(Simple)任何一個時間點您的應用程式都應該傳達同樣的資訊，且當在背後的資料改變的時候 React 會自動管理關於界面 UI 上的更新。 定義的方式(Declarative)這個翻譯有點不是很精準，大略是說您不應該從外部去控制元件該如何更新資料，而是在元件內部定義資料是哪來的怎麼更新。當資料發生變更的時候，概念上就是 React 點擊了 refresh 按鈕，接著元件會自己知道只變更有更新的部分。 構建可組合的元件什麼是元件呢？在 React 中所有的東西都是元件。事實上，使用 React 就是在建立這些可以重複使用的元件。因此你的目標就是封裝，組件化，重複使用，關注點分離。 小弟認為最好實務上的舉例就是類似 WinForm 或 WPF 的控制項(dll)。用起來就像 XAML ，透過屬性傳遞參數，至於程式行為已經都封裝在類別裡面了。 給個 5 分鐘看看React 挑戰了很多傳統的做法，而且第一次大略看到這東西也許會覺得它瘋了嗎。給個 5 分鐘閱讀官方文件：這些概念已經建立了上千個元件且我們應用在 Facebook 和 Instagram。","link":"/2014/02/08/reactjs-why-reactjs/"},{"title":"Develop environment install note","text":"Solarized SublimeText 3 Document SublimeText 3 Tips SublimeText 3 Theme SublimeText 3 Javascript plugin iTerm2 iTerm2 Color Themes iTerm2 login with zsh oh-my-zsh 備註：會直接詢問密碼強迫更改成 default zsh ，使用 iTerm2 建議不要直接改成預設。接著在~/.zshrc修改樣板爲agnoster並在最下方補上 export DEFAULT_USER=[name]。 1$ chsh -s /bin/bash # Mofidy to default bash 1export DEFAULT_USER=&quot;&quot; 1234&quot;caret_style&quot;: &quot;phase&quot;,&quot;caret_extra_bottom&quot;: 0,&quot;caret_extra_top&quot;: 0,&quot;caret_extra_width&quot;: 2, ~/.ssh/config","link":"/2014/01/28/develop-environment-install/"},{"title":"React 互動式動態 UI","text":"互動式動態 UI你已經學會如果使用 React 呈現資料了。現在讓我們的界面增加互動的功能。 範例1234567891011121314151617181920212223/** @jsx React.DOM */var LikeButton = React.createClass({ getInitialState: function() { return {liked: false}; }, handleClick: function(event) { this.setState({liked: !this.state.liked}); }, render: function() { var text = this.state.liked ? 'like' : 'unlike'; return ( &lt;p onClick={this.handleClick}&gt; You {text} this. Click to toggle. &lt;/p&gt; ); }});React.renderComponent( &lt;LikeButton /&gt;, document.getElementById('example')); 事件處理與合成事件跟你在 HTML 裡替標簽增加事件處理程序一樣，在 React 中你必須要駝峰式的命名來設定事件。例如：onClick。React 保證實做的合成事件在 IE8 以上瀏覽器裡定義的所有事件行為是一致的。也就是說不管你使用哪種瀏覽器 React 都知道如何按照 Spec 規範傳遞(Bubble)和截取事件，並傳遞給事件處理程序確保一切都和 W3C 規範的一樣。如果你想使用 React 在觸控裝置上(例如: 智慧型手機和平板)，你可以呼叫 React.initializeTouchEvents(true) 開啟他們。 表面之下的機制：自訂繫結和委派React 內部做了一些處理以確保你的程式執行的效能不會太糟和容易理解。 自動繫結：在 Javascript 中當一個 callback 函式被建立時你通常需要明確的將它跟某個物件的方法關聯在一起使得我們可以確定資料是正確的。在 React ，每一個方法都是自動跟元件綁定。React 會暫存已綁定的方法以增加 CPU 和記憶體的使用效率。 事件委派：React 實際上並沒有附加任何事件到元素本身。當 React 啟動時，它會在最上層啟動一個事件監聽器監聽所有的事件。當一個元件載入或取消載入的時候，事件處理程序會自動從內部增加或移除。一旦事件被觸發，React 會知道如何調派以及使用對應的程序，如果裡面沒有對應的事件，React 則不會執行任何動作。如果你想學習關於增加處理速度的知識可以參考David Walsh’s excellent blog post。 元件就是狀態機React 認為 UI 就是一個簡單的狀態機。從 UI 的角度思考，UI 本身俱有多種狀態，並且負責把這些狀態輸出呈現。這樣做可以輕易讓你的 UI 保持一致。在 React 中，你只要單純更新元件的狀態，接著根據狀態渲染輸出新的 UI。React 透過較有效率的方式協助你更新 DOM 。 狀態如何運作比較普遍的方式通知 React 資料已經變動了是透過呼叫 setState(data, callback) ，這個方法會把資料 data 整合進 this.state 接著重新渲染元件。當原件完成這個動作，你可以額外的加入 callback 做後續處理，當然也可以不加。大多的狀況你不會需要提供 callback 因為 React 會自動及時的更新資料。 什麼元件應該有狀態？大部分的原件都應該會從 props 取得一些資料，然後輸出。然而有些時候你還是需要回應使用者的操作，伺服器的請求，或一些隨著時間變化的資料。這個時候我們就會使用狀態 state 。試著讓大多數的元件盡可能沒有狀態。透過這種方式你可以獨立各種狀態的邏輯盡可能減少複雜的邏輯，這會使你的應用程式比較容易理解。一個比較常見的模式是先建立一些沒有狀態的元件，它們只負責輸出資料，然後在它們的上層有一個負責管理狀態的元件再把狀態資訊透過 props 傳給子元素。這個有狀態的元件內部封裝所有邏輯和方法，透過屬性宣告的方式底下的元件只要負責渲染資料。 該如何使用狀態？狀態應該負責管理資料，實務上就是元件內的事件處理程序在資料發生異動的時候被觸發然後更新 UI 。在實際的程式裡這些資料通常是很小的 JSON。當建立一個管理狀態的元件時，盡可能思考最簡化的表達方式，且資料只放在 this.state 中。在 render() 方法內部則根據這個狀態單純的計算出你需要的資訊就好。你會發現思考並以這種方式寫程式往往是最正確的。因此在狀態內部增加任何多餘的資料或計算意味著你需要去處理多餘的東西以確保資料是一致的，不要一味的依賴 React 計算處理資料。 狀態不應該這樣用？this.state 應該只存放 UI 需要呈現的資料，不應該包含： 已處理完成的資料：不用預先計算處理狀態的資料。在 render() 裡面計算資料是比較容易確保 UI 的資料是正確的。舉例來說如果有一個項目清單的陣列，你想要輸出清單數量，應該單純的在 render() 裡面使用 this.state.listItems.length + ' list items' 而不是把值直接存在 this.state。 React 元件：在 render() 裡面根據 props state 去建置。 重複存取在 props 裡的資料：props 應該是正確資料的來源，因為 props 可能隨著時間改變。適當的把 props 存在 state 可以協助我們取得之前的資料。 補充說明：在上面的文章中我們了解到通常會使用一個主要的元件負責管理狀態，而其他子元件需要的時候則直接使用主元件的 props 和方法，下面的補充範例我們將簡單的示範一些關於使用事件的方式： 12345678910111213141516171819202122232425262728293031/** @jsx React.DOM *//* 建立一個 Clicker 元件類別 */var Clicker = React.createClass({ /* 透過 render() 輸出三個超連結並使用主元件的事件。 */ render: function () { var bind = this.handleBind.bind(this); return ( &lt;div&gt; { /* 下面這個超連結示範了一般使用主元件的方法 */} &lt;a onClick={this.handleNormal}&gt;Normal&lt;/a&gt; { /* 使用 bind() 的目的是為了在 function 內再使用主元件的函式 */} &lt;a onClick={bind}&gt;Bind&lt;/a&gt; { /* 在 0.4.0 版之後為了簡化程式碼，預設就是 autoBind。 */} &lt;a onClick={this.autoBindClick}&gt;AutoBind&lt;/a&gt; &lt;/div&gt; ); }, handleNormal: function (event) { alert('Normal Event'); }, handleBind: function (event) { alert(this.ALERT_BIND); /* 取用主元件的函式 */ }, autoBindClick: function (event) { alert(this.ALERT_AUTOBIND); }, ALERT_BIND: 'Bind Event', ALERT_AUTOBIND: 'Auto Bind Event' // oldAutoBindClick: React.autoBind(function () {...})});React.renderComponent(&lt;Clicker /&gt;, document.getElementById('example')); 其他資訊React.autoBind() 移除Javascript bind()","link":"/2014/02/10/reactjs-ui/"},{"title":"React 重複利用元件","text":"重複利用元件這裡的設計界面，指的是打破現有的設計元素(button, form, fields 等)組合出定義良好可重複使用的元件。這樣一來下次你需要建置一樣的界面的時候就可以少寫一些程式碼，同時也節省許多開發時間。 Prop 驗證當你的應用程式不斷增加，透過設定 propTypes 有助你確保你的元件被正確的使用。。React.PropTypes 會產生一系列的驗證使得你可以確保收到的資料是正確的。當 prop 提供一個無效的資料時就會發出一個錯誤的例外。讓我們看看下面的使用範例： 123456789101112131415161718192021222324252627282930React.createClass({ propTypes: { // 您可以替 prop 指定 Javascript 預設的型別 // 這些都是可以選擇的 optionalArray: React.PropTypes.array, optionalBool: React.PropTypes.bool, optionalFunc: React.PropTypes.func, optionalNumber: React.PropTypes.number, optionalObject: React.PropTypes.object, optionalString: React.PropTypes.string, // 可以明確的限制 prop 為列舉型別。 optionalEnum: React.PropTypes.oneOf(['News','Photos']), // 限制某種 Class someClass: React.PropTypes.instanceOf(SomeClass), // 加上特上面說的任何一種型別加上必須的限制。 requiredFunc: React.PropTypes.func.isRequired // 加上自訂的驗證 customProp: function(props, propName, componentName) { if (!/matchme/.test(props[propName])) { throw new Error('Validation failed!') } } }, /* ... */}); 下面提供一個範例，你可以試著把 isShow 改成非 boolean 的任何值。 123456789101112/** @jsx React.DOM */var Test = React.createClass({ propTypes: { isShow: React.PropTypes.bool.isRequired }, render: function () { return ( &lt;p&gt;{this.props.isShow ? &quot;true&quot; : &quot;false&quot;}&lt;/p&gt; ); }});React.renderComponent(&lt;Test isShow={true} /&gt;, document.getElementById('example')) 出現錯誤： 我們可以再多嘗試一些範例來更明確理解: 1234567891011121314151617181920212223242526/** @jsx React.DOM */ var Car = function (wheel, brand) { this.wheel = wheel; this.brand = brand; }; Car.prototype.run = function () { console.log('go!'); var Bike = function (wheel) { this.wheel = wheel; } var car = new Car(4, 'Toyota'); var bike = new Bike(2); console.log(car var Test = React.createClass({ propTypes: { vihicle: React.PropTypes.instanceOf(Car) }, render: function () { return ( &lt;p&gt;I drive {this.props.vihicle.brand} car and its has {this.props.vihicle.wheel} &lt;/p&gt; ); } }); React.renderComponent(&lt;Test vihicle={car} /&gt;, document.getElementById('car')); // React.renderComponent(&lt;Test vihicle={bike} /&gt;, document.getElementById('bike')); 預設 PropReact 可以讓你定義 props 的預設值 12345678var ComponentWithDefaultProps = React.createClass({ getDefaultProps: function() { return { value: 'default value' }; } /* ... */}); 執行範例： 123456789101112/** @jsx React.DOM */var ComponentWithDefault = React.createClass({ getDefaultProps: function () { return {value: 'B'} }, render: function () { return ( &lt;div&gt;{this.props.value}&lt;/div&gt; ); }});React.renderComponent(&lt;ComponentWithDefault value='A' /&gt;, document.getElementById('example')); getDefaultProps 將會把預設值暫存起來，以確保 this.props.value 有值。以上面的實際範例來說如果你不帶值則值會是 B ，如果有值則預設值會被取代。這使得你可以放心使用 props ，而無需反覆撰寫脆弱的代碼來處理元件。 傳遞 Props 的捷徑常見的 React 元件是用基本 HTML 組合的延伸。通常你會想要傳遞屬性給 HTML 元素，React 提供了 transferPropsTo() 方法可以把屬性帶入讓你少打一些字。 12345678910111213141516/** @jsx React.DOM */var CheckLink = React.createClass({ render: function() { // transferPropsTo() will take any props passed to CheckLink // and copy them to &lt;a&gt; return this.transferPropsTo(&lt;a&gt;{'√ '}{this.props.children}&lt;/a&gt;); }});React.renderComponent( &lt;CheckLink href=&quot;javascript:alert('Hello, world!');&quot;&gt; Click here! &lt;/CheckLink&gt;, document.getElementById('example')); 上面這段說明，其實我們應該先釐清一般來說我們會把 React.renderComponent(&lt;Component attribute='value'/&gt;)，當作呼叫函式或實例化物件，所以這邊的工作是把參數帶進去。接著因為 React 在 render() 的時候只能有一個根元素去包含其他元素。所以當你用了 transferPropsTo() 實例化產生物件那邊的屬性(attributes)會被整合到跟元素，接著你可以用 this.props.children 拿到在帶進來的子元素。如果上面這段說明你還不是很明白，我們在比較一下沒有 transferPropsTo() 的寫法： 12345678910111213141516/** @jsx React.DOM */var CheckLink = React.createClass({ render: function() { // transferPropsTo() will take any props passed to CheckLink // and copy them to &lt;a&gt; return (&lt;a href={this.props.href}&gt;{'√ '}{this.props.children}&lt;/a&gt;); }});React.renderComponent( &lt;CheckLink href=&quot;javascript:alert('Hello, world!');&quot;&gt; Click here! &lt;/CheckLink&gt;, document.getElementById('example')); 好吧！上面這個例子你並沒有少打幾個字，但如果當屬性很多的時候就真的是了XD Mixin在 React 中元件是是幫助你重複使用程式碼最好的方式，但是有些時候不同的元件可能會同樣的功能。有時候被稱作橫切關注點。React 提個 mixin 解決這個問題。一個常見的情況是元件透過 setInterval() 更新，不過問題是當你不需要更新要取消 setInterval() 的時候。當你知道關於元件的生命週期，你就可以透過 mixin 讓有需要這個功能的元件共用。 1234567891011121314151617181920212223242526272829303132333435363738/** @jsx React.DOM */var SetIntervalMixin = { componentWillMount: function() { this.intervals = []; }, setInterval: function() { this.intervals.push(setInterval.apply(null, arguments)); }, componentWillUnmount: function() { this.intervals.map(clearInterval); }};var TickTock = React.createClass({ mixins: [SetIntervalMixin], // Use the mixin getInitialState: function() { return {seconds: 0}; }, componentDidMount: function() { this.setInterval(this.tick, 1000); // Call a method on the mixin }, tick: function() { this.setState({seconds: this.state.seconds + 1}); }, render: function() { return ( &lt;p&gt; React has been running for {this.state.seconds} seconds. &lt;/p&gt; ); }});React.renderComponent( &lt;TickTock /&gt;, document.getElementById('example')); 注意當元件混入很多 mixin event 的時候，如果是生命週期的函式則保證被呼叫，但如果不是則會導致元件被破壞。","link":"/2014/02/12/reuse-components/"},{"title":"React 複合式元件","text":"複合式元件到目前為止我們看過了如何建立一個單一的元件去呈現資料以及回應使用者的操作。接下來讓我們來看看 React 的另一個重要的功能：可組成。 動機：關注點分離模組化建立可重複使用的界面元件，透過使用 function 或類別，讓我們可以在開發時得到一些益處。具體來說可以針對應用程式的功能分離不同的關注點，不過還是請你在建立新元件的時候儘量保持單純。針對應用程式自行設計元件庫，你的 UI 也比較容易和你的應用整合在一起。 在使用 jQuery 和其他第三方套件時候，我們常常會因為作者設定的 HTML 結構(樣板)打亂了我們既有的編排習慣，在 React 中我們通常只要在需要的地方放入一個 &lt;div&gt; ，接著實際產出的 HTML 和功能會透過 Javascript 直接注入。我們只要知道怎麼用元件就好，而不需要去組織樣板。 範例讓我們建立一個單純的 Avatar(頭像)元件，它使用 Facebook Graph API 來取得個人資料和大頭照然後顯示。 1234567891011121314151617181920212223242526272829303132333435/** @jsx React.DOM */var Avatar = React.createClass({ render: function() { return ( &lt;div&gt; &lt;ProfilePic username={this.props.username} /&gt; &lt;ProfileLink username={this.props.username} /&gt; &lt;/div&gt; ); }});var ProfilePic = React.createClass({ render: function() { return ( &lt;img src={'http://graph.facebook.com/' + this.props.username + '/picture'} /&gt; ); }});var ProfileLink = React.createClass({ render: function() { return ( &lt;a href={'http://www.facebook.com/' + this.props.username}&gt; {this.props.username} &lt;/a&gt; ); }});React.renderComponent( &lt;Avatar username=&quot;pwh&quot; /&gt;, document.getElementById('example')); 在上面的範例中，Avatar 元件實例裡面俱有 ProfilePic 和 ProfileLink 兩個元件。在 React 裡面主元件就是最上層的元件應該要提供 props 所需的資料。更精准一點來說，如果有一個元件Ｘ被寫在元件Ｙ的 render() 裡面，這表示 Y 是擁有者-主元件也就是那個負責掌管狀態的元件。如同之前討論的一個元件不能更動自己的 props，而是透過上層元件去設定。通過屬性當接點我們可以保證 UI 的資料永遠是來自同一個地方以確保資料一致性。有個重要的觀念是釐清這些被擁有者的關係和主從關係。被擁有者關係是 React 所俱有的，而元素地主從關係(父元素及子元素關係)就是單純的 DOM 結構。拿上面的範例說明：Avatar 擁有 div，ProfilePic，ProfileLink 物件。div 只是父元素，但他不是ProfilePic 和 ProfileLink 的擁有者(主元件)。 從程式的概念上來理解，一個 Avatar 是透過 React.createClass() 先建立類別，然後 new (React.renderComponent(&lt;Avatar /&gt;, [domTag]))產生的實例物件來使用，每一個物件本身都有自己的 this.props 屬性。且資料通常是透過 &lt;Avatar username={data} /&gt; 傳入的。元件的資料狀態通常避免從外部影響，帶入參數之後就讓元件自己內部去處理。看看編譯過的程式碼會比較好理解 React.renderComponent(Avatar({username:'pwh'}), document.getElementById('example'));，所以擁有者元件是 Avatar 而不是 render() 裡面的 &lt;div&gt;。當然所謂的控管資料和狀態就是 Avatar 。而 &lt;div&gt; 只不過是用來輸出 DOM 結構的父元素。 子元件當你建立了一個 React 物件，你可以包含其他的 React 元件或 Javascript 表示式。 1&lt;Parent&gt;&lt;Child /&gt;&lt;/Parent&gt; 讓我們根據上面的說明再提出一個範例 123456789101112131415161718192021222324252627282930/** @jsx React.DOM */var Avatar = React.createClass({ render: function () { return ( &lt;div&gt; &lt;ProfilePic username={this.props.username} /&gt; &lt;ProfileLink username={this.props.username} /&gt; {this.props.children /* 載入子元素 */} &lt;/div&gt; /* 複習一下一個元件只能有一個根節點，你不能在這邊再加入一個 &lt;div&gt; */ ); }});var ProfilePic = React.createClass({ render: function () { return ( &lt;img src={'http://graph.facebook.com/' + this.props.username + '/picture'} /&gt; ); }});var ProfileLink = React.createClass({ render: function () { return ( &lt;a href={'http://www.facebook.com/' + this.props.username}&gt; {this.props.username} &lt;/a&gt; ); }});React.renderComponent(&lt;Avatar username='andyyu0920'&gt;&lt;ProfileLink username='phw' /&gt;&lt;/Avatar&gt;, document.getElementById('example')); 父元件可以透過 this.props.children 讀取子元件。 子元件調和(Reconciliation)調和的意思是 React 更新渲染 DOM 的處理過程。一般來說子元件會根據他們的順序重新被調整輸出。舉下面的例子來說 123456789// Render Pass 1&lt;Card&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/Card&gt;// Render Pass 2&lt;Card&gt; &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/Card&gt; 我們會直覺的認為 &lt;p&gt;Paragraph 1&lt;/p&gt; 被移除，但實際上 React 會重新調和 DOM ，他會把第一個元素的內容換掉，接著刪除最後一個元素。 1234567891011121314151617181920212223/** @jsx React.DOM */var Card = React.createClass({ render: function () { return ( &lt;div&gt; {this.props.children} &lt;/div&gt; ) }});React.renderComponent( &lt;Card&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt; &lt;/Card&gt;, document.getElementById('example'));React.renderComponent( &lt;Card&gt; &lt;p&gt;Paragraph 2&lt;/p&gt; &lt;/Card&gt;, document.getElementById('example')); 為了更理解上面說的我們實作了另一個範例 1234567891011121314151617181920/** @jsx React.DOM */var Card = React.createClass({ getInitialState: function () { return {children: [&lt;input type='text' /&gt;, &lt;p&gt;Paragraph 1&lt;/p&gt;, &lt;p&gt;{(new Date().toTimeString())}&lt;/p&gt;]}; }, render: function () { return ( &lt;div&gt; {this.state.children} &lt;/div&gt; ); }});var card = React.renderComponent( &lt;Card /&gt;, document.getElementById('example') );setInterval(function() { card.setState({children: [&lt;input type='text' /&gt;, &lt;p style={{display: 'none'}}&gt;Paragraph 1&lt;/p&gt;, &lt;p&gt;{(new Date().toTimeString())}&lt;/p&gt;,&lt;p&gt;Paragraph 2&lt;/p&gt;]});}, 500); 直覺上我們會覺得 &lt;input&gt; 會被重新輸出，但是當我們在輸入框裡面留下資料的時候會發現他並沒有變成空白。總結來說 React 並不是單純直接把元件輸出，而是在內部經過比對處理後只更新異動的部分。 內嵌子元件狀態對大多數元件來說，上面說的這種機制通常沒有什麼問題，然而對控管 this.state 的元件來說這可能會有問題。一般情況下你可以透過隱藏元素來取代刪除他們。也就是說通常元件的結構定義完成之後我們通常不會去破壞任何一個節點。 12345678910// Render Pass 1&lt;Card&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/Card&gt;// Render Pass 2&lt;Card&gt; &lt;p style={{display: 'none'}}&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/Card&gt; 動態的內嵌子元件當情況變得更複雜，內嵌的子元件被重新排列，例如顯示搜尋結果，或者要加入一些新的元件。在這些情況下每個元件唯一的識別子或狀態必須維持在 render() 傳遞。 12345678910render: function() { var results = this.props.results; return ( &lt;ol&gt; {this.results.map(function(result) { return &lt;li key={result.id}&gt;{result.text}&lt;/li&gt;; })} &lt;/ol&gt; ); } 當 React 調和(重新調整)這些帶有 key 的子元件時，這可以確保任何有 key 的元件都將被重新載入(而不是被破壞)或破壞(而不是重複使用)。我們來寫段範例驗證 1234567891011121314151617181920/** @jsx React.DOM */var data = [{id: 1, text:'A'}];var List = React.createClass({ render: function () { var results = this.props.results; return ( &lt;ol&gt; {results.map(function (result) { return &lt;input type='text' key={result.id}/&gt;; })} &lt;/ol&gt; ); }});React.renderComponent(&lt;List results={data} /&gt;, document.getElementById('example'));setInterval(function() { data[0].id += 1; React.renderComponent(&lt;List results={data} /&gt;, document.getElementById('example'));}, 5000); 在 &lt;input&gt; 輸入值之後 5 秒後因為 key 變換了所以你的輸入的值就被清空了。 資料流在 React ，資料是從主元件透過 props 傳遞就如同之前說過的。實際上這是一個單向的資料繫結。主元件負責把資料繫結到子元件的 props ，主元件可以基於 props 或 state 進行計算，由於這個流程會發生遞迴所以資料會自動映射至使用的地方。 關於效能你也許會思考這樣的模式當 React 需要修改大量資料和節點的時候效能會不佳，好消息是 Javascript 本身是非常快速的，而且 render() 往往不會太複雜，因此大部份的應用程式速度都非常快。此外問題幾乎都在 DOM 的更動並不是 Javascript 而且 React 將會使用 batching 和 change detection 優化這些。然而有些時候你真的想要調整這些效能的問題，此時你可以覆寫 shouldComponentUpdate() 方法，透過回傳 false 。React 將會略過這段處理。詳細參閱 the React reference docs 。 注意：當 shouldComponentUpdate() 傳回 false ，此時資料被改變了，React 就不能維持 UI 同步了。只有在有明顯效能問題的時候才使用它，且請確保你知道該如何使用。","link":"/2014/02/12/reactjs-composite-components/"},{"title":"React 元件運作與生命週期","text":"與瀏覽器之間的運作React 針對瀏覽器提供了十分強大的抽象化概念，讓你在大部份的情況下不必再直接操作 DOM ，不過有些時候或許還是需要單純的存取底層的 API(DOM API)，可能是使用第三方函式庫或者事已經寫好的程式碼。 關於虛擬 DOMReact 快速的原因是因為它從來不直接影響 DOM。React 會負責在記憶體中持續維護一份 DOM 的表現結構。render() 方法負責回傳關於 DOM 的描速，React 就能得知其和記憶體中結構的差異，接著他會計算出最快的更新方式然後交給瀏覽器去影響 DOM。此外，React 完整實作了對應的事件系統，所有物件的事件保證符合 W3C 的規範，且關於事件氣泡傳遞(bubbles)的行為在任何瀏覽器也都一致。甚至可以在 IE8 使用 HTML5 的事件。大多數的時候你的程式操作應該都會 React 所建構的”仿瀏覽器”的世界裡，因為它俱有高效能和相對容易使用。不過有些情況下，你可能會需要存取使用底層基本的 API，例如使用 jQuery 第三方套件，React 提供了一個後門允許你可以直接操作底層的 API。 Refs 和 getDOMNode()為了與瀏覽器互動，你需要使用指向 DOM 節點的參考物件。每一個 Mounted 的 React 元件都會有 getDOMNode() 的功能 ，你可以透過呼叫它取得該 DOM 的參考物件。 注意：getDOMNode() 只能在元件已經掛載完畢時使用(換句話說這表示該物件已經被渲染放置到 DOM 裡了)。如果你嘗試在元件尚未掛載完畢前呼叫這個 API 將會發生例外。 為了取得 React 元件的參考，你可以使用 this 取得目前元件或者使用 refs，使用 refs 則需要設定一個名稱，如下範例： 1234567891011121314151617181920212223242526/** @jsx React.DOM */var MyComponent = React.createClass({ handleClick: function() { // 透過原生 API 明確的指示 input 為 focus 狀態。 this.refs.myTextInput.getDOMNode().focus(); }, render: function() { // ref 屬性替元件增加一個參考然後你就可以在元件掛載完畢後使用 `this.refs` return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref=&quot;myTextInput&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick={this.handleClick} /&gt; &lt;/div&gt; ); }});React.renderComponent( &lt;MyComponent /&gt;, document.getElementById('example')); 更多關於 Refs想要了解更多關於 refs 及如何有效的使用可以參考 refs 文件 元件的生命週期元件的生命週期有三個主要的部分： Mounting：元件正準備要被寫入 DOM Updating：元件偵測到狀態的改變準備重新渲染。 Unmounting：元件正要被從 DOM 中移除。 React 根據生命週期提供了對應的方法(事件)讓你可以在對應的階段做一些處理。Will 的方法用在某些狀況準備發生之前，Did 的方法則表示該狀況已經發生後。 Mounting 掛載流程 getInitialState()：當物件被調用時此方法會在寫入 DOM 之前被觸發，通常用來管理狀態的元件可以用這個方法初始化一些資料。 componentWillMount：當元件內部的結構處理完畢準備寫入 DOM 之前觸發。 componentDidMount(DOMElement rootNode)：當元件被寫入 DOM 之後觸發。當初始化需要操作 DOM 元素就可以用這個方法。 Updating 更新流程 componentWillReceiveProps(nextProps)：已掛載的元件收到新的 props 時被觸發。在這個方法裡你通常會去比較 this.props 和 nextProps 然後再用 this.setState 去改變狀態。 shouldComponentUpdate(nextProps, nextState)：這個函式需要回傳一個布林值，當元件判斷是否需要更新 DOM 時會被觸發。你可以在這個方法裡面去比較 this.props，this.state，nextProps，nextState 來決定是否需要更新，回傳 false 則會跳過此次觸發不更新，如果你什麼都不回傳預設會當做 false 。 componentWillUpdate：例如在上面 shouldComponentUpdate 你回傳了 true ，元件確定要更新了，在準備更新前這個方法會被觸發。 componentDidupdate(prevProps, prevState, rootNode)：更新後觸發。 Unmounting 卸載流程 componentWillUnmount()：當元件準備要被移除或破壞時觸發。 掛載後才能使用的方法 getDOMNode()：使用此方法會傳回一個 DOM 元素物件，透過這個方法你可以取得一個參考物件直接操作 DOM 節點。 forceUpdate()：任何已掛載的元件，當你知道元件內部有些狀態已經改變但他不是透過 this.setState() 去修改值的時候可以呼叫這個方法強迫更新。 注意：componentDidMount() 和 componentDidUpdate() 的 rootNode 參數只是提供你一個比較方便的方式存取 DOM ，這和使用 this.getDOMNode() 是一樣的。補上一段實作各種方法的範例您可以試著把註解的地方取消看看變化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** @jsx React.DOM */var Test = React.createClass({ getInitialState: function () { console.log(&quot;&gt; getInitialState()&quot;); return {user: 'AndyYou'}; }, componentWillMount: function () { console.log(&quot;&gt; componentWillMount()&quot;); }, componentDidMount: function (node) { console.log(&quot;&gt; componentDidMount(node)&quot;); console.log(node.className); console.log(node.value); console.log(node.id); console.log(this.getDOMNode().className); console.log(this.getDOMNode().value); console.log(this.getDOMNode().id); }, componentWillReceiveProps: function (nextProps) { console.log(&quot;&gt; componentWillReceiveProps(nextProps)&quot;); console.log(nextProps); }, handleChange: function (e) { console.log(e.target.value); this.setState({user: e.target.value}); }, shouldComponentUpdate: function (nextProps, nextState) { console.log(&quot;&gt; shouldComponentUpdate(nextProps, nextState)&quot;); console.log(&quot;nextProps: &quot;); console.log(nextProps); console.log(&quot;nextState: &quot;); console.log(nextState); return true; /* need return true/false */ }, componentWillUpdate: function (nextProps, nextState) { console.log(&quot;&gt; componentWillUpdate(nextProps, nextState)&quot;); }, componentWillUnmount: function () { console.log(&quot;&gt; componentWillUnmount()&quot;); }, render: function () { return ( &lt;input type='text' id='foobar' value={this.state.user} className='nav' onChange={this.handleChange} /&gt; ); }});var test = React.renderComponent(&lt;Test title='Untitled' /&gt;, document.getElementById('example'));// test.setProps({title: 'No'});// React.unmountComponentAtNode(document.getElementById('example'));// test.setState({user:'Calvert'}); 支援的瀏覽器和兼容在 Facebook 我們支援了包含 IE8 在內的舊瀏覽器，我們已經落實瀏覽器兼容很長一段時間了，這讓我們可以實作出有實用且遠見的 Javascript。這表示我們並沒有太多 Hack 特定瀏覽器產生鬆散的分支代碼，根據這些經驗我們可以確信我們的程式碼在任何瀏覽器都是可以正常運作的。舉個例子常見 +new Date() 這種寫法我們會改用 Date.now()。React Open Source 專案和 Facebook 內部使用的的是一樣的，我們已經證實並正在使用。此外我們並不試圖讓實作兼容功能變成函式庫的一部份，如果每個函式庫都重新實作這些功能，為了支援老舊瀏覽器，你會反覆載入相同功能的程式碼。如果你需要支援舊的瀏覽器，可能你已經在使用 es5-shim。 兼容es5-shim.js 可以從 kriskowal’s es5-shim 取得。下面是 React 支援老舊瀏覽器需要的東西 Array.isArray Array.prototype.forEach Array.prototype.indexOf Array.prototype.some Date.now Function.prototype.bind es5-sham.js 也可以從 kriskowal’s es5-shim 取得，React 需要： Object.create React 的非最小化建置則需要 paulmillr’s console-polyfill console.l* 跨瀏覽器的議題雖然 React 對於瀏覽器的抽象化過程處理的非常不錯，但是有些瀏覽器的限制或怪異的行為我們還是找不到解法 IE8 的 onScroll 事件IE8 的 onScroll 事件不會造成事件的氣泡傳遞而且 IE8 也沒有定義對應的處理事件。目前關於在 IE8 的這個事件已經被忽略了。 PolyfillsPolyfilling 是由 RemySharp 所提出的術語，它是用來描速關於複製缺少的 API 和 API 功能的行為。你可以使用它撰寫應用程式的程式碼而不用擔心其他瀏覽器是不是支援。事實上，polyfills 並不是新技術也不是和 HTML5 捆绑到一起的。 Polyfills 是什麼？讓我們直接來看實務 Polyfills 指的是什麼。例如使用 json2.js 就是一種 Polyfills。 123if (typeof JSON.parse !=='function') { // Crockford’s JavaScript implementation of JSON.parse} 上面這段程式碼表示; 如果瀏覽器本身可以執行 JSON.parse，那麼 json2.js 就不會重新定義或者干擾 JSON 物件。如果沒有原生的 API 可用，json2.js 就會執行一段 JavaScript 來實現這個功能，它和原生的 JSON API 是完全兼容的。最終的結果就是你可以在網頁上使用 json2.js 而不用考慮瀏覽器執行的是哪種程式碼。","link":"/2014/02/16/reactjs-assembly-operation-and-life-cycle/"},{"title":"React 關於 Refs","text":"關於 Refs當你透過 render() 回傳你的 UI 結構之後，你可能想要從外部調用這個元件實例的方法。通常情況下為了取得一些元件或計算後資料你可能這樣做，但其實是不必要的，因為 React 通常會確保資料是最新的 props 且透過 render() 傳遞到子元件。不過的確有些情況還是會需要從外部調用方法。想像下面這種狀況，當你想讓一個已存在的某元件的子元件 &lt;input /&gt; 在你清空欄位後馬上 focus 該 &lt;input /&gt;： 1234567891011121314151617181920212223242526272829var App = React.createClass({ getInitialState: function() { return {userInput: ''}; }, handleKeyUp: function(e) { this.setState({userInput: this.getDOMNode().value}); // this.setState({userInput: e.target.value}); # 官方範例使用 e.target.value 會導致無法正常運作。 }, clearAndFocusInput: function() { this.setState({userInput: ''}); // Clear the input // 我們希望在這邊可以 focus &lt;input /&gt; }, render: function() { return ( &lt;div&gt; &lt;div onClick={this.clearAndFocusInput}&gt; Click To Focus and Reset &lt;/div&gt; &lt;input ref=&quot;theInput&quot; value={this.state.userInput} onKeyUp={this.handleKeyUp} /&gt; &lt;/div&gt; ); }});React.renderComponent(&lt;App /&gt;, document.getElementById('example')); 請注意，在這個範例我們想要通知 &lt;input /&gt; 做些事情。這件事件沒辦法透過 props 辦到。我們想要讓 &lt;input /&gt; focus ，然而這邊遇到了一點問題，那就是 render() 回傳的不是子元素 &lt;input /&gt; 的元件，在這個時候它只是一子元件的結構描述。記得當你從 render() 回傳一個結構，它並不包含替你產生子元素的物件實例。關於在內部的標簽(內部的元件)，它們都只是結構描述。不過你可能已經想到把 &lt;input /&gt; 先存在變數裡了，注意！！你不應該把『這些事情或物件』存起來，然後期待這可能有一天會用到。如下 1234567891011// 錯誤範例: DO NOT DO THIS!render: function() { var myInput = &lt;input /&gt;; // 我可能會呼叫這個物件的 Method this.rememberThisInput = myInput; // 在未來某個時間點我就可以直接呼叫他 return ( &lt;div&gt; &lt;div&gt;...&lt;/div&gt; {myInput} &lt;/div&gt; );} 在這個錯誤範例中，&lt;input /&gt; 只是描述結構。這個描述是用來建立 &lt;input /&gt; 背後的實際物件。如果我們把這段程式完成如下並試著觀察這段程式碼的運作，事實上當你呼叫 this.rememberThisInput 是會出 ERROR 的！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;html&gt; &lt;head&gt; &lt;title&gt;Hello React&lt;/title&gt; &lt;script src=&quot;http://fb.me/react-0.8.0.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://fb.me/JSXTransformer-0.8.0.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://code.jquery.com/jquery-1.10.0.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;example&quot;&gt;&lt;/div&gt; &lt;div&gt; 原生 Javascript 範例示範 focus 所以我們可以透過 element.focus() 讓元素 focus。 &lt;div id='test-trigger'&gt;Click!&lt;/div&gt; &lt;input type='text' id='test' /&gt; &lt;/div&gt; &lt;script&gt; /* 原生 Javascript 範例示範 focus */ var HandleClick = function (e) { var el = document.getElementById('test'); el.focus(); }; var el = document.getElementById('test-trigger'); if (el.addEventListener) { el.addEventListener('click', HandleClick, false); } else { el.attachEvent('onclick', HandleClick); } &lt;/script&gt; &lt;script type=&quot;text/jsx&quot;&gt; /** @jsx React.DOM */ var App = React.createClass({ getInitialState: function () { return {userInput: ''} }, handleKeyUp: function (e) { this.setState({userInput: this.getDOMNode().value}); }, clearAndFocusInput: function () { this.setState({userInput: ''}); // console.log(this.rememberThisInput); // this.rememberThisInput.focus(); }, render: function () { var myInput = &lt;input value={this.state.userInput} onKeyUp={this.handleKeyUp} /&gt; this.rememberThisInput = myInput; return ( &lt;div&gt; &lt;div onClick={this.clearAndFocusInput} &gt;Click to Focus and Reset&lt;/div&gt; {myInput} &lt;/div&gt; ); } }); React.renderComponent(&lt;App /&gt;, document.getElementById('example')); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 那我們怎麼通知 &lt;input /&gt; 背後的這個物件呢？ ref 屬性(attribute)React 支援一個非常特別的屬性，你可以把它附加到任何在 render() 裡面的元件上(就是標簽 tag 上)。這個特殊的屬性可以讓你存取到對應的『背後的實際物件』，它保證可以在任何時間點存取到當下的物件。下面是一個範例： 1 在 render() 裡將回傳任意的元素設定 ref 屬性(attribute)1&lt;input ref='myInput' /&gt; 2 在程式碼(典型的範例是在處理事件或函式裡)中你就可以透過 this.refs 存取這個『背後的物件』。1this.refs.myInput 完整的範例12345678910111213141516171819202122232425262728/** @jsx React.DOM */var App = React.createClass({ getInitialState: function () { return {userInput: ''}; }, handleKeyUp: function (e) { this.setState({userInput: this.getDOMNode().value}); console.log(e); // 官方範例使用的 e.target.value 是錯誤的！ }, clearAndFocusInput: function (e) { this.setState({userInput: ''}); this.refs.theInput.getDOMNode().focus(); }, render: function () { return ( &lt;div&gt; &lt;div onClick={this.clearAndFocusInput}&gt; Click To Focus and Rest &lt;/div&gt; &lt;input ref='theInput' value={this.state.userInput} onKeyUp={this.handleKeyUp} /&gt; &lt;/div&gt; ); }});React.renderComponent(&lt;App /&gt;, document.getElementById('example')); 在這個範例裡，render() 方法裡回傳的結構中包含了一個 &lt;input /&gt; 的結構描述，不過這次不同的是這個物件可以透過 this.refs.theInput 取得。然後在 clearAndFocusInput 函式裡使用 this.refs.theInput 。 總結比起使用 this.props 和 this.state ，this.refs是操作物件或傳送訊息給特定子元素最方便的方式，但是建議不要透過他們去操作你的資料。一般來說被動處理計算的資料應該使用 this.props 和 this.state。 Refs 的用途 可以定義任何 public 的 method 在你的元件類別裡(例如 reset 方法)，然後透過 refs 去呼叫。 在你需要呼叫 DOM 的 API 時取得該元素。this.refs.myInput.getDOMNode()。 Refs 會自動記錄，如果你的子元素被破壞這個 refs 也會被破壞。不用擔心記憶體的問題，除非你做了一些瘋狂的事情，像是把整個物件都加入參考。 注意事項 不要在 render() 方法裡面使用 this.refs 或者當任何元件的 render() 正在運行的時候。 如果你想要使用 Google Closure Compiler (Javascript minify) ，請檢查不要用任何指定屬性屬性的方式使用 refs，這意味著當你設定了一個 ref='myRefstring'那麼你最好使用 this.refs['myRefString'] 這種方式。 如果你是第一次用 React 開發，通常你會傾向讓 this.refs 去幫你達到你要的功能，如果遇到這種情形，請審慎思考關鍵在哪，該如何設計階層結構，該 state 管理控制哪些資料。通常把state放置在元件最高階層，控制好關於『自己』的狀態會讓程式碼變得乾淨，清晰易懂。良好的設計 state 會導致你不會一直去使用 this.refs 強迫控制元件，且會讓資料易於控制和正確。","link":"/2014/02/19/reactjs-regarding-the-refs/"},{"title":"React 關於表單","text":"表單表單元件像是 &lt;input&gt;，&lt;textarea&gt;和&lt;option&gt;和其他元件有些不同，因為他們可以被使用者操作而產生變化。這些元件提供一個介面好讓我們以表單的形式和使用者產生互動。 Props 的輸入與輸出表單元件提供一些 props 會根據使用者的操作影響屬性值和呈現。 value ： &lt;input&gt; &lt;textarea&gt; 支援。 checked ： checkbox，radio 支援。 selected：&lt;option&gt; 支援。 在 HTML 裡面 &lt;textarea&gt; 的 value 是嵌在子元素就是像這樣 &lt;textarea&gt;value here&lt;/textarea&gt;，但是在 React 你可以用 value 取代。表單元件透過 onChange 設定 callback 可以達到監聽的功能，就是一旦這些值改變了就會觸發 onChange。onChange 會在使用者有以下狀況時被觸發： &lt;input&gt; 或 &lt;textarea&gt; 的 value 改變時。 checked 改變時。 selected 改變時。 就像所有的 DOM 事件，onChange 支持所有原生元件且可以監聽到因氣泡傳遞產生的觸發。 元件約束一個 &lt;input&gt; 一旦設定了 value 就是一個約束的元件。輸出後元素 &lt;input&gt; 的值將會永遠映射到 this.props.value 舉例來說 123456789/** @jsx React.DOM */var Test = React.createClass({ render: function () { return ( &lt;input type='text' value='Hello!' /&gt; ); }});React.renderComponent(&lt;Test /&gt;, document.getElementById('example')); value 一旦設定，你會發現不能改變了，像上面範例 value 永遠等於 Hello! 。任何輸入都無法改變值，因為 React 已經定義 value 是 Hello!，如果你想要讓 &lt;input&gt; 可以被使用者操作你應該使用 onChange 事件： 123456789101112131415/** @jsx React.DOM */var Test = React.createClass({ getInitialState: function () { return {value: 'Hello!'} }, handleChange: function (event) { this.setState({value: event.target.value}); }, render: function () { // var value = this.state.value; return ( &lt;input type='text' value={this.state.value} onChange={this.handleChange} /&gt; ); }}); 讓我們整理一下你在目前學習過程可能會產生的疑惑，就是 props 和 state 的差異，首先是 props 不應該由元件本身去操作異動，應該只能夠在使用元件的時候當作帶入的參數(雖然的確是可以使用 setProps() 去設定，不過這違反官方的設計模式)。接著的工作就是負責傳遞資料。而 this.state 可以當作參數傳遞資料也可以在元件內部去設置改變。換句話說，你應該只能在元件內部呼叫 setState() ，常見的應用都是用 this.state 處理關於使用者操作互動產生的結果。此外要注意的是如果你真的在子元件也使用了 state 那它跟主元件本身的狀態是分開獨立的。另一個問題是為什麼 props 可以用 propTypes 驗證，而 state 沒有，主要是因為關於 state 完全是由元件設計者控制的，想像一下一般的情況下你設計了一個元件，而當其他人要使用的時候他應該只需要使用 React.renderComponent(&lt;YourComponent /&gt;, document.getElementById('example')) 輸出元件即可，根據你提供的文件，它可以在屬性設定自己的參數 &lt;YourComponent name=&quot;Andy&quot; /&gt; ，而 this.state 根本沒機會外露(修改元件除外)。所以如果你真的需要驗證 state 的時候就在適合的生命週期事件中處理就好了，例如 componentWillUpdate 事件。根據上面這些說明，我們得到結論：就是一旦 &lt;input&gt; 的 value 被綁定就不會變動了，我們稱為元件約束，所以應該在 value 綁入一個變數，而這個變數按照模式的規劃應該使用 this.state 取得值是比較正確的。 123handleChange: function(event) { this.setState({value: event.target.value.substr(0, 140)}); } 修改 handleChange() 範例就可以實作限制在 140 個字元。 不被約束的元件如果一個 &lt;input&gt; 沒有設定 value 那它就是一個不被約束的元件。此時 input 的 value 就會是使用者輸入的值。 123render: function() { return &lt;input type=&quot;text&quot; /&gt;;} 上面這段程式碼並沒有設定 value ，使用者輸入的任何值都會立刻反應。想要在使用者改變欄位值的同時做些處理可以使用 onChange 。如果你想在初始化的時候不要帶入空值，且可以隨著使用者操作回饋，你可以使用 defaultValue。 123render: function() { return &lt;input type=&quot;text&quot; defaultValue=&quot;Hello!&quot; /&gt;;} 其他類似的屬性像是&lt;input&gt; 還有 defaultChecked，&lt;select&gt; 也有 defaultValue 。 進階議題為什麼要約束元件？React 在設計像是 &lt;input&gt; 這類表單元件時面臨一個表現時的挑戰。舉例來說在 HTML 1&lt;input type=&quot;text&quot; name=&quot;title&quot; value=&quot;Untitled&quot; /&gt; 在傳統 HTML 是表示初始化值設定為 Untitled 當使用者更新欄位時，元素取得的屬性將會改變，然而如果你使用 node.getAttribute('value') 其實他還是會返回 Untitled。讓我們直接看下面這段原始碼 1234567891011121314151617&lt;html&gt; &lt;head&gt; &lt;title&gt;Hello React&lt;/title&gt; &lt;script&gt; var val1, val2; function Log () { console.log(this); console.log(this.getAttribute('value')); console.log(document.getElementsByName(this.name)[0].value); console.log(this.value); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type='text' name='i1' value='Untitled' onchange=&quot;Log.apply(this)&quot; /&gt; &lt;/body&gt;&lt;/html&gt; 試著輸入值觀察 console 。注意：HTML 的 onchange 行為是在你改變了值，滑鼠移出欄位之時才觸發。 React 是透過 &lt;input value=' '/&gt; 的 value 影響元素，但是當我們改變欄位的時候卻只能從 node.value 而不是 node.getAttribute('value') 取得使用者改變的資料，所以如果要把這個值表現在元素上就只能把這個 node.value 放到 state 變數，然後屬性就使用 this.state.value。這也就是為什麼需要約束元件。也因此當我們如下程式碼的時候 123render: function() { return &lt;input type=&quot;text&quot; name=&quot;title&quot; value=&quot;Untitled&quot; /&gt;;} 因為我們接不到 event.target.value 所以 React 會一直保持 Untitled。 關於 Textarea在 HTML一般設定 &lt;textarea&gt; 是用子元素去設定 1&lt;textarea name=&quot;description&quot;&gt;This is the description.&lt;/textarea&gt; 開發者可以很輕易的使用多行的內容，但因為 React 是 Javascript 所以當你想要換行的時候可以使用 \\n。 先看下面這段程式碼 123456789/** @jsx React.DOM */var Textarea = React.createClass({ render: function () { return ( &lt;textarea value='value' defaultValue='default'&gt;This is dog&lt;/textarea&gt; ); }});React.renderComponent(&lt;Textarea /&gt;, document.getElementById('example')); 其實我們這三個設定都可以用，但是子元素會等於 defaultValue 所以當子元素和 defaultValue 都用的時候會產生錯誤 If you supply defaultValue on a &lt;textarea&gt;, do not pass children. 而 value 會覆寫 defaultValue 。為了避免混淆我們一般建議只用 value，接下來的用法就和上面提到的一樣。 關於 Select一般我們使用 &lt;select&gt; 要指定選項是透過在 &lt;option selcted&gt;，在 React 為了讓元件方便操作我們改用下面的方式 12345678910111213/** @jsx React.DOM */var Dropdown = React.createClass({ render: function () { return ( &lt;select value={this.props.selected}&gt; &lt;option value=&quot;A&quot;&gt;Apple&lt;/option&gt; &lt;option value=&quot;B&quot;&gt;Banana&lt;/option&gt; &lt;option value=&quot;C&quot;&gt;Cranberry&lt;/option&gt; &lt;/select&gt; ); }});React.renderComponent(&lt;Dropdown selected='C' /&gt;, document.getElementById('example')); 如果要是預設值也是用 defaultValue 如下 12345678910111213/** @jsx React.DOM */var Dropdown = React.createClass({ render: function () { return ( &lt;select value={this.props.selected} defaultValue=&quot;B&quot;&gt; &lt;option value=&quot;A&quot;&gt;Apple&lt;/option&gt; &lt;option value=&quot;B&quot;&gt;Banana&lt;/option&gt; &lt;option value=&quot;C&quot;&gt;Cranberry&lt;/option&gt; &lt;/select&gt; ); }});React.renderComponent(&lt;Dropdown /&gt;, document.getElementById('example'));","link":"/2014/02/15/react-on-a-form/"},{"title":"11 種類型的程序猿","text":"甘道夫(Gandalf)這種類型的程式設計師看起來就像演員候選名單中負責飾演魔戒-甘道夫的人，他（或者『她』）有著長到快到膝蓋的鬍子，佩戴著一頂看起來有點蠢的帽子，他們可能會在冬天穿著斗篷或披風。對團隊而言幸運的是這個人就跟甘道夫會魔法一樣，他在工作時也像在變魔術一樣強大。不幸的是你們就時常要忍受甘道夫訴說關於他的經歷，像是他是如何上山下海為了把打洞卡送到電腦室。甘道夫類型的程式設計師是你團隊的重砲手，不過你應該該試著讓他們留在後勤部隊，只在必要的時候呼叫他們。 殉道者在其他職業中，『殉道者』只是單純的工作狂，但是在開發這塊領域『殉道者』已經達到另一個境界。工作狂至少還會回家洗澡睡覺。但是殉道者則以睡在桌下那些空的披薩盒堆為榮。問題是沒有人請『殉道者』做到這種境界，而且他們常常會說出類似 “OK！快下班回家吃晚餐吧！我會在今晚做完後面三週的進度” 讓團隊的其他人感到內疚。 宅宅請注意，當他或她和你注意到你時，你蠻有可能就會被迫聽一場長達三個小時的『鋼彈W vs 七龍珠Z』的講座，或者是為什麼 PS3 Xbox 360 哪一個更好之類的分析。宅宅的工作環境充滿了海報，公仔，以及其他週邊，大部分他們喜歡的東西來自日本，宅宅不光是有點難相處，他們有時實在是花太多時間在他們的愛好上包含工作時。 Vince Neil (重金屬音樂歌手)這個40多歲的傢伙就像是 1984 年代所有不良示範(或者很潮?)的集合體，一頭蓬鬆的長髮，故意弄破，皺摺刷白的牛仔褲外加一個印花領巾。Vince 工作的時候都會哼著像是邦喬飛和威豹樂隊的歌。如果Pour Some Sugar on Me不是那麼俱有傳染力的話，這點原本可能沒那麼糟。一般來說跟 Vince 一起工作還挺好玩的，通常他們經驗也很豐富，不過就是童心未泯。不過當他或她想融入搖滾樂風格的生活方式時，事情變的很麻煩。你也不想跟一個每天帶解酒液的人一起上班吧。 忍者忍者型的程式設計師通常是團隊中的 MVP，但卻沒人意識到這件事。就像那些傳說的刺客一樣，你不會知道忍者是何時執行任務的。但你總會在隔天早上開啟版控時發現證據，看到忍者在凌晨4點的時候 check in 了一份程式碼，那是你本來計劃一週完成的任務，你甚至不知道忍者怎麼知道這項任務。你看！當你還沒開完會，忍者就已經在工作了。忍者是非常神秘的，你可能甚至不知道他們的名字，但你知道有他們在每一個專案似乎都可以進行得更順利。雖然行事謹慎不過忍者是一個孤獨的戰士，千萬不要強迫他們和普通員工組隊。 理論家理論家知道一切關於程式設計的知識。他們可以花4個小時演講關於一個冷門語言的歷史或者指出你的 code 哪裡寫得不完美導致浪費了3奈秒。當他們開始寫 code 的時候，他的程式碼非常乾淨優美，導致我們這些凡人很難理解他們的程式碼，他們最愛用像是遞迴這類的技巧，微調每一個區塊的程式碼到極致。不過他們犧牲了時間和程式的可讀性。理論家也是很容易分心的，一個簡單需要1個小時的任務，他們要花3個月，因為他們覺得現有的工具不夠好所以他們必須要自己打要一套新的工具來建置新的函式庫，再用它來打造整個系統以滿足他們的高標準。理論家可能是你最好的隊員之一如果你有辦法控制他們讓他們專注專案本身，而不是浪費時間在研究終極排序演算法上。 牛仔牛仔基本上是不受控制的，他們通常是很厲害的程式設計師，通常工作速度是一般人的 2 到 3 倍，問題是有一半的時間是靠偷工減料得來的，牛仔認為把程式提交到版控很浪費時間，把設定資料存到程式外部也很浪費時間，跟其他人溝通也很浪費時間…你懂了吧。牛仔的程式碼幾乎都是『義大利麵式碼』，因為他們從來不重構。很可能會發生的是; 7 頁的核心功能的程式碼看起來似乎就像教科書教材中『不要這麼做』範例，但這些程式碼卻神奇的能運作。牛仔肯定無法跟其他牛仔一起工作，如果你把兩個牛仔放在一個專案，那這個專案註定失敗，因為他們會互相扯對方後腿。把牛仔放在一個只注重完成期限而不管其他事情的專案是最好的，因為他一定能在期限前完成。牛仔大概就是聒噪版的忍者。只是忍者精確地執行任務，牛仔則是往紅色三角形布一路狂衝的憤怒公牛。 傘兵你知道那些電影中的突擊隊員，就是指揮官帶著那些被空投之後深入敵方陣營且執行秘蜜計劃的人。這些人是軟體開發中的傘兵。傘兵是你最後的手段，為了拯救那些快死的專案，你把他們送到那些專案。傘兵缺乏耐心執行那些長期的任務，但是他們不可思議的強項是快速了解不熟悉的程式包含別人的 API 等，然後快速上手。其他程式設計師也許要數週或數個月去熟悉專案以利有效率的工作。傘兵只需要數小時或幾天。傘兵也許不夠了解核心的程式碼，不過在缺乏時間，全隊可能失敗的情況下他們可能會成功。 庸才 (Mediocre Man)堪用就是你從庸才身上拿到最好的東西，他們總是用較長的時間產生比團隊中其他人更糟的程式。穩扎穩打緩慢地完成專案可以用來形容他們。不過他們總是可以讓專案完成的剛剛好或者堪用，這也讓他們總是能有工作。當你面試這種類型的工程師時，他們可以告訴你很多關於他們曾經參與過的專案，但不是很了解他們實際參與的項目。要知道是不是庸才是相當容易的：詢問他們所做工作的具體內容，他們會突然得到失憶症。 傳教士不管你既有的系統環境是什麼，傳教士堅持他可以改善所有的狀況，但是你要放棄你現有的工具和流程，並且用其他東西取代。傳教士實際上是理論家的相反。傳教士是坦率的，直言不諱，他們知道有關軟體開發的可怕，但是執行專案的數量卻不夠多。傳教士有著一顆專案經理或者部門主管的心，不過他們缺乏經驗或知識來成為管理者。所以在傳教士變成一個單純管理的角色之前，其他人不得不一直忍耐傳教士們想要徹底改革這個工作環境的嘗試。 Googler最後一個但是不在清單中的就是 Googler，他們是那種只要不開瀏覽器搜尋就不能完成專案的類型，因為他們老是忘記基本的語法，或是根本不想記，他們看得懂這些語法主要的目的但是不能記住確切的單字拼法或語法排列。他們通常最少開三個分頁使用不同的關鍵字或排列來搜尋同一件事。舉例來說 第一個 Tab -&gt; Get value of the first array 第二個 Tab -&gt; Get value of the array[] 第三個 Tab -&gt; Array[] get first value 他們是非常機智的不過他們寫程式的速度通常相對慢了一點，因為他們主要的時間都花在搜尋。 原文","link":"/2014/08/06/11-type-of-code-monkey/"},{"title":"iOS App Store 上架憑證流程筆記","text":"在開發幾個 App 之後對於上架簽署憑證之間的關係一直沒有搞的很清楚，所以做了一下筆記。 當 APP 開發完成之後要安裝到實機會需要在建置應用程式時(build)加上憑證，我們一般稱為應用程式憑證簽署(code signing)，白話文就是替應用程式綁上名牌以確保這個 APP 是合法的。 總結來說要完成一個可以上架的 APP 需要完成下面這些步驟： 在Mac上產生憑證密鑰 .certSigningRequest 是拿第一步所產生的密鑰到 apple developer 網站來產生密鑰憑證檔案 .cer 將第二步的 .cer 裝到鑰匙圈中。 回到 apple developer 申請產生iOS的憑證檔 provisioning profile。 將裝置憑證檔案 provisioning profile 安裝到 xcode 。 概念說明本文不是要做流程記錄如果想學習整個流程可以參考教學這篇文章是想針對各種憑證做些概念上的筆記其實當你到 Apple Developer 的 Certificates, Identifiers &amp; Profiles 界面時你可以觀察到全部大概就是下列這些東西 Certificates Identifiers Devices Provisioning Profiles 我們先用 Development APP 建置的流程來概略說明一下關係，當你想要申請一張 Certificates 除了先購買開發者帳號外，第一步就是要先在鑰匙圈管理程式中產生Certificate Signing Request (CSR) 檔案，實際上他就是一對公私鑰。接著在製作 Certificates 的時候 Apple 會跟你要這個 CSR ，最後完成這張憑證，下載回來後點擊就可以安裝。 當你完成上敘動作，此時 Xcode 就可以把 APP 安裝到裝置上了。當你連接裝置由於你已經有憑證了，Xcode 會自動幫你產生一個通用的 App ID (Xcode iOS Wildcard App ID)，幫你把裝置的 UDID 上傳到網站上，合成一個開發用的 Provisioning Profile (iOS Team Provisioning Profile) 並在安裝到裝置上，接著 APP 就可以部署到裝置上了。 看完流程你就可以歸納出整個流程是這樣的 Apple 跟你要了一組 CSR 來識別身份順便幫你產了一組 Certificates 驗明你這個開發者。 Identifiers 就像在註冊網址一樣，替 APP 產一組唯一的識別名稱，Apple 可以透過這個 ID 授權開放一些功能給這個 APP。 Devices 就是可用的裝置清單。 最後你需要合出一個 Provisioning Profile 在你的 Build Settings 設定這張 Profile. 而這張 Profile 就是把上述的那些資訊全部整合在一起的一個檔案。最終會被打包進 ipa 中。 如果是測試用的 APP 或使用 Testflight 你會需要再把這個 Profiile 安裝到機器上。 我們可以合理的猜想第 5 步驟應該是 Apple 需要判斷這個安裝程式誰可以安裝，如果是在 App Store 上的 App 你需要登入 Apple ID 然後系統就可以註記這個 APP 現在歸屬于誰或者說誰可以安裝，這可以說明當你在一台裝置使用不同帳號安裝軟體後，當 User A 安裝了某軟體X，接著 User B 使用了自己的帳號，當某軟體X出更新的時候，彈出來的帳號預設是 User A 因為 Apple 知道這個應用程式是屬於誰的。但 Development 的 APP 並沒有，所以需要在機器本身再安裝一個 Profile 來判斷誰能夠安裝。您可以在 iPhone 的 設定 &gt; 一般 &gt; 描述檔中觀察到這些 Profile. CertificateCertificate 憑證簡單說就是一個身份的證明，證明你是一個 Apple 開發者，然後才可以把 APP 安裝到機器上，當你對 APPLE 購買了開發者之後就可以取得，共分成兩大類 Development 和 Production Development 認證可以讓你部署 APP 到裝置上(上限100台)做測試，而 Product 則是用來發佈到 App Store。 Development Certificate iOS App Development簽署測試用的APP以安裝在實機上。 Apple Push Notification service SSL (Sandbox)當你的APP需要使用到Apple Push Notification功能時需要使用此種憑證，開啟沙箱功能。 ProductionProduction 憑證又分成5種各針對不同需求的 APP App Store and Ad Hoc 使用於提交到 App Store 或特殊用途的簽證如：TestFlight。 Apple Push Notification service SSL (Production) 當提交的應用程式需要使用 Apple Push Notification 功能的時候。 Pass Type ID Certificate 當APP需要更新Passbook資料的時候 Website Push ID Certificate VOIP Services Certificate 1Ad hoc是拉丁文常用短語中的一個短語。這個短語的意思是「特設的、特定目的的（地）、即席的、臨時的、將就的、專案的」。這個短語通常用來形容一些特殊的、不能用於其它方面的的，為一個特定的問題、任務而專門設定的解決方案。這個詞彙須與a priori區分。 App IDsApp ID 就是 APP 唯一的識別名稱，App ID 應該和 Xcode 中的 Bundle ID 一樣。App ID 分成兩種 Explicit App ID：唯一的 App ID，用來針對單一 APP 命名，例如 com.apple.MyApp。 Wildcard App ID：類似使用正規式匹配符號的概念，指的是某些符合命名的 APP。例如 * 可表示所有 APP，com.apple.* 指的是開頭是 com.apple 的 APP。 App ID 可以設定相關 APP Services授權。例如，如果要使用 Apple Push Notification Services，則必須使用 Explicit App ID，以方便能識別唯一的應用程式。 Provisioning Profile簡單說 Provisioning Profile 就是包含 App ID, Certificates, Devices 列表資訊的一個檔案。其用途就是用來確認這個 APP 是否合法，首先就是我們會需要 Certificate 來證明開發者是誰，然後 App ID 用來設定該 App 的授權的其他功能並驗證 Bundle ID 是否唯一。再來就是在測試的時候確定裝置是否能安裝。所有這個 Profile 可以說是用來規範驗證這個 App 的檔案。 了解觀念之後就不需要死記簽證的流程了。","link":"/2014/08/06/ios-app-shelves-certificate-process-notes/"},{"title":"How to get plist?","text":"12NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;YOUR_PLIST_FILE&quot; ofType:@&quot;plist&quot;];NSDictionary *dictionary = [[NSDictionary alloc] initWithContentsOfFile:path];","link":"/2014/08/04/ios-how-to-get-plist/"},{"title":"關閉OSX通知時 ICON 跳跳跳的動畫","text":"當你在 Mac 上開啓 Line 的時候，由其實開發時常常因為 Line 收到通知導致那個在 Dock 上的 Icon 一直在那邊彈跳(Dock Bouncing) 想把它關掉必須靠指令 關閉12$ defaults write com.apple.dock no-bouncing -bool TRUE$ killall Dock 開啓12$ defaults write com.apple.dock no-bouncing -bool FALSE$ killall Dock","link":"/2014/08/08/turn-off-osx-notification-icon-animation-of-jump-jump/"},{"title":"iOS UIScrollView 使用 Autolayout","text":"前言誰說你不能讓一些既有的控制項使用一些新技巧，UIScrollView 是從 iOS 一開始就存在的控制項，已經很多部落格文章, Stackflow 問題和官方文件討論如何用舊有的方式在 UIScrollView 中設定你的內容，本文將描述一些搭配 AutoLayout 的使用技巧。 自從 iOS 引入了自動佈局(Auto Layout)，也出現了一些新的方式協助你設定滾動頁面中的內容(Scrolling Content)，使用自動佈局可以大大地減少撰寫的程式碼。依照舊的方式設定 UIScrollView 其中一個最麻煩的地方就是處理 UIScrollView 中內容的尺寸(Content Size)，就是裡面的那些控制項。如果內容是一張圖片你可以相當單純的直接計算圖片的尺寸，不過如果你要放在 UIScrollView 裡面的內容是一堆 UIButton, UILabel, 和你自訂 UIView 就不是這麼容易。你就需要撰寫一大堆程式碼用來處理排列對齊以及適應各種螢幕情況。 在這篇文章中會教你如何使用 UIScrollView 搭配 AutoLayout 自適應設計，如此就不管裝置是直放或橫擺裡面的控制項就能呈現適合的大小，同時也會教你在 UIScrollView 中當虛擬鍵盤出現時控制項通常是 UITextField 如何捲動到適合的位置。 使用 IB (Interface Builder)建立一個基本的 Layout為了讓你對接下來做的事情有點感覺我們先看一下完成後的樣子 現在讓我們來建立我們的 UI ，首先建立一個 Single View Project ，接著在 Main.storyboard 中的 ViewController 拖入一個 UIScrollView 當作主要 ViewController.view 的 subview。 然後加入一些自動佈局的佈局條件(AutoLayout Constraints)讓 UIScrollView 放置到你想要的位置。在這個範例中 UIScrollView 需要佔據整個 UIView 所以這邊加了 4 個邊緣距離設定(Edge)的佈局條件，且距離 4 邊距離都是 0 ，也許你想要的設定跟這裡的不一樣，你可以照著你想要呈現的方式設定。 使用一個 UIView 包住其他的內容或控制項下一步則是在 UIScrollView 中建立一個單獨的 子 UIView 控制項，它的功能就是一個容器(Container)我們會將所有的內容和控制項放到這個 UIView 中。這麼做的原因是之後我們可以很簡單的使用佈局條件(Constraints)實現 AutoLayout，在這個範例中我將它命名為 Content View。如果你的內容是一個 UIImageView 其實你可以很單純的直接放置進 UIScrollView 就跟我們這個 Content View 一樣。 接著，我們要設定 Content View 和 UIScrollView 的佈局條件(Constraints)，官方對 UIScrollView 做了一些改變，如果要支援 Autolayout 你就必須要設定正確，下面是必須完成的兩個條件： Content View 控制項並需要有明確的尺寸大小，指的是你必須設定 width, height 或者使用 placeholder 預先配置一個尺寸接著在執行時期(Run Time)改變尺寸。從另一個角度來看，意思就是你的內容大小無法根據 UIScrollView 來取得尺寸大小，不過它可以根據 UIScrollView 外部的 View 來取得大小，我們將會使用這個技巧來讓你的佈局可以自動適應裝置直立或橫擺。如果你的內容是一張圖片，那麼 UIImageView 會根據你的圖片尺寸取得大小，不過你仍然要設定 Placeholder Constraints 不然 IB 依舊會顯示錯誤訊息給你。 即使 Content View 不能根據 UIScrollView 取得尺寸，但我們還是要設定 Content View 的 Top, Bottom, Leading, Trailing 的佈局條件，這一步是大多數人覺得困惑的地方，因為 Apple 官方已經改變了 Constraints 在這種情況下的用途，現在它可以用來指示 UIScrollView 關於 Content View 的邊界，所以可以拿來計算內容的大小。這些特殊情況的 Constraints 其行為並不像一般的佈局條件，不管你給他們什麼設定，他們不會真的改變 Content View 的尺寸。一旦它們存在 UIScrollView 就能夠計算出 Content View 的尺寸。 這麼說可能有點抽象，讓我們繼續往下走，設定你的 Content View 到 UIScrollView 四個邊界的 Constraints 吧。當你完成這些設定你會注意到 IB 顯示了一些錯誤訊息，因為 UIScrollView 還是沒辦法決定 Content View 的尺寸。 不過你可以先不要理他們。 然後在這個 Content View 放入你需要的其他控制項如 UILabel, UITextField 等照你平常設定 AutoLayout 使用。開啟模擬器會發現垂直的排列稍微正常一點，簡單的說你會發現似乎只有 Top 和 Left 可以往下推算的條件是生效的。註：這裡為了方便辨識 UIScrollView 底色為黃色，Content View 為藍底。 水平方向卻是錯的很離譜，雖然有設定左邊邊界到 UILabel ，UILabel 和 UITextField 的間距以及最後 UITextField 到 Content View 的間距，因為無法確定 UITextField 的尺寸設定，所以看起來整個縮起來，因為不知道右邊和下面的邊長值，所以就算你設定了 Right 或 Bottom 的 Edge 還是無法判斷長度或寬度。我們需要一些方式來設定 UITextField 的 width ，我們可以透過寫死的方式設定，不過這樣就沒辦法讓 UITextField 自動根據橫的或直的螢幕改變寬了。解決的辦法是直接讓佈局條件設定為依據 UIScrollView 外部 ViewController 的那個 view，不過這一個步驟無法靠 IB 完成，我們需要寫一些程式碼，此時 IB 依舊提示錯誤訊息，所以我們需要為 Content View 設定 Placeholder Width 來解掉這個錯誤，多加入一個 width 的 Constrains 然後把 Placeholder 勾起來。 使用 command + option + enter 開啟 Assistant editor 把 Content View 加入 IBOutlet，因為我們要使用程式碼來實作我們剛剛說的方式，讓 Content View 直接參考外面的 view。接著在 viewDidLoad 加入下面程式碼 123456789101112131415@interface DBKViewController ()@property (strong, nonatomic) IBOutlet UIView *contentView;@end@implementation DBKViewController- (void)viewDidLoad{ [super viewDidLoad]; NSLayoutConstraint *leftEdgeAlign = [NSLayoutConstraint constraintWithItem:self.contentView attribute:NSLayoutAttributeLeading relatedBy:0 toItem:self.view attribute:NSLayoutAttributeLeft multiplier:1.0 constant:0]; [self.view addConstraint:leftEdgeAlign]; NSLayoutConstraint *rightEdgeAlign = [NSLayoutConstraint constraintWithItem:self.contentView attribute:NSLayoutAttributeTrailing relatedBy:0 toItem:self.view attribute:NSLayoutAttributeTrailing multiplier:1.0 constant:0]; [self.view addConstraint:rightEdgeAlign];}@end 你還是會看到 IB 出現一些警示，所以我們可以透過 IB 的功能來更新一下 storyboard 或者一口氣更新 然後我們就完成了讓控制項自適應的技巧。 把控制項移動到鍵盤上方到了這一步你可以會問有什麼是我曾經被 UIScrollView 困擾的問題，乍看之下好像都完成了，不過當你需要編輯 UITextField 的時候，就會發現你的控制項被虛擬鍵盤擋住了，這也是我們為什麼會需要用 UIScrollView 通常是因為你有太多控制項需要往下延伸，不過鍵盤擋住了我們的輸入框導致在輸入的時候看不到我們輸入了什麼。要解決這個問題，首先我們需要追蹤是哪一個 UITextField 開始進入編輯的狀態，有很多種方式，這邊我們選擇了設定 UITextField 的 delegate 到 ViewController。先在 ViewController 中加上 UITextFieldDelegate 1@interface DBKViewController () &lt;UITextFieldDelegate&gt; 然後 選擇 delegate 接著我們實作一些委派函式好讓正在編輯的 UITextField 可以捲動到鍵盤的上方，我們需要取得正在編輯的控制項參考，所以加入下面的程式碼： 12345678910111213@interface DBKViewController () &lt;UITextFieldDelegate&gt;@property (nonatomic, weak) UITextField *activeTextField;@end- (void)textFieldDidBeginEditing:(UITextField *)textField{ self.activeTextField = textField;}- (void)textFieldDidEndEditing:(UITextField *)textField{ self.activeTextField = nil;} 接著我們需要註冊關於鍵盤出現的通知(Notifications)。 123456789101112131415161718192021- (void)viewWillAppear:(BOOL)animated { [super viewWillAppear:animated]; [self registerForKeyboardNotifications];}- (void)viewWillDisappear:(BOOL)animated { [self deregisterFromKeyboardNotifications]; [super viewWillDisappear:animated];}- (void)registerForKeyboardNotifications{ [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWasShown:) name:UIKeyboardDidShowNotification object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillBeHidden:) name:UIKeyboardWillHideNotification object:nil];}- (void)deregisterFromKeyboardNotifications{ [[NSNotificationCenter defaultCenter] removeObserver:self name:UIKeyboardDidShowNotification object:nil]; [[NSNotificationCenter defaultCenter] removeObserver:self name:UIKeyboardWillHideNotification object:nil];} 最後實作當鍵盤出現/消失的函式(selector)和替 UIScrollView 加入一個 IBOutlet 以方便當要捲動時設定，如果你覺得這些程式碼似曾相識因為他們是參考 Apple 官方文件而來的，如果你曾經搜尋過 how to scroll a text field into view 你應該也看過很多類似的程式碼。不過大部份的文章包含 Apple 的教學，當你需要轉動裝置時都會有一個 Bug 那就是他們取到了錯誤的鍵盤尺寸。相關問題可以參考這篇Stackoverflow 第一步我們透過NSNotification物件取得鍵盤的尺寸，接著使用 UIEdgeInsets 去偏移顯示區域，取得鍵盤的高度之後透過計算在呼叫 scrollRectToVisible 去捲動，程式碼如下 1234567891011121314151617181920212223- (void)keyboardWasShown:(NSNotification*)notification{ NSDictionary* info = [notification userInfo]; CGRect keyboardRect = [[info objectForKey:UIKeyboardFrameBeginUserInfoKey] CGRectValue]; keyboardRect = [self.view convertRect:keyboardRect fromView:nil]; UIEdgeInsets contentInsets = UIEdgeInsetsMake(0.0, 0.0, keyboardRect.size.height, 0.0); self.scrollView.contentInset = contentInsets; self.scrollView.scrollIndicatorInsets = contentInsets; CGRect screenRect = self.view.frame; screenRect.size.height -= keyboardRect.size.height; if (!CGRectContainsPoint(screenRect, self.activeTextField.frame.origin) ) { [self.scrollView scrollRectToVisible:self.activeTextField.frame animated:YES]; }}- (void)keyboardWillBeHidden:(NSNotification*)notification{ UIEdgeInsets contentInsets = UIEdgeInsetsZero; self.scrollView.contentInset = contentInsets; self.scrollView.scrollIndicatorInsets = contentInsets;} 完整範例 Github其他補充12scrollView.contentInset這個屬性效果等於 CSS 中的 Padding 屬性，設定時使用 UIEdgeInsetsMake(0,0,0,0) 順序為上、左、下、右。 1CGRectContainsPoint(arg1, arg2) 判斷當 arg1(CGRect) 中有 arg2(CGPoint)時回傳 YES 參考資料Using UIScrollView with Auto Layout in iOSUIScrollView 原理详解","link":"/2014/08/09/ios-use-uiscrollview-autolayout/"},{"title":"使用 Gulp 為前端開發伺服器","text":"因為 Gulp 這個任務執行工具最近越來越流行，所以想說試著用它來做些事情，其實它跟 Grunt 一樣可以拿來處理很多事情像是整合 Javascript 檔案，壓縮圖片等等。如果你之前從來沒聽過 Gulp 這裡建議您先閱讀 英文教學, Gulp 初體驗。在這篇文章中，我們將學習使用 Gulp 來完成一個簡單的小型伺服器以協助您平日的前端開發，當然這也支援 livereload。 從前的方式假想一下當你想開發一個 SPA (單頁式應用程式)，這個應用程式的進入點是 index.html ，最後我們的目標是透過 localhost 來存取這個頁面。為什麼一定要用 localhost 因為一些安全機制你不能直接透過 file:/// 的檔案來執行 ajax，在過去或許你會安裝一個 Apache 或 Nginx 伺服器，學會這招！你將不再需要為了開發把自己的機器弄髒了。(當然 Grunt 也能辦到請參考) 更好的方式今時今日，Javascript 幾乎實作了所有的東西，包含一個 Web Server，其中最流行的一個叫做 Connect，我們將使用它透過一個 Gulp 的擴充套件 gulp-connect 來完成我們的目的。接下來的文章我們將會學習如何設定一個 Web Server，所以我假設你已經懂了基本的 Gulp 和 關於如何使用 gulpfile.js。 初始化設定12345$ mkdir spa-website$ cd spa-website$ npm init$ npm install --save-dev gulp$ npm i -D gulp-connect # 縮寫 現在我們可以來定義 Web Server 的任務了，我們的 gulpfile.js 看起來會像下面 12345678var gulp = require('gulp'), connect = require('gulp-connect');gulp.task('webserver', function() { connect.server();});gulp.task('default', ['webserver']); 超級直覺的吧！現在你可以啟動一個 Web Server ，透過在 terminal 執行 gulp 指令，然後開啟瀏覽器輸入 localhost:8080 如果你在目錄中有 index.html 你就能看到網頁。這個小型的 Web Server 是掛載在 gulpfile.js 放置的目錄之上也就是 localhost:8080 的根目錄，換個角度說吧！通常我們會在一個目錄組織自己的 nodejs 專案，而這個 gulpfile.js 要放在專案的根目錄，因為你會需要 require node_module 裡面的 gulp，同時也方便你組織路徑。一旦你執行 gulp 指令這個 Server 就會啟動直到你使用 Ctrl + c 結束這個任務。如果你已經有經驗的話那也可以直接查閱 Github 看看範例。每一個範例包含了所有待會實作的結果，你只需要下 npm install 安裝所有相依的套件即可使用。 加入 livereload如上面所看到的使用 gulp 建立一個 Web Server 是非常簡單的。下一步讓我們繼續來加入 livereload 支援，這樣一來當我們更新頁面的內容瀏覽器就會自動更新就不用一直手動更新頁面。我們需要做兩件事讓 gulp 的 Web Server 支援 livereload ，第一件事情是設定 Web Server 就是我們的 gulp-connect 支援 livereload ，接著我們必須通知 livereload 何時要更新頁面。第一個步驟非常簡單直接設定 livereload: true 設定 server 這個任務如下 12345gulp.task('server', function () { connect.server({ livereload: true, });}); 第二個步驟則視您的需求，在這個範例我們會設定自動編譯 LESS 檔案為 CSS 然後把更新的內容提交給瀏覽器。讓我們來看看這個範例的部分。我們需要一個偵測器，這個東西的用途是判斷 LESS 檔案是否被變更，接著這個偵測器會去觸發 LESS 編譯的任務，然後就會輸出 CSS 檔案，接下來這個檔案應該要透過 livereload 注入。 根據我們的需求我們會需要使用 gulp-less 這個外掛是用來編譯 LESS 的，同樣的你需要透過 npm install --save-dev gulp-less 去安裝這個套件。而所謂的偵測器已經附加在 gulp.js 裡面了，我們這個應用程式的架構大致上像這樣 1234567├── node_modules│ └── ...├── styles│ └── main.less├── gulpfile.js├── index.html└── package.json 剛剛我們提到了偵測器，我們這邊用的就是 gulp.watch() 這個方法，他的功用就如上面說的當觀察到某個檔案產生變化，通常就是你存檔的瞬間，它就可以去觸發你設定的任務。在這個範例中就是一個 watch 的任務，Gulp.js 會一直監聽所有在 styles 目錄中符合 *.less 的檔案(就是任意名稱且附檔名為 less 的檔案)，接著當他看到檔案改變了就要去觸發 less 任務，這邊我們編譯的就是 main.less 這個 LESS ，每一次執行完編譯的動作，其結果將自動被注入到瀏覽器。關於 gulpfile.js 看起來會像下面這樣 12345678910111213141516171819202122var gulp = require('gulp'), connect = require('gulp-connect') less = require('gulp-less');gulp.task('server', function () { connect.server({ livereload: true });});gulp.task('less', function () { gulp.src('styles/*.less') .pipe(less()) .pipe(gulp.dest('styles')) .pipe(connect.reload());});gulp.task('watch', function () { gulp.watch('styles/*.less', ['less']);});gulp.task('default', ['less', 'server', 'watch']); 完成設定之後回到 Terminal 執行 gulp 然後在瀏覽器開啟 localhost:8080。我們現在可以對 LESS 做一些修改然後存檔，在這一瞬間 gulp 已經完成編譯並且 refresh 您的瀏覽器了，注意到這邊這個方式並不需要額外安裝 livereload 的瀏覽器擴充元件。livereload 以不同的方式運作。 調整設定注意上面的 gulpfile.js 只是一個小小的示範，以讓你可以快速理解如何建立一個 gulp 搭配 gulp-connect 支援 livereload 的 Web Server。我非常建議您可以搜尋一些其他的套件將它們組合出一些其他的任務，你應該試著重組這些任務結構，並且試試非內建的 gulp-watch 套件，它可以讓你處理剛剛變更過的檔案，隨著你要處理的任務越來越多這將會非常有幫助。讓我們簡單地用實際範例說明一下吧！你會發現除了 LESS 變更會自動更新，如果你是變更 HTML 那 livereload 並不會有任何反應，為什麼？因為你並沒有觀察 html ，所以你可能會像下面這樣 12345678910111213141516171819202122232425262728var gulp = require('gulp'), connect = require('gulp-connect'), less = require('gulp-less');gulp.task('server', function () { connect.server({ livereload: true });});gulp.task('less', function () { gulp.src('styles/main.less') .pipe(less()) .pipe(gulp.dest('styles/')) .pipe(connect.reload());});gulp.task('html', function () { gulp.src('*.html') .pipe(connect.reload());});gulp.task('watch', function () { gulp.watch('styles/*.less', ['less']); gulp.watch('*.html', ['html']);});gulp.task('default', ['less', 'server', 'watch']); 這個時候如果改用 gulp-watch 那麼設定檔就會像下面這樣 123456789101112131415161718192021222324252627var gulp = require('gulp'), connect = require('gulp-connect'), less = require('gulp-less'), watch = require('gulp-watch');gulp.task('server', function () { connect.server({ livereload: true });});gulp.task('less', function () { gulp.src('styles/*.less') .pipe(watch(function (f) { return f.pipe(less()) .pipe(gulp.dest('styles/')) .pipe(connect.reload()); }));});gulp.task('html', function () { gulp.src('*.html') .pipe(watch(function (files) { files.pipe(connect.reload()); }))});gulp.task('default', ['less', 'html', 'server']); 你就不需要再多一個 watch 的任務了。兩種方式您都可以使用端看您的偏好。 設定 hostname 和 port 號關於 gulp-connect 他其實有很多設定選項，在這個範例中我們將設定一個 hostname 和使用 80 port 這樣一來你就可以少打一點字 1234connect.server({ post: 80, host: gulp.dev}) 先別急著執行，為了讓你設定的 hostname 能夠運作你必須要先將這個網域名稱加到你的 hosts 1127.0.0.1 gulp.dev 然後執行 sudo gulp 必須要有 sudo 權限才能使用 80 port 其他進階的功能你甚至可以使用 connect 套件在同一時間產生多個 Web Server 服務，這對您的開發也是有幫助的舉例來說你可以執行一個開發用的 Server 然後同時執行整合測試。gulp-connect 也允許您使用多個目錄為根目錄，舉例來說當你使用 CoffeeScript 你會希望把一些編譯的 Javascript 檔案放在 .tmp 暫存目錄然後把這個目錄 mount 上來當根目錄用，如此你就不會把你的專案目錄弄髒了。 重構在前面的範例我們只不過小試了一下用 gulp 來編譯 LESS 然後使用 gulp-connect 搭配 livereload ，實際上我們可以做的更好。當混合多種編譯和 livereload 到同一個任務的時候有可能會有一些問題和導致整個設定越來越混亂，所以讓我們來把他們分離並且讓偵測器在檔案一變更的時候就直接做些處理，為了達到這個目的，我們會需要使用剛剛提到的 gulp-watch。 然後我們加入編譯 CoffeeScript 的任務，下面這個新的設定結構將會更加清楚。首先我們先安裝需要的套件 12$ npm i -D gulp-watch$ npm i -D gulp-coffee 安裝好之後 require 這些套件函式庫，在下面這些步驟中我假設你已經有一些 .coffee 的檔案在 scripts 目錄，如果沒有你可以到這邊下載。重構後的 gulpfile.js 如下 12345678910111213141516171819202122232425262728293031323334353637var gulp = require('gulp'), connect = require('gulp-connect'), less = require('gulp-less'), watch = require('gulp-watch'), coffee = require('gulp-coffee');gulp.task('server', function () { connect.server({ root: ['.', '.tmp'], livereload: true });});gulp.task('livereload', function () { gulp.src(['.tmp/styles/*.css', './tmp/scripts/*.js', '*.html']) .pipe(watch()) .pipe(connect.reload());});gulp.task('less', function () { gulp.src('styles/main.less') .pipe(less()) .pipe(gulp.dest('.tmp/styles'));});gulp.task('coffee', function () { gulp.src('scripts/*.coffee') .pipe(coffee()) .pipe(gulp.dest('.tmp/scripts'));});gulp.task('watch', function () { gulp.watch('styles/*.less', ['less']); gulp.watch('scripts/*.coffee', ['coffee']);});gulp.task('default', ['less', 'coffee', 'server', 'livereload', 'watch']); 這個版本最大的改變是我們增加了 livereload 任務，這個任務透過 gulp-watch 來觀察那些已經被編譯完成的檔案，只要他們有變動就幫忙 reload 。套件提供的 watch() 函式允許我們只重載那些變更的檔案，而內建的 gulp.watch() 將會重載所有檔案，而不是只有變更的檔案。因為這個額外的任務我們不需要在每個任務後面加上 .pipe(connect.reload()) ，所以我們達到了任務的關注點分離，比起全部混在一起這可能是比較好的做法。我們同時也注意到那些被編譯的檔案不是存在對應的原始碼目錄中，他們被放在暫存的目錄裡 .tmp 這樣的好處是這些編譯的檔案不會污染 styles, scripts 目錄，並且在實務上我們通常會排除這個 .tmp 目錄進入我們的版控。但我們又直接把它 mount 到了根目錄如此一來程式碼路徑就不用變更了。 結論你已經學會了關於 Gulp 如何設定為你的開發伺服器了。你可以結合這個技術到各種專案去，注意這個 Web Server 只適合當作本地開發機如果是產品，你還是應該使用像是 Nginx 這類的伺服器。任何剛剛做到的任務你都可以使用 Grunt 達成。只不過 Gulp 設定起來對程式設計師比較直覺。","link":"/2014/08/26/using-gulp-for-front-end-development-server/"},{"title":"Gulp 使用問題與記錄","text":"這篇文章除了記錄一下最後只是堪用的解法，如果有高手知道更好的做法煩請賜教。 話說小弟今天要來寫一些 React 的測試專案，就想說那就搭上 Gulp 吧！原本的目的很單純就只是用 Gulp compile 一些常用的 meta language，像是 Less, Jade 外加上 Jsx。也不是什麼很大的專案所以架構上其實就是在 React 的 StartKit上面再開個自己的測試目錄。 一開始也都用的很開心，然後就發現：在啟動 server 支援 livereload 後，當從 src 目錄刪除檔案，dist 目錄的檔案竟然沒被刪掉！！！(好啦！我知道正確來說應該是要先輸出到 .tmp 在 copy)。說明一下我想完成的目標就是： 一個簡單的 Server 支援 watch &amp; livereload。 存檔後直接把 src 底下的檔案編譯至對應的 dist 目錄下。 接著我希望 dist 目錄下的檔案要正確的對應，意思是如果我新增/刪除一個檔案，那 dist 也要新增/刪除。 直覺反應這也不是什麼大問題，那就補上 clean 的套件就好，一開始沒注意到 gulp-clean 有非同步的小問題因為我是要刪 dist 而不是 src 所以直覺得拆成兩個 task，想說我任務都有照順序先 clean 在 compile 為什麼一下噴 Error，一下又正常，再加上一開始不想要用全部清掉這種方式。 於是就讓我 Google 到這一篇 Delete feature request ，因為下面有人提到使用 gulp-filter 的方式，接著我就將 watch 的 task 部分換成 123gulp.task('default', function () { watch('css/**/*.css').pipe(gulp.dest('./dist/'));}); 這種寫法，並補上 filter ，本來以為要打完收工的時候，卻發現我對 Node 很多東西觀念太薄弱，我不會替 vinyl-fs 物件綁上 event，也不知道怎麼根據 pipe() 來的檔案資訊來切換目錄，且有人提到可以用 gaze 的方式我試了半天也宣告失敗。附帶一提當你使用上面這種 watch 的寫法時其實 log 的資訊比較清楚。 最後差強人意的 gulpfile 在下面，最後如果有興趣要測的可以用 Github 測試環境在 playground 目錄下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081var gulp = require('gulp'), connect = require('gulp-connect'), less = require('gulp-less'), react = require('gulp-react'), watch = require('gulp-watch'), jade = require('gulp-jade'), clean = require('gulp-clean');/*** Compilers*/gulp.task('less', ['clean-css'], function () { gulp.src('playground/src/styles/less/*.less') .pipe(less()) .pipe(gulp.dest('playground/dist/css'));});gulp.task('clean-css', function () { gulp.src('playground/dist/css/*', {read: false}).pipe(clean({force: true}));});gulp.task('jsx', ['clean-js'], function () { gulp.src('playground/src/scripts/jsx/*.jsx') .pipe(react()) .pipe(gulp.dest('playground/dist/js/'));});gulp.task('clean-js', function () { gulp.src('playground/dist/js/*', {read: false}).pipe(clean({force: true}));});gulp.task('jade', ['clean-html'], function () { gulp.src('playground/src/templates/**.jade') .pipe(jade()) .pipe(gulp.dest('playground'));});gulp.task('clean-html', function () { gulp.src('playground/*.html', {read: false}).pipe(clean({force: true}));});/*********************************************************//*** Web Server*/gulp.task('server', function () { connect.server({ root: ['playground'], livereload: true });});gulp.task('livereload', function () { watch(['playground/*.html', 'playground/dist']) .pipe(connect.reload());});gulp.task('watch', function () { gulp.watch('playground/src/styles/less/*.less', ['less']); gulp.watch('playground/src/scripts/jsx/*.jsx', ['jsx']); gulp.watch('playground/src/templates/**.jade', ['jade']);});/*********************************************************//*** Mixin feature of usage*/gulp.task('default', ['less', 'jsx', 'jade', 'server', 'livereload', 'watch']);","link":"/2014/09/10/gulp-real-notes/"},{"title":"理解 Javascript 的 Function.prototype.bind","text":"Function.prototype.bind 函式繫結大概是當您開始學習 Javascript 時最後關注到的議題。通常是當您遇到一種狀況：需要在其他 Function 保留 this 的執行環境(Context)。講執行環境可能太抽象，舉例來說就是當您需要在函式的另外一個函式中呼叫 this.action() 的時候。(這邊如果看不懂請耐著性子看下去)不過通常這時您可能也不知道您需要的就是 Function.prototype.bind()。 第一次您遇到上述的問題，您可能會傾向于把 this 儲存成一個變數，接著即便您切換了 Context 還是可以參考到這個物件。如果您看不懂上面在說什麼，請先參考這篇文章。許多人會採用 self, _this 或者 context 當作變數名稱，並且把 this 放進去。這些方法都是可行的且並沒有什麼不妥，但有一個更不錯的方式。 我們實際上要解決的問題是？下面有一份簡單的範例程式碼，情況是某人忘記把 Context 存成一個變數： 123456789101112131415161718192021222324252627282930313233343536/** * 我們舉例一個機器人物件，機器人有一些基本的 function 來執行動作 * 不過問題是當我們要求機器人執行動作的時候，他需要先到確定還有沒有能量。 * * * Note: 這段程式碼只是希望能夠用具像化一點的比喻來說明。 */var Robot = { /** private */ power: 100, walk: function () { console.log('Robot walked'); this.power -= 10; }, fly: function () { console.log('Robot flied'); this.power -= 20; }, check: function (excute) { if (this.power &gt; 0) excute(); }, /** public */ showoff: function () { this.check(function () { this.walk(); /* 實際執行的動作。 */ this.fly(); }) }}Robot.showoff(); 如果照著上面把實際要執行的動作當作 callback 傳給 check()，當您要再次呼叫 this.walk() 的時候就會發現出現錯誤訊息 1TypeError: Object #&lt;Object&gt; has no method 'walk' 這是因為我們再次傳進去的匿名函式不知道關於 this 的東西，在這裏我們並沒有善用閉包來保存 Context。而對很多人可能就會把上面的範例修改為如下 123456789101112131415161718192021222324252627282930var Robot = { /** private */ power: 100, walk: function () { console.log('Robot walked'); this.power -= 10; }, fly: function () { console.log('Robot flied'); this.power -= 20; }, check: function (excute) { if (this.power &gt; 0) excute(); }, /** public */ showoff: function () { var that = this; this.check(function () { that.walk(); /* 實際執行的動作。 */ that.fly(); }) }}Robot.showoff(); 宣告成區域變數之後，閉包就會幫助我們 Keep 這個 Context，這也是相對直覺的方式，同上面說的這沒有任何不妥。不過我們知道了一件事，就是我們需要保存 Robot 這個物件參考的 Context，給 Callback 即範例中的 excute。當我們呼叫 that.walk() 的時候其實就是在使用閉包。根據 MDN 說明，其實閉包就是一個特殊的物件，它有兩個含義： 它是一個 function。 它產生了一個 Context ，概略的說就是幫你記錄上一層有宣告的變數。 這裏就不詳細說明關於閉包，不理解的推薦這篇文章和這篇 閉包的方式已經可以運作了，但是我們覺得他不夠漂亮，因此我們就來使用 Function.prototype.bind()。 讓我們來重構上面的程式範例 123456789101112131415161718192021222324252627282930var Robot = { /** private */ power: 100, walk: function () { console.log('Robot walked'); this.power -= 10; }, fly: function () { console.log('Robot flied'); this.power -= 20; }, check: function (excute) { if (this.power &gt; 0) excute(); }, /** public */ showoff: function () { // var that = this; this.check(function () { this.walk(); this.fly(); }.bind(this)); }}Robot.showoff(); 我們剛剛做了什麼？？當我們呼叫了 .bind() 的時候，其實它非常單純的建立了一個新的 function，只不過這個 function 把 this 的值綁定進去。所以我們同時把我們想要的 Context(即 Robot 物件) 給保存了下來。接著當我們的回呼函式在執行的時候 this 就是參考到 Robot 這個物件。 如果你有興趣了解 Function.prototype.bind() 內部運行機制，他看起來大概就像下面這樣 123456Function.prototype.bind = function (scope) { var fn = this; return function () { return fn.apply(scope); };} 接著我們再來看看一個非常簡單的案例： 12345678910111213var foo = { x: 3}var bar = function () { console.log(this.x);}bar(); // undefinedvar boundFunc = bar.bind(foo);boundFunc(); // 3 這個範例是說，bind() 幫我們建立了一個新的 function ，並且當我們執行時這個 function 的 this 是指向 foo，而不是全域。如果您還是不清楚可以大略理解為：把 function 掛到某個物件底下(當然不是真的加進去)，只是這樣一來可以透過 this 取得該物件的 Context。 實務應用當我們學習某些東西時，我不只需要理解觀念，也會試著將其套用在實務上以驗證自己是否明白。來看看一些實務上的應用吧！ Click 事件處理其中一個用途是拿它來追蹤點擊次數，然後可能是要把它存在某個物件裡類似下面這樣 1234567var logger = { x: 0, increment: function () { this.x++; console.log(this.x); }} 然後指派一個按鈕的 Click 處理函式去呼叫 logger 物件 123document.querySelector('button').addEventListener('click', function () { logger.increment();}); 不過上面這種做法，我們已經建立了一個不必要的匿名函式，並且因為這個匿名函式使用了 logger 呼叫了 increment() 所以產生了一個閉包用以確保了 this 是正確的參考物件。不明白！？再看看下面這個最根本的寫法吧 1document.querySelector('button').addEventListener('click', logger.increment); // NaN 原本是這樣的，當你 Click 的時候執行一個 function ，不過如果你用上面這種寫法的話，意思是你只是把 function 傳進去，根據 this 的定義他其實是指的是誰(哪個物件)呼叫這個函式 this 就是指向它。而這裡呼叫的人根本不是 logger 這個物件。也因此使用了一個匿名函式，建立了一個閉包，就是為了保留住 logger 物件的狀態。 好了！講完上面這些我們來看看更乾淨的寫法： 1document.querySelector('button').addEventListener('click', logger.increment.bind(logger)); 現在，對於 bind() 應該比較不陌生了吧！本篇是在寫 React 時產生了一點疑問所研究的筆記，因為在 React 中蠻多機會的使用 bind。如官方的範例 123456789101112componentDidMount: function() { $.ajax({ url: this.props.url, dataType: 'json', success: function(data) { this.setState({data: data}); }.bind(this), error: function(xhr, status, err) { console.error(this.props.url, status, err.toString()); }.bind(this) });}","link":"/2014/09/11/understanding-javascript-functionprototypebind/"},{"title":"關於 Reactjs 的核心觀念","text":"這篇文章為官方部落格的文章隻翻譯。原文。 以觀念來說React 是一種使用 Javascript 來快速建立大型 Web 的方式，它非常容易擴展，且官方已將其使用在 Facebook 與 Instagram 上。 其中最好的部分就是 React 讓您在建立程式時重新思考關於應用程式。在這篇文章，將會引導您使用 React 完成一個可以搜尋過濾產品資料的範例。 從模擬架構開始想像我們已經有了一個 JSON 的 API 以及一個設計師模擬的草圖。我們的設計師顯然不是很優，因為他的模擬像這樣： 而我們的 JSON API 傳回來的資料長得像這樣： 12345678[ {category: &quot;Sporting Goods&quot;, price: &quot;$49.99&quot;, stocked: true, name: &quot;Football&quot;}, {category: &quot;Sporting Goods&quot;, price: &quot;$9.99&quot;, stocked: true, name: &quot;Baseball&quot;}, {category: &quot;Sporting Goods&quot;, price: &quot;$29.99&quot;, stocked: false, name: &quot;Basketball&quot;}, {category: &quot;Electronics&quot;, price: &quot;$99.99&quot;, stocked: true, name: &quot;iPod Touch&quot;}, {category: &quot;Electronics&quot;, price: &quot;$399.99&quot;, stocked: false, name: &quot;iPhone 5&quot;}, {category: &quot;Electronics&quot;, price: &quot;$199.99&quot;, stocked: true, name: &quot;Nexus 7&quot;}]; 第一步：拆解 UI 為元件階層結構您即將要做的第一個步驟是根據模擬的 UI 畫出每一個元件(包含子元件)的階層方塊並且給予名稱，如果你正在與設計師一起工作那可能你已經完成這個任務。看看他們的 Photoshop 中圖層的名稱大略就是你 React 元件最後的名稱。不過我們怎麼知道哪個部分應該是元件？當您建立一個新的函式或物件，您可以根據單一職責原則，指的是每一個元件理想的情況下應該只做一件事。如果該元件的功能不斷增加那就應該再把它拆解，並建立更小的子元件。 常見的需求是 - 顯示 JSON 的資料給使用者。根據過去的經驗，您會發現如果您的資料模型(Model)建立的正確，您的 UI (同時表示您的元件結構)就可以輕鬆的將資料呈現給使用者。其原因是使用者界面和資料模型往往遵循一樣的資料結構，意味著其實將 UI 獨立為元件並非很困難。就只是根據每一個小區塊需要呈現的資料模型去分解成個別的元件。 看到上圖，這個應用程式將會有 5 個元件，下面的斜體字表示每一個元件對應的模型 FilterableProductTable (橘色) 用來組織包含其他子元件，即這個元件的最上層的容器。 SearchBar (藍色) 取得 使用者輸入的搜尋條件。 ProductTable (綠色) 根據 使用者輸入的搜尋條件 顯示過濾後的資料列表。 ProductCategoryRow (青色) 顯示 分類 標題。 ProductRow (紅色) 顯示每一個 _產品_。 如果您認真觀察 ProductTable 你會看到表格還有標題列(即 Name 和 Price 欄位名稱那邊)並沒有被規劃為獨立元件。這只是偏好問題。根據這個範例，我們規劃這個區塊為 ProductTable 的一部份，這是因為輸出產品列表資料是 ProductTable 的責任，當然包含欄位名稱，且目前看來它的工作很單純並不需要再拆出一個元件。然而如果這個標題列變得越來越複雜(舉例來說：如果我們需要增加排序功能)，如此一來增加一個 ProductTableHeader 元件會是比較好的做法。 現在我們已經定義好關於這個模擬的元件架構，讓我們重新組織成一個階層圖，這樣我們就能清楚看出元件的主從關係。 FilterableProductTable SearchBar ProductTable- ProductCategoryRow - ProductRow 第二步：建立一個靜態版本的 React 元件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** @jsx React.DOM */var ProductCategoryRow = React.createClass({ render: function() { return (&lt;tr&gt;&lt;th colSpan=&quot;2&quot;&gt;{this.props.category}&lt;/th&gt;&lt;/tr&gt;); }});var ProductRow = React.createClass({ render: function() { var name = this.props.product.stocked ? this.props.product.name : &lt;span style={{color: 'red'}}&gt; {this.props.product.name} &lt;/span&gt;; return ( &lt;tr&gt; &lt;td&gt;{name}&lt;/td&gt; &lt;td&gt;{this.props.product.price}&lt;/td&gt; &lt;/tr&gt; ); }});var ProductTable = React.createClass({ render: function() { var rows = []; var lastCategory = null; this.props.products.forEach(function(product) { if (product.category !== lastCategory) { rows.push(&lt;ProductCategoryRow category={product.category} key={product.category} /&gt;); } rows.push(&lt;ProductRow product={product} key={product.name} /&gt;); lastCategory = product.category; }); return ( &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Price&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt;{rows}&lt;/tbody&gt; &lt;/table&gt; ); }});var SearchBar = React.createClass({ render: function() { return ( &lt;form&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Search...&quot; /&gt; &lt;p&gt; &lt;input type=&quot;checkbox&quot; /&gt; Only show products in stock &lt;/p&gt; &lt;/form&gt; ); }});var FilterableProductTable = React.createClass({ render: function() { return ( &lt;div&gt; &lt;SearchBar /&gt; &lt;ProductTable products={this.props.products} /&gt; &lt;/div&gt; ); }});var PRODUCTS = [ {category: 'Sporting Goods', price: '$49.99', stocked: true, name: 'Football'}, {category: 'Sporting Goods', price: '$9.99', stocked: true, name: 'Baseball'}, {category: 'Sporting Goods', price: '$29.99', stocked: false, name: 'Basketball'}, {category: 'Electronics', price: '$99.99', stocked: true, name: 'iPod Touch'}, {category: 'Electronics', price: '$399.99', stocked: false, name: 'iPhone 5'}, {category: 'Electronics', price: '$199.99', stocked: true, name: 'Nexus 7'}];React.renderComponent(&lt;FilterableProductTable products={PRODUCTS} /&gt;, document.body); 現在您已經有了元件的階層結構。該是時候實作程式的功能了。在學習 React 的過程中，我們推薦最簡單的方式是一開始只要建立一個能取得資料模型和渲染出 UI 畫面但是不能互動的版本。拆成這些步驟是因為建立靜態版本通常是需要打很多字且不太需要思考，而建立互動機制需要您仔細的構思，如此一來在建立元件時比較不會出錯。 在建立靜態版本的時候通常你會思考關於元件 重複使用 的機會以及該怎麼透過 props 從父元素傳入資料。如果您已經熟悉關於 state 的觀念，就會知道在建立靜態版本時根本不應該使用 state。state 是互動時才會需要用到的功能，所謂的互動指的是當資料變動，而 UI 也需要對應更新。由於這只是靜態版本所以根本不需要用。 您可以由底層往上或者由上而下撰寫您的元件，意思是說你可以選擇從結構中最外層的元件開始建起(即從 FilterableProductTable)開始，或者從最內部的子元件開始(ProductRow)。在單純的範例中，通常從上至下相對快速，而如果專案較大，通常從下而上會比較推薦，因為也同時方便您撰寫測試，可以逐步測試元件是否正常。 在這一步的最後，您會得到一個可重複使用元件的函式庫，你可以用它來輸出呈現你的資料模型，以確認 UI 的呈現是否有誤。不過這個元件只有 render() 方法，因為截至目前為止它還只是靜態版本。 元件的最上層(FilterableProductTable)將會取得資料模型，透過屬性傳入資料。如果你修改了 Model 的資料且再次執行 renderComponent() 你應該會看到資料更新了。這讓你可以清楚地觀察這個元件是怎麼更新資料，這就是 React 透過 one-way data flow (或稱 one-way binding) 單向數據流的方式去保持所有資料一致，同時也方便模組化。 簡易補充: props vs state在 React 裏有兩種類型的 Model 就是你放資料的地方：props 與 state。理解他們的區別非常重要，如果您還不懂他們之間的差別請閱讀官方或者這篇文章 第三步：定義最少但完整的 UI 狀態為了讓您的 UI 俱有互動性，你可能會需要讓資料模型做些修改，接著 UI 根據 one-way binding 更新資料。React 透過使用 state 讓這一切變得很簡單。您可以把 state 想是讓您存放動態資料的地方，而當資料有所變動，React 會自動呼叫 render() 執行 UI 的更新。 而要讓建立的程式能夠正確執行，首先需要思考關於這個程式最少需要哪些可變動的狀態，只有變動的資料才需要放到 state。關鍵的原則是 DRY (Don’t Repeat Yourself) ，不重複原則。找出程式在特定需求內必須要的最少狀態。例如：如果你要建立一個 TODO List，其實你就只要一個陣列包含待辦清單的項目。當你需要計算項目總數時，不需要在 state 中的儲存另一個變數，而是單純使用陣列取得數量即可。 思考我們這個範例中各種取得的資料 所有產品的列表 Search input 的搜尋條件 checkbox 是否有被選取的值 過濾後的清單 讓我們一個一個討論看看誰是屬於 state 。簡單的思考關於這三個問題 資料是透過 props 從父元素傳進來的嗎？如果是，這可能不屬於 state 。 這資料會隨著時間推移而改變嗎？ 如果不是，那它應該不屬於 state 。 你能從現有任何 state 或者 props 計算出這個資料嗎？如過是！那這肯定不屬於 staet。 產品列表是透過 props 傳遞進來的，所以這不應該存在 state，當然有經驗的開發者會說這通常從資料庫來，但這個範例不是。搜尋條件和 checkbox 似乎是狀態，因為他們會改變。而且是不能透過計算得到的。最後過濾後的清單也不該儲存在 state ，因為他是可以被計算出來的，根據我們拿到的過濾條件去運算。所以最後我們歸納出應該被放在 state 的有: 搜尋條件 checkbox 的值 第四步：應該在何處使用 state123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/** @jsx React.DOM */var ProductCategoryRow = React.createClass({ render: function() { return (&lt;tr&gt;&lt;th colSpan=&quot;2&quot;&gt;{this.props.category}&lt;/th&gt;&lt;/tr&gt;); }});var ProductRow = React.createClass({ render: function() { var name = this.props.product.stocked ? this.props.product.name : &lt;span style={{color: 'red'}}&gt; {this.props.product.name} &lt;/span&gt;; return ( &lt;tr&gt; &lt;td&gt;{name}&lt;/td&gt; &lt;td&gt;{this.props.product.price}&lt;/td&gt; &lt;/tr&gt; ); }});var ProductTable = React.createClass({ render: function() { var rows = []; var lastCategory = null; this.props.products.forEach(function(product) { if (product.name.indexOf(this.props.filterText) === -1 || (!product.stocked &amp;&amp; this.props.inStockOnly)) { return; } if (product.category !== lastCategory) { rows.push(&lt;ProductCategoryRow category={product.category} key={product.category} /&gt;); } rows.push(&lt;ProductRow product={product} key={product.name} /&gt;); lastCategory = product.category; }.bind(this)); return ( &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Price&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt;{rows}&lt;/tbody&gt; &lt;/table&gt; ); }});var SearchBar = React.createClass({ render: function() { return ( &lt;form&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Search...&quot; value={this.props.filterText} /&gt; &lt;p&gt; &lt;input type=&quot;checkbox&quot; value={this.props.inStockOnly} /&gt; Only show products in stock &lt;/p&gt; &lt;/form&gt; ); }});var FilterableProductTable = React.createClass({ getInitialState: function() { return { filterText: '', inStockOnly: false }; }, render: function() { return ( &lt;div&gt; &lt;SearchBar filterText={this.state.filterText} inStockOnly={this.state.inStockOnly} /&gt; &lt;ProductTable products={this.props.products} filterText={this.state.filterText} inStockOnly={this.state.inStockOnly} /&gt; &lt;/div&gt; ); }});var PRODUCTS = [ {category: 'Sporting Goods', price: '$49.99', stocked: true, name: 'Football'}, {category: 'Sporting Goods', price: '$9.99', stocked: true, name: 'Baseball'}, {category: 'Sporting Goods', price: '$29.99', stocked: false, name: 'Basketball'}, {category: 'Electronics', price: '$99.99', stocked: true, name: 'iPod Touch'}, {category: 'Electronics', price: '$399.99', stocked: false, name: 'iPhone 5'}, {category: 'Electronics', price: '$199.99', stocked: true, name: 'Nexus 7'}];React.renderComponent(&lt;FilterableProductTable products={PRODUCTS} /&gt;, document.body); OK 我們已經決定了這個元件程式最少的 state，下一步我們需要定義哪些元件是要變動的，以及是哪些要使用 state 。記住！React 提供的是一種單向資料流的結構，通常是由上而下。剎那間可能不太輕易判斷哪個元件該管理或使用 state，這通常也是初學者最難理解的部分。請跟著下面這些規則去推敲: 思考程式中需要使用到 state 的部分 找出哪些元件需要根據 state 輸出不同的結果 找出共同的擁有者元件(最上層的元件通常需要管理 state) 如果你不能找出某一個元件該擁有狀態的理由，那就建立一個新的元件用來管理狀態，並且加在共同擁有者元件之上。 讓我們應用這些規則在這個範例上 ProductTable 需要根據 state 過濾產品列表以及 SearchBar 需要顯示搜尋條件的值和 checkbox 的狀態。 共同擁有者元件是 FilterableProductTable。 把過濾條件和 checkbox 值都放在 FilterableProductTable 在概念上也是合理的。 所以我們決定 state 應該放在 FilterableProductTable ，首先加上 getInitialState() 方法，讓它回傳一個物件 {filterText: '', inStockOnly: false}這是用來初始化 state 的，接著傳入 filterText 和 inStockOnly 給 SearchBar 當作屬性，最後在 ProductTable 中使用這些屬性值去過濾，並且設定 form 的值。 現在你可以看到您的應用程式俱有這些行為：在 state 中把 filterText 的值設成 ball 然後資料就會更新。 註：先別急著操作網頁上的 form。 第五步：加入反向數據流123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/** @jsx React.DOM */var ProductCategoryRow = React.createClass({ render: function() { return (&lt;tr&gt;&lt;th colSpan=&quot;2&quot;&gt;{this.props.category}&lt;/th&gt;&lt;/tr&gt;); }});var ProductRow = React.createClass({ render: function() { var name = this.props.product.stocked ? this.props.product.name : &lt;span style={{color: 'red'}}&gt; {this.props.product.name} &lt;/span&gt;; return ( &lt;tr&gt; &lt;td&gt;{name}&lt;/td&gt; &lt;td&gt;{this.props.product.price}&lt;/td&gt; &lt;/tr&gt; ); }});var ProductTable = React.createClass({ render: function() { console.log(this.props); var rows = []; var lastCategory = null; this.props.products.forEach(function(product) { if (product.name.indexOf(this.props.filterText) === -1 || (!product.stocked &amp;&amp; this.props.inStockOnly)) { return; } if (product.category !== lastCategory) { rows.push(&lt;ProductCategoryRow category={product.category} key={product.category} /&gt;); } rows.push(&lt;ProductRow product={product} key={product.name} /&gt;); lastCategory = product.category; }.bind(this)); return ( &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Price&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt;{rows}&lt;/tbody&gt; &lt;/table&gt; ); }});var SearchBar = React.createClass({ handleChange: function() { this.props.onUserInput( this.refs.filterTextInput.getDOMNode().value, this.refs.inStockOnlyInput.getDOMNode().checked ); }, render: function() { return ( &lt;form&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Search...&quot; value={this.props.filterText} ref=&quot;filterTextInput&quot; onChange={this.handleChange} /&gt; &lt;p&gt; &lt;input type=&quot;checkbox&quot; value={this.props.inStockOnly} ref=&quot;inStockOnlyInput&quot; onChange={this.handleChange} /&gt; Only show products in stock &lt;/p&gt; &lt;/form&gt; ); }});var FilterableProductTable = React.createClass({ getInitialState: function() { return { filterText: '', inStockOnly: false }; }, handleUserInput: function(filterText, inStockOnly) { this.setState({ filterText: filterText, inStockOnly: inStockOnly }); }, render: function() { return ( &lt;div&gt; &lt;SearchBar filterText={this.state.filterText} inStockOnly={this.state.inStockOnly} onUserInput={this.handleUserInput} /&gt; &lt;ProductTable products={this.props.products} filterText={this.state.filterText} inStockOnly={this.state.inStockOnly} /&gt; &lt;/div&gt; ); }});var PRODUCTS = [ {category: 'Sporting Goods', price: '$49.99', stocked: true, name: 'Football'}, {category: 'Sporting Goods', price: '$9.99', stocked: true, name: 'Baseball'}, {category: 'Sporting Goods', price: '$29.99', stocked: false, name: 'Basketball'}, {category: 'Electronics', price: '$99.99', stocked: true, name: 'iPod Touch'}, {category: 'Electronics', price: '$399.99', stocked: false, name: 'iPhone 5'}, {category: 'Electronics', price: '$199.99', stocked: true, name: 'Nexus 7'}];React.renderComponent(&lt;FilterableProductTable products={PRODUCTS} /&gt;, document.body); 到上面為止你會發現除非你手動更改 state 的設定，如果你在網頁的表單上輸入任何東西，input 完全沒反應。這是因為 React 是單向數據流的模式。現在讓我們補上其他方向來的數據，由於表單元件在這個結構的內部，而我們只能用 FilterableProductTable 去更新 state 。React 使得數據流非常明確，清楚易懂，歸納的結論就是更新 state 和資料操作請在 owner 擁有者元件裡作，而當子元件的觸發的行為需要更新數據時還是拿父元件的方法。不過這個方式的缺點就是你需要多打一些字，相較于 two-way binding。雖然 React 也提供一個擴充套件叫做 ReactLink 它可以協助您快速做到 two-way binding，不過這篇文章是用來說明整個React 基礎的觀念，所以我們不打算在這篇提太多額外的東西以免造成混淆。 如果您是著輸入一些條件或者勾起 checkbox 在這上一版的程式碼，您會看到 React 忽略您的輸入。這是故意的，因為我們已經設定 input 的 value 是 this.state.filterText ，他就要確保永遠等於這個參考讓我們來想想我們希望怎樣，我們希望確保使用者輸入的任何改變都是去更新 state ，而 input 則一樣從 state 取得資料。 FilterableProductTable 就要把修改 state 的函式傳給 SearchBar，如此一來當 input 觸發 onChange 時才能變更 state。雖然這樣聽起來好像會多了不少程式碼，但這能確保資料流向是非常清楚的。 最後，就這樣而已希望這篇文章能夠使您理解關於 React 如何建立元件和應用程式的觀念。雖然它比起你現在的框架或程式碼的確讓你多打了一些字，不過記住讀程式碼遠遠比撰寫還要困難，而這麼做會讓你的程式碼模組化且非常容易閱讀。","link":"/2014/09/12/on-reacts-core-ideas/"},{"title":"React 關於工具整合","text":"工具整合一般來說，每一個專案使用不同的建置方式，系統環境，以及部署方式。React 試著盡可能的讓一切與系統環境沒有任何相依性。意味著官方盡可能讓所有平台都能用一樣的方式運行 React。 ReactReact CDN在下載頁面官方提供了 React 的 CDN。這些預先編譯的檔案使用的是UMD 模組格式。將它們放置到 &lt;script&gt; 標簽中就可以注入 React 到您的全域環境中。在 CommonJS 與 AMD 的環境下只要引入就能馬上使用。 UMD 提供兼容多種環境的特性。為了達到這個目的，一般狀況，但不是全部，UMD 模組格式會把程式碼包進一個立即調用的函式(Immediately Invoked Function Expression，IIFE)中。 使用 Git 中的 masterReact 提供了一份說明，協助您在取得 GitHub(https://github.com/facebook/react) 後執行編譯建置。同時也提供了 CommonJS 方式的模組在 build/modules 目錄底下，您可以將它們放到任何環境或者支援 CommonJS 的封裝工具。 JSX瀏覽器下的 JSX 編譯如果您偏好使用 JSX ，您也可以在官方下載頁面找到這個可以在瀏覽器執行時期編譯 JSX 的 js 檔案 JSTransformer，以讓您可以在開發時方便的使用。單純的使用 &lt;script type='text/jsx'&gt; 嵌入您的程式碼，搭配 JSX Transformer 即可。不過請注意要加入 /** @jsx React.DOM */ 在開始的地方，否則 JSX Transformer 將不會執行轉譯的工作。 注意: 瀏覽器版的 JSX 編譯檔案相當大，且必須耗費多餘的與要呈現的結果無關運算，這應該要避免。千萬別在發佈的產品上使用。 發佈: 預先編譯 JSX如果您已經有安裝 npm 那麼您可以很輕鬆的直接執行 npm install -g react-tools 來安裝 jsx 的指令工具。這個工具將會先幫你把 JSX 格式的檔案轉換為原始的 Javascript，然後您就可以直接使用。當然您也可以使用自動編譯的方式，透過 jsx --watch src/ build/，如此一來當目錄有任何變更的時候，指令工具就會自動幫您編譯。需要更多詳細的用法資訊請執行 jsx --help。 實用的開源專案開源碼社群已經有許多整合 JSX 的工具，查閱 JSX 整合工具 可以找到適合您的開源專案或工具。","link":"/2014/09/13/reactjs-about-tools/"},{"title":"React 附加組件介紹","text":"附加組件(Add-ons)官方會把一些實用的共用工具放置在 React.addons。這些工具應該暫時被視為還在實驗階段，但最後官方應該會將其整合進核心功能或者如下列共用的工具函式庫: TransitionGroup 與 CSSTransitionGroup 是用來處理關於動畫和過場特效，不過它們通常不是這麼容易實作。 LinkedStateMixin 簡化處理使用者表單欄位和元件狀態之間的一些狀況。 classSet 讓操作 DOM 的 CSS 字串時的程式碼較簡潔。 TestUtils 簡單的測試工具。 cloneWithProps 複製 React 元件與修改 props。 update Javascript 函式，簡化處理不可變動的資料的過程。 下面列出的項目只存在 React 開發版本中: PureRenderMixin 適用於特定情況下改善效能。 Perf 用來測量效能並提供優化的建議。 當您需要使用這些附加組件時，請使用 react-with-addons.js ，而不是單純使用 react.js。","link":"/2014/09/13/reactjs-add-ons-introduction/"},{"title":"React 雙向資料繫結","text":"雙向繫結(Two-way binding)輔助函式React 可以搭配 ReactLink 是一種實作雙向資料繫結較簡單的方式。 注意: 如果您剛開始使用這個 framework ，ReactLink 並不是必須的東西，且應該謹慎使用。 在 React 中，資料流遵循單一方向: 從上而下，從父元件到子元件。這是因為在馮‧紐曼架構下資料流通常一次只有一個方向。您可以單純地就把上面提的這些說名歸納為一個 “one-way data binding” 的機制。在實務上說明就是資料都是從 this.state 或 this.props 來的。 由於大部份應用程式的需求都是關於取得資料並在程式中操作這些資料，或者抽象的說需要讓資料流回程式中。什麼意思？舉例來說:當我們開發了一個表單 form 當表單每次收到使用者變更的資料後您就需要更新 React 的 state。(取得 form 資料 -&gt; 更新 state)又或者你希望在 Javascript 和 React 中調整佈局，改變某些 DOM 的尺寸大小。(取得關於 Size -&gt; 調整佈局) 要完成上面這些任務，透過做法是透過監聽 change 事件，取得資料(這些資料通常來自 DOM)，接著執行 setState() 。封閉的資料流可以帶來一些好處如: 明確易懂，便於維護。用實際的範例來說: 只要你能確定資料來源永遠是 this.state ，而每一階層需要資料的元件都是跟 state 取得，如此一來只要變更 state 其他的元件就應該要自己負責更新資料。 Two-way binding 雙向的資料繫結 – 由於很多時候 DOM 上顯示的值必須和某個 state 中的值一致，所以所謂的 Two-way binding 即程式在背後自動幫您同步這兩個值。改變 form 時 model 會修正，更新 model 後 form 的 UI 也會跟著更新。使用 Two-way binding 的好處是程式碼變得簡潔並適用于多種應用。根據上述的這些情況 React 提供了 ReactLink: 這個語法糖衣讓您可以輕鬆完成這樣的功能，或者我們可以說 ReactLink就是幫您連結資料來源到 React 的 state。 注意: ReactLink 只不過幫您把 onChange/setState() 這兩件事包起來做成一個簡單的慣例。它並不會修改底層運行的模式和資料流。 ReactLink: Before 和 After這邊我們先不使用 ReactLink 示範一個簡單的表單範例: 123456789101112131415161718192021/** * @jsx React.DOM */var NoLink = React.createClass({ getInitialState: function () { return { message: 'Hello!' } }, handleChange: function (event) { console.log(event.target.value); this.setState({message: event.target.value}); }, render: function () { var message = this.state.message; return &lt;input type='text' value={message} onChange={this.handleChange} /&gt;; }});React.renderComponent( &lt;NoLink /&gt;, document.getElementById('example')); 當然這個部分運作的非常良好，且關於資料的運作與流向非常清楚。不過你也發現了，一旦欄位增加程式碼就會變的有些冗長。接著我們換成使用 ReactLink: 12345678910111213141516var WithLink = React.createClass({ /* 載入 React.addons.LinkedStateMixin 中的方法 (this.linkState)*/ mixins: [React.addons.LinkedStateMixin], getInitialState: function () { return {message: 'Hello!'} }, render: function () { return ( &lt;div&gt; &lt;input type='text' valueLink={this.linkState('message')} /&gt; {this.state.message} &lt;/div&gt; ) }}); LinkedStateMixin 加入了一個叫 linkState() 的方法到 React 元件中。然後 linkState() 的功能是回傳了一個 ReactLink 物件，其實這個物件不過就是包含著 state 的值和實做一個 onChange 的 callback。 ReactLink 物件就像 props 一樣，會被傳到整個階層樹狀結構中，因此您可以輕易的設定任何值的 two-way binding 。 值得提醒的是關於 checkbox 的 value 屬性有比較特殊的行為，只有在 checkbox 被勾選，表單提交時才會送出 value (屬性預設會是 on)。關於 value 屬性值是不會改變的不管是勾選或不選。針對 checkbox ，您應該改用 checkedLink 而不是 valueLink: 1&lt;input type=&quot;checkbox&quot; checkedLink={this.linkState('booleanValue')} /&gt; 總結來說我們就只是透過 valueLink 搭配 ReactLink 物件來完成 two-way binding 這件事。 關於內部運作在這一小節我們將要探討關於 ReactLink 的兩個面向: 建立 ReactLink 物件與如何使用。為了證明 ReactLink 很簡單，我們將實作一些程式碼範例讓您更加清楚其運作。 ReactLink 不使用 LinkedStateMixin1234567891011121314151617181920212223242526272829/** * @jsx React.DOM */var WithoutMixin = React.createClass({ getInitialState: function () { return {message: 'Hello!'} }, handleChange: function (newValue) { this.setState({message: newValue}) }, render: function () { var valueLink = { value: this.state.message, requestChange: this.handleChange }; return ( &lt;div&gt; &lt;input type='text' valueLink={valueLink} /&gt; {this.state.message} &lt;/div&gt; ) }});React.renderComponent( &lt;WithoutMixin /&gt;, document.getElementById(&quot;example&quot;)) 誠如您所見，即使不使用 addons 提供的輔助函式我們一樣可以輕鬆使用 ReactLink。ReactLink 只是一個非常單純的物件，它就只是包含 value 和 requestChange 這兩個屬性。同樣的 LinkedStateMixin 也很單純，就只是根據您傳入的參數，決定存取哪一個 this.state 和幫您實作一個使用 this.setState() 的方法。最後我們透過 valueLink 或 checkedLink 告訴 React 這個元素的值要使用 ReactLink 物件，請在適當的時候幫我呼叫裡面的 callback 。 觀念上我們可以歸納為: React 本身只有 one-way data binding 的機制，即資料流都是遵從單一方向。而 two-way binding 的機制只不過是簡化 onChange/setState 這兩件事。 ReactLink 不使用 valueLink123456789101112131415161718192021222324252627/** * @jsx React.DOM */var WithoutLink = React.createClass({ mixins: [React.addons.LinkedStateMixin], getInitialState: function () { return {message: 'Hello!'} }, render: function () { var valueLink = this.linkState('message'); var handleChange = function (e) { valueLink.requestChange(e.target.value); }; return ( &lt;div&gt; &lt;input type='text' value={valueLink.value} onChange={handleChange} /&gt; {this.state.message} &lt;/div&gt; ) }});React.renderComponent( &lt;WithoutLink /&gt;, document.getElementById('example')); 關於 valueLink 屬性也相當單純，它只是簡單的處理 onChange 事件以及呼叫 this.props.valueLink.requestChange() 接著使用 this.props.valueLink.value 取代原本的值。","link":"/2014/09/14/reactjs-a-two-way-data-binding/"},{"title":"React 動畫","text":"動畫React 提供了一個 ReactTransitionGroup 的組件元件來作為一個底層的動畫 API，以及另一個 ReactCSSTransitionGroup 來方便實作基本的 CSS 動畫。 高度抽象化的 API(High-level API) 與 底層的 API(Low-level API) 是什麼？ High-level API 允許開發者操作WSDL，一般來說一個 WDSL 編譯器全部的 SOAP 界面來產生物件，而開發者需要做的就只是直接呼叫物件中的 method，簡單的來說你不需要直接操作 SOAP 的結構。而 Low-level API 則允許開發者直接去動 SOAP 結構，而不是呼叫物件中的方法 更多關於 High-level 與 Low-level 定義 高度抽象化的 API: ReactCSSTransitionGroupReactCSSTransitionGroup 建構在 ReactTransitionGroup 之上，當 React 元件掛載或卸載到 DOM 物件時，您可以透過 ReactCSSTransitionGroup 可以簡單加入 CSS 過場特效與動畫。這個靈感來自于 ng-animate 。 入門ReactCSSTransitionGroup 是一個連接到 ReactTransitions 的介面。這個單純的元素需要把你想要做動畫效果的元件全部包起來。下面的範例是我們要讓列表的項目淡入淡出: 123456789101112131415161718192021222324252627282930313233343536/** @jsx React.DOM */var ReactCSSTransitionGroup = React.addons.CSSTransitionGroup;var TodoList = React.createClass({ getInitialState: function() { return {items: ['hello', 'world', 'click', 'me']}; }, handleAdd: function() { var newItems = this.state.items.concat([prompt('Enter some text')]); this.setState({items: newItems}); }, handleRemove: function(i) { var newItems = this.state.items; newItems.splice(i, 1); this.setState({items: newItems}); }, render: function() { var items = this.state.items.map(function(item, i) { return ( &lt;div key={item} onClick={this.handleRemove.bind(this, i)}&gt; {item} &lt;/div&gt; ); }.bind(this)); return ( &lt;div&gt; &lt;button onClick={this.handleAdd}&gt;Add Item&lt;/button&gt; &lt;ReactCSSTransitionGroup transitionName=&quot;example&quot;&gt; {items} &lt;/ReactCSSTransitionGroup&gt; &lt;/div&gt; ); }}); 在這個元件中，當你把一個 item 加入 ReactCSSTransitionGroup ，它將會取得 example-enter 的 CSS 屬性，而當你再次點擊這個項目時會取得 example-enter-active 樣式。而這個慣例是根據在 transitionName 的名稱所組成的。現在，您可以使用這些 class 樣式去觸發 CSS 的動畫或者過場的效果。舉例來說讓我們加入下面的 CSS 12345678.example-enter { opacity: 0.01; transition: opacity .5s ease-in;}.example-enter.example-enter-active { opacity: 1;} 你可能注意到了，當您要移除某個項目的時候， ReactCSSTransitionGroup 卻把它保留在 DOM 裏面。同時如果你用的是未經壓縮的 react-with-addons 版本，就會看到 console 警告你，React 期望取得一個 CSS 效果。ReactCSSTransitionGroup 會保留您的 DOM 元素直到動畫執行完畢 試著加入下面這段 CSS 12345678example-leave { opacity: 1; transition: opacity .5s ease-in;}.example-leave.example-leave-active { opacity: 0.01;} 動畫群組被需要被掛載才能執行為了套用這些過場特效到子元素中，ReactCSSTransitionGroup 必須要先被掛載到 DOM 中。下面是一個錯誤的示範，因為ReactCSSTransitionGroup 是隨著新的項目一起被掛載而無法生效，如果您把 ReactCSSTransitionGroup 包覆在子元素的外層則會出現奇怪的效果。比對上面一開始的範例就會明白了。 這小節要說明的觀念是: ReactCSSTransitionGroup 運作的方式是先安裝到 DOM 在賦予子元件這些效果。 有無 items 的動畫行為雖然上面的範例我們在 ReactCSSTransitionGroup 中渲染了列表，不過 ReactCSSTransitionGroup 的是允許沒有子元件的。意味著您可以移除到完全沒有項目，即渲染的 items 是空的。這個部分我們理解到 ReactCSSTransitionGroup 是針對單一元素在掛載或者卸載的時候套用動畫。同時也可以用在新元素取代舊元素的時候其行為為兩個元素同時播放動畫，舊的元素會先保留 DOM 等其動畫播放完畢。舉例來說，我們可以實作一個簡單圖片輪播的範例: 123456789101112131415161718/** @jsx React.DOM */var ReactCSSTransitionGroup = React.addons.CSSTransitionGroup;var ImageCarousel = React.createClass({ propTypes: { imageSrc: React.PropTypes.string.isRequired }, render: function() { return ( &lt;div&gt; &lt;ReactCSSTransitionGroup transitionName=&quot;carousel&quot;&gt; &lt;img src={this.props.imageSrc} key={this.props.imageSrc} /&gt; &lt;/ReactCSSTransitionGroup&gt; &lt;/div&gt; ); }}); 注意: 您必須替每一個在 ReactCSSTransitionGroup 中的子元素設定 key 的屬性，即使只有一個項目。這是 React 偵測判斷子元素狀態的方式(entered, left, stayed)。 這邊提供一段展示影片，即使我們只透過 this.state 去更新圖片的 src ，ReactCSSTransitionGroup 還是會再產生一個節點。 官方提供的範例只是概念上的說明，上面展示影片的範例程式碼如下: 1234567891011121314151617181920212223242526272829/** @jsx React.DOM */var ReactCSSTransitionGroup = React.addons.CSSTransitionGroup;var ImageCarousel = React.createClass({ propTypes: { imageSrc: React.PropTypes.string.isRequired }, getInitialState: function () { return {imageSrc: this.props.imageSrc} }, handleChangeImage: function () { console.log('changed'); this.setState({imageSrc: 'dist/images/1.jpg'}); }, render: function () { return ( &lt;div&gt; &lt;ReactCSSTransitionGroup transitionName=&quot;carousel&quot;&gt; &lt;img src={this.state.imageSrc} key={this.state.imageSrc} onClick={this.handleChangeImage}/&gt; &lt;/ReactCSSTransitionGroup&gt; &lt;/div&gt; ); }});React.renderComponent( &lt;ImageCarousel imageSrc='dist/images/0.jpg' /&gt;, document.getElementById('example')); 關閉動畫如果您想，您也可以取消 enter 或 leave 的動畫。有時候你的需求是只要物件出現時的動畫，但是最一開始的範例有提到如果沒有實作移除的動畫， ReactCSSTransitionGroup 會卡著 DOM 物件。您可以透過在 ReactCSSTransitionGroup 加入 transitionEnter={false} 或 transitionLeave={false} props 已關閉動畫效果。 123&lt;ReactCSSTransitionGroup transitionName='example' transitionLeave={false}&gt; {items}&lt;/ReactCSSTransitionGroup&gt; 注意: 使用 ReactCSSTransitionGroup 時，裡面的元件並沒辦法在過場或動畫結束後收到任何通知，也不能在動畫時期執行更多複雜的邏輯。如果您需要控制更多細節，您可以使用底層的 API ReactTransitionGroup API ，它一樣是透過提供 hooks 的方式讓您可以自訂效果。 底層 API: ReactTransitionGroupReactTransitionGroup 是動畫的基礎。當子元素被加入或移除(如上面範例)，會在一個特有的生命週期去呼叫它的 hooks。 componentWillEnter(callback)當元件被加入一個已存在的 TransitionGroup 這個事件被呼叫，而觸發時間跟 componentDidMount() 時一樣。它會中斷其他的動畫直到 callback 被執行。另外是他不會在初始化的時候被呼叫。 componentDidEnter()當上面的 callback 執行完畢之後接著會執行這個事件。 componentWillLeave(callback)當子元件已經被從 ReactTransitionGroup 移除的時候會執行這個事件，雖然子元件已經被移除了，但是 ReactTransitionGroup 還是會保留 DOM 直到 callback 被呼叫。 componentDidLeave()一樣的當 willLeave callback 被呼叫(時間點跟 componentWillUnmount 一樣)。 渲染一個不同元件預設 ReactTransitionGroup 會輸出一個 span 不過您是可以使用 component 屬性修改這個預設的行為 123&lt;ReactTransitionGroup component={React.DOM.ul}&gt; ...&lt;/ReactTransitionGroup&gt; 所有的 DOM 元件都在 React.DOM. 底下，然後 component 並不需要一定是 DOM 元件。這可以是任何您想要的 React 元件甚至是您開發的。","link":"/2014/09/13/reactjs-animation/"},{"title":"React 複製元件","text":"複製元件在少數的情況下，某個元件可能想要變更不屬於自己的 props(例如: 修改 this.props.children 的 className )。或者是複製多個被傳入的元件。cloneWithProps() 是這件事變的可能。 1ReactComponent React.addons.cloneWithProps(ReactComponent component, object? extraProps) 複製淺層的 component 然後合併 extraProps 。 Props 被使用和 transferPropsTo() 一樣的方式合併，所以類似像 className 屬性就會被整合進去。 注意: cloneWithProps 不會轉移 key 屬性至複製的元件中。如果您希望保存 key，請使用 extraProps 物件 1var clonedComponent = cloneWithProps(originalComponent, { key : originalComponent.props.key });","link":"/2014/09/15/reactjs-replication-components/"},{"title":"React 與 DOM 的差異","text":"DOM 的差異React 為了跨瀏覽器和提升效能的因素，實作一套和瀏覽器本身無關的 events 以及模擬 DOM 的機制。我們可以借由這個機制處理一些關於原始 DOM 設計上一些不足的地方。 所有的 DOM 屬性 Properties 和 Attributes (包含事件)都應該使用駝峰式命名 camelCased ，這和一般的 Javascrpt 程式碼風格一致。我們故意在這邊違背 html 規格 ，因此這和 html 規格是不同的。 style 屬性透過 Javascript 物件和駝峰式的屬性來設定，而不是 CSS 字串。所以設定 CSS 的語法風格會和 DOM, Javascrit 屬性一致，外加這麼做可以防止 XSS 攻擊。 所有在事件符合 W3C 規範，且所有事件(包含 submit)傳遞都遵照 W3C 規範，查閱 Event System 取得更多資訊。 關於 onChange 事件行為就跟你所期待的一樣，當一個表單欄位改變了，事件就會被觸發，而不是在 onblur 失去焦點的時候才觸發。 我們特意違背現有的瀏覽器行為，因為原始的 onChange 事件行為跟其名稱並不符合，React 需要正確的用到這個 Event ，當使用者輸入資料的同時 React 就會及時反應。查閱Forms得知更多資訊。 表單輸入的屬性例如 value checked 更多關於一些命名，用法，等請查閱 Forms","link":"/2014/09/14/reactjs-and-dom-differences/"},{"title":"React cloneWithProps 與實作 Tabs","text":"實作一個 Tabs 元件複合式(組合)元件在 React 中任何東西都是元件，就像樂高一樣，你可以用小片的積木組成大塊的，再組合出您想到的東西。同樣的道理您也可以用許多的小元件(小功能模組)來組合出您的應用程式。所謂的複合式元件或稱作組合元件，他其實就是由多個元件去組成一個多功能的大元件。 在這篇文章我們要來建立一個 tabs 標簽切換功能的元件，為了達成這個功能我們需要 4 個不同的元件:&lt;Tabs /&gt;, &lt;TabList /&gt;, &lt;Tab /&gt; 和 &lt;TabPanel /&gt; 分別用來呈現整個 tabs ， 列出 標簽列，標簽列的按鈕，以及顯示的內容。結構如下: 123456789101112131415161718&lt;Tabs&gt; &lt;TabList&gt; &lt;Tab&gt;Iron man&lt;/Tab&gt; &lt;Tab&gt;Superman&lt;/Tab&gt; &lt;Tab&gt;Lucy&lt;/Tab&gt; &lt;/TabList&gt; &lt;TabPanel&gt; 鋼鐵人介紹 &lt;/TabPanel&gt; &lt;TabPanel&gt; 超人介紹 &lt;/TabPanel&gt; &lt;TabPanel&gt; 鹿茸介紹 &lt;/TabPanel&gt;&lt;/Tabs&gt; 首先是 &lt;Tabs/&gt; 的行為，它被用來當做一個容器，其角色有點像是一個 controller ，因為它必須要掌管所有 DOM 的事件(點擊 Tab 切換至該內容，被選取到的 index)同時也需要管理 state 看看哪個 &lt;Tab/&gt; 目前正被選取到，所以我們會稱 &lt;Tabs /&gt; 為擁有者元件(owner component)。 我們遭遇到的第一個挑戰是: 元件之間該如何溝通。每一個元件都有一個 state 。每當 state 發生變動，React 就會更新並重新渲染元件以使其跟 state 一致。當我們選了某個索引後，&lt;Tabs/&gt; 元件就要去更新 &lt;Tab/&gt; 和 &lt;TabPanel/&gt; 的 state。 典範轉移首先我們為每一個元件建立一個 API，透過建立一個方法來變更 state。在 React 中一個元件可以透過 this.props.children 去存取子元件。所以一開始我們理論上只要使用 handleSelected 去設定適當該顯示的子元件如下: 12345var tabs = this.props.children[0].props.children, panels = this.props.children.slice(1), index = this.state.selectedIndex;tabs[index].handleSelected(true);panels[index].handleSelected(true); 這樣的做法在 v0.10.0 以前的版本是可以運作的，概略的實作如下: /** * @jsx React.DOM */ var Tab = React.createClass({ getInitialState: function () { return {selected: false} }, handleSelected: function (status) { this.setState({selected: status}); }, render: function () { var cx = React.addons.classSet; var classes = cx({ 'react-tab': true, 'active': this.state.selected }); return ( &lt;li className={classes}&gt; &lt;a href='#' data-index={this.props.index}&gt;{this.props.children}&lt;/a&gt; &lt;/li&gt; ); }}); var TabList = React.createClass({ render: function () { return ( &lt;ul className='react-tab-list'&gt; {this.props.children} &lt;/ul&gt; ); }}); var Tabs = React.createClass({ getInitialState: function () { return {selectedIndex: 0} }, componentDidMount: function () { var tabs = this.props.children[0].props.children, panels = this.props.children.slice(1), index = this.state.selectedIndex; for (i in tabs) { if (i == index) { tabs[i].handleSelected(true); panels[i].handleSelected(true); } else { tabs[i].handleSelected(false); panels[i].handleSelected(false); } } }, handleClick: function (e) { var index = parseInt(e.target.getAttribute('data-index')); var tabs = this.props.children[0].props.children, panels = this.props.children.slice(1); for (i in tabs) { if (i == index) { tabs[i].handleSelected(true); panels[i].handleSelected(true); } else { tabs[i].handleSelected(false); panels[i].handleSelected(false); } } }, render: function () { return ( &lt;div className='react-tabs' onClick={this.handleClick}&gt; {this.props.children} &lt;/div&gt; ); }}); var TabPanel = React.createClass({ getInitialState: function () { return {selected: false} }, handleSelected: function (status) { console.log(this.props.name + ' selected: ' + status); this.setState({selected: status}); }, render: function () { var cx = React.addons.classSet; var classes = cx({ 'react-tab-panel': true, 'active': this.state.selected }); return ( &lt;div className={classes}&gt; {this.props.children} &lt;/div&gt; ) }}); var App = React.createClass({ render: function () { return ( &lt;div className='container'&gt; &lt;Tabs&gt; &lt;TabList&gt; &lt;Tab name='ironman' index={0}&gt;Iron man&lt;/Tab&gt; &lt;Tab name='superman' index={1}&gt;Superman&lt;/Tab&gt; &lt;Tab name='lucy' index={2}&gt;Lucy&lt;/Tab&gt; &lt;/TabList&gt; &amp;lt;TabPanel name=&amp;#x27;panel-ironman&amp;#x27;&amp;gt; 鋼鐵人 &amp;lt;/TabPanel&amp;gt; &amp;lt;TabPanel name=&amp;#x27;panel-superman&amp;#x27;&amp;gt; 超人再起 &amp;lt;/TabPanel&amp;gt; &amp;lt;TabPanel name=&amp;#x27;panel-lucy&amp;#x27;&amp;gt; 露西 &amp;lt;/TabPanel&amp;gt; &amp;lt;/Tabs&amp;gt; &amp;lt;/div&amp;gt; ); }}); React.renderComponent( &lt;App /&gt;, document.getElementById('example')); See the Pen oitzv by AndyYou (@AndyYou) on CodePen. 不過到了 React v0.10.0 版本的時候這樣做會出現警告: 1Invalid access to component property &quot;setSelected&quot; 到了 v0.11.0 的時候更慘您已經無法直接存取子元件的方法，因為是新版的 React this.props.children 回傳的物件只是描述物件(discriptors)。不再是對應元件的參考物件，且官方建議您不應該直接存取子元件的實際物件。 Component RefsReact 提供一種機制給你取得實際元件的物件，就是使用 refs 1234567891011121314151617var App = React.createClass({ handleClick: function () { alert(this.refs.myInput.getDOMNode().value); }, render: function () { return ( &lt;div&gt; &lt;input ref=&quot;myInput&quot;/&gt; &lt;button onClick={this.handleClick}&gt; Submit &lt;/button&gt; &lt;/div&gt; ); }}); 透過 refs 屬性您就可以取得該子元件的參考 動態的子元件典型的 refs 使用方式是父元件已經知道子元件的情況，所以可以直接在 tag 中指定 ref 如上面的範例。不過這次我們希望我們的 Tabs 元件可以動態的放入 &lt;Tab/&gt; 和 &lt;TabPanel/&gt;例如: 123456789101112131415161718192021222324252627var App = React.createClass({ render: function () { return ( &lt;div className='container'&gt; &lt;Tabs&gt; &lt;TabList&gt; &lt;Tab name='ironman' &gt;Iron man&lt;/Tab&gt; &lt;Tab name='superman' &gt;Superman&lt;/Tab&gt; &lt;Tab name='lucy' &gt;Lucy&lt;/Tab&gt; &lt;/TabList&gt; &lt;TabPanel name='panel-ironman'&gt; 鋼鐵人 &lt;/TabPanel&gt; &lt;TabPanel name='panel-superman'&gt; 超人再起 &lt;/TabPanel&gt; &lt;TabPanel name='panel-lucy'&gt; 露西 &lt;/TabPanel&gt; &lt;/Tabs&gt; &lt;/div&gt; ); }}); 而 Tabs 只是動態地把開發者加入的任意結構輸出 123456789var Tabs = React.createClass({ render: function () { return ( &lt;div className='react-tabs'&gt; {this.props.children} &lt;/div&gt; ); }}); 因此我們需要一些動態指定 refs 的方法，而這個方法就是透過 cloneWithProps 12345678910111213141516var App = React.createClass({ render: function () { var index = 0, children = React.Children.map(this.props.children, function (child) { return React.addons.cloneWithProps(child, { ref: 'child-' + (index++) }); }); return ( &lt;div&gt; {children} &lt;/div&gt; ); }});","link":"/2014/09/16/reactjs-clonewithprops-and-implemented-tabs/"},{"title":"React 單元測試","text":"單元測試React.addons.TestUtils 讓您可以在您的測試框架中更簡單的測試您的元件(官方使用 Jest)。簡單的來說它是一系列輔助的方法以協助您測試 React 元件。 Simulate (模擬方法)1Simulate.{eventName}(DOMElement element, object eventData) 模擬一個 DOM 的事件調派，其中可以包含一個 eventData。這可能是在 ReactTestUtils 最有用的一個工具。 使用方式的範例: 1234var node = this.refs.input.getDOMNode();React.addons.TestUtils.Simulate.click(node);React.addons.TestUtils.Simulate.change(node);React.addons.TestUtils.Simulate.keyDown(node, {key: &quot;Enter&quot;}); 下面開始使用統一的格式來簡易說明每個方法的格式 1回傳的物件型別 方法名稱(參數型別 參數名稱) renderIntoDocument1ReactComponent renderIntoDocument(ReactComponent instance) 輸出一個元件到 document 獨立的 DOM 節點(div)去。如下面舉例的一小段測試範例: 123456789101112describe(&quot;Label Test&quot;,function(){ beforeEach(function() { ReactTestUtils = React.addons.ReactTestUtils; }); it(&quot;Check Text Assignment&quot;, function () { var label = &lt;Label&gt;Some Text We Need for Test&lt;/Label&gt;; ReactTestUtils.renderIntoDocument(label); expect(label.refs.p).toBeDefined(); expect(label.refs.p.props.children).toBe(&quot;Some Text We Need for Test&quot;) });}); 觀察原始碼: 12345renderIntoDocument: function(instance) { var div = document.createElement('div'); // 我們的測試並不需要附加到網頁中的某個 DOM 元素時使用: return React.renderComponent(instance, div);} mockComponent1object mockComponent(function componentClass, string? tagName) 模擬元件，顧名思義透過傳入一個模擬的元件模組到這個方法中以快速製作一個”假”元件，取代本來用 render 的方式。讓我們來查看原始碼好理解官方簡短的說明: 1234567891011mockComponent: function(module, mockTagName) { var ConvenienceConstructor = React.createClass({ render: function() { var mockTagName = mockTagName || module.mockTagName || &quot;div&quot;; return ReactDOM[mockTagName](null, this.props.children); } }); copyProperties(module, ConvenienceConstructor); module.mockImplementation(ConvenienceConstructor); return this;} isDescriptorOfType1boolean isDescriptorOfType(ReactDescriptor descriptor, function componentClass) 當 discriptor 物件符合該元件類別時回傳 true。 關於 descriptors我們提過 React 是透過一套虛擬 DOM 的機制，並不是直接操作 DOM 元素，在 v0.10 版之前 React 回傳給你的物件都是這個 discriptor (描速物件) 它和 React 內部操作的元件是指向同一個參考。 更多關於 discriptor 機制 isDOMComponent1boolean isDOMComponent(ReactComponent instance) 如果物件是 DOM 元件 (例如: &lt;div&gt;, &lt;span&gt;)就回傳 true。 isCompositeComponent1boolean isCompositeComponent(ReactComponent instance) 判斷是否為復合式元件(即用 React.createClass())。 isCompositeComponentWithType1boolean isCompositeComponentWithType(ReactComponent instance, function componentClass) 結合 isComponentOfType() 和 isCompositeComponent()。 isTextComponent1boolean isTextComponent(ReactComponent instance) 如果物件是一個純文字元件就回傳 true。 findAllInRenderedTree1array findAllInRenderedTree(ReactComponent tree, function test) 遍歷所有在結構中的元件，並使用傳入的 test()。當 test(component) 為 true 就把該元件加入陣列。很少機會會單純使用這個方法，它通常用來對 React 的原生物件做其他的單元測試。 scryRenderedDOMComponentsWithClass1array scryRenderedDOMComponentsWithClass(ReactComponent tree, string className) 找出在已輸出的 DOM 元件中跟 tagName 一致的物件。 findRenderedDOMComponentWithTag1ReactComponent findRenderedDOMComponentWithTag(ReactComponent tree, string tagName) 類似 scryRenderedDOMComponentsWithClass() 不過一定要回傳一個結果，如果沒有或其他數量就例外。 scryRenderedDOMComponentsWithTag1array scryRenderedDOMComponentsWithTag(ReactComponent tree, string tagName) 找出所有在已輸出樹狀結構中符合 tagName 的元件，並傳回一個陣列。 findRenderedDOMComponentWithTag1ReactComponent findRenderedDOMComponentWithTag(ReactComponent tree, string tagName) 類似 scryRenderedDOMComponentsWithTag() ，不過一定要回傳一個結果，如果沒有或其他數量就例外。 scryRenderedComponentsWithType1array scryRenderedComponentsWithType(ReactComponent tree, function componentClass) 找出在樹狀結構中所有跟 componentClass 型別一致的元件。 findRenderedComponentWithType1ReactComponent findRenderedComponentWithType(ReactComponent tree, function componentClass) 跟 scryRenderedComponentsWithType() 一樣，不過一定要回傳一個結果，如果沒有或其他數量就例外。","link":"/2014/09/15/reactjs-unit-tests/"},{"title":"在 CodePen 中使用 React","text":"在 codepen.io 上使用 React為了能夠在 CodePen 上使用 React 和 JSX 您必須要: 加入這支 script 到 CodePen http://codepen.io/chriscoyier/pen/yIgqi.js React: http://fb.me/react-0.11.1.js JSX Transformer: http://fb.me/JSXTransformer-0.11.0.js 緣由React 是一個由 Facebook 團隊所提供的一組 Javascript 函式庫。當您開始使用 CodePen 撰寫一些 React 範例時會發現 CodePen 無法正常運作。這是因為當您在 Javascript 區塊輸入程式碼時，他其實只是在您的文件上加上一個&lt;script&gt; 標簽且並沒有定義任何 type 。所以當您想使用 CodePen 轉寫一些小範例時您有幾種選擇: 不使用 JSX，使用類似像 React.DOM.div 之類的原生 JS 取代 將 JS 寫在 html 區塊，並且使用 &lt;script type='text/jsx'&gt; 使用上述的方式加入一段 script 關於上面這一小段程式碼是由Mark Funk所提出的一個解法。 1234567891011121314(function() { function runScripts() { var bodyScripts = 'body script:not([src])'; Array.prototype.forEach.call(document.querySelectorAll(bodyScripts), function setJSXType(element) { element.setAttribute('type', 'text/jsx'); }); }; if (window.addEventListener) { window.addEventListener('DOMContentLoaded', runScripts, false); } else { window.attachEvent('onload', runScripts); }})(); 簡單來說這段程式碼會尋找 CodePen 放置到預覽中的 script 標簽並且加入 type 。附帶一提的是，JSX Transformer 是用來協助您方便開發的並不適用于發佈的產品上。最後，當您發生錯誤時請檢查您瀏覽器的 console，JSX Transformer 會很貼心的提示您錯誤訊息。","link":"/2014/09/16/reactjs-used-in-the-codepen-react/"},{"title":"React classSet 方法","text":"操作樣式名稱(Class)classSet() 是一個協助您快速操作 DOM 裏 class 字串的工具。這裡有一些常見的情況，當沒有使用 classSet() 的時候: 12345678910111213141516171819202122/** * @jsx React.DOM */var ClassSet = React.createClass({ render: function () { var classString = 'message'; if (this.props.isImportant) { classString += ' message-important'; } if (this.props.isRead) { classString += ' message-read'; } return ( &lt;div className={classString}&gt;Great, I'll be there&lt;/div&gt; ) }});React.renderComponent( &lt;ClassSet isRead='1' isImportant='1' /&gt;, document.getElementById('example')) 你可能因為一些 CSS Class 設定的問題而開始組合字串，但很顯然的這是個很無聊瑣碎的工作。而且這種做法程式碼很難閱讀且易出錯。這個時候 classSet() 可以幫你解決這個問題。 123456789101112131415161718192021/** * @jsx React.DOM */var ClassSet = React.createClass({ render: function () { var cx = React.addons.classSet; var classes = cx({ 'message': true, 'message-important': this.props.isImportant, 'message-read': this.props.isRead }) return ( &lt;div className={classes}&gt;Great, I'll be there&lt;/div&gt; ) }});React.renderComponent( &lt;ClassSet isRead='1' isImportant='1' /&gt;, document.getElementById('example')) 其他補充事項:只要看到程式中使用了 React.addons.*， React 記得使用 react-with-addons 的版本，另外有些屬性名稱因為跟程式關鍵字衝突會有變更，這裡的 class 就變成 className，另外一個常遇到的是 for 要改成 htmlFor。 12345678return ( &lt;div className={classes}&gt; &lt;label htmlFor='boy'&gt;Boy&lt;/label&gt; &lt;input type='radio' id='boy' name='sex'/&gt; &lt;label htmlFor='girl'&gt;Girl&lt;/label&gt; &lt;input type='radio' id='girl' name='sex'/&gt; &lt;/div&gt;) 當我們使用 classSet() 時，我們傳入一個物件，其中的 key 屬性名稱就是 CSS class 樣式。當它設成 Truthy values 的時候就表示要套用，這個樣式名稱會自動加入串接的字串中。 Truthy values 指的是只要 Javascript 判斷為真即可，並不是一定要 true，舉例來說 1, string, Object 都是 Truthy values 。 不要再使用串字串的方式了！","link":"/2014/09/14/reactjs-classset-method/"},{"title":"React 不變性的輔助函式","text":"不變性的輔助函式(Immutability Helpers)在一開始我們必須先對這文鄒鄒的術語做個解釋: 所謂的 Immutability 英文的意思就是不能夠或不輕易受外界影響而改變。而在程式領域中我們舉的例子來說明: 即當資料或物件建立之後就不能或者輕易改變。以 C# 來說明就是 Array 和 List 的關係，Object-C 的 NSArray 和 NSMutableArray 對應的關係。 React 允許您使用任何方式來管理資料，包含可變性，或不變性的資料或物件。然而如果您能夠在一些影響效能關鍵的地方使用不變性的資料且判斷是否要執行更新，將會有助您提升效能。通常使用 shouldComponentUpdate() 搭配靜態資料能有效的提升程式的執行效率。 shouldComponentUpdate() 被調用在 props 或 state 收到新值後 render() 之前，如果回傳 true 就更新， false 就不動。 在原生 Javascript 中處理不變性資料比起其他中介語言更加困難例如: Clojure。好消息是官方提供了我們一個方便的輔助函式update()，它可以協助我們處理這類的資料。 在這邊我們補上一個實作範例: 12345678910111213141516171819202122232425262728293031323334353637/** * @jsx React.DOM */var Car = React.createClass({ getInitialState: function () { return { wheel: 4 } }, getDefaultProps: function () { return { brand: {name: 'Toyota'} } }, handleClick: function () { this.setProps({brand: {name: 'Audi'}}); // this.setState({wheel: 1}); /* 只要改變 props 或 state 都會觸發 shouldComponentUpdate */ }, shouldComponentUpdate: function (nextProp) { console.log(this.props.brand); console.log(nextProp.brand); console.log(this.props.brand === nextProp.brand) return true; }, render: function () { return ( &lt;div onClick={this.handleClick}&gt; {this.props.brand.name} &lt;/div&gt; ) }});React.renderComponent( &lt;Car /&gt;, document.getElementById('example')); 主要的概念舉例來說如果您的資料是這樣: 123myData.x.y.z = 7;// 或者...myData.a.b.push(9); // { a: { b: [ 9 ] } } 由於上一次的物件或資料已經被覆蓋了，您沒有辦法知道哪些資料發生變更。於是，您需要建立一個新的 myData 副本，只改需要改的地方。實務上您應該常常會使用 === 在 shouldComponentUpdate() 去比對新舊物件/資料。下面我們繼續回到資料處理的部分即上面實作範例 handleClick 那邊 123var newData = deepCopy(myData);newData.x.y.z = 7;newData.a.b.push(9); 不幸的是，如果真的複製每一個環節那肯定多做很多不必要的操作，效能自然不好，而且有些狀況下不容易做到。我們的確可以透過另一種方式: 只複製那些我們要改變的物件，保留那些沒變的物件。不過這在今天的 Javascript 非常麻煩 123456var newData = extend(myData, { x: extend(myData.x, { y: extend(myData.x.y, {z: 7}), }), a: extend(myData.a, {b: myData.a.b.concat(9)})}); 上面這段虛擬碼大略跟您使用 Underscore extend 方法意思相同: http://underscorejs.org/#extend看起來上面這種做法的效能會很不錯(因為他只有淺層複製了 log n 個物件，其他的沿用)。不過這麼做其實很痛苦，因為格式看起來是不斷重複一樣的東西。這樣不止很煩，而且很容易出 bug。 update() 提供了另一種簡單的語法糖衣將這個模式從新包裝，使其看起來清楚一些，我們的程式碼將會是如下: 1234var newData = React.addons.update(myData, { x: {y: {z: {$set: 7}}}, a: {b: {$push: [9]}}}); 雖然語法還是有一點點複雜，需要一點時間適應的(這種寫法的靈感來自 MongoDB 查詢語法)。這樣的做法沒有太多多餘重複的程式碼。關於 $ 前綴字這邊稱之為指令，而要改變的資料結構稱為目標。 指令列表 {$push: array} push() 所有項目至陣列 {$unshift: array} unshift() 就是插入所有項目到陣列 {$splice: array of arrays} 使每個陣列呼叫 splice() {$set: any} 完整取代資料 {$merge: object} 合併物件 {$apply: function} 傳入目前值到函式並取得新值 範例簡易的使用 push12var initialArray = [1, 2, 3];var newArray = update(initialArray, {$push: [4]}); // =&gt; [1, 2, 3, 4] 巢狀集合123var collection = [1, 2, {a: [12, 17, 15]}];var newCollection = update(collection, {2: {a: {$splice: [[1, 1, 13, 14]]}}});// =&gt; [1, 2, {a: [12, 13, 14, 15]}] 存取集合中索引為 2 ，然後底下的 a 物件執行 splice() 函式，前兩個參數分別是起始索引，第二個參數是要取代幾個元素，後面則是要加入的元素 13, 14 。 使用 function 來更新值12345678910var obj = {a: 5, b: 3};var newObj = update(obj, {b: {$apply: function(x) {return x * 2;}}});// =&gt; {a: 5, b: 6}// This is equivalent, but gets verbose for deeply nested collections:var newObj2 = update(obj, {b: {$set: obj.b * 2}});```### 淺層合併```jsvar obj = {a: 5, b: 3};var newObj = update(obj, {$merge: {b: 6, c: 7}}); // =&gt; {a: 5, b: 6, c: 7} 補充- 關於淺層複製與深層複製(Shallow copies v.s. Deep copies)淺層複製盡可能的只複製少量資訊，一個集合的淺層複製只複製結構，不複製元素，當您使用淺層複製意味著兩個物件共同參考到同一個元素記憶體位置的意思。而深層複製，複製了所有東西，簡單說就是真的把所有東西複製一份。","link":"/2014/09/18/reactjs-the-invariance-of-the-auxiliary-function/"},{"title":"理解 Function.prototype.bind","text":"前言自從 2013 年 Reactjs 開放原始碼後就被其單純的架構和理念所吸引。但由於沒有迫切的需求一直沒有將其使用于產品中。且在當時 Angular 正流行，大部份的人都被 two-way binding 神奇簡練的寫法給嚇傻了，相較之下在第一眼看到 Reactjs 其給人的感受為: 怎麼好像要多打很多 Code 啊!?而在 2014 因為 Facebook 提出 Flux 與 Jest 等東西的使我決定認真的研究一下並將其使用在產品上。但由於 React 相關文章大多很散且中文文章不多，所以接下來的 30 天我將逐步根據官網教學與一些國內外高手的文章心得，佐以實作驗證後，記錄為此系列文章。 準備關於第一個部分，我打算會列出一些網路資源與一點點使用 React 時重要的 Javascript 觀念。 理解 Javascript 的 Function.prototype.bind大部分 Javascript 的介紹您都可以輕易的在網站上找到，不過在學習過程中我覺得特別需要提到的是關於 bind() 的用法，因為在 React 中其實蠻容易遇到的，所以一開始我希望針對這部分做個簡單的介紹。第二天開始我們將從 Getting Started 逐步介紹。 Function.prototype.bind 函式繫結大概是當您開始學習 Javascript 時最後關注到的議題。通常是當您遇到一種狀況：需要在其他 Function 保留 this 的執行環境(Context)。講執行環境可能太抽象，舉例來說就是當您需要在函式的另外一個函式中呼叫 this.action() 的時候。(這邊如果看不懂請耐著性子看下去)不過通常這時您可能也不知道您需要的就是 Function.prototype.bind()。 第一次您遇到上述的問題，您可能會傾向于把 this 儲存成一個變數，接著即便您切換了 Context 還是可以參考到這個物件。如果您看不懂上面在說什麼，請先參考這篇文章。許多人會採用 self, _this 或者 context 當作變數名稱，並且把 this 放進去。這些方法都是可行的且並沒有什麼不妥，但有一個更不錯的方式。 我們實際上要解決的問題是？下面有一份簡單的範例程式碼，情況是某人忘記把 Context 存成一個變數： 123456789101112131415161718192021222324252627282930313233343536/** * 我們舉例一個機器人物件，機器人有一些基本的 function 來執行動作 * 不過問題是當我們要求機器人執行動作的時候，他需要先到確定還有沒有能量。 * * * Note: 這段程式碼只是希望能夠用具像化一點的比喻來說明。 */var Robot = { /** private */ power: 100, walk: function () { console.log('Robot walked'); this.power -= 10; }, fly: function () { console.log('Robot flied'); this.power -= 20; }, check: function (excute) { if (this.power &gt; 0) excute(); }, /** public */ showoff: function () { this.check(function () { this.walk(); /* 實際執行的動作。 */ this.fly(); }) }}Robot.showoff(); 如果照著上面把實際要執行的動作當作 callback 傳給 check()，當您要再次呼叫 this.walk() 的時候就會發現出現錯誤訊息 1TypeError: Object #&lt;Object&gt; has no method 'walk' 這是因為我們再次傳進去的匿名函式不知道關於 this 的東西，在這裏我們並沒有善用閉包來保存 Context。而對很多人可能就會把上面的範例修改為如下 123456789101112131415161718192021222324252627282930var Robot = { /** private */ power: 100, walk: function () { console.log('Robot walked'); this.power -= 10; }, fly: function () { console.log('Robot flied'); this.power -= 20; }, check: function (excute) { if (this.power &gt; 0) excute(); }, /** public */ showoff: function () { var that = this; this.check(function () { that.walk(); /* 實際執行的動作。 */ that.fly(); }) }}Robot.showoff(); 宣告成區域變數之後，閉包就會幫助我們 Keep 這個 Context，這也是相對直覺的方式，同上面說的這沒有任何不妥。不過我們知道了一件事，就是我們需要保存 Robot 這個物件參考的 Context，給 Callback 即範例中的 excute。當我們呼叫 that.walk() 的時候其實就是在使用閉包。根據 MDN 說明，其實閉包就是一個特殊的物件，它有兩個含義： 它是一個 function。 它產生了一個 Context ，概略的說就是幫你記錄上一層有宣告的變數。 這裏就不詳細說明關於閉包，不理解的推薦這篇文章和這篇 閉包的方式已經可以運作了，但是我們覺得他不夠漂亮，因此我們就來使用 Function.prototype.bind()。 讓我們來重構上面的程式範例 123456789101112131415161718192021222324252627282930var Robot = { /** private */ power: 100, walk: function () { console.log('Robot walked'); this.power -= 10; }, fly: function () { console.log('Robot flied'); this.power -= 20; }, check: function (excute) { if (this.power &gt; 0) excute(); }, /** public */ showoff: function () { // var that = this; this.check(function () { this.walk(); this.fly(); }.bind(this)); }}Robot.showoff(); 我們剛剛做了什麼？？當我們呼叫了 .bind() 的時候，其實它非常單純的建立了一個新的 function，只不過這個 function 把 this 的值綁定進去。所以我們同時把我們想要的 Context(即 Robot 物件) 給保存了下來。接著當我們的回呼函式在執行的時候 this 就是參考到 Robot 這個物件。 如果你有興趣了解 Function.prototype.bind() 內部運行機制，他看起來大概就像下面這樣 123456Function.prototype.bind = function (scope) { var fn = this; return function () { return fn.apply(scope); };} 接著我們再來看看一個非常簡單的案例： 12345678910111213var foo = { x: 3}var bar = function () { console.log(this.x);}bar(); // undefinedvar boundFunc = bar.bind(foo);boundFunc(); // 3 這個範例是說，bind() 幫我們建立了一個新的 function ，並且當我們執行時這個 function 的 this 是指向 foo，而不是全域。如果您還是不清楚可以大略理解為：把 function 掛到某個物件底下(當然不是真的加進去)，只是這樣一來可以透過 this 取得該物件的 Context。 實務應用當我們學習某些東西時，我不只需要理解觀念，也會試著將其套用在實務上以驗證自己是否明白。來看看一些實務上的應用吧！ Click 事件處理其中一個用途是拿它來追蹤點擊次數，然後可能是要把它存在某個物件裡類似下面這樣 1234567var logger = { x: 0, increment: function () { this.x++; console.log(this.x); }} 然後指派一個按鈕的 Click 處理函式去呼叫 logger 物件 123document.querySelector('button').addEventListener('click', function () { logger.increment();}); 不過上面這種做法，我們已經建立了一個不必要的匿名函式，並且因為這個匿名函式使用了 logger 呼叫了 increment() 所以產生了一個閉包用以確保了 this 是正確的參考物件。不明白！？再看看下面這個最根本的寫法吧 1document.querySelector('button').addEventListener('click', logger.increment); // NaN 原本是這樣的，當你 Click 的時候執行一個 function ，不過如果你用上面這種寫法的話，意思是你只是把 function 傳進去，根據 this 的定義他其實是指的是誰(哪個物件)呼叫這個函式 this 就是指向它。而這裡呼叫的人根本不是 logger 這個物件。也因此使用了一個匿名函式，建立了一個閉包，就是為了保留住 logger 物件的狀態。 好了！講完上面這些我們來看看更乾淨的寫法： 1document.querySelector('button').addEventListener('click', logger.increment.bind(logger)); 現在，對於 bind() 應該比較不陌生了吧！因為在 React 中蠻多機會的使用 bind()。如官方的範例 123456789101112componentDidMount: function() { $.ajax({ url: this.props.url, dataType: 'json', success: function(data) { this.setState({data: data}); }.bind(this), error: function(xhr, status, err) { console.error(this.props.url, status, err.toString()); }.bind(this) });} 資源列表官方網站React.NETSebastian GistReactJS.tw 台灣粉絲團React揭秘React Components","link":"/2014/09/16/reactjs-reactjs-day-1-introduction-and-understanding-functionprototypebind/"},{"title":"React 實作一個 Tabs 元件","text":"實作一個 Tabs 元件複合式(組合)元件在 React 中任何東西都是元件，就像樂高一樣，你可以用小片的積木組成大塊的，再組合出您想到的東西。同樣的道理您也可以用許多的小元件(小功能模組)來組合出您的應用程式。所謂的複合式元件或稱作組合元件，他其實就是由多個元件去組成一個多功能的大元件。 在這篇文章我們要來建立一個 tabs 標簽切換功能的元件，為了達成這個功能我們需要 4 個不同的元件:&lt;Tabs /&gt;, &lt;TabList /&gt;, &lt;Tab /&gt; 和 &lt;TabPanel /&gt; 分別用來呈現整個 tabs ， 列出 標簽列，標簽列的按鈕，以及顯示的內容。結構如下: 123456789101112131415161718&lt;Tabs&gt; &lt;TabList&gt; &lt;Tab&gt;Iron man&lt;/Tab&gt; &lt;Tab&gt;Superman&lt;/Tab&gt; &lt;Tab&gt;Lucy&lt;/Tab&gt; &lt;/TabList&gt; &lt;TabPanel&gt; 鋼鐵人介紹 &lt;/TabPanel&gt; &lt;TabPanel&gt; 超人介紹 &lt;/TabPanel&gt; &lt;TabPanel&gt; 鹿茸介紹 &lt;/TabPanel&gt;&lt;/Tabs&gt; 首先是 &lt;Tabs/&gt; 的行為，它被用來當做一個容器，其角色有點像是一個 controller ，因為它必須要掌管所有 DOM 的事件(點擊 Tab 切換至該內容，被選取到的 index)同時也需要管理 state 看看哪個 &lt;Tab/&gt; 目前正被選取到，所以我們會稱 &lt;Tabs /&gt; 為擁有者元件(owner component)。 我們遭遇到的第一個挑戰是: 元件之間該如何溝通。每一個元件都有一個 state 。每當 state 發生變動，React 就會更新並重新渲染元件以使其跟 state 一致。當我們選了某個索引後，&lt;Tabs/&gt; 元件就要去更新 &lt;Tab/&gt; 和 &lt;TabPanel/&gt; 的 state。 典範轉移首先我們為每一個元件建立一個 API，透過建立一個方法來變更 state。在 React 中一個元件可以透過 this.props.children 去存取子元件。所以一開始我們理論上只要使用 handleSelected 去設定適當該顯示的子元件如下: 12345var tabs = this.props.children[0].props.children, panels = this.props.children.slice(1), index = this.state.selectedIndex;tabs[index].handleSelected(true);panels[index].handleSelected(true); 這樣的做法在 v0.10.0 以前的版本是可以運作的，概略的實作如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132&lt;div data-height=&quot;268&quot; data-theme-id=&quot;8540&quot; data-slug-hash=&quot;oitzv&quot; data-default-tab=&quot;js&quot; data-user=&quot;AndyYou&quot; class='codepen'&gt;&lt;pre&gt;&lt;code&gt;/** * @jsx React.DOM */var Tab = React.createClass({ getInitialState: function () { return {selected: false} }, handleSelected: function (status) { this.setState({selected: status}); }, render: function () { var cx = React.addons.classSet; var classes = cx({ &amp;#x27;react-tab&amp;#x27;: true, &amp;#x27;active&amp;#x27;: this.state.selected }); return ( &amp;lt;li className={classes}&amp;gt; &amp;lt;a href=&amp;#x27;#&amp;#x27; data-index={this.props.index}&amp;gt;{this.props.children}&amp;lt;/a&amp;gt; &amp;lt;/li&amp;gt; ); }});var TabList = React.createClass({ render: function () { return ( &amp;lt;ul className=&amp;#x27;react-tab-list&amp;#x27;&amp;gt; {this.props.children} &amp;lt;/ul&amp;gt; ); }});var Tabs = React.createClass({ getInitialState: function () { return {selectedIndex: 0} }, componentDidMount: function () { var tabs = this.props.children[0].props.children, panels = this.props.children.slice(1), index = this.state.selectedIndex; for (i in tabs) { if (i == index) { tabs[i].handleSelected(true); panels[i].handleSelected(true); } else { tabs[i].handleSelected(false); panels[i].handleSelected(false); } } }, handleClick: function (e) { var index = parseInt(e.target.getAttribute(&amp;#x27;data-index&amp;#x27;)); var tabs = this.props.children[0].props.children, panels = this.props.children.slice(1); for (i in tabs) { if (i == index) { tabs[i].handleSelected(true); panels[i].handleSelected(true); } else { tabs[i].handleSelected(false); panels[i].handleSelected(false); } } }, render: function () { return ( &amp;lt;div className=&amp;#x27;react-tabs&amp;#x27; onClick={this.handleClick}&amp;gt; {this.props.children} &amp;lt;/div&amp;gt; ); }});var TabPanel = React.createClass({ getInitialState: function () { return {selected: false} }, handleSelected: function (status) { console.log(this.props.name + &amp;#x27; selected: &amp;#x27; + status); this.setState({selected: status}); }, render: function () { var cx = React.addons.classSet; var classes = cx({ &amp;#x27;react-tab-panel&amp;#x27;: true, &amp;#x27;active&amp;#x27;: this.state.selected }); return ( &amp;lt;div className={classes}&amp;gt; {this.props.children} &amp;lt;/div&amp;gt; ) }});var App = React.createClass({ render: function () { return ( &amp;lt;div className=&amp;#x27;container&amp;#x27;&amp;gt; &amp;lt;Tabs&amp;gt; &amp;lt;TabList&amp;gt; &amp;lt;Tab name=&amp;#x27;ironman&amp;#x27; index={0}&amp;gt;Iron man&amp;lt;/Tab&amp;gt; &amp;lt;Tab name=&amp;#x27;superman&amp;#x27; index={1}&amp;gt;Superman&amp;lt;/Tab&amp;gt; &amp;lt;Tab name=&amp;#x27;lucy&amp;#x27; index={2}&amp;gt;Lucy&amp;lt;/Tab&amp;gt; &amp;lt;/TabList&amp;gt; &amp;lt;TabPanel name=&amp;#x27;panel-ironman&amp;#x27;&amp;gt; 鋼鐵人 &amp;lt;/TabPanel&amp;gt; &amp;lt;TabPanel name=&amp;#x27;panel-superman&amp;#x27;&amp;gt; 超人再起 &amp;lt;/TabPanel&amp;gt; &amp;lt;TabPanel name=&amp;#x27;panel-lucy&amp;#x27;&amp;gt; 露西 &amp;lt;/TabPanel&amp;gt; &amp;lt;/Tabs&amp;gt; &amp;lt;/div&amp;gt; ); }});React.renderComponent( &lt;App /&gt;, document.getElementById(&quot;example&quot;)); See the Pen oitzv by AndyYou (@AndyYou) on CodePen. 不過到了 React v0.10.0 版本的時候這樣做會出現警告: 1Invalid access to component property &quot;setSelected&quot; 到了 v0.11.0 的時候更慘您已經無法直接存取子元件的方法，因為是新版的 React this.props.children 回傳的物件只是描述物件(discriptors)。不再是對應元件的參考物件，且官方建議您不應該直接存取子元件的實際物件。 Component RefsReact 提供一種機制給你取得實際元件的物件，就是使用 refs 1234567891011121314151617var App = React.createClass({ handleClick: function () { alert(this.refs.myInput.getDOMNode().value); }, render: function () { return ( &lt;div&gt; &lt;input ref=&quot;myInput&quot;/&gt; &lt;button onClick={this.handleClick}&gt; Submit &lt;/button&gt; &lt;/div&gt; ); }}); 透過 refs 屬性您就可以取得該子元件的參考 動態的子元件典型的 refs 使用方式是父元件已經知道子元件的情況，所以可以直接在 tag 中指定 ref 如上面的範例。不過這次我們希望我們的 Tabs 元件可以動態的放入 &lt;Tab/&gt; 和 &lt;TabPanel/&gt;例如: 123456789101112131415161718192021222324252627var App = React.createClass({ render: function () { return ( &lt;div className='container'&gt; &lt;Tabs&gt; &lt;TabList&gt; &lt;Tab name='ironman' &gt;Iron man&lt;/Tab&gt; &lt;Tab name='superman' &gt;Superman&lt;/Tab&gt; &lt;Tab name='lucy' &gt;Lucy&lt;/Tab&gt; &lt;/TabList&gt; &lt;TabPanel name='panel-ironman'&gt; 鋼鐵人 &lt;/TabPanel&gt; &lt;TabPanel name='panel-superman'&gt; 超人再起 &lt;/TabPanel&gt; &lt;TabPanel name='panel-lucy'&gt; 露西 &lt;/TabPanel&gt; &lt;/Tabs&gt; &lt;/div&gt; ); }}); 而 Tabs 只是動態地把開發者加入的任意結構輸出 123456789var Tabs = React.createClass({ render: function () { return ( &lt;div className='react-tabs'&gt; {this.props.children} &lt;/div&gt; ); }}); 因此我們需要一些動態指定 refs 的方法，而這個方法就是透過 cloneWithProps 12345678910111213141516var App = React.createClass({ render: function () { var index = 0, children = React.Children.map(this.props.children, function (child) { return React.addons.cloneWithProps(child, { ref: 'child-' + (index++) }); }); return ( &lt;div&gt; {children} &lt;/div&gt; ); }});","link":"/2014/10/07/reactjs-implemented-a-tabs-component/"},{"title":"React PureRenderMixin","text":"PureRenderMixin如果您的 React 元件的 render 函式非常單純(相對來說，就只是單純想把 props 和 state 輸出)，您就可以使用 PureRenderMixin 來提升效能: 12345678var PureRenderMixin = require('react').addons.PureRenderMixin;React.createClass({ mixins: [PureRenderMixin], render: function() { return &lt;div className={this.props.className}&gt;foo&lt;/div&gt;; }}); 內部的 mixin 幫您實作了 shouldComponentUpdate ，他會幫您比對 props 與 state ，只要一樣就回傳 false。協助您快速提升一些效能: 1234567891011121314151617181920212223/** * @jsx React.DOM */var PureRenderMixin = React.addons.PureRenderMixin;var iPhone = React.createClass({ mixins: [PureRenderMixin], getDefaultProps: function () { return {className: 'red'} }, handleClick: function () { this.setProps({className: 'blue'}); console.log('excute handle click'); }, render: function() { console.log('I am rendering now...'); return &lt;div className={this.props.className} onClick={this.handleClick}&gt;foo&lt;/div&gt;; }});React.renderComponent( &lt;iPhone /&gt;, document.getElementById('example')) 注意:關於比對方面，React 只為您執行淺層的比對。意思是如果您的資料結構非常複雜可能 shouldComponentUpdate() 可能永遠判斷兩個物件為 true，因為他只做淺層比對，有可能是只比較參考。 所以建議您使用單純屬性和狀態或使用強制更新 forceUpdate() 當你知道這個資料結構太複雜的時候。 此外，shouldComponentUpdate 會略過子元件的更新，所以請確保所有的東西是真的很單純！","link":"/2014/09/18/reactjs-purerendermixin/"},{"title":"React 大解密","text":"React 揭秘關於這篇文章將會試著解釋關於 React 核心的概念。 鳥瞰架構在傳統的網頁應用程式中，我們如果要增加互動性時勢必廣泛的操作 DOM 元素，一般來說現在最普遍的技術是使用 jQuery:上圖我們故意讓 DOM 示意為紅色這是因為操作更新 DOM 是需要付出昂貴的代價，也意味著這很吃效能。很多時候我們會使用 Model 來記錄關於 APP 狀態，不過通常我們最後目標是必須要將狀態呈現給使用者，所以我們必須自己實作這些細節。這已經是我們很稀鬆平常的開發模式。 而 React 的主要目標就是提供一種不同且更有效率的方式去執行關於操作更新 DOM 這個部分，最終這個方式會取代我們直接操作 DOM 的方法。React 使用的方式是透過建立一套虛擬 DOM 的機制，React 幫你處理關於操作 DOM 方面的事情。 為什麼多引進一層架構會讓效能增加? 如果在其架構之上多引入一層可以提升速度，這不是暗示瀏覽器並沒有實作最佳的 DOM 操作方式。這也意味著虛擬 DOM 有著跟實際 DOM 不同的語義和行為。值得關注的是當我們改變虛擬 DOM 時並不能保證立即得到效果。也因為這個機制導致 React 在實際接觸 DOM 之前必須要等待事件回圈結束。在同一時間它會去計算最小差異並盡可能的用最少的步驟去更新 DOM。 如此一來應用程式便能獨立執行批次更新，套用計算後的差異到實際 DOM 上，任何應用程式如果這麼做那麼都能夠像 React 一樣有效率。但實際上自己編寫程式碼去做這些任務是很繁瑣且容易出錯，React 的精華之處就是幫你處理掉這些問題。 元件就上面所提到的虛擬 DOM 的機制有著跟直接操作實際 DOM 不一樣的語義和行為，所以也會有明顯不同的 API。所謂的元素即在 DOM 結構中的一個節點(node)，不過在虛擬 DOM 機制底下一個節點完全是不一樣的東西，我們稱這個節點為元件。 使用元件對 React 來說是一件非常重要的事情，因為元件的設計概念是要拿來做計算的，就是計算和實際 DOM 的差異。比起計算整個結構的差異，React 透過虛擬 DOM 將使得實際執行的時間複雜度大幅下降。 為了理解為什麼? 我們必須深入探討元件的設計，就從 Hello World 範例: 12345678/** @jsx React.DOM */var HelloMessage = React.createClass({ render: function() { return &lt;div&gt;Hello {this.props.name}&lt;/div&gt;; }});React.renderComponent(&lt;HelloMessage name=&quot;Andy&quot; /&gt;, mountNode); 上面這段程式碼出現了一些可怕的東西，且在這個階段無法完全說明清楚。即使是這麼小的一段範例都包含著一個很強大的概念，所以在這邊我們將會花些時間慢慢一點一點說明。 這個範例建立了一個 React 元件的類別(class): HelloMessage，然後透過 renderComponent() 在虛擬的 DOM 的機制中建立一個元件(&lt;HelloMessage /&gt;, 本質上它就是 HelloMessage 類別實例化的物件，同時也是一個虛擬的 DOM)最後把這個物件裝到真實的 DOM 元素(mountNode)。 首先是需要注意的事情是 React 的虛擬 DOM 通常來自您在應用程式中客制的元件(在這個例子是 &lt;HelloMessage&gt;)。這是一個意義重大的新嘗試，從內建的 DOM 分離出來。DOM 通常不帶有任何程式邏輯，就只是一個被動的資料結構，且讓我們能夠附加處理事件。換句話說 React 的虛擬 DOM 是透過特定程式中的元件所創造的，且能夠加入程式中的特定 API 及內部邏輯。這樣的方式比起直接修改操作 DOM ，例如: 使用 jQuery 的方式，這種建置 View 的方法是一種全新的抽象化方式與框架。 值得一提的是: 如果您一直持續關注 HTML 你也許知道關於 HTML 也許很快的也能自訂 DOM。這將會帶給 DOM 類似的功能: 定義特定程式使用的 DOM 元素，不過 React 並不需要等到官方和瀏覽器完全實作這件事，因為虛擬 DOM 並不是真的 DOM。這讓 React 搶先在自訂元素與 Shadow DOM這些功能實作普及之前您就能先用了。 回到我們的範例，我們已經建立了一個叫做 &lt;HelloMessage&gt; 的元件並且掛載 mountNode 裡面。讓我們用圖片來說明初始化幾個部分的情形，首先，我們將虛擬 DOM 與實際 DOM 的關係視覺化，假設 mountNode 是網頁中的 &lt;body&gt; 標簽: 關於掛載(mount)一詞就理解為『對應』，把 a 掛載到 b 上 = 可以把 b 視為 a 。 箭頭表示虛擬元件已經被掛載到原生 DOM 元素中。這段過程非常短，不過也讓我們來看看關於應用程式的視圖部分的邏輯: 這張圖片指的是整個網頁的內容是由我們客制的 &lt;HelloMessage/&gt; 來呈現，那麼關於 &lt;HelloMessage/&gt; 看起來到底長怎樣? 關於元件輸出渲染的部分是透過 render() 去定義欲呈現的元素。React 並沒有確切的說明關於何時或多頻繁的會去執行 render() 。只有告訴我們當它注意到有效合法的改變時本身會去執行足夠次數的 render()，無論你回傳什麼樣的 DOM 結構。 在我們這個案例，render() 回傳了一個 &lt;div&gt; 裡面包含了一些內容。React 會執行這個 render() 取得 &lt;div&gt; 然後更新實際的 DOM ，使兩者一致。 不僅僅是更新 DOM，還會幫你記住已經更新的東西。這也是我們待會會提到的關於 React 如何快速的判斷其中差異的方法。關於 render() 如何回傳 DOM 節點，這邊我先簡略帶過。它是透過 JSX 去定義結構，這是一個非原生的 Javascript，注意雖然它看起來像是 XML。最後 JSX 會被編譯回 Javascript，看看 JSX 的編譯結果有助我們理解這個架構: 12345678/** @jsx React.DOM */var HelloMessage = React.createClass({displayName: 'HelloMessage', render: function() { return React.DOM.div(null, &quot;Hello &quot;, this.props.name); }});React.renderComponent(HelloMessage( {name:&quot;John&quot;} ), mountNode); 看到了吧！我們真的不是回傳一個 DOM 元素，而是一個等價于 DOM 元素的 React Shadow DOM。所以我們得知 React 回傳的並不是真的 DOM。您可以理解為標記物件。 狀態與變化到目前為止，我們忽略了故事中很重要的一段，關於元件可以被改變這件事。如果一個元件不允許被調整修改，那 React 跟 static rendering framework(靜態渲染框架) 也沒啥兩樣，功能就類似于 Mustache 或者 HandlebarsJS這些樣板引擎，不過 React 的重點就是有效率的更新，要能夠更新元件勢必要允許我們修改一些狀態之類的東西。 React 使用元件的 state 屬性來表示其狀態的資料模型。關於這點在官方文件的第二個範例就有舉例說明: 12345678910111213141516171819202122/** @jsx React.DOM */var Timer = React.createClass({ getInitialState: function() { return {secondsElapsed: 0}; }, tick: function() { this.setState({secondsElapsed: this.state.secondsElapsed + 1}); }, componentDidMount: function() { this.interval = setInterval(this.tick, 1000); }, componentWillUnmount: function() { clearInterval(this.interval); }, render: function() { return ( &lt;div&gt;Seconds Elapsed: {this.state.secondsElapsed}&lt;/div&gt; ); }});React.renderComponent(&lt;Timer /&gt;, mountNode); React 會在適當的時間點執行回呼函式 getinitialState(), componentDidMount() 以及 componentWillUnmount() ，根據到目前為止的解釋您應該可以清楚地理解這些函式名稱的其含義。所以我們推測元件和狀態背地裡的行為: render() 是 state 和 props 的一個 function，也就是當它們發現異動會執行 render。 state 只能透過 setState() 去改變。 props 不應該持續變動，只有當其父元素用新的屬性重新輸出時才改變。 (在這之前我們沒有明確地提到 props ，不過他們就是屬性 attributes。當元件要 render 時，它們就來自那些 JSX Tag 中的屬性) 稍早，我們曾經提到 React 會自己執行足夠次數的 render ，意思是除非有需要不然 React 不會執行 render。那需要什麼？當你發動 setState() 或者父元件重新賦予新的 props，React 就會重新輸出。 現在我們將所有的事情放在一起，用一張圖來說明當程式更新了虛擬 DOM 的資料流(例如: 回應 AJAX 呼叫): 發動了 AJAX React 內部需要呼叫 setState 用以改變內部狀態 因內部狀態改變進而觸發 render render 執行需要依照生命週期呼叫像 componentWillMount 這類的方法 最後根據計算的最小差異更新 DOM 從 DOM 取得資料截至目前為止，我們只有討論到關於收到狀態改變，到如何傳遞到實際 DOM，但實務上我們會需要從 DOM 取得資料，例如從 input 取得使用者輸入的資料。為了觀察如何運作，我們取用了官方第三個範例: 123456789101112131415161718192021222324252627282930313233343536/** @jsx React.DOM */var TodoList = React.createClass({ render: function() { var createItem = function(itemText) { return &lt;li&gt;{itemText}&lt;/li&gt;; }; return &lt;ul&gt;{this.props.items.map(createItem)}&lt;/ul&gt;; }});var TodoApp = React.createClass({ getInitialState: function() { return {items: [], text: ''}; }, onChange: function(e) { this.setState({text: e.target.value}); }, handleSubmit: function(e) { e.preventDefault(); var nextItems = this.state.items.concat([this.state.text]); var nextText = ''; this.setState({items: nextItems, text: nextText}); }, render: function() { return ( &lt;div&gt; &gt;h3&lt;TODO&lt;/h3&gt; &lt;TodoList items={this.state.items} /&gt; &lt;form onSubmit={this.handleSubmit}&gt; &lt;input onChange={this.onChange} value={this.state.text} /&gt; &lt;button&gt;{'Add #' + (this.state.items.length + 1)}&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; ); }});React.renderComponent(&lt;TodoApp /&gt;, mountNode); 簡單的說，我們把我們要的行為綁定到 DOM 的事件(在這個範例就是 onChange)，接著你在這個事件中呼叫 setState 讓 React 幫您更新介面(實際的 DOM)。如果您的程式有資料模型，您的事件大概就是透過 setState 更新那個資料模型，React 發現狀態異動就會去更新。另外如果您曾經用過其他提供雙向資料繫結的框架，看起來可能會懷疑 React 本身在技術上退化了? 儘管這個範例看起來 React 並不是真的把事件加到 &lt;input&gt; 的 “onChange” ，取而代之的是加到文檔層級。讓事件透過汽泡傳遞的機制然後分派他們到正確的虛擬 DOM 元素。這麼做的好處是包含提升速度(在 DOM 綁定太多處理事件會讓網站變慢)，跨瀏覽器實現一樣的行為(處理事件的屬性和其派送的行為並沒有統一的標準，意思是在不同瀏覽器可能有些許的差異)。 所以最後我們可以總結一張完整的圖片來說明關於資料流和事件處理機制: 結論 React 是一個處理 View 的函式庫: React 並不強迫您要在 Model 做些什麼設定或改變。一個 React 元件只是一個 View-Level 的概念，而元件的狀態就只是 UI 方面的狀態。您可以繫結任何類型的資料模型或者函式庫到 React(雖然某些資料模型的處理方式會更有效率，例如 Om) React 的元件抽象化在更新 DOM 的方面尤其優秀: 元件抽象化是一個原則，使得我們可以編寫組織良好的架構，同時又提供高效率的更新機制。 React 元件從 DOM 的角度執行更新不太方便: 比起函式庫自動傳遞同步資料模型，撰寫事件處理給 React 帶來一種很低階的感覺。 React 是抽象漏洞: 意味著 React 有本質上的缺陷，但有提供避免問題發生的方向。大部份的時間你的程式只會和虛擬 DOM 打交道，但有時候你需要直接對 DOM 做些操作。此時您可以查閱手冊的這部分","link":"/2014/09/20/reactjs-reactjs-decrypt/"},{"title":"Flux 概念詳述篇","text":"介紹還記得之前小弟很認真的想跟大家分享 Flux 不過老實說在當時自己只能夠”模仿”，Dispatcher 和 Store 的觀念也有點模糊。由於今天看了這篇文章之後，覺得很不錯所以來補貼一下。不過在這之前強烈推薦您還是先閱讀關於 Reactjs 的部分。 什麼是 Flux再一次我們說 Flux 是 Facebook 內部搭配 React 使用的一種架構，一種設計模式。它不是一個 Framework 或 Library 。它單純是一種新的架構用來搭配補充 React 以及其單向資料流的概念。然而我們也知道 Facebook 有提供一個 Dispatcher 的函式庫。這個 Dispatcher 是一個全域的發佈/訂閱處理函式庫，他可以廣播 payload (實際資料) 到被註冊的 callback 回呼函式。一個典型的 Flux 架構將會使用這個 Dispatcher 函式庫配合 Nodejs 的 EventEmitter 模組來達成設置一個事件系統以協助管理應用程式的狀態。如果用另一個角度來說那就是 Dispatcher 其實就只是處理事件的註冊與廣播，概念上我們可以先理解為一個 Pub/Sub 機制，各自把自己需求的事件註冊到這個管理中心，接著如果廣播觸發某一事件的時候所有對應的事件都要被執行，而實際實作面就是透過 EventEmitter 來完成，想看實際的程式碼大概就是如下: 12345678var EventEmitter = require('events').EventEmitter, person = new EventEmitter();person.on('speak', function() { console.log('I am here');});person.emit('speak'); 要解釋 Flux 比較好的方式可能是透過說明每一個組成的局部: Actions - 輔助函式 Helper methods, 單純只是便利我們將資料傳給 Dispatcher Dispatcher - 接收 Actions 以及廣播 payloads 到被註冊的回呼函式(callback) Stores - 應用程式狀態和處理邏輯(即那些被註冊到 Dispatcher 的回呼函式)的容器， Controller Views - 一般來說就是那些負責管理 State ，把狀態透過 props 往下傳遞到子元件的 React 元件 看起來就會像下圖: 怎麼 API 也有關聯？ 當你需要處理來自外部的資料，我們發現透過 Actions 來讓資料進入 Flux 流程接著進入 Stores 後續各個流程都將比較方便，是最無痛的方式。 Dispatcher所以到底什麼是 Dispatcher ?基本上 Dispatcher 管理著整個流程。他就像是您應用程式的中央集線器，或者要把它比喻成電話總機。Dispatcher 收到 Actions 來的執行動作，接著分派這個動作和資料去給那些註冊的回呼函式。 所以本質上這就只是一個 發佈/訂閱 系統？不全然是， Dispatcher 會廣播 payload 就是實際要傳遞的資料到所有被註冊的回呼函式包含讓你以特定順序執行回呼的功能，甚至是在執行之前先等更新完成。記住在您的程式中永遠只有一個 Dispatcher ，只有一個總機小姐XD 接著讓我們來看看程式碼的部分: 1234567891011var Dispatcher = require('flux').Dispatcher;var AppDispatcher = new Dispatcher();AppDispatcher.handleViewAction = function(action) { this.dispatch({ source: 'VIEW_ACTION', action: action });}module.exports = AppDispatcher; 在上面的範例，我們建立了一個 Dispatcher 的實例物件，建立了一個 handleViewAction 的方法。這樣的抽象化有助於區分是 View 觸發 Action 或者 Server/API 觸發 Action。dispatch method 就是用來廣播 action 和 payload 到回呼函式。這個 action 接著就會觸發 Stores 內實際的行為函式然後更新狀態。圖解如下 相依性Dispatcher 模組提供的其中一個最酷的部分就是可以替回呼函式定義相依性和序列化。所以當其中一個函式需要相依於另外一個時，為了適當的輸出，您可以使用 Dispatcher 的 waitFor 方法。為了利用這個特性，我們需要在 Store 回傳並儲存 Dispatcher 的識別索引，而方式就是透過儲存 register 方法回傳的值。程式碼範例如下: 123ShoeStore.dispatcherIndex = AppDispatcher.register(function(payload) {}); 然後在我們的 Store 裡，當處理一個被分派的 action 時我們就可以使用 waitFor 來確保上面那個回呼函式已經被執行 1234567case 'BUY_SHOES': AppDispatcher.waitFor([ ShoeStore.dispatcherIndex ], function() { CheckoutStore.purchaseShoes(ShoeStore.getSelectedShoes()); }); break; Stores在 Flux 中，Stores 針對特定需求管理應用程式的狀態。這基本上是指針對每一個應用程式，stores 管理著資料，接收資料的方法和 dispatcher 的回呼函式。讓我們來看看 Store 的程式碼: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657var AppDispatcher = require('../dispatcher/AppDispatcher');var ShoeConstants = require('../constants/ShoeConstants');var EventEmitter = require('events').EventEmitter;var merge = require('react/lib/merge');// shoes 物件，用在內部處理資料var _shoes = {};// 從 action 載入 shoes 資料function loadShoes(shoes) { _shoes = data.shoes;}// 將我們的 store 物件與 Node 的 Event Emitter 合體var ShoeStore = merge(EventEmitter.prototype, { // 取得所有鞋子資料 getShoes: function() { return _shoes; }, emitChange: function() { this.emit('change'); }, addChangeListener: function(callback) { this.on('change', callback); }, removeChangeListener: function(callback) { this.removeListener('change', callback); }});// 註冊 dispatcher callbackAppDispatcher.register(function(payload) { var action = payload.action; var text; // 定義如何處理特定動作 action switch(action.actionType) { case ShoeConstants.LOAD_SHOES: loadShoes(action.data); break; default: return true; } // 當 action 執行完畢則觸發 change event ShoeStore.emitChange(); return true;});module.exports = ShoeStore; 上面程式碼中最重要的一件事就是我們擴充了 store 的功能加入了 EventEmitter。之後我們的 Stores 就可以監聽和廣播事件。而我們的 View 和元件就可以根據事件來更新，因為 Contriller View 監聽 Stores，利用觸發 change event 就可以讓 Controller View 知道程式的狀態已經變更了該更新狀態。我們同時也透過 register 方法註冊了一個 Callback 到 AppDispatcher ，這麼一來 Store 就開始監聽 AppDispatcher 的廣播。上面的 switch 敘述式會決定處理的方式針對對應的 action 然後發出一個廣播，接著觸發 change event 因為 view 監聽著 change event 所以就可以根據事件來更新狀態。 Controller View 就可以透過 getShoes 來檢索 _shoes 裡面的資料，當然這只是一個單純的範例，複雜的邏輯都可以放在這邊。 Action Creators 和 ActionsAction Creators 是一系列方法的集合，我們可以在 View 呼叫他們，透過他們把 action 發送給 Dispatcher. Actions 實際上只是透過 dispatcher 來分派實際資料。關於 Facebook 如何使用它們 - action 類型常數被用來定義該執行什麼樣的行為，並且包含著資料一起被送出。在註冊的回呼函式裡這些 action 可以根據”類型”被處理，且方法可把 action 中的 data 當作參數。 讓我們來看看關於常數是如何定義的: 12345var keyMirror = require('react/lib/keyMirror');module.exports = keyMirror({ LOAD_SHOES: null}); 上面程式碼，我們使用了 React 的 keyMirror 函式庫，沒錯！您已經猜到了。鏡射我們的 keys 所以我們的值就會直接等於我們的 key. 1{ LOAD_SHOES: 'LOAD_SHOES' } 之後我們只要透過觀察這支檔案，我們就能得知關於 ShoeStore 的行為，透過常數幫助我們讓事情更具有組織性，也能讓我們得知關於這個程式實際上在做什麼。 現在我們可以來看看對應的 Action Creator 123456789101112131415var AppDispatcher = require('../dispatcher/AppDispatcher');var ShoeStoreConstants = require('../constants/ShoeStoreConstants');var ShoeStoreActions = { loadShoes: function(data) { AppDispatcher.handleAction({ actionType: ShoeStoreConstants.LOAD_SHOES, data: data }) }};module.exports = ShoeStoreActions; 在上面的範例中，我們在 ShoeStoreActions 建立了一個方法，它可以呼叫 dispatcher 並傳入我們提供的資料。現在我們就能夠在我們的 view 或者 API 匯入這隻 actions 檔案透過 ShoeStoreActions.loadShoes(ourData) 把資料和 actionType 傳給 Dispatcher 並廣播。接著 ShoeStore 將會聽到該事件被呼叫而去執行對應的方法來載入鞋子的資料。 Controller ViewsController Views 就只是 React 元件且該元件正監聽著 change event ，從 Stores 接受應用程式的狀態和資料。當然它可以把資料透過 props 傳遞給子元件。 程式碼看起來便會如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** @jsx React.DOM */var React = require('react');var ShoesStore = require('../stores/ShoeStore');// Method to retrieve application state from storefunction getAppState() { return { shoes: ShoeStore.getShoes() };}// Create our component classvar ShoeStoreApp = React.createClass({ // Use getAppState method to set initial state getInitialState: function() { return getAppState(); }, // Listen for changes componentDidMount: function() { ShoeStore.addChangeListener(this._onChange); }, // Unbind change listener componentWillUnmount: function() { ShoesStore.removeChangeListener(this._onChange); }, render: function() { return ( &lt;ShoeStore shoes={this.state.shoes} /&gt; ); }, // Update view state when change event is received _onChange: function() { this.setState(getAppState()); }});module.exports = ShoeStoreApp; 上面的範例中，我們透過 addChangeListener 把對應更新的事件註冊進去，當事件被廣播時元件就可以執行 this._onChange 函式來更新元件的狀態。應用程式的狀態和資料都被保存在 Stores，所以我們可以使用 Stores 中任何 public 的方法來取得資料或狀態。 結合所有的東西現在我們已經各別解釋關於 Flux 結構的每個部分，我們應該具備關於這個架構實際上是如何運作的觀念，讓我們更仔細地來看看下面運作的圖示","link":"/2014/11/11/flux-notes/"},{"title":"輕鬆學 Flux","text":"前言小弟身為一個資質駑鈍的人，這正是我在學習 Flux 初期最希望有人可以幫我總結的事。服用本篇前須對 React 有基本的認識。因為底子不好在參透官方範例時一直東奔西跑的查資料一下這個 merge 是什麼意思，一下又怎麼這邊一個 Dispatcher, AppDispatcher 然後又 ActionCreator總之是你搞得我好亂啊。不過因為最近 React 的盛行讓我得以閱讀許多大大的分享因而有這一篇 我應該使用 Flux 嗎？如果您的應用程式需要處理很多動態的資料那麼答案是 YES! 您可能應該使用 Flux但如果您的應用程式只是靜態頁面，且不需要去共用一些應用程式的狀態，也從來不需要更新資料那麼這個答案就是 NOFlux 不能帶給你任何好處 為什麼要用 Flux?Flux 是一個相當複雜的概念，為什麼要增加程式的複雜度呢？哈！開玩笑的！！百分之九十的 iOS 應用程式透過 table view 來呈現資料。iOS toolkit 擁有非常好的架構來處理關於資料模型的問題，這使得開發起來非常容易。 不過在前端的世界(HTML, Javascript, CSS) 我們沒有那些東西也沒人強迫我們一定得用這些，取而代之的是我們有一個大問題。沒人知道該怎麼完美的處理前端架構這個問題。處理前端的工作已經好一陣子了，所謂的最佳實踐從來沒有完美的解決所有問題，現實反而是針對個別小問題的函式庫解決了他們jQuery? Backbone? Handlebars? 其實我們也都知道真正的問題是關於資料，一但它邏輯和 UX 變得越來越複雜就很少人可以精準的控制他。 什麼是 Flux?Flux 是一個 Facebook 創造的術語: 用來描述單一方向的資料流搭配特定的事件和註冊監聽的設計模型。並沒有一定是指 Flux 的函式庫，不過您的確需要 Flux Dispatcher 以及事件函式庫。官方文件是用一種概念的方式在介紹因此對於像我這種資質比較差的人的確不是個很好的起點。沒幫我分解片段片段程式碼就吸收得很慢。不過一旦你了解了關於 Flux 的想法您應該就能夠讀懂那些東西。 先不要試圖去比較 Flux 和 MVC 結構，把它們兩者搞在一起的話只會得到混亂。 OK! 談論夠多了，讓我們慢慢的探討，這篇文章將會慢慢解釋所有概念佐以程式碼。 1. 你的 Views (React Component) 分派了動作一個 dispatcher 本質上是一套事件機制。它負責廣播事件和註冊回呼函式(callback)。而且全部就只有一個，一個全域的 dispatcher 物件。為了讓事情單純你應該就直接使用 Facebook 的 Dispatcher Library 官方在解釋 Dispatcher 那段一開始的確讓我慌了。 12var Dispatcher = require('flux').Dispatcher;var AppDispatcher = new Dispatcher(); 接著我們假設您的應用程式中有一個新增的按鈕功能是加入一個項目到清單中: 1&lt;button onClick={ this.createNewItem }&gt;New Item&lt;/button&gt; 當按鈕點擊的時候會發生什麼事情呢？您的 View 派送了一個非常特別的事件，這個事件包含著兩件事事件名稱和該項目的資料 12345678createNewItem: function( evt ) { AppDispatcher.dispatch({ eventName: 'new-item', newItem: { name: 'Andy' } // example data });} 2. 您的 Store 需要回應被派送來的事件就像 Flux 一樣 “store” 也是 Facebook 創造的術語。對於我們的應用程式來說，我們需要一個邏輯集合(就是處理邏輯的物件)與資料來處理這份清單。這指的就是 Store ，它不只要管理資料模型也需要回應上面提到的特殊的事件。在這邊我們就稱它為 ListStore一個 store 本身是單獨的物件，應該就只有一個，意思是你不應該 new 出另外一個物件。換言之我們的 ListStore 是獨一無二全域的物件。 123456789101112// 一個全域物件用來處理清單資料和邏輯var ListStore = { // 實際資料模型的集合 items: [], // 存取方法，後續我們將使用它來取得資料 getAll: function() { return this.items; }}; 這個 store 接著要回應 dispatcher 發過來的特殊事件。 12345678910111213141516var ListStore = …AppDispatcher.register( function( payload ) { switch( payload.eventName ) { case 'new-item': ListStore.items.push( payload.newItem ); break; } return true;}); 這是典型的 Flux 處理回應 dispatcher 派送過來的 action 的機制。每一個 payload 包含著事件名稱和資料，透過 dispatcher 分派過來。好了我們同時解釋了在官網那張圖上的 action 與 payload 。 dispatcher.dipatch({}) 發動這個 method =&gt; 派送一個 action{} 裡面的物件我們稱為 payload 接著用一個 switch 程式片段用來決定該執行什麼動作。 核心概念 1: 一個 store 不只是一個資料模型，但其包含著資料模型。 核心概念 2: store 在程式中是唯一知道該如何更新資料的角色。這也是整個 Flux 最重要的部分。dispatcher 觸發的事件並不知道如何處理資料。對應回官方的說明這叫做一個 action。 對應的行為是寫在 store 然後透過 AppDispatcher.register 註冊。 舉例來說如果有其他部分需要追蹤關於圖片的資料您就應該再開一個 store 並叫做 ImageStore。一個 store 只負責處理單一需求。當您的程式變大的時候可以很輕易地根據需求找到對應的部分。如果程式不複雜可能您只需要一個 store。 記住！只有 store 是被允許註冊 dispatcher 的 callback。View 永遠不會呼叫 AppDispatcher.register 。而 dispatcher 也只能夠從 View 送訊息到 store。 3. Store 觸發了一個 “Change” 事件我們幾乎快學完了！現在您的資料確實已經改變了，但是我們需要通知程式中其他角色。store 接著會觸發一個事件，但不是靠 dispatcher 。這邊通常是初學者容易搞混的地方，但這就是 Flux 採用的方式。這邊我們讓 store 具備有觸發事件的能力方法有很東種例如使用 MicroEvent 或者採用 EventEmitter。這邊為了讓你釐清觀念也不要加入太多東西所以我們先用 MicroEvent 其觀念就是讓 Store 具備廣播事件的能力，你可能就會問廣播什麼事件？大略你可以先理解成這是一個發佈/訂閱的事件機制。當 store 告訴全世界: 嘿！我飯煮好了！該吃飯的人就自己自動過來吃 XD。 註: 官方採用的方式可能一直在調整，從 merge 到 object-assign 其實觀念都是一樣的就是讓 store 具備廣播事件的能力且官方使用 EventEmitter。 這邊我們就透過 MicroEvent 讓 store 可以通知全世界: 1MicroEvent.mixin( ListStore ); 好了！store 已經具備該能力了那就直接在下面呼叫 1234567891011121314151617AppDispatcher.register( function( payload ) { switch( payload.eventName ) { case 'new-item': ListStore.items.push( payload.newItem ); // 告訴其他人我已經改變好了 ListStore.trigger( 'change' ); break; } return true;}); 核心觀念: 當我們觸發事件時我們不需要再把資料帶出去。view 只需要知道資料已經有更新了。讓我們繼續看下去來理解原理 4. View 回應 Change 事件現在我們需要顯示清單。當清單發生改變，我們的 view 將會全部重新渲染輸出，沒有錯是全部！為了讓 view 知道何時該更新，從 view 被掛載後它就必須監聽從 store 發出的 change 事件。 123componentDidMount: function() { ListStore.bind( 'change', this.listChanged );}, 為了簡單起見，我們會使用 forceUpdate 強制重新渲染。另一個方法是將整個清單存到 state。在 React 元件內的方法就會如下: 1234listChanged: function() { // Since the list changed, trigger a new render. this.forceUpdate();}, 別忘記當卸載時把監聽清除 123componentWillUnmount: function() { ListStore.unbind( 'change', this.listChanged );}, 然後呢？讓我們來看看 render 函式，我們特意保留到最後再看 123456789101112131415161718192021222324render: function() { // 記住, ListStore 是全域物件! // 透過它取得資料 var items = ListStore.getAll(); var itemHtml = items.map( function( item ) { return &lt;li key={ listItem.id }&gt; { listItem.name } &lt;/li&gt;; }); return &lt;div&gt; &lt;ul&gt; { itemHtml } &lt;/ul&gt; &lt;button onClick={ this.createNewItem }&gt;New Item&lt;/button&gt; &lt;/div&gt;;} 好了！我們已經完成整個循環。當你加入新的項目 -&gt; view 透過 dispatcher 派送一個 action -&gt; store 回應這個 action 處理資料(處理的 callback 已經被註冊到 dispatcher) -&gt; store 處理完畢觸發 change 事件-&gt; view 因為有監聽這個事件所以做出對應的處理更新。 不過這邊還有一個問題，每一次我們都重新渲染了整個 view ，這難道不會造成什麼效能異常糟糕嗎？ 不會！ 沒錯我們的確是讓 render 方法重新在渲染一次，所有在 render 內部的程式碼會重跑一次，不過 React 只會在當資料有所改變的時候才會更新實際的 DOM，關於 render 事實上他只是產生一個虛擬的 DOM。然後 React 會自動去和上一次的比較，如果兩個虛擬的 DOM 不同的話 React 才會更新實際的 DOM 而且是只有實際 DOM 不同的地方而已。 核心觀念: 當 store 的資料改變 view 不需要知道資料到底是增加還是減少或者修改，view 只要負責重新輸出整個元件，接著 React 的虛擬 DOM 機制會幫你處理如何有效率的更新 DOM。是不是整個變得很單純。 還有一個東西: Action Creator 是什麼鬼？記得，當我們點擊我們的按鈕時我們派送了一個特殊的事件: 1234AppDispatcher.dispatch({ eventName: 'new-item', newItem: { name: 'Andy' }}); 如果很多 view 需要這一個事件，那麼很快這一小段程式碼將到處重複，很快當你需要修改的時候又會搞不清楚。Flux 建議我們將這些派送的事件抽象化，叫做 action creator。就只是把這些 AppDispatcher.dispatch 根據其功能分門別類，這樣其他 view 要用就只要引用就好 12345678910ListActions = { add: function( item ) { AppDispatcher.dispatch({ eventName: 'new-item', newItem: item }); }}; 現在您的 view 就可以單純呼叫 ListActions.add 。 希望到這邊為止可以建立起 Flux 的概念，剩下的就在看看官方的範例應該就比較看得懂了。","link":"/2014/11/15/fools-learn-flux/"},{"title":"ActionPack 雜記","text":"Action PackAction Pack 是整個 Rails 的核心部份，由 ActionDispatch, ActionController, ActionView 組成ActionDispatch 處理接收到的請求(Requests)，即網址的部分，ActionController 負責把請求對應轉換成回應(Responses)接著 ActionController 調用 ActionView 來處理回應的格式(html, js, json, xml) 等 通常 ActiveRecord 比較常會被獨立使用，而 ActionPack 通常我們會透過 Rails 整合在一起使用。 路由在 Rails 路由通常分成2大類 comprehensive, resources ，通用型的路由就是讓你指定 [http verb] [mapping url] [controller#action]具體的流程是當 Server 透過網址取得請求，此時 Rails 會透過 Action Dispatch 去處理網址判斷該對應到哪個 controller 和 action 並把 parameter 帶進去 123Sample::Application.routes.draw do resources :products # Resources 會產生 7 組路由end 上面的範例 Rails 會先假設您有一個 ProductsController 1resources :people, except: [:update, :destroy] 12345678910111213141516171819202122232425262728293031323334def index @products = Product.allenddef show @product = Product.find(params[:id])enddef new @product = Product.newenddef create @product = Product.new(prarms.require(:product).premit(:title, :description, :image_url, :price)) respond_to do |format| if @product.save format.html { redirect_to @product, notice: &quot;Product was successfully created&quot; } format.json { render action: 'show', status: :created, location: @product} else format.html { render action: 'new' } format.json { render json: @product.errors, status: :unprocessable_entity } end endenddef editenddef updateenddef destroyend 共用 route12345concern :reviewable do resources :reviewsendresources :products, concern: :reviewable 路由得設法123456789root :to =&gt; 'welcome#index'root to: 'controller#action'match 'messages/show', to: 'messages#show', :via =&gt; 'get'match 'messages/show' =&gt; 'messages#show', via: [:get, :post]get 'messages/show' =&gt; 'messages#show'# 省略的寫法match 'messages/show' # 相等於 match 'messages/show' =&gt; 'messages#show'match 'messages' =&gt; 'messages#index', :as =&gt; 'index'match &quot;/messages/show/:id&quot; =&gt; &quot;messages#show&quot;, :constraints =&gt; {:id =&gt; /\\d/} # 限制參數","link":"/2015/04/04/action-pack-note/"},{"title":"使用 Selenium 搭配 Cloud-based 壓力測試","text":"這是一篇記流水帳的操作步驟，文章翻譯自微軟 Developer Tools Blogs文章加上小弟遇到的特殊情形經官方人員協助處理完成的紀錄。 本文主要是介紹如何使用 Selenium 搭配微軟的雲端服務 Visual Studio Online 執行壓力測試。透過 Selenium 我們可以達到最貼近使用者操作的情形模擬。首先讓我們需要概略的認識 Visual Studio Online(VSO) 的 Cloud-based Load Testing(CLT) 和 Selenium。 Cloud-based Load Testing: 這是 Visual Studio 2013 後引入的新功能，這篇記錄就不詳細介紹關於 CLT 的部分您可以參考官方的介紹 快速入門的話可參考這個連結 Selenium Selenium 是一套模擬瀏覽器操作，自動執行的測試軟體，簡單說就是可以側錄或撰寫 script 讓它自動幫你執行，詳細介紹直接參考官方 請參考官方網站對 Selenium 的基礎操作有些瞭解，這篇文章主題為 Selenium 搭配 CLT 故如何撰寫 script 不再這篇重點 原文教學針對使用 Selenium Nuget 搭配 Phantomjs Nuget ，不過因為小弟的站大量使用 socket.io 在這邊 phantomjs 1.x 會有一些問題，所以我們補上如何使用 Firefox 當作模擬的瀏覽器 正文開始在 VS 撰寫 Selenium 單元測試【一】 首先在 VS 中建立一個單元測試專案(Unit Test Project)。 檔案 -&gt; 新增專案 -&gt; 範本 -&gt; Visual C# -&gt; 測試 -&gt; 單元測試專案 【二】 專案建立完成後，安裝 Selenium Nuget 。對專案按右鍵 -&gt; 管理 Nuget 套件 -&gt; 搜尋 Selenium -&gt; 安裝 【三】 安裝完成之後，參考目錄下應該會看到 WebDriver 【四】 下載實際使用的瀏覽器模擬驅動，原文為了單純起見使用了 PhantomJs，接著您可以在 Nuget 搜尋 PhantomJS 並且安裝，安裝後記得修改 phantomjs.exe 的屬性為有更新時才複製 【五】 建立 C# 檔案開始撰寫單元測試，您也可以先透過 Selenium IDE 側錄大部份的行為為程式碼再來修改。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647using Microsoft.VisualStudio.TestTools.UnitTesting;using OpenQA.Selenium;using OpenQA.Selenium.PhantomJS;using System;using System.Text;namespace SeleniumSample{ [TestClass] public class SeleniumTests { [TestMethod] public void TheBingSearchTest() { TestContext.BeginTimer(&quot;BingSearchTest_Navigate&quot;); _driver.Navigate().GoToUrl(&quot;http://www.bing.com/&quot;); TestContext.EndTimer(&quot;BingSearchTest_Navigate&quot;); TestContext.BeginTimer(&quot;BingSearchTest_SearchBHarry&quot;); _driver.FindElement(By.Id(&quot;sb_form_q&quot;)).SendKeys(&quot;Brian harry blog&quot;); _driver.FindElement(By.Id(&quot;sb_form_go&quot;)).Click(); TestContext.EndTimer(&quot;BingSearchTest_SearchBHarry&quot;); var elementText = _driver.FindElement(By.XPath(&quot;//ol[@id='b_results']/li/h2/a&quot;)); Assert.IsTrue(elementText.Text.Equals(&quot;Brian Harry's blog - Site Home - MSDN Blogs&quot;), &quot;Verified title of the blog page&quot;); } public TestContext TestContext { get; set; } #region Additional test attributes [TestInitialize] public void SetupTestSuite() { Console.WriteLine(&quot;Test init called: {0}&quot;); _driver = new PhantomJSDriver(); } [TestCleanup] public void CleanupTestSuite() { _driver.Quit(); } #endregion private IWebDriver _driver; }} 其他範例使用 Firefox 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768using System;using System.Text;using Microsoft.VisualStudio.TestTools.UnitTesting;using System.Text.RegularExpressions;using OpenQA.Selenium;using OpenQA.Selenium.Firefox;using System.Threading;using OpenQA.Selenium.Interactions;using System.Collections.Generic;using OpenQA.Selenium.Support.UI;using System.Linq;namespace PasserTesting{ [TestClass] public class SeleniumCase { private IWebDriver _driver; private const String WEB_SITE = &quot;http://www.google.com&quot;; public TestContext TestContext { get; set; } [TestMethod] public void VisitGoogle() { TestContext.BeginTimer(&quot;Begin View Index&quot;); _driver.Navigate().GoToUrl(WEB_SITE); TestContext.EndTimer(&quot;Begin View Index&quot;); var title = _driver.Title; Assert.IsTrue(title.Equals(&quot;Google&quot;)); } private bool IsElementPresent(By by) { try { _driver.FindElement(by); return true; } catch (NoSuchElementException) { return false; } } #region Additional test attributes [TestInitialize] public void SetupTestSuite() { Console.WriteLine(&quot;Test init called: {0}&quot;); _driver = new FirefoxDriver(); } public void CleanupTestSuite() { _driver.Quit(); } #endregion }} 【六】 對方案右鍵加入 -&gt; 新增項目 -&gt; 測試設定 -&gt; 加入測試設定檔案 【七】 設定測試設定的部署加入 phantomjs.exe 【八】 建置方案 【九】 從 測試 -&gt; 測試設定 -&gt; 選取測試設定擋 【十】 先透過測試總管(Test Explorer)在本機驗證測試 (測試 -&gt; 視窗 -&gt; 測試總管) 到此我們已經完成測試的流程，接著要設定上 CLT 執行 為單元測試加上負載測試【一】 替專案加上負載測試(右鍵 -&gt; 加入負載測試) 根據精靈提示設定您需要的情節 【二】 在本地端驗證設定執行的狀況 透過 Visual Studio Online 執行 Selenium 測試搭配 CLT【一】 恭喜！接下來您只要一個鍵就能夠在 Microsoft Azure Cloud 執行您的測試【二】 當負載測試加完之後，在 測試 -&gt; 測試設定 -&gt; 選取測試檔案 選擇之前建立的 .testsettings【三】 打開這個測試檔案把設定改成使用 VSO 想瞭解更多關於壓力測試請參考 【四】 當執行全部完成之後你就可以下載報告。就可以點擊檢視報告上方的連結 【五】 最後您可以得到關於你這次的測試資料大略如下圖 使用 Firefox(暫時的解決方案，官方表示正在處理更完整的方式)當您因為一些其他原因無法使用 PhantomJS 當作 WebDriver 時這裏提供另外一個方案 【一】 首先我們必須要雲上裝上 Firefox 所以我們必須要提供一段 script 讓雲上的機器自己安裝 Firefox 12345678910111213141516171819202122232425262728293031323334353637::::::::::::::::::::::::::::::::::::::::::: Automatically check &amp; get admin rights:::::::::::::::::::::::::::::::::::::::::@echo offCLSECHO.ECHO =============================ECHO Running Admin shellECHO =============================:checkPrivilegesNET FILE 1&gt;NUL 2&gt;NULif '%errorlevel%' == '0' ( goto gotPrivileges ) else ( goto getPrivileges ):getPrivilegesif '%1'=='ELEV' (shift &amp; goto gotPrivileges)ECHO.ECHO **************************************ECHO Invoking UAC for Privilege EscalationECHO **************************************setlocal DisableDelayedExpansionset &quot;batchPath=%~0&quot;setlocal EnableDelayedExpansionECHO Set UAC = CreateObject^(&quot;Shell.Application&quot;^) &gt; &quot;%temp%\\OEgetPrivileges.vbs&quot;ECHO UAC.ShellExecute &quot;!batchPath!&quot;, &quot;ELEV&quot;, &quot;&quot;, &quot;runas&quot;, 1 &gt;&gt; &quot;%temp%\\OEgetPrivileges.vbs&quot;&quot;%temp%\\OEgetPrivileges.vbs&quot;exit /B:gotPrivileges::::::::::::::::::::::::::::::START::::::::::::::::::::::::::::setlocal &amp; pushd .&quot;%~dp0\\Firefox.exe&quot; /S 【二】 要執行這段 setup script 我們需要先在方案的資料夾下建立一個 Deployment 資料夾把上面那段 script 放入並且命名為 setup.cmd【三】 下載要安裝的 Firefox.exe 放置到一樣的 Deployment 目錄【四】 開啟 Visual Studio 對 .testsettings 點擊兩下開啟如下設定 【五】 加入 Deployment 目錄後下一步設定指令碼，選擇剛剛在同個目錄下的 setup.cmd","link":"/2014/12/23/use-selenium-to-match-cloud-based-stress-test/"},{"title":"ActiveRecord 雜記","text":"優化 Model count123class Like &lt; ActiveRecord::Base belongs_to :guestbook_entry, counter_cache: trueend 其他小筆記 Rails 慣例 date -&gt; created_on, datetime -&gt; created_at 如果 Model 的單偶數錯誤了就到 config/initializers/inflections.rb 去修改 123ActiveSupport::Inflector.inflections do |inflect| inflect.irregular 'tax', 'taxes'end 或者直接改 Model 本身 123class Sheep &lt; ActiveRecord::Base self.table_name = &quot;sheep&quot;end 要換 key 的名稱，4 版後直接調整 schema 12345create_table :products, id: false do |t| t.string :sku, primary_key: true t.timestampsend rails console 下的一些指令12$ Order.column_names$ Order.columns_hash[&quot;column_name&quot;]","link":"/2015/04/04/active-record/"},{"title":"Rails 精簡練習","text":"指令練習1234567891011121314$ rails generate scaffold User name:string bio:text birthday:date$ rails destroy scaffold User$ rails g scaffold Post name --skip-assets$ rails db$ rails console$ rails g controller posts # 複數$ rails g controller posts index new create # 後面可以接 action$ rails g model Post title body:text$ rails d model post$ rake db:setup$ rake db:migrate$ rake db:migrate:status$ rake routes 手刻練習 建立文章控制器 posts_controller.rb 加入 resources :posts 路由 加入 列表 action index 建立 index view 加入 新增 action new 加入 new view 重點在 form_for 表單 新增 post model rails g model post title body:text 建立 create action 來儲存 model，記得補上驗證 建立 show view 顯示單筆資料 Model 可以建立之後把 index view 補上 each do 把 new view 抽出 _form 然後建立 edit action and update 補上 destroy action 加上關聯的 comment 留言 model 補上 model 關聯的設定 路由設定 建立 comments_controller.rb comments 這個 controller 是依附在 posts 底下，加上巢狀 resources 會得到 /posts/:post_id/comments 所以注意表單 form_for([@post, @post.comments.build]) 的部分 建立 create action 重點在 @post = Post.find(params[:post_id]) 和 @comment = @post.comments.create(params[:comment].permit(:name, :body)) 注意 view 的 _form 部分 view 總共會建立 3 個 _form, _comment, 再修改 posts/show 使用 render “comments/form” 實作 comments_controller 的 destroy action ，記得要從 @post.commetns.find() -&gt; destroy models/post.rb 記得 dependent: :destroy 1.1$ rails g controller posts 2. 修改 config/routes.rb12resources :postsroot &quot;posts#index&quot; 3. 加入 action123456class PostsController &lt; ApplicationController def index endend 4. 加入 index view1&lt;h1&gt;Hello world!&lt;/h1&gt; 5. 實作新增 new123456class PostsController &lt; ApplicationController #... def new endend 6. 在 app/views/posts/new.html.erb 新增表單，此時沒有 Model ，因為我們在 form_for 用 symbol123456789&lt;%= form_for :post, url: posts_path do |f| %&gt; &lt;%= f.label :title %&gt; &lt;%= f.text_field :title %&gt; &lt;%= f.label :body %&gt; &lt;%= f.text_field :body %&gt; &lt;%= f.submit %&gt;&lt;% end %&gt; 此時當我們送出 post 的時候，第一沒有 create 的 action 因為 resources :posts 幫我們加上了 8 個路由，扣掉 put, patch 功能一樣有 7 組不同功能的路由 12345678get &quot;posts&quot; =&gt; &quot;posts#index&quot;, :as =&gt; &quot;posts&quot; # 取得 posts_path helperpost &quot;posts&quot; =&gt; &quot;posts#create&quot;, :as =&gt; &quot;posts&quot;get &quot;posts/:id&quot; =&gt; &quot;posts#show&quot;, :as =&gt; &quot;post&quot; # 注意單數，用的時候後面要帶 model 參數才能取得 :idget &quot;posts/new&quot; =&gt; &quot;posts#new&quot;, :as =&gt; &quot;new_post&quot;get &quot;posts/:id/edit&quot; =&gt; &quot;posts#edit&quot;, :as =&gt; &quot;edit_post&quot;put &quot;posts/:id&quot; =&gt; &quot;posts#update&quot;, :as =&gt; &quot;post&quot;patch &quot;posts/:id&quot; =&gt; &quot;posts#update&quot;, :as =&gt; &quot;post&quot;delete &quot;posts/:id&quot; =&gt; &quot;posts#destroy&quot;, :as =&gt; &quot;post&quot; 7. 新增 Post Model12$ rails g model Post title body:test$ rake db:migrate 8. 在 controller 新增 create action12345678910def create @post = Post.new(post_params) @post.save redirect_to @postendprivatedef post_params params.require(:post).permit(:title, :body)end 這個時候送出會產生錯誤，因為 redirect_to @post 的關係。一般情況下此時只要有對應的 app/views/posts/show.html.erb 就能 work 了 9. 建立 show action 和 view12345&lt;h1&gt;&lt;%= @post.title %&gt;&lt;/h1&gt;&lt;p&gt;&lt;%= time_ago_in_words(@post.created_at) %&gt;&lt;/p&gt;&lt;p&gt;&lt;%= @post.body %&gt;&lt;/p&gt; 10. index 列表1234&lt;% @posts.each do |post| %&gt; &lt;h2 &gt;&lt;%= link_to post.title, post_path(post)%&gt;&lt;/h2&gt; &lt;p class=&quot;date&quot;&gt;&lt;%= post.created_at.strftime(&quot;%B %d, %Y&quot;) %&gt;&lt;/p&gt;&lt;% end %&gt; 11. 加入 comment12$ rails g model Comment name:string body:text post:references$ rake db:migrate 12345678910111213# post.rbclass Post &lt; ActiveRecord::Base has_many :comments validates :title, presence: true, length: { minimum: 5 } validates :body, presence: trueend# routes.rbresources :posts do resources :commentsend 因為現在 Comment model 是關聯在 Post model 下面，所以 @post = Post.find(params[:post_id]) 當我們要在 CommentsController 找 Post 需要 :post_id 12345678class CommentsController &lt; ApplicationController def create @post = Post.find(params[:post_id]) @comment = @post.comments.create(params[:comments].permit(:name, :body)) redirect_to post_path(@post) endend form_forform_for 的用途是建立一個 html 的 form 表單，讓使用者可以透過 form 把資料傳回後端，新增或者更新某個指定物件的屬性。這個方法(method)有幾種稍微不同的用法，取決於您想從 Rails 的 Model 中自動對應多少東西，或者說自動處理掉 Model 對應的部分針對一般情況的 Model，我們透過傳入 form_for 一個字串或 symbol 來表示我們要對應的物件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#--- erb&lt;%= form_for :xx do |f|%&gt; &lt;%= f.text_field :oo %&gt;&lt;% end %&gt;#--- 輸出&lt;form method=&quot;post&quot; accept-charset=&quot;UTF-8&quot; action=&quot;同一個路由&quot;&gt; &lt;input name=&quot;utf8&quot; value=&quot;✓&quot; type=&quot;hidden&quot;&gt; &lt;input name=&quot;authenticity_token&quot; value=&quot;EsXGzijdB1Wx8f5FNtO+l8XDEpoA49Ko7nJsZw+Tb5N5BpIQPs3NCw9iO5gwZTkJgyzDm48GHDQCkPwwcFa2WA==&quot; type=&quot;hidden&quot;&gt; &lt;input id=&quot;xx_oo&quot; name=&quot;xx[oo]&quot; type=&quot;text&quot;&gt;&lt;form &gt;#-- 協助記憶&lt;%= form_for :object do |f| %&gt; &lt;%= f.text_field :attribute %&gt;&lt;% end %&gt;#--- 您也可以單純用 text_field，在 yield 中的 f 變數是一個 FormBuilder 物件，透過與 Model 物件或者 symbol 的定義合作產生表單#--- erb&lt;%= text_field :a, :b %&gt;&lt;%= text_field :person, :name %&gt;#--- 輸出&lt;input type=&quot;text&quot; id=&quot;a_b&quot; name=&quot;a[b]&quot;&gt;&lt;input type=&quot;text&quot; id=&quot;person_name&quot; name=&quot;person[name]&quot;&gt;#--- 當 submit 的時候會收到 params[:a][:b], params[:pserson][:name]#--- 此時如果有一個 @a 的變數傳進來預設就會初始化帶入這些欄位#--- 範例#--- view/&lt;input type=&quot;text&quot; id=&quot;a_b&quot; name=&quot;a[b]&quot;&gt;#--- controller/class SomeController &lt; ApplicationController class A attr_accessor :b end def action @a = A.new @a.b = &quot;What happen?&quot; endend#--- 如此 view 的 a[b] 就會自動帶入 What happen? 在 form_for 右邊還可以帶入參數 url 可以修改 submit 的網址即 action=”url here” namespace 替內部的 input id 再加上特殊的前綴字例如上面本來是 a_b 如果加上 namespce: ‘x’ 就會變成 x_a_b html 其他原生 html 的屬性 e.g. :html =&gt; { :multipart =&gt; true } 針對表單還有 FormOptionHelper 和 DateHelper 可以針對下拉式選單或日期做處理 注意 form_for 本身不會建立一個獨立的 scope ，意味著您看同時混搭 FormHelper 和 FormTagHelper 123456&lt;%= form_for :person do |f| %&gt; &lt;%= f.text_field :first_name %&gt; &lt;%= text_area :last_name %&gt; &lt;%= check_box_tag &quot;person[admin]&quot;, &quot;1&quot;, @person.company.admin? %&gt; &lt;%= f.submit %&gt;&lt;% end %&gt; form_for 搭配 Model在上面的範例，會根據傳入 form_for 的 symbol 去產生對應的 from 表單 name 屬性，如此一來可以被對應為一個物件，如果您傳入的是字串那麼意思也是一樣的。我們也可以把 Model 物件本身當作參數傳入，如果 @person 存在且您想編輯它那麼您可以直接使用如下 123&lt;%= form_for @person do |f| %&gt; ...&lt;% end %&gt; 這麼寫的行為幾乎跟您使用 symbol 一樣，不過有些微不同，首先是表單的前綴字即用 model 的 class name ， 且 form 會有 id 且會根據 new 或 edit 不同當然如果不想被綁死您也可以修改 12&lt;%= form_for(@person, as: :client) %&gt;&lt;% end %&gt; 其次是當該物件已經被初始化或者說有值的時候對應 attributes 的欄位會自動帶入該值，因此如果該 view 已經有個變數 post也可以這樣寫 12&lt;%= form_for post do |f| %&gt;&lt;% end %&gt; 在剛剛的範例中，雖然我們沒有明確的指定，但我們還是要使用 :url 來指定 post 的目標。然而如果我們的物件有透過 resources 指定路由的話路徑就會自動處理例如 123456789101112131415161718192021222324252627&lt;%= form_for @post do |f| %&gt;&lt;% end %&gt;# 會等於&lt;%= form_for @post, as: :post, url: post_path(@post), method: :patch, html: { class: &quot;edit_post&quot;, id: &quot;edit_post&quot;} do |f| %&gt;# 如果 @post 是剛初始化的話&lt;%= form_for(Post.new) do |f| %&gt; ...&lt;% end %&gt;&lt;%= form_for @post, as: :post, url: posts_path, html: { class: &quot;new_post&quot;, id: &quot;new_post&quot; } do |f| %&gt; ...&lt;% end %&gt;# 當然也可以覆寫&lt;%= form_for(@post, url: super_post_path) do |f| %&gt;# 或者設定回應的格式&lt;%= form_for(@post, format: :json) dp |f| %&gt;# 針對 namespace 路由 e.g. admin_post_url&lt;%= form_for([:admin, @post]) do |f|&gt;# 如果是關聯的子物件屬性&lt;%= form_for([@post, @comment]) do |f| %&gt; 關掉 id 12345&lt;%= form_for(@post) do |f| %&gt; &lt;%= f.fields_for(:comments, include_id: false) do |cf| %&gt; ... &lt;% end %&gt;&lt;% end %&gt; 也可以改用別的 FormBuilder 1234&lt;%= form_for @person, url: { action: &quot;create&quot; }, builder: LabellingFormBuilder do |f| %&gt;# 照上面的範例如果我們用&lt;%= render f %&gt;# 則會 render people/_labelling_form 的樣板 redirect_to 的用法將瀏覽器重新定向到參數(options)中指定的目標，這個參數可以用下面格式:(Hash, Model Record, String 搭配 protocol://, String, :back) 總結來說是三種格式 Hash - 這種格式是透過搭配 url_for 產生的 12redirect_to url_for(controller: 'posts', action: 'new')redirect_to :action =&gt; &quot;new&quot; # 就算你不加 url_for 預設也會幫您呼叫 Record - 一筆紀錄其實就是您取出來的 model 本質上當您 redirct_to @model 時總結來說就是轉址到 model_path(@model)對應的路徑即 /posts/:id 就是 “posts#show” (PostsController &gt; show action)。所以雖然我們上面沒有定義 show action 但只要有 view (show.html.erb)就能夠執行是因為 Rails 預設當找不到 action 的時候會直接去找對應 action 的 view。 傳入紀錄的方式在內部是透過 polymorphic_url 來處理 123456789101112131415161718192021222324# 當我們使用 RESTful 路由時內部的各種狀況範例如下:## # 呼叫 post_url(post)# polymorphic_url(post) # =&gt; &quot;http://example.com/posts/1&quot;# polymorphic_url([blog, post]) # =&gt; &quot;http://example.com/blogs/1/posts/1&quot;# polymorphic_url([:admin, blog, post]) # =&gt; &quot;http://example.com/admin/blogs/1/posts/1&quot;# polymorphic_url([user, :blog, post]) # =&gt; &quot;http://example.com/users/1/blog/posts/1&quot;# polymorphic_url(Comment) # =&gt; &quot;http://example.com/comments&quot;### ==== 其他範例## # an Article record# polymorphic_url(record) # same as article_url(record)## # a Comment record# polymorphic_url(record) # same as comment_url(record)## # it recognizes new records and maps to the collection# record = Comment.new# polymorphic_url(record) # same as comments_url()## # the class of a record will also map to the collection# polymorphic_url(Comment) # same as comments_url() 字串 - 有使用 protocol:// 例如: http:// 就是直接傳入網址 字串不搭配 protocol 就是 //example.com 會用當前的通訊協定 :back - 簡單的說就是 redirect_to(request.env[&amp;quot;HTTP_REFERER&amp;quot;]) 的縮寫 123456789101112# 完整範例 redirect_to :action =&gt; &quot;show&quot;, :id =&gt; 5 redirect_to post redirect_to &quot;http://www.rubyonrails.org&quot; redirect_to &quot;/images/screenshot.jpg&quot; redirect_to articles_url redirect_to :back# 搭配狀態 redirect_to post_url(@post), :status =&gt; :found redirect_to :action=&gt;'atom', :status =&gt; :moved_permanently redirect_to post_url(@post), :status =&gt; 301 redirect_to :action=&gt;'atom', :status =&gt; 302 routesrouting 模組使 Ruby 具有 rewrite URL 網址的能力，這是一種處理 Request 對應到 controller 及 action 的方式。主要是用來取代像是 apache 中 mod_rewrite 規則的功能。而在 Rails 中您可以不用動到 Server 的設定，只要設定 config/routes.rb 即可。 建立路由的核心概念就像是列出一張對應表，對應 Requests 。這張對應表告訴系統該怎麼執行，其中必須要遵循一些規則樣式。 1234Rails.application.routes.draw do # Pattern 1 指定對應的 request 路徑到 controller # Pattern 2 告訴他們去別的地方end 其中路由的功能還包含 helper 來協助生成網址 最基本的 Pattern 1 類似於下面範例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455get '/products/:id', to: 'products#show' # 把 :id 傳入 params 然後把 request 交給 products_controller 的 show action 處理get '/products/:id', to: 'products#show', as: 'product' # 對應單數如此一來會產生 product_path helper# 使用 resources 方式一口氣產出 7 種不同的路由(實際上 patch, put 功能一樣總數有8個)resources :products # 複數# 這種 resources 的方式是透過 http method 搭配 url 組成一系列的路由，把 4 組 url + 5 個 http verbs = 7 組功能# 例如 DELETE /products/17 當 Rails 收到這組 Request 時，就會呼叫 products 的 destroy 並把 params 帶入get '/photos', to: 'photos#index'get '/photos' =&gt; 'photos#index' # 除了用 :to 還可以直接用 =&gt;get '/photos/new', to: 'photos#new'get '/photos/:id', to: 'photos#show'post '/photos', to: 'photos#create'get '/photos/:id/edit', to: 'photos#edit'put '/photos/:id', to: 'photos#update'patch '/photos/:id', to: 'photos#update'delete '/photos/:id', to: 'photos#destroy'# 省略的寫法match 'messages/show' # 相等於 match 'messages/show' =&gt; 'messages#show'match 'messages' =&gt; 'messages#index', :as =&gt; 'index'match &quot;/messages/show/:id&quot; =&gt; &quot;messages#show&quot;, :constraints =&gt; {:id =&gt; /\\d/} # 限制參數# 單數的 resourceresources :post&gt; new_post_path&gt; edit_post_path&gt; post_path# 命名空間的用法namespace :admin do resources :photosend# 這樣的路徑會加上 admin -&gt; /admin/posts# 如果單純想把前面沒有 /admin 的路由對應到 Admin::PostsController 則scope module: 'admin' do resources :postsend# 或者resources :posts, module: 'admin'# 當某個 model 底下有子 model 時如class User &lt; ActiveRecord::Base has_many :orderendclass Order &lt; ActiveRecord::Base belongs_to :userend# 路由得設法resources :users do resources :ordersend render 方法 文件渲染回應給瀏覽器的內容 渲染 action (rendering an action) 123render :action =&gt; &quot;goal&quot;render :action =&gt; &quot;short_goal&quot;, :layout =&gt; falserender :action =&gt; &quot;long_goal&quot;, :layout =&gt; &quot;spectacular&quot;","link":"/2015/04/04/commands/"},{"title":"Compass 使用筆記","text":"Compass Note 4 個關鍵的功能 變數, mixin, 繼承, 巢狀 selector sass 透過變數 $ 來減少重複與達到管理樣式的能力，與 less 的 @ 是一樣的 e.g. $variable 透過 mixin 就可以減少重複 selector ，且一般我們如果要追加某種共用樣式可能要多加一個 class 在 sass 中可以透過 mixin 來處理這個問題 123456789101112ul.horizontal-list { float: left; padding-left: 1em;}#header ul.nav { color: white;}#footer ul.nav { color: black;} 就可以換成 1234567891011121314@mixin horizontal-list { float: left; padding-left: 1em;}#header ul.nav { @include horizontal-list; color: white;}#footer ul.nav { @include horizontal-list; color: black;} mixin 也可以使用參數，把其當作一個 function 來宣告並使用，宣告時用 @mixin 前綴詞，引用時用 @include 透過在 scss 內部加入 @extend 來繼承，繼承的原理就只是把 @extend 的父元素名稱複製一份加到 @extend .list 中的 list 1234567.error { color: red;}.validate-error { @extend: .error;} extend 後面記得是 .class sass 3.2 後有一種 placeholder selector 用 % 就是該 class 是不會輸出的 1234567%base { color: red;}.header { @extend %base;} placeholder selector 的用途是避免多產生多餘的樣式，以免干擾 CSS 如果 placeholder selector 沒有被繼承那麼所有片段程式碼都不會被輸出 簡言之 Compass 是一個 Sass Framework 作用是讓撰寫 Sass 更有效率更快速 就像 Rails 之於 Ruby , Compass 之於 Sass Compass 是由三個主要的部分組成的 mixins, utilities 函式庫 一個和應用程式整合的環境 一個平台用來建置套件和 framework 操作建立專案 1compass create project-name compass 幫你建立了一個 config.rb, sass 目錄, stylesheets 目錄 其中 stylesheets 是用來輸出 css 的地方 compass unpack extension-name 可以把套件解壓縮到專案目錄 extensions/compass stats 查閱目前樣式狀態 @import &quot;compass/reset&quot; 可以載入 Eric Meyer 的 reset.css 而 compass 有把 reset 拆成比較小的 mixin 如: @include reset-body; Grid system 最有名的兩套分別是 Bluepint and 960Grid簡單的說 Grid system 就是透過 columns 和 gutter 來設定欄位和區間，原本你可能需要數學計算分配而透過這些 framework 你只需要指定所佔的欄位數即可。 Compass 支援 Grid system 中的功能把其變成 mixin 於是你就只要在原本具有的語義 class 中 @include 就好如此一來就不需要追加 class Blueprint .container width: 950px column 設定方式為 span-1, span-x 預設共 24 欄 compass 現在已經移除 blueprint 如果要再用需要 gem install compass-blueprint 接著在 config.rb 加入 require &quot;copass-blue&quot; compass 把 blueprint 抽成 mixin 所以只需要在要套用的樣式中 @include column(2) zebra-stripe Table helpers12345678910@import &quot;compass/reset&quot;;@import &quot;compass/utilities/tables&quot;;table { $table-color: #666; @include table-scaffolding; @include inner-table-borders(1px, darken($table-color, 40%)); @include outer-table-borders(2px); @include alternating-rows-and-columns($table-color, adjust-hue($table-color, -120deg), #222222);} 載入 css3 函式庫 123456789@import 'compass/css3';.rounded { @include border-radius(5px);}/* 單個圓角 */.rounded-one { @include border-corner-radius(top, left, 5px);} Sass 的變數是有 scope 的 舊版的 Sass 變數採用 ! 不過因為不好看就改成 $ 當宣告完變數之後本身並沒有任何影響，除非你開始套用變數 CSS 的命名規則是只有 _ 和英文字為開頭後面可用一般英數，使用 - 連接時視為單一字的語意 e.g. $dark-color 而不是 $dark_color 用 _ 則表示兩個單字的語義 在 Sass 中 - 和 _ 是可以互換的 $blue-color 和 $blue_color 都可以指向同一個變數，包含 mixin 和 function 除了變數, mixin, function 之外其他 .class 的地方則不能通用 &amp; 在 nested selector 中代表的是 parent. 所以除了一般 123456789101112/* 除了一般 */.foo { &amp;:hover { color: red; }}&lt;!--也可以--&gt;.foo { .bar &amp; { color: blue; }} selector nesting 還可以用在樣式 1234567891011.nav { border: { color: red; width:1px; style: solid; }}border: 1px solid #ccc { left: 0px; 0pright: 0px;} 在變數後面加上 !default 的意思是如果載入的的檔案中有人先定義了那就不複寫 一般來說在 Sass 中 @import 是說在 compile 時期去把對應的檔案載入一起編譯而不是原來的 CSS import 不過在三種狀況下會使用原來 CSS 的 import 後面接 .css 副檔名 http 的檔案路徑 使用 url() 如果有一隻 CSS 又想要用 sass 的 @import 那就直接把副檔名換成 .scss 在原生 CSS 中所有註解都會顯示但在 sass 中提供一種 silent comments 的機制 // 註解就是 silent comment 一般是不會被輸出的 /*...*/ 則會輸出，不過如果該註解被放在一些地方則不會被輸出 1234body { color /* This won't appear in the CSS */: #333; padding: 1em; /* Nor will this */ 0;} 當需要重複的不再只是單純得值，而是一小段樣式的時候就該使用 mixin 區分何時該用 mixin 何時該用 .class 的區別，通常如果你能夠給一些樣式集一個有意義的名稱且在不同的 .class 中套用那就應該用 mixin e.g. rounded-corner而 .class 是用在 html 裡面的， mixin 適用在 css 裡面的 依照 Sass 的觀念 mixin 用來描述外觀，而 .class 需要有語意 mixin 參數用 , 隔開 12345@mixin link-color($normal, $hover, $visited) { color:$normal; &amp;:hover { color:$hover; } &amp;:visited {color:$visited; }} @include mixin 時參數可以帶名稱和預設值 一直用 mixin 會導致 CSS 越來越大，有效的利用繼承可以減少程式碼 @extend 繼承的功用 1234.disabled { color: gray; @extend a;} 繼承簡單來說就是把被繼承的 selector 複製一份加入繼承元素的 selector group 123456789101112a { color: blue;}.disabled { @extend a;}&lt;!--will turn to --&gt;a, .disabled { color: blue;} @extend 的時候不能指定 .a .b 一次只能指定一個 selector 或 placeholder selector 123456789.a .b { color:red;}.c { @extend .a // 可以 @extend .a.b // 可以 @extend .a .b // 錯誤} 儘量讓 @extend 繼承保持單純不要去 @extend 已經在巢狀內部的 selector 透過 @import 整合成一隻檔案避開傳統 css @import 效能低落的問題 $x: red !default; 預設變數的跟 !important 相反，如果有直就不覆蓋 _ 和 - 可以互相替換，變數, mixin, function 都可以，不過 selector 就不行了 mixin 讓我們可以在 sass 裡面把表現層的語義保留在 sass 內部而不用為了增加外觀樣式追加 .class extend 就是擴展 selector group，盡量不要在多重 nest 中使用 extend ，僅僅在有關係的語義上使用可以避免混亂 Grid system Grid 是從印刷術出現就開始有的近幾年引入 web design 簡單說其目的就是提供統一的欄位與間隔留白讓所有內容遵循規則來達成好閱讀，有設計感的目的 在 web 中 grid 就只是一些簡單的數學除法 用來計算 content 和 container Grid 技術上使用了 3 種東西來設計 column 測量內容的垂直單位, container 容器包含著一個柵格系統, gutter 統一的間距在每個 column 之間 sass 裡面是可以用 for 的用法如下 1234567891011@for $n from 1 to 10 { .span-#{$n} { @extend .column; width: span($n); }}.span-#{$blueprint-grid-columns} { @extend .column; width: span($blueprint-grid-columns); margin: 0;} Sass 跟 Less 一樣都能用 #{$variable} 來取代 selector 或者 properties ceil 無條件進位 floor 無條件捨去 round 四捨五入 compass create project –using blueprint/basic 只建立最基本的 blueprint 只提供 span() 等 function compass create project –using blueprint/semantic 有提供 column 來建立欄位 @include column($content-columns, true); true 是 last 就是沒有 margin-right: 10px 那段 960 Grid 960Grid 和 Blueprint 第一個差異是 960Grid 的 column 兩邊都有 gutter 在 960gs 中 container 變成 container_12 而 span-1 變成 grid_1 在 960gs 不像 blueprint 需要在 row 最後一個 column 加上 last 他會自動斷行，不過如果需要強制斷行就要用 omega 安裝外掛 gem install compass-plugin 接著在 config.rb require compass create project -r x –using 960 其中 -r 是 require 某 lib ，而 --using 是套用某 framework 到該專案 blueprint 用 span() function 和語意版的 column() 來做欄位切分而 960gs 則是用 grid() grid system 還有一個重要的部分就是 vertical rhythm, column 用來做垂直分配 column 而 vertical rhythm 則用來控制水平 row 之間的間距 vertical rhythm 用 compass 來處理 vertical rhythm 第一步就是先載入 `compass/typography” 宣告 $base-font-size base-line-height @include establish-baseline 接著用 @include adjust-font-size-to(48px); 要在上下追加空白 @include leader(2) or @include trailer(1) 底層的原理是透過一樣的計算方式追加 margin leader(2) 裡面的數字是 baseline 的倍數 leader, trailer 用的是 margin padding-leader, padding-trailer 是用 padding 12345678@import &quot;compass/typography&quot;;$base-font-size: 16px;$base-line-height: 24px;@include establish-baseline;h1 { @include adjust-font-size-to(24px);} compass common helpers 其他筆記 table 要消除預設的 border 間距 1234table { border-collapse: collapse; border-spacing: 0;} 載入 reset.css 只要 @import “compass/reset” 或者 12@import &quot;compass/reset/utilities&quot;;@include global-reset; 又或者要個別使用每個小段落 reset-html5 讓 html5 新標籤 display: block; reset-box-model 移除 margin, padding, borders reset-font 設定 font-size 和 line-height reset-focus 移除 outline 例如 input 的樣式 reset-table, reset-table-cell 設定 table 的 border 和 alignment reset-quotation 特別為 blockquotes 設定 截斷文字 12345.truncate { wihte-space:nowrap; overflow: hidden; text-overflow: ellipsis;} 超連結樣式，截斷文字，清單樣式 這些功能都需要先 @import &quot;compass/typography&quot; 最佳實踐關於超連結的 pseudo selector 的順序應該是 a :visited :focus :hover :active 不過 compass 提供的 link-color 的參數是根據開發者常用的習慣 link-colors($normal, $hover, $active, $visited, $focus) 帶參數名稱如下 1234567a { @include link-colors( #333, $hover: #00f, $active: #f00, $visited: #555, $focus: #f00);} 不過根據 80/20 法則我們一般開發時最常用的狀況是 a { @include link-colors(#333, #00f); } 就是設定一般顏色和 hover 顏色而已 a {@include hover-link} 單純在 hover 時幫你的 link 加底線 @include unstyled-link 幫你把連結的樣式全部去除，編譯後的 CSS 如下 1234567p.secret a,p.secret a:hover,p.secret a:focus { color: inherit; cursor: inherit; text-decoration: inherit} List background-position: right 30px bottom 10px 也可以這樣設定 background-position 若用百分比的話不是以外框來計算而是以中心點 在處理圖片清單時因為 IE 的 list-style-image 有 bug 所以一般的做法都是如下 12345ul.features li { background: url(/images/pretty-bullet.png) 5px 5px no-repeat; list-style-type: none; padding-left:20px;} 不過你就需要根據圖片大小計算 background-position (padding - image width)/2 compass 提供了 @include pretty-bullets('pretty-bullet.png') 方法讓你可以快速製作圖片清單 同時也提供 $height, $width, $line-height, and $padding 參數給你設定 12345ul.features { @include pretty-bullets('pretty-bullet.png', $padding: 10px, $line-height: 22px)} 注意在 compass 中我們設定圖片不指定完整路徑只要給 檔名+副檔名即可 mixin 內部 compass 自己有用 image-url helper 因為在 IE 8 以前光用 list-style: none 是無法去除 list 樣式的還要額外加上 list-style-image: none; list-style-type: none; margin: 0;所以 compass 另外提供了 @include no-bullets 來消除樣式 注意無論 pretty-bullets 或者 no-bullets 都有單複數的用法差別是加上 s 會影響所有子元素，不加 s 只會影響一層 @include horizontal-list 可以快速做出水平的清單 horizontal-list($padding, $direction) @include delimited-list 把項目 inline 並且在中間加上 , 1ul.words { @include delimited-list(&quot;! &quot;) } 截斷文字 @include ellipsis; 不換行 @include nowrap text-indent 文字縮排 直接用圖片取代文字 @include replace-text(&quot;coffee-header.png&quot;) replace-text-with-dimensions 根據圖片尺寸修改元素尺寸 Layout helper 要用 sticky footer 和延展元素的 Helper 就需要先載入 compass/layout 果直接用 fixed 把 footer 定在 bottom 在 IE6 會死必須要設定 body height:100%; sticky footer -&gt; @include sticky-footer(40px, &quot;#content&quot;, &quot;#footer&quot;, &quot;#sticky-footer&quot;); #footer 放在 #content 內部是用來撐開內容避免和 #sticky-footer 重疊 stretch 擴展元素 123456a.login { @include stretch(5px, 5px, 5px, 5px) }/* 編譯成 */a.login { position: absolute; top: 5px; right: 5px; bottom: 5px; left: 5px;} css3 要用 css3 功能要先 @import “compass/css3” 舉例來說 @include border-radius(5px) 會幫你把所有瀏覽器的 prefix 都加進去，所以檔案一定會變大，如果要減少你可以設定 1234@import &quot;compass/css3&quot;;$experimental-support-for-opera: false;$experimental-support-for-khtml: false;$experimental-support-for-microsoft:false; 設定成 false，compass 就會忽略不加 prefix @include border-radius(10px); 圓角 line-height 有 5 種方式定義 line-height normal 是第一種預設是 1 - 1.2 inherit 繼承 parent 百分比 px, em 等單位 純數字 這五種定義的方式可以用縮寫跟在 font 後面 123body { font: 100%/normal arial;} CSS 的繼承又分成 絕對繼承和相對繼承 例如 color 在 parent 設定了之後子元素都會繼承，這種稱為絕對繼承 font-sizez 為相對繼承，例如 body 12px 子元素 h1 font-size: 120% 就會拿 12px * 1.2 = 14.4 繼承列表 line-height 的繼承比較複雜 @include text-shadow($color, $x, $y, $blur) mixin 來做陰影 box-shadow 和 text-shadow 都有 mixin 可以用 使用 shadow 時可以設定預設值這樣就不用全部一個一個設定 1234567891011121314$shadow-color:#ccc$shadow-h:5px;$shadow-v:5px;$shadow-blur:0;$default-text-shadow-color: $shadow-color;$default-text-shadow-h-offset: $shadow-h;$default-text-shadow-v-offset: $shadow-v;$default-text-shadow-blur: $shadow-blur;$default-box-shadow-color: $shadow-color;$default-box-shadow-h-offset:$shadow-h;$default-box-shadow-v-offset: $shadow-v;$default-box-shadow-blur: $shadow-blur; 漸層 漸層的顏色方向 0deg 和 360 deg 方向是往上，90deg 往右 順時針以此類推至於顏色的百分比則是到該點前都是這個顏色，顏色的百分比把它當成點即可 在 compass 裡面用漸層如下 12345#pattern { @include background( linear-gradient(360deg, red 0%, blue 100%) )} line-height 繼承的例子1234567891011121314151617&lt;html&gt; &lt;head&gt; &lt;style&gt; body { font-size: 16px; line-height:120%;} h1 { font-size: 32px; } p {font-size: 12px;} #footer { font-size:12px;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt; Level - h1 &lt;/h1&gt; &lt;p&gt; Lorem ipsum dolor sit amet co &lt;/p&gt; &lt;div id='footer'&gt; This is footer foobar. &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 當大家都有 font-size 然後 line-height 在父元素用百分比時如上 16px * 120% = 19.2px 所以底下的子元素都會套用這個 line-height line-height 是設定 content-area 跟 inline-box 是兩個東西 因為繼承的關係所以 line-height 最好用純數字，因為其會根據 font-size 做計算 font-face 可以用來指定字體來源 在 compass 中使用 font-face 123@import &quot;compass&quot;;@include font-face(&quot;FontName&quot;, &quot;FontName.woff&quot;, woff, &quot;FontName.ttf&quot;, ttf) compass 可以透過 PIE.htc 來支援 IE6 以前的瀏覽器使用方法是先安裝 compass install compass/pie 123456789@import &quot;compass/css3/pie&quot;;.pie-element { @include pie-element(relative);}.rounded { @include pie; @include border-radius(20px);} CSS sprites 為什麼要用 sprite 第一點降低下載的次數，第二當 web 需要換圖片路徑時不管網路速度多快還是會閃爍 compass 產的 sprite 只能夠用 png 要用 compass 幫你產 sprites 第一步需要先 @import &quot;compass/utilities/sprites&quot;; 第二步只要 @import &quot;icons/*.png&quot; 只要 import 該目錄底下的圖片即可就可以讓 compass 幫你產 sprite map 的圖片而已，注意不要路徑不要全帶。以 @import “icons/*.png” 這個範例接著 compass 就會去把 images/icons/ 底下的 png 都合體產出一張 icons-xxxxxx.png 的圖片在 /images 中預設 sprites 會用垂直排列的方式 第三步我們要產出 spriting css 就是對應取得圖片的 css ，compass 提供兩種方式產出這些 css @include all-icons-sprites; // 中間是 map name 接著就會全部寫入 css @include -sprite($name) // 前面是 map name 後面參數是要產出的圖片檔名，這種方式不能用在全域只能套用在某個 .class 內部。 通常 map name 就是目錄的名稱 當我們用 @include all-icons-sprites 把所有 css 的樣式產出之後就可以用 icons-filename 去套用該圖片 預設來說 compass 不會幫我們設定 width, height 通常我們在套用 sprite 的時候建議用 @extend ，因為產出是 .class 如果要使用 mixin 就要改成下面的寫法，注意這種方式只會產出內部的 properties 就是樣式 rules單一 mixin 的方式只能寫在 selector 內部 123456@import &quot;compass/utilities/sprites&quot;;@import &quot;icons/*.png&quot;;.add-button { @include icons-sprite(box-add);} 當把圖片放在巢狀目錄內的時候 e.g. images/icons/whats 那麼 sprites 會在該目錄先產出一張圖片命名規則一樣 what-&lt;hashcode&gt;.png，不過 mixin, variable, function 則會用最後一層的目錄名稱 可以使用 map 的名稱即目錄名稱加上屬性來針對該 sprite 設定 12345$&lt;map&gt;-&lt;property&gt;: setting;$&lt;map&gt;-&lt;sprite&gt;-&lt;property&gt;: setting;$&lt;目錄名稱&gt;-&lt;圖片名稱&gt;-&lt;屬性&gt;: 設定值;$icons-spacing: 10px; 注意：這些變數必須被定義在圖片匯入 @import 之前否則他們不會產生效果 $icons-spacing 可以在 sprite 周圍加透明的 padding $icons-repeat: repeat-x; 可以設定圖片是否要重複 compass 不支援垂直重複，所以沒有 repeat-y 可以設定 透過 $&lt;map&gt;-position: 0px 來達到 offset ，注意的是百分比%會跟 CSS 的 position 一樣並不是用最左邊界來計算也就是說如果設定 100% 會剛好貼齊右邊 sprite map layout 除了預設的垂直排列外 compass 還提供了不同的組圖方式 $&lt;map&gt;-layout: vertical/horizontal/diagonal/smart $icons-layout:smart 用 smart ，compass 會用最少的空間去排列組合 sprites 注意一旦使用了 smart 就不能用 position 和 repeat 這兩個屬性只能給 vertical 和 horizontal 使用 compass 預設會自動清除過期或不用的圖片，不過如果你不想清除可以設定 $&lt;map&gt;-clean-up: true/false 預設 compass 產出的 sprite 是沒有帶尺寸的 postion 會自動根據圖片的大小去排列但如果要加上尺寸也是可以如下設定，注意他們是 helper function 不是設定值 123456789&lt;map&gt;-sprite-height($name);&lt;map&gt;-sprite-width($name);@import &quot;icons/*.png&quot;;.next { @include icons-sprite(arrow); width: icons-sprite-width(arrow); height: icons-sprite-height(arrow);} 或者全部都要加上尺寸 $&lt;map&gt;-sprite-dimensions: true/false 當然我們也可以替所有的 sprite 加上基本的樣式 .class 1$&lt;map&gt;-sprite-base-class: &quot;.class-name&quot;; 原理來說每一個 sprite 會 @extend base-class compass 會自動輸出 :hover, :active, :target 等 pseudo selectors 給 sprites 只要檔案名稱結尾符合 _hover _active 只要圖片名稱如上面這樣給定 compass 就會自動幫你產出 :hover 等狀態時的樣式 arrow_hover.png 通常我們只要 @import &quot;icons/*.png&quot; compass 就會自動幫我們產生一張 sprite map 然後伴隨著 mixin, function 等東西，但如果你不想使用這些變數或 mixin 也可以使用 sprite-map($glob)` helper 1$icons: sprite-map(&quot;icons/*.png&quot;, $arrow-spacing: 5px); 如此一來就不用根據 map name 和 sprite name 一個一個設定 在 compass 協助我們產出 sprites map 之後我們仍然需要針對每一個 sprite 撰寫樣式此時我們就能夠用 sprite helper 或者說這個 helper 可以直接讓我們操作底層的東西 1234$icons: sprite-map(&quot;icons/*.png&quot;);.next { background: sprite($icons, arrow) no-repeat;} 模擬底層的運作寫法 sprite-map 函式的意義就是建立一個 map 物件 12345678910$icons: sprite-map(&quot;icons/*.png&quot;);.sprite-base { background: $icons no-repeat;}.next { @extend: .sprite-base; background-position: sprite-position($icons, arrow);}.add-button { @extend .sprite-base; @include sprite-background-position($icons, box-add);} 加入尺寸 1234567@icons: sprite-map(&quot;icons/*.png&quot;);.sprite-base { background: $icons no-repeat; }.next { @extend .sprite-base; @include sprite-background-position($icons, arrow); @include sprite-dimensions($icons, arrow);} compass 提供了三種路徑 helper image-url(‘logo.png’) 從 /root 裡面的 images 目錄開始找 font-url(‘arial.ttf’) 從 /font 目錄找 stylesheet-url 從 /css 或 /stylesheets 目錄開始找 注意到 compass 沒有提供 javascript 的目錄同樣的也沒有 sass 的 helper 透過在 config.rb 加入一些設定可以在 assets 後面追加 query 且使用版號 123asset_cache_buster do |http_path, real_path| &quot;v=1&quot;end 因為在路徑後面加上 query 會導致某些 proxy 不敢 cache 所以也可以關掉 1asset_cache_buster :none 所以正確來說我們會在檔案中加入 time-stamp 或 hash 所以 compass 提供的作法如下 1234567891011121314asset_cache_buster do |path, real_path| if File.exists? (real_path) pathname = Pathname.new(path) modified_time = File.mtime(real_path) new_path = &quot;%s/%s-%s%s&quot; % [ pathname.dirname, pathname.basename(pathname.extname), modified_time.strftime(&quot;%s&quot;), pathname.extname ] {:path =&gt; new_path} endend 即使在開發時期都應該使用 URL 而不是相對路徑，不過 compass 還是提供設定讓你可以快速產生相對路徑 1relative_assets = true http_path 可以快速幫所有路徑修改 URL Path http_path = &quot;/super-fancy-app&quot; 編譯 production 1compass compile --force -e production 一旦加上了 http_path 建議就要把 relative_assets 關閉 1234http_path = '/my-app'relative_assets = falseimages_dir = 'images' #locally it's the images folderhttp_images_dir = 'imgs' #on the webserver it's different 在註解加上驚嘆號就會被強制輸出 123/*! comment here*/ 另外就像 less 一樣變數也可以在字串中，樣式屬性，Selector 使用用法為 #{$variable} 123456$copyright-year: unquote(&quot;2012&quot;);$company-name: unquote(&quot;Example, Inc&quot;);/*! Copyright #{$copyright-year}, #{$company-name} All Rights Reserved.*/ 包含全部網址的設定 1234asset_host do |asset| host_number = (asset.hash % 4) + 1 &quot;//img-#{host_number}.example.com&quot;end compass 也提供一個 method 讓我們可以快速地把圖片轉成 base64 .icon { background: inline-image(&quot;black-dot.png&quot;); } gem install css_parser compass stats 可以觀察目前 selectors 和 css 的狀態 expression 表達式在 sass 中大多用來表示樣式值或屬性 data type 每一個 css property 的值或者變數都有一個型別，依據不同的型別有不同的行為 string 分成有加 &quot; 和 沒有 &quot; ，有加的可以包含除了 “ 以外其他的特殊符號例如 !, 沒有加引號的不能用數字或特殊符號開頭也不能包含空白 * &amp; 除此之外還有一些其他特殊的結構 sass 也是為字串 如 !important 雖然他是用 ! 開頭但 sass 是其為字串 url() 內部得值也被視為 unquoted string number, 單位也會被一併計算 e.g 1em * 2px = 2em*px color 有 hex, rgb, hsl 等方式定義 list e.g. 1px solid black，列表值可以用空白隔開或者 , list 是一系列的值的組合被用在像是 border 或 background 中 boolean 在 sass 中 若比較的兩個值為非布林值則傳回得值跟一般程式不同，e.g blue and red = red, false and red = false, blue or red = blue string, number, color, list, boolean 以上為 Sass 中的型別 當 function 有很多參數時 sass 的 function 可以帶入參數名稱 rgb($green: 127, %blue: 127, $red: 255) abs() 絕對值, ceil() 無條件進位, comparable(1, 2) 傳回 true/false 看兩者是否能夠運算或比較, floor() 無條件捨去, percentage() 把小數轉成百分比, round() 四捨五入, unit() 傳回單位, unitless() 傳回 true/false 看是否有單位 色彩的 function 像是 alpha($color), opacity($color), blue($color), red($color), green($color) 來取得色彩資訊 adjust($color, $red:20, $blue: -20) 調整顏色 red + 20, blue - 20 調淡顏色 adjust(gray, $lightness:15%) scale($color, $lightness: 30%) scale 只能用百分比且不支援 $hue function 的寫法 123@function grid-width($cells) { @return ($cell-width +$cell-padding) * $cells;} 在 #{...} 中 &quot; 會被移除 迴圈的寫法 1234567@for $i from 1 to 5 { ... /* $i 到 4 */}@for $i form 1 through 5 { /* ... 到 5 */} Sass 的 loop 不能一次加2 也不能倒數，不過我們可以透過一些小技巧來達到這個需求 12345678910@for $i from 0 to 10 { $i: 10 - $i; ...}@for $i from 0 through 10 { $i:$ * 2; ...} each 的用法 123456@each $section in home, about, archive, projects { nav .#{section} { ... }} nth($list, $index) 取得列表中的值","link":"/2015/04/04/compass/"},{"title":"Rails 簡易的實作登入","text":"簡易的實作登入1. Create a User model12$ rails g model User name:string password:digest$ rake db:migrate 2. Modify user.rb to have validations of name(account)1234class User &lt; ActiveRecord::Base validates :name, presence: true, uniqueness: true has_secure_passwordend 確保 name 就是帳號是唯一的，然後因為 password 的 type 為 digest 所以預設幫我們使用了 has_secure_password我們知道當我們在註冊的時候表單常常會要求我們輸入兩次密碼以確保我們設定是正確的，這就是 has_secure_password 幫我們處理的部份如果我們使用 scaffold 的話，Rails 會自動在幫我們在 model and view 加上這個，這會告訴 Rails 幫我們驗證兩個 passwords 的欄位接著 view 就會吃 :password, :password_confirmation 兩個參數，如此 model 才會驗證。 在 view 裡面 Rails 會幫我們多一組 password_confirmation 的參數，這個參數實際上並不會建在 db 裡面 3. Gemfile uncomment gem 'bcrypt'1$ bundle install 到了這一步我們的 User model 就有驗證的功能。即 User 可以 user.authenticate接著因為 Rails 會幫我們把 hash 自動從 view 中移除，即不會顯示 password 的資料。所以我們就到 create and update 把導向 :show的部份移除，直接導回首頁。 調整完 view 之後就可以建立 Session controller。會員 controller 單純管理會員資料，而 SessionController 負責管理登入登出 1$ rails g controller Sessions new create destroy 在 session 的 create action 中我們必須要記錄一些資料在 session，好讓我們知道該 user 的身份 我們在 session controller 有三個 action 分別為 new, create, destroy new 用來顯示登入頁面create 用來登入，建立 sessiondestroy 用來刪除 session 登出 4. 登入驗證 in Session#create123456789def create user = User.find_by(name: params[:name]) if user and user.authenticate(params[:password]) session[:user_id] = user.id redirect_to root_url else redirect_to login_url endend 5. 調整 new.html.erb 用來當作登入123456789101112131415161718192021&lt;div class=&quot;depot_form&quot;&gt; &lt;% if flash[:alert] %&gt; &lt;p id=&quot;notice&quot;&gt;&lt;%= flash[:alert] %&gt;&lt;/p&gt; &lt;% end %&gt; &lt;%= form_tag do %&gt; &lt;fieldset&gt; &lt;legend&gt;Please Log In&lt;/legend&gt; &lt;div&gt; &lt;%= label_tag :name, 'Name:' %&gt; &lt;%= text_field_tag :name, params[:name] %&gt; &lt;/div&gt; &lt;div&gt; &lt;%= label_tag :password, 'Password:' %&gt; &lt;%= password_field_tag :password, params[:password] %&gt; &lt;/div&gt; &lt;div&gt; &lt;%= submit_tag &quot;Login&quot; %&gt; &lt;/div&gt; &lt;/fieldset&gt; &lt;% end %&gt;&lt;/div&gt; 6. 登出片段1234def destroy session[:user_id] = nil redirect_to root_url, notice: &quot;Logged out&quot;end 7. 調整 route1234567Sample::Application.routes.draw do controller :session do get 'login' =&gt; :new post 'login' =&gt; :create delete 'logout' =&gt; :destroy endend 8. 綁上 before_action in application_controller.rb1234567891011class ApplicationController &lt; ActionController::Base before_action :authorize private def authorize unless User.find_by(id: session[:user_id]) redirect_to login_url, notice: &quot;Please log in&quot; end endend 9. 不要驗證，在 controller 加上，記住 SessionController 自己本身要加1skip_before_action :authorize, only: :create 注意 before_action and before_filter","link":"/2015/04/04/login/"},{"title":"Ruby 快速筆記","text":"Ruby 快速筆記 Ruby 中的字串需要包在 &quot; 或者 ' 中不過兩者有一點微妙的差別，在雙引號中可以使用逸出字元(\\n \\r \\) 等等，不過單引號會原封不動的輸出除了 \\\\ 例外 在呼叫方法的時候 Ruby 可以省略 () puts 和 print 的差別是 puts 會在行末加上 \\n，如果是用 , 分開不同的參數輸出則每個參數後面都會有 \\n 第三個輸出的 method 是 p ，puts 和 print 不管輸出的是數字或字串都只會顯示內容 1234puts &quot;1&quot; # =&gt; 1puts 1 # =&gt; 1p &quot;1&quot; # =&gt; &quot;1&quot;p 1 # =&gt; 1 用 p 輸出可以得知值的型別，值得注意的是如果用 p 輸出，單引號和雙引號會有差別 因為 p 不會轉譯逸出字元所以雙引號會被直接輸出 123456p &quot;Hello \\n&quot; # =&gt; &quot;Hello \\n&quot;# 但是單引號本來就會直接輸出逸出字元, 如下:puts '\\n' # =&gt; \\n 所以骨子裡是 '\\\\n'# 因此遇上 p 的時候會輸出 `\\\\n`p '\\n' #= '\\\\n' 設定語系 1$ ruby -E utf-8 say_chinese.rb 陣列的多種初始化方式 123456a = Array.new # =&gt; []a = [] # =&gt; []# Array.new(size, default_value)a = Array(2, 3) # =&gt; [3, 3] 取得 User Input 1text = gets.chomp 格式化文字 123&quot;String&quot;.upcase # =&gt; STRING&quot;String&quot;.downcase # =&gt; string&quot;string&quot;.capitalize # =&gt; String 條件控制式 123456789if / elsif / elseif true puts &quot;Yes&quot;elsif true puts &quot;I don't know&quot;else puts &quot;No&quot;end unless 123456789unless false =&gt; excuteunless true =&gt; do nothingunless = if not# unless = if notunless false puts 'It will excute'end while 12345counter = 1while counter &lt; 11 puts counter counter = counter + 1end while true =&gt; 執行 =&gt; false 停止 until false =&gt; 執行 =&gt; true 就停止 for 1234567for num in 1..3 # 1, 2, 3 puts numendfor num in 1...3 # 1, 2 puts numend loop 1234567891011121314151617181920212223loop { print &quot;Hello, World!&quot; }i = 0loop do i += 1 puts i break if i &gt; 5end# 迴圈中 skiploop do i += 1 next if i % 2 == 0 print iendarray.each do |i| puts iend5.times do puts &quot;Ruby!&quot;end 轉字串 11.to_s reverse 陣列的方法，單純反轉 index 1234567891011121314puts &quot;Please input words: &quot;text = gets.chompwords = text.split(' ')frequencies = Hash.new(0)words.each { | word | frequencies[word] += 1}frequencies = frequencies.sort_by{ | word, frequence | frequence }frequencies.reverse!frequencies.each do | word, frequence | puts word + &quot; &quot; + frequence.to_send is_a? 121.is_a? Integer # =&gt; true&quot;string&quot;.is_a? Integer # =&gt; false 確認該值為 Boolean 12# checking whether foo is a boolean!!foo == foo 字串轉 symbol / symbol 轉字串 12&quot;string&quot;.to_sym:symbol.to_s 關於排序 12345678910111213141516arr = [4, 3, 2, 1]arr.sort!arr.sort! { |x, y| x &lt;=&gt; y} # 小到大arr.sort! { |x, y| y &lt;=&gt; x} # 大到小arr.sort! do if x &gt; y 1 elsif x &lt; y -1 else 0 endend# x &gt; y = 1, x &lt; y = -1 時是小到大 Hash 12345678910111213141516171819202122232425262728hash = Hash.new# 設定預設值hash = Hash.new('a default')hash['nonexists'] # =&gt; a defaulthash = {}hash = { &quot;one&quot;: 1}hash = { :one =&gt; 1}hash = { one: 1}hash = Hash[&quot;xxx&quot; =&gt; 1]movie_rating = { iron_man: 4, super_man: 3}good_movies = movie_rating.select { |k, v| v &gt; 2 }movie_rating.each_value { |v| puts v }movie_rating.each_key { | k | puts k } 產出 Range Array 12a_z = (&quot;a&quot;..&quot;z&quot;).to_a[1, 2, 3].zip([4, 5, 6]) #=&gt; [[1, 4], [2, 5], [3, 6]] 計算效能 123performance = Benchmark.realtime do # do your codeend 因為 block 本身不是物件，所以不能夠用變數來存取他。也因此有了 Proc 物件的存在。 Proc 物件的用法可以在加入 method 的參數使用 &amp; 1234567891011121314151617181920212223def greeter yieldendphrase = Proc.new { puts &quot;Hello, Ruby!&quot; }greeter &amp;phrase# 或者直接運行phrase.call# 進階用法把 method 當作 Proc 傳入strings = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]nums = strings.map(&amp;:to_i)# 範例def greeter yield(&quot;your name&quot;)endhi = Proc.new { |name| puts &quot;Hi #{name}&quot; }hi.callgreeter &amp;hi 相等的 methods collect = map to_sym = intern lambda 與 ProcProc 和 lambda 都是物件，大致上行為一致例如: 12lambda { puts &quot;Hello!&quot; }Proc.new { puts &quot;Hello!&quot; } 最主要的兩個差別是 lambda 會確認 arguments 的數量，Proc 不會Proc 會幫你把沒傳入的參數帶入 nil 1234l = lambda {|x, y| puts x }p = Proc.new { |x, y| puts x }l.call(1) # ArgumentError: wrong number of arguments (1 for 2)p.call(1) # Work 第二個最恐怖的差異是 Proc return 之後就不回原本的 method 了控制權由他掌控，而 lambda 會把控制權交回給呼叫的 method yield 指的是呼叫 block 這件事，而 Proc 是用來包 block 的物件，lambda 也是不過骨子裡還是 Proc 物件。&amp; 的意思是把 Proc 或 lambda 轉回 block 所以我們可以這樣用 123456789101112131415def meow yieldendl = lambda { puts &quot;I'm lambda&quot; }p = Proc.new { puts &quot;I am Proc&quot; }meow &amp;lmeow &amp;p# 當要把 block 當作實際參數時則def bark(o) o.callendbark lbark p 歸納 block, Proc, lambda 一個 block 只是一小段程式碼被包在 do ... end 或者 { } 裡面。他本身並不是一個物件，不過他可以被傳進方法(method) e.g each, select, collect, map，由於其不是一個物件所以不能夠直接存進變數中。 一個 Proc 物件可以儲存一個 block，然後我們可以重複使用。 lambda 就跟 Proc 很類似，不過它在乎您傳入的參數的數量，且當 method 呼叫時他會把控制權交回給 method 並不像 Proc 會立即回傳。 123456789101112131415def batman_ironman_proc victor = Proc.new { return &quot;Batman will win!&quot; } victor.call &quot;Iron Man will win!&quot;endputs batman_ironman_procdef batman_ironman_lambda victor = lambda { return &quot;Batman will win!&quot; } victor.call &quot;Iron Man will win!&quot;endputs batman_ironman_lambda 其 Proc 的指標。如果要取得該 Proc 的指標，需要在最後一個參數前面加上 ’&amp;’，這東西只能有一個，且必須放在最後面，否則都會跳出 syntax 123456def f3(n, p) p[n] # call proc p # 'p[n]' is equivalent to 'p.call(n)' # 'yield n' will not work unless a block was given, but notice that the block has nothing to do with parameter 'p'endf3('Tony', Proc.new{|name| puts name}) # 'Proc.new' is equivalent to 'Kernel::proc' &amp; 的意義是當我們把 block 傳進定義的 method 參數時把該 block 轉成 Proc (背地裏是取得該指標) 參考文章 Proc &amp; lambda 百分比符號的用法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849%(interpolated string (#{ &quot;default&quot; })) #=&gt; &quot;interpolated string (default)&quot;# 雙引號的另外一種取代的寫法，當文字裡面有其他雙引號時可以用這種寫法內不會自動幫您把 `&quot;` 轉成 `\\&quot;` 如此一來可以省略反斜線%Q(interpolated string (#{ &quot;default&quot; })) #=&gt; &quot;interpolated string (default)&quot;# (...) 括號可以用其他非英數字元取代如 `!`%Q!Joe said: &quot;Frank said: &quot;#{what_frank_said}&quot;&quot;!%Q[Joe said: &quot;Frank said: &quot;#{what_frank_said}&quot;&quot;]%Q+Joe said: &quot;Frank said: &quot;#{what_frank_said}&quot;&quot;+# 單引號的另一種寫法，不過注意單引號內部不會轉譯會直接輸出%q(non-interpolated string) #=&gt; &quot;non-interpolated string&quot;%q(Joe said: 'Frank said: '#{what_frank_said} ' ') #=&gt; &quot;Joe said: 'Frank said: '\\#{what_frank_said} ' '&quot;# 類似 %Q 的功能不過用在正規式上，該脫曳的字元會自動加上 `\\`%r(#{ &quot;interpolated&quot; } regexp)i #=&gt; /interpolated regexp/i# 空白分開會被轉成陣列，每個元素外圍用雙引號包起來%W(interpolated\\ string #{ &quot;separated by whitespaces&quot; }) #=&gt; ['interpolated string', 'separated by whitespaces']%W(#{foo} Bar Bar\\ with\\ space) #=&gt; [&quot;Foo&quot;, &quot;Bar&quot;, &quot;Bar with space&quot;] # 跟 %W 類似但元素不會編譯或脫曳字元%w(non-interpolated\\ string separated\\ by\\ whitespaces) #=&gt; ['non-interpolated string', 'separated by whitespaces']%w(#{foo} Bar Bar\\ with\\ space) #=&gt; [&quot;\\#{foo}&quot;, &quot;Bar&quot;, &quot;Bar with space&quot;]# 轉成 symbol%s(non-interpolated symbol) #=&gt; :'non-interpolated symbol'%s(foo) #=&gt; :foo%s(foo bar) #=&gt; :&quot;foo bar&quot;%s(#{foo} bar) #=&gt; :&quot;\\#{foo} bar&quot;# 會將內部內容透過子 shell 來執行%x(echo #{ &quot;interpolated shell command&quot; }) #=&gt; &quot;interpolated shell command\\n&quot;","link":"/2015/04/04/ruby-notes/"},{"title":"Jekyll - Psych::Nodes (NameError)","text":"Jekyll 遇到 uninitialized constant Psych::Nodes (NameError)當 jekyll 的環境遇到 Ruby 2.1.x Psych 2.0.10 會出現不相容問題，所以請 1$ gem uninstall psych 參考","link":"/2015/04/04/fix-jekyll-psych-issue/"},{"title":"Carrier Wave 使用筆記","text":"Carrier Wave這套 gem 提供一個簡單且非常彈性的方式來協助 Ruby 程式上傳圖片，同時也能夠跟 Rake base 的程式整合的很好 e.g. Ruby on Rails 安裝 gem 12gem 'carrierwave'&gt; bundle install 建立 uploader 1&gt; rails g uploader Avatar 範例我們加開一個 User 12&gt; rails g model User name bio:text&gt; rake db:migrate 針對已經存在的物件我們加入關聯 12&gt; rails g migration AddAvatarToUsers avatar:string&gt; rake db:migrate 調整 User Model 讓 User 可以取得 carrierwave 處理好的資訊 123class User &lt; ActiveRecord::Base mount_uploader :avatar, AvatarUploaderend 處理 View 123456&lt;%= form_for @user, :html =&gt; {:multipart =&gt; true} do |f| %&gt; &lt;p&gt; &lt;%= f.file_field :avatar %&gt; &lt;%= f.hidden_field :avatar_cache %&gt; &lt;/p&gt;&lt;% end %&gt; 注意 :html =&gt; {:multipart =&gt; true} 要加，還有 controller 中的 permit 要放行。e.g params.require(:user).permit(:name, :bio, :avatar, :avatar_cache) 接下來在 view 中就可以使用 &lt;%= image_tag(@user.avatar_url) %&gt;","link":"/2015/04/04/carrier-wave/"},{"title":"Devise 快速上手","text":"devise 使用筆記Devise 是一套彈性的驗證機制解決方案，它是根據 Warden 為架構的基礎延伸的。Devise 本身具備 支援 rake 架構在 Rails 之上提供完整的 MVC 方案 提供您可以使用多個 Model 在同一時間登入 模組化，您只需要採用您需要的部份 整體是由 10 個模組組成 Database Authenticatable 加密並儲存密碼於資料用以驗證使用者身份。驗證機制可以透過 POST 或者 HTTP 基本的驗證方式 Omniauthable 加入 OmniAuth(https://github.com/intridea/omniauth) 的支援 Confirmable 寄送 Email 與確認機制驗證帳號是否正確與啟用 Recoverable 重設密碼與寄送 Reset 信件 Registerable 處理註冊流程包含帳號本身的編輯與刪除 Rememberable 管理 Token 的產生與清除，這些資訊會被存在使用端的 cookie Trackable 追蹤紀錄登入的次數，時間與 IP Validatable 提供信箱和密碼的驗證機制。此部分並沒有強制使用且可以根據不同的情況客製，您可以自行定義您的驗證機制 Lockable 提供鎖定機制，當帳號不斷登入失敗時會啟用。同時提供 Email 解鎖的機制 Devise 確保能夠在 YARV, JRuby 環境下執行緒安全(Thread-Safe)，簡單的說即在多執行緒的情況下確保變數(通常是全域變數)是正確一致的。 資訊Devise wikiDevise wiki 提供許多關於 Devise 的資料包含 how-to 的文章以及常見問題的答案。當您完成這個 README 文件的閱讀後請記得瀏覽 wiki Bug 回報如果您發現問題，我們希望您能告知我們。然後我們希望當您想要回報時可以遵循一些規範如果您發現關於安全問題的 bug ，請不要使用 Github 上面的 Issue 回報，請直接發 Mail 到 opensource@plataformatec.com.br 郵件列表如果您有任何問題，意見或疑慮，請使用 Google Group 告知我們而不是在 Github 上面開 Issues https://groups.google.com/group/plataformatec-devise RDocs當然您可以查閱 RDoc 格式的 Devise 文件在下面連結 http://rubydoc.info/github/plataformatec/devise/master/frames 如果您需要使用舊版的 Rails 搭配 Devise 您可以在指令介面執行 gem server 來存取舊版的文件。 程式範例這邊有一些程式範例放在 Github 上面，它們展示了 Devise 各種不一樣的功能同時也有搭配不同版本 Rails 的範例，如下面連結 https://github.com/plataformatec/devise/wiki/Example-Applications 套件我們的社群已經建立了很多的擴展套件，它們可以幫您加上其他的功能，您可以參考下面連結根據您的需求使用 https://github.com/plataformatec/devise/wiki/Extensions 貢獻我們希望您可以考慮協作 Devise。如果要執行測試，請進入 Devise 的頂層目錄並執行 bundle install -&gt; rake 為了通過這些測試您會需要使用 MongoDB Server 與 Rails 整合如果您是第一次建立 Rails 應用程式我們建議您不要使用 Devise。Devise 需要您對於 Rails Framework 有足夠的了解。如果是這種情況我們建議您先使用一些簡單的驗證機制 Michael Hartl’s online book Ryan Bates’ Railscast 一旦您對於 Rails 和驗證機制有充足的認識，我們保證 Devise 將會讓您開發更便捷。 入門Devise 3.0 需搭配 Rails 3.2 以上版本。您可以先在 Gemfile 加入: 1gem 'devise' 接著執行 bundle install 安裝它。在完成安裝之後，您需要執行 generator 來自動安裝和變更一些設定 1$ rails genereate devise:install 這個 generator 會安裝一個 initializer 其內容是用來描述所有 devise 的設定。通常您需要查看一下這隻檔案 config/initializers/devise.rb在您完成這個步驟之後您已經可以使用 generator 將 devise 加入到任何 model 1$ rails generate devise MODEL 將 MODEL 的地方取代成您要的 model name ，這個 model 在程式中代表使用者(通常我們使用 User 或者 Admin)。一旦執行該指令會產生一個 model (請確保 model 不重複)以及設定其為預設的 devise 模組。注意：這個指令同時也會設定您的 config/routes.rb 檔案，幫您把路由指定到 devise controller 接著我們檢查 MODEL 看看是否要增加其他的設定，您可能會想要加入像是 confirmable 或 lockable 的功能。如果您開啟這個選項，請記得到 migration 檔案檢查欄位設定，去把適當的屬性註解拿掉，因為 migration 才是實際調整資料庫的地方。舉例來說如果您在 model 中加入 :confirmable 支援那麼就需要去把 migration 中跟 confirmable 相關的部分註解也拿掉。接著執行 rake db:migrate 下一步您需要設定預設的 URL 給 devise 的 mailer 使用，下面提供一個範例設定 1config.action_mailer.default_url_options = { host: 'localhost', port: 3000 } 在完成修改之後需要重啟應用程式，否則您將會看到錯誤訊息。 Controller filters 和 helpersdevise 會幫我們建立一些 helpers 讓我們可以在 controller 和 view 裡面使用。例如要設定一個 controller 需要驗證，只要在 before_action (例如您的 model 叫作 User)加入 12# 限制 controller 的使用權限before_action :authenticate_user! 如果您的 devise model 是其他名稱則把 _user 的部分換掉，例如 model 叫 admin 則換成 authenticate_admin! 下面的 helper 都是以此類推。 12345678# 判斷是否登入user_signed_in?# 取得當前使用者current_user# 存取 sessionuser_session 當使用者執行了登入，啟用帳號，更新密碼之後，devise 會找尋 scope 內的 root_path。具體舉例來說當我們使用了 :user 的 resources就會去找 user_root_path 如果存在就會用它，否則預設會去找 root_path，意思是我們至少需要設定 root_path 12345root to: &quot;home#index&quot;namespace :user do root to: 'home#index' # 路徑會是 /user/home#indexend 您也可以覆寫 after_sign_in_path_for 和 after_sign_out_path_for 到您自訂的 redirect_to 程式碼片段 注意如果您的 devise model 叫 Member 而不是 User 的話，那麼 helpers 會完全不一樣 1234before_action :authenticate_member!member_singned_in?current_membermember_session 設定 Model關於 devise model 內的方法(method) 也允許我們做一些額外的設定，例如您可以選擇加密的演算法 123class User &lt; ActiveRecord::Base devise :database_authenticatable, :registerable, :confirmable, :recoverable, stretches: 20end 除了 :stretches，您還可以定義 :pepper, :encryptor, :confirm_within, :remember_for, :timeout_in, :unlock_in想取得更詳細的資料可以看 initializer 檔案，這隻檔案就是我們執行 rails generate devise:install 時產生的。這隻檔案預設在 config/initializers/devise.rb Strong Parameters 核可參數核可參數提供了一個介面來防止使用者亂送參數，阻止送 Action Controller 的參數被用在 Model 中，除非參數被加到白名單，此外參數也可以被註記為 required 必須。 當您客製化了您的 view，最終您可能要加入新的屬性(attributes)到您的 form。Rails 4 把參數的防護措施從 Model 移到了 Controller，造成 devise 也把處理機制換到了 controller 在 devise 只有三個 action 允許您設定參數是否允許通過傳到 model，這是因為必要的防護機制。它們的名稱和 permitted parameters 允許參數預設值如下 sign_in(Devise::SessionsController#create) - 只允許驗證 key 通過(如 email) sign_up(Devise::RegistrationsController#create) - key 和 password, password_confirmation 三個 account_update(Devise::RegistrationsController#update) - key, password, password_confirmation, current_password 根據您想要放行額外的參數您可以簡單的在 ApplicationController 的 before_action 123456789class ApplicationController &lt; ActionController::Base before_action :configure_permitted_parameters, if: :devise_controller? protected def configure_permitted_parameters devise_parameter_sanitizer.for(:sign_up) &lt;&lt; :username endend 上面這段範例可以協助您增加額外的欄位。如果您需要的是巢狀的屬性(物件)換句話說您正使用 accepts_nested_attributes_for ，這樣的話您就需要告訴 devise 關於這個物件的資訊，devise 讓您可以透過一個 block 來修改預設值 123def configure_permitted_parameters devise_parameter_sanitizer.for(:sign_in) { |u| u.permit(:username, :email) }end 如果您在註冊的時候有一些 checkbox 用來表示使用者的權限(角色)，瀏覽器會把勾選的 checkbox 值當成一個陣列傳入。一個陣列並不屬於核可參數這種情況的話我們可以照下面這樣做 123def configure_permitted_parameters devise_parameter_sanitizer.for(:sign_up) { | u | u.permit({ roles: []}, :email, :password, :password_confirmation)}end 要查詢所有允許的準則和如何宣告內嵌物件和陣列的 permitted keys 請查閱https://github.com/rails/strong_parameters#nested-parameters 另外如果您有多個 devise model 您可能想要針對每個 model 設定不同的防護機制，這種情況下我們建議您直接繼承 Devise::ParameterSanitizer 12345class User::ParameterSanitizer &lt; Devise::ParameterSanitizer def sign_in default_params.permit(:username, :email) endend 然後直接在 controller 內直接使用 1234567891011class ApplicationController &lt; ActionController::Base protected def devise_parameter_sanitizer if resource_class == User User::ParameterSanitizer.new(User, :user, params) else super # Use the default one end endend 上面這個範例覆寫了 User model 允許的參數，這樣 :username 和 :email 都會放行。 設定 views官方建立了 devise 來協助您快速的開發讓您的程式具有驗證機制，然而並不是所有的狀況都剛好適用預設值，您可能會希望客製一些東西。因為 devise 屬於一個引擎，所有的 view 都被打包在 gem 內部。這些 view 可以幫助您快速的開始，不過隨後您可能會希望修改它們，在這種情況下您可以調用下面的指令把 view 從 gem 複製出來 1$ rails generate devise:views 如果您有超過一個的 devise model (例如 User 和 Admin) 您會注意到 devise 所有 model 都使用相同的 view ，幸運的是 devise 提供一個簡單的方法來自訂這些 views您只需要在 config/initializers/devise.rb 中設定 config.scoped_views = true 之後您就可以根據角色如 users/sessions/new, admins/sessions/new 提供不同的 views。如果在 scope 找不到 view，devise 會使用預設在 devise/sessions/new 的 view。 或者您可以使用 generator 來產生 1$ rails g devise:views users 如果您想要只產生部分的 views 例如 registerable 和 confirmable 模組，您可以傳入參數 -v 1$ rails g devise:views -v registrations confirmations 設定 controller如果客製 view 的層級還不夠您使用，您甚至可以自訂 controller 如下 1. 建立您的 controller1$ rails generate devise:controller [scope] 如果您設定 users 來當作 scope 那麼 controllers 將會被建立在 app/controllers/users/ 目錄下，而這些 session controller 會如下 1234567class Users::SessionsController &lt; Devise::SessionsController # GET /resource/sign_in # def new # super # end ... end 2. 設定 routes1devise_for :users, controllers: { sessions: &quot;users/sessions&quot; } 3. 從 devise/sessions 複製 views 到 users/sessions。因為 controller 已經被修改了，所以沒辦法使用預設的 devise/sessions 的 view4. 最後，修改 controller 的 actions12345class Users::SessionsController &lt; Devise::SessionsController def create # custom sign-in code endend 或者您也可以簡單呼叫父類別的行為 1234567class Users::SessionsController &lt; Devise::SessionsController def create super do |resource| BackgroundWorker.trigger(resource) end end end 注意 devise 會使用 flash message 來讓使用者知道操作的結果。devise 預設您的程式會呼叫 flash[:notice] 和 flash[:alert] 設定路由devise 也提供預設的路由。如果您需要自訂他們，您可以透過 devise_for 方法。它提供了一些參數像是 class_name, path_prefix 等等 1devise_for :users, path: &quot;auth&quot;, path_names: { sign_in: 'login', sign_out: 'logout', password: 'secret', confirmation: 'verification', unlock: 'unblock', registration: 'register', sign_up: 'cmon_let_me_in' } 您可能會需要根據 i18n 修改路徑 您可以再參考文件來瞭解更多關於 devise_for 的用法 如果您有需要在做更多的設定例如除了 /users/sign_in 還允許 /sign_in 可以做登入的動作，您只需要建立一個路由 123devise_scope :user do get &quot;sign_in&quot;, to: &quot;devise/sessions#new&quot;end 這樣一來您就多了一個 /sign_in 可以存取了 I18ndevise 在 flash messages 使用了 i18n ，即您在 flash[:notice] 和 flash[:alert] 中的訊息是多國語系的，如果要針對訊息客製您可以在 local file 定義 1234en: devise: sessions: signed_in: 'Signed in successfully.' 您也可以根據 resources 區分不同的訊息，注意 scope 是單數 1234567en: devise: sessions: user: signed_in: 'Welcome user, you are signed in.' admin: signed_in: 'Hello admin!' devise mailer 使用簡單的格式來建立標題訊息 12345678en: devise: mailer: confirmation_instructions: subject: 'Hello everybody!' user_subject: 'Hello User! Please confirm your email' reset_password_instructions: subject: 'Reset instructions' OmniAuthdevise 同時支援 OmniAuth 讓您可以使用一些外部的驗證機制，要使用它們只需要把 config/initializers/devise.rb 的設定註解拿掉即可 1config.omniauth :github, 'APP_ID', 'APP_SECRET', scope: 'user,public_repo'","link":"/2015/04/04/devise/"},{"title":"CentOS Rails 環境安裝","text":"CentOS Rails 環境安裝安裝 Apache &amp; PostgreSQL 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213$ service --status-all # 檢查服務運行的狀態$ yum list installed # 檢查已安裝的 yum packages$ yum install httpd # 安裝 apache$ yum install postgresql postgresql-server postgresql-devel postgresql-libs # 安裝 PostgreSQL，注意沒裝 devel 和 libs 裝 gem 時會出錯。# 第一次啟動如果炸掉 ERROR: `/var/lib/pgsql/data is missing. Use “service postgresql initdb” to initialize the cluster first.`$ service postgresql initdb# 如果又遇到 Initializing database: mkdir: cannot create directory `/var/lib/pgsql/data/pg_log': File exists$ rm -rf /var/lib/pgsql/data/pg_log # 把 log 刪除$ service postgresql start # 啟動 PostgreSQL$ chkconfig postgresql on # 設定開機後自動啟動# 修改 /var/lib/pgsql/data/pg_hba.conf (預設路徑)# local all all ident sameuserlocal all all trust# host all all 127.0.0.1/32 ident sameuserhost all all 127.0.0.1/32 md5# 註：md5 和 trust 差別在於 trust 允許在本機不用輸入密碼來登入資料庫。# 由於變更設定檔需要 reload$ su - postgres$ pg_ctl reload$ psql # 進入介面開 table 或建立 users 權限# 列出 database$ \\list$ \\l# 連線該 db$ \\connect [database_name]# 重設密碼$ \\password# 在 command line 裡分成兩種方式一種是先切換成 postgres 使用者身份直接下指令，另一種是登入 psql 後下 sql 指令# 預設 PostgreSQL 只允許本機上的 user 和 PostgreSQL 中 role name 相同的帳號不用密碼登入# 預設只有 db 的 owner 可以操作裡面的東西(不包含 superuser)# 建立 db role$ createuser test_user # 這種方式會有精靈讓你選權限# SQL下指令記得加 ;# 建立 db role (SQL)$ create role [rails_user] with createdb login password 'password here';# 修改 role (SQL)$ alter role [rails_user] with createdb login password 'password here';# 列出所有使用者的權限$ \\du# 顯示所有 roles 名稱(SQL)$ select rolname from pg_roles;# 查看 table 權限$ \\z# 列出所有 table$ \\dt# 當前的使用者$ select current_user;# 當前連線的 db$ select current_database();# 離開 psql$ \\q# 檢查 PostgreSQL status$ service postgresql status# 移除 db (OSX)$ rm /usr/local/var/postgres/postmaster.pid$ dropdb rbase_test# 在 SQL 中移除 db$ drop database if exists [database name]# 列出 tables$ \\dt# 建立新資料庫$ CREATE DATABASE mydb;# 建立使用者$ CREATE USER andy with password 'p@ssw0rd';$ createuser test --interactive -P # 含建立密碼 + 權限# 連線資料庫$ \\c database# 建立 table 範例CREATE TABLE films ( code char(5) CONSTRAINT firstkey PRIMARY KEY, title varchar(40) NOT NULL, did integer NOT NULL, date_prod date, kind varchar(10), len interval hour to minute);# 列出 table schema$ \\d+ [tablename]# 刪除 tableDROP TABLE IF EXISTS table;# 插入資料INSERT INTO films VALUES('UA502', 'Bananas', 105, DEFAULT, 'Comedy', '82 minutes');INSERT INTO films (code, title, did, date_prod, kind)VALUES ('T_601', 'Yojimbo', 106, DEFAULT, 'Drama'),('HG120', 'The Dinner Game', 140, DEFAULT, 'Comedy');# 選取 table 大小和隨機的指數SELECT relname, reltuples, relpages FROM pg_class ;# select size of tables and indices in descending order of sizeSELECT relname, reltuples, relpages FROM pg_class ORDER BY relpages DESC ;# select size of tables and indices in descending order of tuple- / recordcountSELECT relname, reltuples, relpages FROM pg_class ORDER BY reltuples DESC ;# 修改密碼$ su - postgres$ psql template1$ alter user postgres with password 'postgres_password';# 列出使用者SELECT * FROM &quot;pg_user&quot;;# change user for all tablesfor tbl in `psql -qAt -c &quot;select tablename from pg_tables where schemaname = 'public';&quot; YOUR_DB` ; do psql -c &quot;alter table $tbl owner to NEW_OWNER&quot; YOUR_DB ; done# change user for all seqsfor tbl in `psql -qAt -c &quot;select sequence_name from information_schema.sequences where sequence_schema = 'public';&quot; YOUR_DB` ; do psql -c &quot;alter table $tbl owner to NEW_OWNER&quot; YOUR_DB ; done# change user for all viewsfor tbl in `psql -qAt -c &quot;select table_name from information_schema.views where table_schema = 'public';&quot; YOUR_DB` ; do psql -c &quot;alter table $tbl owner to NEW_OWNER&quot; YOUR_DB ; done# 複製資料庫create database NEWDB with template OLDDB;# 修改 DB owner/nameALTER DATABASE name RENAME TO newnameALTER DATABASE name OWNER TO new_owner# Showing transaction status in the psql prompt$ \\set PROMPT1 '%/%R%x%# '# from http://sql-info.de/postgresql/notes/transaction-status-in-the-psql-prompt.html# 列出資料表欄位SELECT attname FROM pg_attribute, pg_typeWHERE typname = 'table_name'AND attrelid = typrelidAND attname NOT IN ('cmin', 'cmax', 'ctid', 'oid', 'tableoid', 'xmin', 'xmax');# 備份 / 還原 使用 Dump# 備份$ pg_dump dbname &gt; outfile$ pg_dump dbname | gzip &gt; filename.gz# 還原$ psql dbname &lt; infile$ createdb dbname &amp;&amp; gunzip -c filename.gz | psql dbname# 更新$ update auth_user set is_superuser = 't' where username='abhiomkar';```[完整 PostgreSQL 建立 ROLE 教學](https://www.digitalocean.com/community/tutorials/how-to-use-roles-and-manage-grant-permissions-in-postgresql-on-a-vps--2)[OSX PostgreSQL Installing](https://marcinkubala.wordpress.com/2013/11/11/postgresql-on-os-x-mavericks/)[OSX 簡易控制 PostgreSQL](http://robots.thoughtbot.com/starting-and-stopping-background-services-with-homebrew)## 安裝 Rails```# 1. 安裝 git$ yum install curl-devel expat-devel gettext-devel \\ openssl-devel zlib-devel# 取得原始碼 https://www.kernel.org/pub/software/scm/git/$ wget https://www.kernel.org/pub/software/scm/git/git-2.2.0.tar.gz$ tar -zxf git-2.0.0.tar.gz$ make prefix=/usr/local all # 注意換路徑不需要加到 bin$ sudo make prefix=/usr/local install? Ruby with Readline 尚未測試成功# 2. 安裝 Ruby$ yum install -y gcc openssl-devel libyaml-devel libffi-devel readline-devel zlib-devel gdbm-devel ncurses-devel$ wget http://cache.ruby-lang.org/pub/ruby/2.2/ruby-2.2.0.tar.gz$ tar -zxvf ruby-2.0.0.tar.gz$ ./configure$ make &amp;&amp; make install$ gem install bundler# 安裝 Rails 之前先安裝 sqlite3$ yum install sqlite-devel$ yum install readline-devel$ gem install rails$ cd [YOUR_PROJECT]$ bundle install 常見問題日文完整教學","link":"/2015/04/04/deploy/"},{"title":"歡迎使用 Jekyll","text":"哈囉 jekyll ！這是一篇展示的文章。使用 Markdown 格式所撰寫 1234567def print_hi(name) puts &quot;Hi, #{name}&quot;endprint_hi('Tom')#=&gt; prints 'Hi, Tom' to STDOUT. 1234def print_hi(name) puts &quot;Hi, #{name}&quot;endprint_hi('Tom') 123456$ jekyll build$ jekyll build --watch$ jekyll build --source &lt;s&gt; --destination &lt;d&gt;$ jekyll serve$ jekyll serve --watch$ jekyll serve --port 8000 超連結用法 Jekyll docs for more info on how to get the most out of Jekyll. File all bugs/feature requests at Jekyll’s GitHub repo. If you have questions, you can ask them on Jekyll’s dedicated Help repository. 副檔名列表 程式語言縮寫 Rouge 支援語言列表 Try to use default markdown def say_hello puts &quot;Hello, Ruby&quot; end","link":"/2015/04/04/welcome-to-jekyll/"},{"title":"rake db 常用指令備註","text":"123456789101112$ rake db:create # Create the database from DATABASE_URL or config/database.yml for the current Rails.env (use db:create:all to create all dbs in the config)$ rake db:drop # Drops the database using DATABASE_URL or the current Rails.env (use db:drop:all to drop all databases)$ rake db:fixtures:load # Load fixtures into the current environment's database$ rake db:migrate # Migrate the database (options: VERSION=x, VERBOSE=false)$ rake db:migrate:status # Display status of migrations$ rake db:rollback # Rolls the schema back to the previous version (specify steps w/ STEP=n)$ rake db:schema:dump # Create a db/schema.rb file that can be portably used against any DB supported by AR$ rake db:schema:load # Load a schema.rb file into the database$ rake db:seed # Load the seed data from db/seeds.rb$ rake db:setup # Create the database, load the schema, and initialize with the seed data (use db:reset to also drop the db first)$ rake db:structure:dump # Dump the database structure to db/structure.sql$ rake db:version # Retrieves the current schema version number","link":"/2015/04/06/rake-t/"},{"title":"Psql 學習記錄","text":"何謂 psqlpsql 是讓我們可以操作 Postgres SQL 的指令介面。其包含著一大票的參數設定，不過這篇記錄只會紀錄我工作時比較常用到的部分 OK! 首先是當我們安裝好 Postgres 之後怎麼連線 連線 -h 代表要連線的 host，以本機來說就是 localhost -U 要登入的帳號 使用 –username 等價 -W 登入帳號的密碼 使用 –password 等價 -w 不使用密碼 -p PORT 號 –port 等價 (預設: 5432) -d 資料庫名稱 –dbname= 等價 小提醒：縮寫的參數後的值只需要隔一個空白則可，但全名(–dbname, –username) 可以加上 = 或不加。但縮寫不可以加上 = 1234$ psql -h localhost -U andyyou database_name# 完整版psql &quot;dbname=your_dbname host=your_host user=andyyou password=12345678 port=5432 sslmode=require&quot; 如果您想使用 GUI 的話 PGCommander 可能是目前最好用的工具。不過這邊我們希望把指令學起來，如此當下次需要在遠端伺服器執行任務時就可以派上用場。 登入後確認當前使用者1$ select current_user; 離開123$ \\q# 或者 CTRL + d 求助如果記不住指令的時候只要記得下 --help 參數即可 123456# 指令介面下$ psql --help# 已經登入 postgres 之後$ \\?$ \\help 操作資料庫一般來說只要記住 \\? 進到指令介面在查要用的指令即可。不過這邊還是把我常用的列出來 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293# 修改密碼$ alter user user_name with password 'new_password';# 列出所有資料庫$ \\l# 列出所有 Tables$ \\d# 顯示表格資訊$ \\d table_name# 列出 table schema$ \\d+ [tablename]# 列出使用者SELECT * FROM &quot;pg_user&quot;;# 列出所有角色 + 權限$ \\du# 列出該 db schema 與角色的權限$ \\dn+# 列出當前使用者SELECT current_user;# 授權$ grant all on schema public to public;# 移除 db (OSX)$ rm /usr/local/var/postgres/postmaster.pid$ dropdb rbase_test# 在 SQL 中移除 db$ drop database if exists [database name]# 列出 Table/View 權限$ \\dp# 建立使用者$ CREATE USER andy with password 'p@ssw0rd';$ createuser test --interactive -P # 含建立密碼 + 權限# 連線資料庫/切換資料庫$ \\c database# 建立新資料庫$ CREATE DATABASE mydb;# 刪除 tableDROP TABLE IF EXISTS table;# 建立 table 範例CREATE TABLE films ( code char(5) CONSTRAINT firstkey PRIMARY KEY, title varchar(40) NOT NULL, did integer NOT NULL, date_prod date, kind varchar(10), len interval hour to minute);# 插入資料INSERT INTO films VALUES('UA502', 'Bananas', 105, DEFAULT, 'Comedy', '82 minutes');INSERT INTO films (code, title, did, date_prod, kind)VALUES ('T_601', 'Yojimbo', 106, DEFAULT, 'Drama'),('HG120', 'The Dinner Game', 140, DEFAULT, 'Comedy');# 備份 / 還原 使用 Dump# 備份$ pg_dump dbname &gt; outfile$ pg_dump dbname | gzip &gt; filename.gz# 還原$ psql dbname &lt; infile$ createdb dbname &amp;&amp; gunzip -c filename.gz | psql dbname# 更新$ update auth_user set is_superuser = 't' where username='abhiomkar';# 顯示所有 roles 名稱(SQL)$ select rolname from pg_roles;# 查看 table 權限$ \\z# 移除 db (OSX)$ rm /usr/local/var/postgres/postmaster.pid$ dropdb rbase_test pg_hba.conf 在哪裡？/var/lib/pgsql/data/pg_hba.conf (Linux 預設路徑)/usr/local/var/postgres/pg_hba.conf (OSX 預設路徑) 善用 find 指令 查詢檔案名稱 1$ find / -name 'pg_hba.conf' 查詢檔案名稱 (不區分大小寫) 1$ find / -iname 'pg_hba.conf' 查詢檔案名稱 (指定目錄) 1$ find /usr -name 'pg_hba.conf' 只搜尋檔案 1$ find /usr -name 'pg_hba.conf' -type f 只搜尋目錄 1$ find /usr -name 'postgres' -type d 忘記密碼的解法1. 找到 pg_hba.conf2. 備份一份起來3. 修改設定1local all all trust 4. 重啟一般在 OSX 下我習慣都用 brew 可以多裝一套 brew services 123$ brew services start postgresql$ brew services restart postgresql$ brew services stop postgresql 5. 現在任何 User 登可以登入了1$ psql -U postgres 6. 重設定密碼1$ ALTER USER user_name with password 'new_password'; 7. 換回原來設定8. 重啟無法刪除 dbDETAIL: There is 1 other session using the database. 麻煩請找找是否有 GUI 軟體或其他 Session 正在連線。 無法連線的狀況錯誤訊息 123psql: could not connect to server: Connection refused Is the server running locally and accepting connections on Unix domain socket &quot;/tmp/.s.PGSQL.5432&quot;? OSX 環境下解法 1$ rm /usr/local/var/postgres/postmaster.pid","link":"/2015/04/06/psql-notes/"},{"title":"使用 Javascript 取得元素的座標","text":"前言由於使用 Javasript 偵測元素尺寸的方式並不直覺，每個元素有 6 個 DOM 的尺寸的屬性 offsetWidth, offsetHight, clientWidth, clientHeight, scrollWidth, scrollHeight。再加上 offset[Top | Left], scroll[Top | Left], client[Top | Left] 等方向距離的屬性導致這件事變得異常複雜，外加它們都是整數因此在一些操作上會有些誤差。在開始之前對於那些急性子的人我先提供他們一些對於座標屬性的整理，您可以先大略看過這些整理，後面我們將針對一個實際的例子來練習，這些整理應該可以讓一些老手快速的回復記憶，其實就是因為這樣所以我才紀錄了這篇文章。 先附上兩張圖式 CSS Box 為 content-box 時的情況(下面為 HTML DOM 屬性) offsetWidth/offsetHeight: 元素 Box Model 總寬高 (width + padding + border) 在 box-sizing: content-box; 時 width = content area width 範例 不管是否超出父元素限制範圍都是總寬高 clientWidth/clientHeight: 一般情況下即元素 Box Model 可視區的 width + padding 可視區 只針對取值的元素本身，以元素本身的角度出發，意思是當我們限制元素寬高時只有能看見的部分會列入計算，扣掉 scrollbar width 如果有個子元素超過自己的寬高則 clientWidth 和 clientHeight 仍然是 width + padding 範例 scrollWidth/scrollHeight: 整個框內的總寬高 元素本身的 padding + 內部元素寬高， 舉例 (scrollHeight) 會是self_padding + children_margin + children_border + children_padding + children_height 範例 offsetTop/offsetLeft: 定義 elem.offsetTop 為唯讀的屬性，會回傳目前元素與 offsetParent 元素的距離 當 position 為 static (沒設定預設是 static) 時 offsetParent 就會是根節點(root) 或是外層結構中最接近的 table cell 元素。其他有 position 的屬性( fixed, absolute, relative)都會讓被設定的外層元素變成 offsetParent 計算元素和 offsetParent 的距離 =&gt; 從元素本身的 margin + offsetParent 的 padding 當元素 CSS 有 display: none; 時，offsetParent 為 null 範例 clientTop/clientLeft: 單純就是 border 寬度 定義為回傳該方向的 border 寬度，單位用 px 該屬性不包含元素的 padding 或者 margin 用 document.getElementById(&quot;elem&quot;).style.borderTopWidth 這類方法取得一樣的值 scrollTop/scrollLeft: 如果該目標元素沒有 scrollbar 則值為 0 例如: 沒有 y 軸 scrollbar 則 scrollTop = 0 從元素 border 內緣開始計算，scrollTop 與 scrollLeft 是取有捲軸的那個元素捲到哪 按照規定 scrollTop 不會小於 0 但是在 OSX 下的 Chrome 和 Safari 可能會產生負值。 範例 CSS Box 為 border-box 時的情況 offsetWidth/offsetHeight: 由於 border-box 的關係 css 設定的 width 會等於總寬。 注意: 在 border-box 模式下 width 不等於 content area 的寬，而是整個 block (不含 margin) clientWidth/clientHeight: border-box 狀態時算法變成從外面減回去 width - border = content area + padding scrollWidth/scrollHeight: 取得值沒有差異，雖然是往內扣但該有的 padding 還是存在。 offsetTop/offsetLeft: 取得值沒有差異 clientTop/clientLeft: 取得值沒有差異 scrollTop/scrollLeft: 取得值沒有差異 理解 Javascript 與 DOM 座標雖然大部份的開發者對於 CSS 的 Box Model 與排版操作十分熟悉不過當我們想要使用 Javascript 來操作這些位置的時候可能會遇到障礙。問題通常出在如何準確擷取到您要的座標資料，一般來說元素本身的座標(排版位置)都不是您直接定義，而是被父元素的 float, padding, margin, position 等等屬性所影響。極少的情況下才會設定絕對位置的 x, y。 為了能夠精準的控制位置，我們得先知道元素的 x, y 座標。會搞得這麼複雜的原因是因為 HTML DOM API 或 Javascript 並沒有內建的功能來處理這些任務。 在這份簡短的教學中，您會學到如何取得 HTML 元素精準的座標和背後的原理。 我們有一個需求在我們開始寫程式之前讓我們先假設遇到一個需求 - 我們想要取得 HTML 元素確切的 x, y 座標。 一般來說，所有的座標設定的行為都需要一個相對的起始點，通常我們會拿 document 最左上角的點來當對應的起始點。而我們放的位置點則對應到元素的最左上角。 現在問題來了您的 HTML 文件並不是一張 bitmap 或者 canvas。如同前面所提到的 HTML 和 Javascript 並沒有一套內建的機制處理這種情形。所以我們需要參考其他元素的相關設定或樣式來得到這個座標，因為他們通常都是透過一堆 CSS 樣式來排版的。接著讓我們透過一個範例來理解其中是如何運作的，最後我們將融會貫通這些技巧來完成我們的需求。 取得座標的程式碼當我們使用原生 Javascript 要取得 HTML 元素的 x ,y 的座標範例如下 123456789101112function getPosition (element) { var x = 0; var y = 0; // 搭配上面的示意圖可比較輕鬆理解為何要這麼計算 while ( element ) { x += element.offsetLeft - element.scrollLeft + element.clientLeft; y += element.offsetTop - element.scrollLeft + element.clientTop; element = element.offsetParent; } return { x: x, y: y };} getPosition 這個 function 會取得 HTML 元素在 document 中的位置並回傳一個包含 x, y 的物件。 下面則示範了如何使用 123var elem = document.querySelector('img');var position = getPosition(elem);alert(&quot;座標: &quot; + position.x + ', ' + position.y); 上面我們使用了 querySelector 函式來找到我們要的元素，其他原生的函式包含 getElementById, getElementByTagName, getElementByClassName。又或者您可以使用 jQuery 的 $( &quot;.girl&quot; )[ 0 ] 來取得元素的 DOM。 範例運作的狀況為了看看上面這段範例程式碼的效果您可以直接連到 範例 範例中的提示框會告訴我們元素座標，如果您去量測瀏覽器的 viewport 可視區域的左上角到該圖片的左上角會如下得到準確的座標，注意 border 不會算在其中。 我們簡單的示範了最單純的例子但是實務上總不是那麼容易。 背後的原理對大多數的狀況來說一個元素的位置取決於自己的 CSS 樣式，不過更多的部分是受到父元素樣式的影響。這些樣式包含了 padding, margin, border ，同時再加上 position 那事情就變得越來越亂了。 小技巧記得直接用瀏覽記得工具來協助計算 解析取得座標的程式碼對於上面的程式碼您應該有個概略的理解，但實作的時候您必須要精準的理解每個片段才行。現在讓我們來認真看看這些程式碼是怎麽運作的 首先再複習一下剛剛取得座標的程式碼 12345678910111213function getPosition (element) { var x = 0; var y = 0; // 搭配上面的示意圖可比較輕鬆理解為何要這麼計算 while ( element ) { x += element.offsetLeft - element.scrollLeft + element.clientLeft; y += element.offsetTop - element.scrollLeft + element.clientTop; // 這邊有個重點，當父元素被下了 position 屬性之後他就會變成 offsetParent，所以這邊我們用迴圈不斷往上累加。 element = element.offsetParent; } return { x: x, y: y };} 第一步是 function 的部分 1function getPosition(element) 我們定義了一個 getPosition 函式，有一個參數 element ，如您從剛剛的用法我們把要取得座標的元素(DOM物件)傳進去。 接著我們定義了兩個座標 x, y 並且初始化為 0 12var x = 0;var y = 0; 這兩個變數會被用來儲存 x, y 座標，因為 offset[Top/Left] 取的是該元素和 offsetParent 的距離，當我們沒有使用 position CSS 規則時 offsetParent 會是 root 或 外層結構中離元素最近的 table cell (在 HTML 標準兼容模式中 root 為 body)，另外一旦您對元素設定了 display: none; 那麼 offsetParent 就會回傳 null。 原來 offset[Top | Left] 並不是像我們一開始認為的直接算出到最左上角的距離，是和 offsetParent 的距離。意思是當外層的結構有元素套用了 position: absolute; 或 relative 等等的時候 offsetParent 就換人了，static 則維持預設。 繼續回到我們的程式碼，因為 offsetParent 不會永遠是 root 所以這邊我們用了一個小小的技巧 123456// 現在您懂了為什麼我們要在這邊用 while!!while(element) { x += (element.offsetLeft - element.scrollLeft + element.clientLeft); y += (element.offsetTop - element.scrollTop + element.clientTop); element = element.offsetParent;} 透過 while 先計算丟進來的元素跟 offsetParent 的距離，如果遇到這個元素有參考 offsetParent 我們就用 element = element.offsetParent 往外一層一層加上去直到 root 為止。 讓我們再更深入探討，稍早我曾提到排版會受到 padding, margin, border 影響。單純看這些屬性本身並不複雜但是混在一起使用時那就真的是災難。 Offset 屬性關於 offsetLeft 和 offsetTop 剛剛上面有提過它就是回傳元素和 offsetParent 之間的距離。 舉例來說當父元素設定了 position: absolute; 那麼我們得到的 offset[Top | Left] 就會是從該元素的 margin 再加上 offsetParent 元素的 padding 所以 offsetParent 元素 border 以內的 block 都被計算了，我們上面就是接著利用 while 把外層的這個元素做一樣的動作。一直做到 root 結果就是我們會得到元素到 root 之間的距離 等等！不要忘記 border由於 border 在 CSS Box Model 中歸屬於 block 內部，所以這段 offset 距離中其實並沒有包含元素的 border 我們可以透過 client[Top | Left] 把它加進去，這樣才是我們要的。用 document.getElementById(&quot;elem&quot;).style.borderTopWidth 這種方法取得值等價。 做到這一步幾乎可以處理所有的狀況，不過還有一個萬惡的捲軸。 Scrolling 捲軸的部分如果您設計的 block 可以捲動，一般來說就是父元素限制了寬高且 overflow: auto; ，但內容的寬高卻超過了這個尺寸，此時您的內容的確是在父元素內部，但取得的座標卻不是我們要的 - 從看到的元素左上角到 root 左上角為了取得這個座標於是我們要把 scrollTop 扣掉。直接看圖比較快 最後呢! 回傳 x, y 1return { x: x, y: y }; 進階範例最後我們透過這個進階的範例 將 position, border, margin, padding 混在一起，透過練習請確定您知道每個部分的值是怎麼得到的。 另外我知道這麼多規則很難記住，所以我整理了上面的總結，您可以在忘記的時候對照一下圖片和規則。 補充在 jQuery 中 $(element).offset() 我們取得的是元素到 document 之間的距離( 自己的 margin 到 document)。但是當元素設定 position: fixed 時取得的值可能不正確。因為當 document 大於 viewport ，就是內容很長，當你捲到底下的時候 fixed 的元素取到的 offset() 會大於你所期待的值。 此時如果要取 fixed element 相對於 viewport 的位置則用 1$(&quot;#el&quot;).offset().top - $(document).scrollTop(); 參考StackOverflowGet an Element’s Position Using JavaScript","link":"/2015/04/07/get-an-element-s-position-by-js/"},{"title":"CSS 背景圖片排版","text":"使用 CSS 套用背景圖片到元素中可能是您前端設計過程中最常用到的功能。background 有非常豐富的屬性，讓我們可以針對不同的需求做設定。 同時一個元素可以具有多張背景圖片。如果您想要套用多張圖片您可以直接在 background-image 屬性值設定，不同圖片路徑之間只要用 , 分開即可。background-position 屬性則是用來指定背景圖片的位置，而這個屬性非常值得深入研究，不同的設定會造成不同的結果，有些效果對您來說可能是沒看過的。 為了確保本文的程式碼和概念清楚單純，我們將只用一張圖片的範例來驗證瞭解每個屬性，不過這些概念同樣適用於多張圖片的情況下。 一個背景圖片被放在一個我們稱之為 background position area 的地方，這個背景座標區域功能就如同其名稱一樣，其中有一個座標系統讓我們可以處理背景圖的定位。 在我們進一步開始探討放置圖片的概念之前，讓我們先快速的在看過一次 CSS box model 以及看看它如何影響元素中背景圖片的位置。 CSS Box Model 區域根據定義在 CSS 中一個元素通常有 3 個區塊，這幾個區塊我們統稱區塊模型，如果您常閱讀英文的文件那麼這邊就是 box ，這幾個區塊分別是 border 區塊, padding 區塊, content 區塊。首先是 border 區塊 這個區塊在元素的最外層包含整個內容加上邊框即 border 本身。 padding 區塊 則是扣除掉 border 後元素內容和內容外圍的空間，沒錯就是您透過 padding 屬性設定的間隙。 最後 content 區塊 就是把元素扣掉 border 和 padding ，實際內容部分。 圖示元素的區塊模型，圖片來源：參考 Codrops CSS 如果您已經知道如何使用 CSS 排版的樣式規則那您可能會問那 margin 呢？margin 在元素的最外圍，包含整個元素，它被用來設定各個元素之間的距離，定義上它不被算在元素內部。 好！當我們給元素設定了 background - 可以是圖片或顏色。背景預設會從 padding 區塊 開始畫，這個行為是可以被改變的，透過使用 background-origin 這個屬性就是用來設定背景從哪邊開始，預設是 padding-box。 為了準確的把背景圖片放到指定的區塊中，這個區塊需要一個座標系統，用來計算座標。接著讓我們更深入的看看座標系統。 注意：如果 background-attachment 屬性設定為 fixed 那麼 background-origin 就會無效。 1background-origin: padding-box|border-box|content-box|initial|inherit; 元素的座標系統預設情況下，CSS 區塊模型的特性是每一個元素都會透過自己的 height 和 width 來建立座標系統。這個座標系統被用來設定元素和其他元素之間的位置關係，同時影響內部子元素與自己的位置關係。 所以在 CSS 中一個 HTML 元素有一個座標系統，但如果是 svg 元素則沒有。這是因為 svg 本身並沒有區塊模型的概念。 在 CSS 裏通常一個元素的起始點會在元素的最左上角，而背景座標區域也同樣屬於區塊模型概念，並且使用這種觀念來擺放圖片，就是從圖片的左上角的點開始。 OK! 因為預設的座標區塊是 padding 區塊，因此我們的背景就會從 padding 區塊的最左上角開始。 意味著當您套用一張背景圖，瀏覽器會先從 padding 最左上角的點開始把圖放進去，然後重複擺放該圖。 例如：您套用了一張背景到元素中且設定了no-repeat，這樣圖片就只會顯示一次，如果您沒設定就會一直重複。 後面我們會繼續討論如何使用 background-position 屬性來調整預設最左上角這個行為。 不過在討論 background-position 之前我們先來驗證 background-origin 使用 background-origin 調整背景擺放的區域與座標系統background-origin 屬性主要是用來改變座標系統的原點藉此調整背景排版的位置，我們有三種值可以用 padding-box, content-box, border-box 直接來看看範例，要小心的是 border-box 其實是有變的不過呢如果您的 border 有設定顏色，那麼會把圖片蓋掉，您可以試著把 border 的 color 弄成半透明驗證。 接著我們就可以使用 background-position 指定背景的位置，我們剩下所有的範例都會採用 padding-box 的設定。 使用 background-position 來設定圖片位置我們已經看過上一節示範預設的圖片位置的起始點和排版的區域是如何運作的。也恩賜預設的 position 的值是 0% 0%。 預設的位置值是採用百分比當作單位。您可以直接設定不同的百分比或者根據 position area 範圍和距離來設定長度 上面圖表示的是設定和邊緣的距離，除了設定百分比和絕對長度之外還有 top, right, left, bottom, 和 center 五個關鍵字能用。就是區分成關鍵字和長度(px)和百分比這三大類。 一個位置的設定方式可以是一個偏移量值(關鍵字,百分比,長度), 兩個偏移量(可以是上面三種值混搭，不過要注意關鍵字的部分前面是橫向 x 軸的所以是 [left | center | right])，這邊要提醒您的是說 background-position: top 25%; 是不正確的，要 background-position: right 25%;，以及四個偏移量，四個偏移量的話就是關鍵字搭配長度。如果兩個值的部分都是關鍵字那順序可以不照語法指定，意思是您可以先放垂直 y 軸的屬性再放 x i.e background: bottom left;下面是語法和一些範例 12345678910111213141516// 語法background-position: 30% 15%, 40% 80%, 10px 10px /* 多張影像用逗號分開*/background-position: length lengthbackground-position: percentage percentagebackground-position: percentagebackground-position: bottom length right lengthbackground-position: left top// 範例background-position: top left;background-position: 50px 30%;background-position: right: 10px bottom 100px;background-position: center centerbackground-position: 10px 20px;background-position: 5em 2em;background-position: 75% 50%; 如果您提供一個值的時候那麼第二個值(偏移量) 123background-position: 10% 50%; /* 10% 是從容器左邊 10% 和圖片從左邊的10%重疊處 */background-position: top; /* 等於 `top center` */background-position: 50px; /* 等於 `50px center` */ 理解百分比的運作 設定上您可以混合任何合法的參數值，例如混搭百分比和長度或者關鍵字，不過要注意的是關鍵字的部分，除非全部都用關鍵字否則順序很重要，注意第一個參數對應水平的偏移量，第二個對應垂直的。 實際上關鍵字是百分比的縮寫，例如 top 等於 0%，bottom 等於 100% 以此類推。 好！接著讓我們開始看看每一種可能的值是如何運作的，這應該是這篇最重要部分，不同的參數類型會產生不同的效果。 絕對位置/長度如何運作當我們指定一個絕對位置的屬性單位(通常是 px)時，您執行的事讓背景圖片根據左上角原點來偏移，換句話說圖片就是根據左上角原點搭配您設定的值來偏移。 看下面的圖片比較容易理解 當然絕對位置的值可以是負數，負數的話就會往反方向移動 百分比是如何運作不同於絕對位置根據原點偏移的概念，百分比會對齊圖片的 X% 的點和容器 X% 的位置。舉例來說 0% 0% 會對其圖片的 0% 0% 位置和元素背景區域的 0% 0% 位置。 一樣我們透過下面圖片來理解 而百分比一樣也可以設定負值。 搭配使用關鍵字指定邊緣在上面的範例我們都是從左邊和上面來計算偏移，這是預設的行為。不過我們可以結合關鍵字來指定邊緣例如： 1background-position: top 1em right 3em; 注意關鍵字要在前面，另外如果指給定三個值 background-position: top 25px right ; 最後一個會變成 0 而設定了無效的值那麼就會使用預設值 0% 0% 例如 background-position: top 25% 尺寸，重複，裁切等等記住，您可以使用多張圖片，如果要對多張圖片設定位置只要使用逗號分隔每一組設定即可。其他如果要控制大小則用 background-size，總而言之有 9 個關於如何控制背景圖的屬性可以使用，一旦您能掌握 position 和 origin 剩下的觀念就相對單純許多。 最後補上一個比較新的屬性的教學 background-blend-mode","link":"/2015/04/09/a-primer-to-image/"},{"title":"理解 Javascript 執行環境","text":"Javascript 中的執行環境與堆疊在這篇筆記中我將會深入的探討 JS 底層中的一些觀念，其中最重要的就是執行環境(Execution Context)。當您閱讀完這篇文章後您可能會比較清楚關於直譯器的運作方式，明白為什麼有些 函式 變數 可以在他們被宣告之前就拿來使用，以及這些值是怎麼決定的。 什麼是執行環境？我們說當 JS 開始執行的時候，這段程式碼必須被執行在下面三種環境之一。 全域 Global：預設當您程式開始執行時的環境 函式：當我們進入一個函式 function 時的環境，也就是開始跑函式內部程式碼的時候 Eval：把一串字串，當作指令來執行時的環境也就是說一段 JS 程式碼只能存在在上面這三種狀態或類型。 讓我們直接來看看程式碼 123456789101112131415161718192021// Global context, JS 最外層的程式碼部分屬於全域var greeting = &quot;Hi&quot;;function person() { // 從大括號開始到結束進入另外一個執行環境 var _firstName = &quot;andy&quot;; var _lastName = &quot;you&quot;; function firstName() { // 另外一個執行環境 return _firstName; } function lastName() { // 執行環境 return _lastName; } alert(greeting + firstName() + ' ' + lastName());} 上面這段範例沒什麼特別的，我們就是有了一個全域的執行環境即 global context ，和 3 個 function context，唯一稍微要注意的是 global context只會有一個。其他執行環境都可以存取全域的東西。 當然您可以有多個 function context 每一個 function 執行的時候就會建立一個新的 context ，OK！不管講執行環境或者 context 都好抽象，那我們就先把他們當作是一個 context 物件，那這個 context 物件講白了就是表示一個環境，一個範圍，一個狀態。它會建立一個範圍一個自己特有的領域，任何在 function 裡面宣告的變數或其他東西都不能被外面直接存取。 如果這樣還不能理解，那我們換個角度來想這件事，你把 context 當成是一張記錄表格，當我開始在 global 執行程式碼的時候。任何變數，function 都會被記載 global 表 上，但是當執行到 function 內部的時候，此時會在開出另外一張 function 表 負責記錄 function 內部的變數等等。 不過我個人認為 執行環境 是最貼切的翻譯，當我在全域這個環境時我能夠取得的變數和進到另外一個 function 環境時可能會有不一樣的狀況。 因此在第一小節我們就下個小結論那就是每一段 JS 在運行的時候會根據片段程式碼所在的區塊有其特有的 環境 執行環境的堆疊對於執行環境有了初步的概念之後我們還得知道 - 瀏覽器的 JS 直譯器通常是單執行緒的，意味著一次只能夠做一件事。也就是說當一個事件被執行的時候其他的任務，事件等等就會被丟到執行佇列中。這個東西我們就叫做執行堆疊 我們已經知道當 JS 開始跑的時候一開始會進入 global 執行環境，如果您在 global 環境中呼叫了一個 function A (即： A();)，這個時候就會建立新的 執行環境 然後這個新的執行環境會被放到執行堆疊的最上面，同樣的如果你現在在 function A 裡面又叫了 function B 那麼就又會在建立一個執行環境一樣放到執行堆疊的最上方，瀏覽器永遠會先處理堆疊上最上面的執行環境，一旦執行環境裡面的任務都執行完了那它就會被移掉換下一個 OK 這邊交代得有點亂，我們看到的程式碼的時候通常最小的執行單位就是那一句一句的 statement 語句，一個語句交代了程式該做一件事。這些 statement 都會有自己的環境，也因此我們可以把環境在當作一個上層單位。一個 context 裡面勢必存在一些任務(語句)。就把一個 context 想像成某個任務好了。看看下面的範例可能比較有感覺 1234567(function foo(i) { if (i === 3) { return; } else { foo(++i); }}(0)); 這段程式碼簡單的呼叫自己三次每一次把參數加一，每當 foo 被呼叫的時候新的 執行環境 就被建立，然後當 執行環境 裡面的程式跑完的時候，就從堆疊中把 執行環境 拿掉，把控制權交還給上一個環境一直到回到 global 為止。 關於執行環境有 5 個重點要牢記在心 單執行緒 同步執行 只有一個 global context function context 沒有限制 就算是自己呼叫自己只要 call function 就會建立執行環境 詳解執行環境所以我們現在知道了每一次 call function 的時候就會建立一個新的執行環境，然而在 JS 直譯器內部每次調用一個執行環境都會有兩個階段 建立階段 當 function 被呼叫了但在開始執行內部程式碼之前 建立一個 scope chain 作用域鍊 建立變數，function，和參數 設定 this 的值 執行階段 賦值，設定 function 的參考和解譯執行程式碼 概念上我們可以把一個 執行環境 想像成一個物件，那麼這個物件大概會有三個屬性如下 12345executionContextObject = { scopeChain: { /* 變數物件 + 所有父代執行環境物件的變數物件*/}, variableObject: {/* 函式的參數/引數，內部的變數和函式*/ }, this: {}} Variable Object 變數物件：根據 ECMA-262 的說明，每一個執行環境會有一個與相關連的變數物件，這個物件負責記錄執行環境中定義的變數和函式。 Activation / Variable Object [AO/VO]這一個執行環境物件在 function 被調用的時候建立，不過在實際的 function 被執行之前，這就是上面提到的階段 1 - 建立階段。在這個階段直譯器會建立 executionObject ，透過掃描函式傳入的參數，內部的函式宣告，變數宣告。結果會被記錄在executionObject 的 變數物件 variableObject 中。 這裏我們大致模擬直譯器是如何執行的流程 尋找呼叫 function 的程式碼 在執行 function 之前建立 執行環境 進入 建立階段 初始化 scope chain 建立 variable object： 建立 arguments object 檢查執行環境的參數，初始化參數的名稱，值以及建立參考 掃描 function 的宣告 根據找到的每一個 function 在 variable object 建立，在這邊其實就是建立 function 名稱在記憶體中的參考指標 如果 function 名稱已經存在那麼指標就會被覆寫 掃描執行環境裡的變數 每一個變數的宣告都會被加入 variable object 的屬性中，並且初始化為 undefined，注意在這個階段並不會賦值 如果變數名稱存在就略過，繼續處理下一個變數 判斷決定 this 的值 執行階段 執行程式碼，賦值，一行一行跑 12345678910function foo(i) { var a = 'hello'; var b = function B() { }; function c() { }}foo(22); 此時在建立階段我們就會得到如下的範例 1234567891011121314fooExecutionContext = { scopeChain: { ... }, variableObject: { arguments: { 0: 22, length: 1 }, i: 22, c: pointer to function c() a: undefined, b: undefined }, this: { ... }} 如您所見，在建立階段處理關於定義宣告的部分，此時並不會賦值，所以 function b 並沒有被參考。不過參數是唯一的例外，此時參數的值已經被建立。一旦建立階段完成，剩下的流程就是開始執行階段，當執行階段完成的時候執行環境就會如下 1234567891011121314fooExecutionContext = { scopeChain: { ... }, variableObject: { arguments: { 0: 22, length: 1 }, i: 22, c: pointer to function c() a: 'hello', b: pointer to function B() }, this: { ... }} 變數宣告提升您可以找到很多關於定義 Javascript hoisting 的資料，他們通常會解釋這就是一種把宣告提升到其所在區域內頂端的行為，然而這樣並沒有解釋到細節，為什麼會發生這件事，不過呢剛剛您已經知道了關於整個直譯器解意的流程，現在您可以很清楚的明白為什麼會這樣了。 123456789101112(function () { console.log(&quot;foo: &quot; + typeof foo); // function pointer console.log(&quot;bar: &quot; + typeof bar); // undefined var foo = 'hello', bar = function() { return 'world'; }; function foo() { return 'hello'; }}()); 現在我們可以回答關於上面這段程式碼的一些問題 為什麼我們在宣告之前可以存取 foo 如果我們看看 建立階段 的流程我們可以知道變數在這個時期早就被建立了 Foo 被宣告 2 次，為什麼 foo 是 function 而不是 undefined 或 string？ 即使 foo 宣告了2次，我們知道在建立階段 function 會先被建立。因此變數已經存在了在這個階段 string 不會被賦予 foo 因此在真正執行 function 之前 foo 是會先被建立，等他真正跑完執行階段的時候 foo 才會被覆寫成 ‘hello’ 為什麼 bar 是 undefined ? bar 就只是一個變數，在這個階段並還沒賦值所以就是 undefined 總結下個收斂的結論就是 每一個片段程式碼都會屬於某個執行環境，或者說在開始執行程式碼之前會先建立 執行環境 執行環境比喻來說就像是一個物件負責紀錄這個 環境 下相關的事物 變數 function 等等 從上往下看這個執行環境物件最重要的是 scope chain, variable object, this 這三個屬性 variable object 才是實際上記錄變數，function，arguments 的地方 另外一個重要的點是 scope chain 他負責記錄每個環境之間切換的關聯，例如從 global -&gt; a() 每次開始建立執行環境的時候就會分成兩個階段 開始建立執行環境的時間點是在 function 被呼叫後，實際執行內部程式碼前 建立階段，初始化這個環境，除了 arguments 外其他都只是先定義變數，函式指標，並沒有賦值 執行階段，開始一行一行執行，賦值希望現在您可以更清楚關於 Javascript 如何運行您的程式碼，瞭解執行環境，堆疊可以讓您更清楚您的程式碼在不同狀態下取到的值，如此一來相信您在組織 JS 的時候會有更好的寫法。 參考012","link":"/2015/04/18/what-is-the-execution-context-in-javascript/"},{"title":"如何將 Azure 帳號或擁有的專案轉給另一個使用者","text":"有些時候，我們會需要將一些權限或者帳單轉交給其他負責人或者公司。為了處理這個問題，你需要提交一個帳務類型的支援回報給 Microsoft。 提交一個 Azure 帳號移轉的支援請求(Support ticket) 連到Azure Support 或Azure 支援中文 然後點擊 取得支援(Get support) 接著您就可以送出一個事件給 Azure 帳務中心。 如果您已經在 Azure 管理介面時可以點您的帳號選下 -&gt; 下拉式選單 -&gt; 聯絡 Microsoft 支援服務 注意只有帳號的最高權限有這個存取權限。 在 建立支援票證 介面填入您的資料 支援類型選擇 帳務(Billing) 選擇語系接著建立支援服務 問題類型選擇 帳戶、訂閱和帳戶入口網站協助(Account, Subscription and Account Portal Assistance) 選擇 移轉我的帳戶、訂閱或資料(Transfer my account, subscription or data) 確認聯絡資料 填寫問題需求 勾選同意之後送出 最後您就可以在管理這邊追蹤進度。 2015-04-07 更新","link":"/2015/04/07/how-to-transfer-ownership-to-another/"},{"title":"快速 JS 筆記","text":"基本的 Javascript 型別定義有 6 個 Number String Boolean Function Object Undefined 如果把比較特殊一點的做歸納整理則如下 Number （數字） String （字串） Boolean （布林） Object （物件） Function （函式） Array （陣列） Date （日期） RegExp Null （空） Undefined （未定義） 字串可以用 + 串接，然後比較特別的是 backslash \\ 跳脫字元。 不是所有的 operator 操作子都是符號，例如 typeof 就不是，他是一元的操作子 Javascript 中只有 NaN 不會等於 NaN 1NaN == NaN // #=&gt; false NaN 表示不合理的計算 Not a Number || 處理優先權最小，再來是 &amp;&amp; 然後則是比較子 &gt;, ==, &lt; 等等 Javascript 討厭的地方在於自動轉型常常會導致誤會 12345678910111213141516171819console.log(8 * numm);// 0console.log(&quot;5&quot; - 1);// 4console.log(&quot;5&quot; + 1);// 51console.log(&quot;five&quot; * 2);// NaNconsole.log(false == 0);// trueconsole.log(null == undefined);// trueconsole.log(0 == null); 如果要測試一個值是否存在可以簡單的直接拿該值跟 null 或 undefined 比較即可 125 == null// false 此外 JS 還對一些值轉換成 Boolean 有自己的規則 0, NaN, &quot;&quot; 空字串 12345678910111213140 == false// true&quot;&quot; == false// trueNaN == false// falseif (!NaN) { console.log(&quot;In this caes NaN equal to false&quot;)}// In this caes NaN equal to false 總結在單純 if expression 中 0, NaN, &quot;&quot;, undefined, null 會等於 false 其他值都是 true。不過注意 &quot; &quot; == false, 0 == false 會是 true，如果不想自動轉型請用=== 和 !== &amp;&amp; 和 || 的行為是會先將兩側的操作元轉成 Boolean (true, false)，不過奇特的是當比完時結果會從兩側來取。 舉例來說 || 當他能夠先將左側的值轉成 true 時他就先回傳左側的值，否則就傳右邊的值。 12345678null || undefined// undefined&quot;foo&quot; || &quot;bar&quot;// fooInfinity || true// Infinity 這個功能讓我們能夠透過 || 來實現預設值的功能，當左邊沒值的時候採用右邊的預設值。 &amp;&amp; 功能也類似，當左邊的值能被轉成 false 的時候，就回傳左邊的值，否則就傳回右邊。 另外 &amp;&amp; 和 || 有一個重點行為是只有當需要時才評估右邊的值，舉例如果 true || X 此時就不需要評估 X 直接回傳 true。 小結判斷規則0, 空字串, NaN, undefined, null 在遇上自動轉型成 Boolean 時都是 false 不管您是使用一般 if 表示式或者 &amp;&amp;, || ，不過如果遇到 == false 操作子時只有 0 和 空字串成立 一個片段程式碼產生一個值稱之為 expressionexpression 類似語言中的片語，一個短句。statement 則是一句完整的句子，在 JS 中用 ; 結束當作一個句子。 通常一個 statement 是獨立的，只會完成某項任務，不過如果它影響了整個程式例如: 異動了機器內部的狀態，或者影響後面的 statement，這些造成的改變我們就稱為 side effect (副作用) 關鍵字123456break case catch class const continue debuggerdefault delete do else enum export extends falsefinally for function if implements import ininstanceof interface let new null package privateprotected public return static super switch thisthrow true try typeof var void while with yield in 的用法在 JS 中如果要檢查一個物件有沒有 property 我們可以使用 in 來檢查 12345678910111213141516var car = { name: 'Toyota'}console.log(&quot;name&quot; in car);// trueconsole.log(&quot;brand&quot; in car);// false// 也可以在 for 裡面遍歷所有的屬性for (var property in object) { console.log(property);} 屬性一般來說物件的屬性名稱必須要是合法的變數名稱。使用 object.property . 的方式取得。不過 JS 有特殊的取法可以用 [] 來取，因為陣列也是一種特殊的物件，同時語法允許我們透過索引和不符合變數命名規則的方式來取得 12345678910var person = { &quot;first name&quot;: &quot;You&quot;, 1: 2}console.log(person[&quot;first name&quot;]);// Youconsole.log(person[1]);// 2 function 中的 argumentsarguments 是一個類陣列物件，它並不是陣列，只是類似但並不包含陣列的 methods 除了 length 外 12345678910111213141516171819// 如果要用陣列的 methodsArray.prototype.slice.call(arguments);function func() {}func.apply(context, array);func.call(context, 1, 2, 3, 4);// 判斷物件是不是陣列Object.prototype.toString.call( anObject )// [object Array]// [object Arguments][].concat( anObject );Array.isArray( [] )// Check an object is array apply 要丟陣列，丟物件會無法取得 arguments，因為 arguments 是一個類 array 的物件，可以想成它是從 array 轉型而來，砍掉一些 methods 1234567891011function Call() { console.log(&quot;arguments type: &quot;, Object.prototype.toString.call(arguments)); for(var i = 0; i &lt; arguments.length; i++) { console.log(arguments[i]); } console.log(&quot;name: &quot;, arguments[&quot;name&quot;]); console.log(arguments.toString());}// Call.apply(null, {name: &quot;andy&quot;, age: 28});// Call.apply(null, [1, 2, 3]); 高階 function 總結筆記一個大型的程式是昂貴的，不只是因為需要花比較多的時間來建置大小永遠牽扯到複雜度，越複雜越容易造成開發者困惑，反過來說也就容易產生 bug，越大的程式越容易躲藏 bug 且不好找。 123456789var total = 0, count = 1;while(count &lt;= 10) { total += count; count += 1;}console.log(total);// 抽象化後console.log(sum(range(1, 10))); 抽象化一詞代表將瑣碎的程式片段包裝成有語意的 function 或 method 讓開發者可以更清楚其代表的意義。 在程式的執行環境裡這些有意義的單字詞彙通常就稱為抽象化。抽象化把實際執行的細節隱藏起來，讓我們能夠用比較高階的方式直接處理問題 JSON.stringify() // -&gt; 轉成文字JSON.parse() // -&gt; 轉成物件 forEach 直接把陣列元素傳入另外一個 functionfilter map 都會產生新的陣列reduce 合併一個新值bind 會產生另外一個 function 1234567891011121314151617181920212223242526272829var arrays = [1, 2, 3, 4];arrays.reduce(處理函式(結果, 每次帶入的元素), 結果變數的初始值)arrays.reduce(function(total, num){ total += num;}, 10);[1, 2, 3].reduce(function(total, num){return total += num}, 10);// 16// 常用的示範function average(array) { function plus(a, b) { return a + b; } return array.reduce(plus) / array.length;}var byName = {};ancestry.forEach(function(person) { byName[person.name] = person;});var ageOfMothers = ancestry.filter(function(person) { return byName[person.mother] != null}).map(function(person) { return person.born - byName[person.mother].born;});console.log(average(ageOfMothers)); Methods 單純就是一個屬性其 value 是一個 function當一個 function 被當成 method 且被呼叫調用時 object.method() 會產生一個特殊的變數 this 在該 function 的 block 中(Javascript 沒有 block 的概念，應該說是 context) 這個 this 會指向該物件。 12345678function speak(line) { console.log(&quot;The&quot; + this.type + &quot; rabbit says: &quot; + line );}var whiteRabbit = {type: 'white', speak: speak};var fatRabbit = {type: 'fat', speak: speak };whiteRabbit.speak(&quot;Oh my ears and whiskers&quot;); bind apply call 的第一個參數可以簡單地想成設定 this 物件值 在 JS 中物件搜尋屬性會先從物件本身開始，如果找不到則找物件的祖先，就是物件的 prototype 123456789101112console.log(Object.getPrototypeOf({}) == Object.prototype);// trueconsole.log(Object.getPrototypeOf(Object.prototype));// → nullconsole.log(Object.getPrototypeOf(isNaN) == Function.prototype);// → trueconsole.log(Object.getPrototypeOf([]) == Array.prototype);// → true 所有 JS 中物件繼承的根 root 就是 Object.prototype它提供了一些方法給所有的物件使用，例如 toString Obejct.create 可以建立物件並指定繼承的對象 123456789var protoRabbit = { speak: function(line) { console.log(&quot;The &quot; + this.type + &quot; rabbit says '&quot; + line + &quot;'&quot;); }};var killerRabbit = Object.create(protoRabbit);killerRabbit.type = &quot;killer&quot;;killerRabbit.speak(&quot;SKREEEE!&quot;); 另外一個建立物件更方便方式是使用 constructor 因為目前 JS 沒有 class 的概念。在 JS 使用 new 搭配 Function 會產生類似 constructor 的效果。建構子會將該物件綁定 this 變數上。當我們使用 new Function() 時會回傳一個新的物件。其意義為請根據建構子回傳一個物件實例。 1234567function Rabbit(type) { this.type = type;}var blackRabbit = new Rabbit(&quot;black&quot;);blackRabbit.type;// black 建構子(在 JS 中也就是所有 function) 會自動取得一個 prototype 屬性且預設會帶一個單純的空物件，繼承自 Object.prototype 這個物件(即複製一個一樣結構的新物件到 prototype)然後每一個透過該建構子產生的物件實例(instance)都會有上面說的 prototype 物件，也就是會共享同一個物件來完成繼承這件事之後修改 prototype 每個用該 function 產生的物件實例都可以取用該物件的屬性 toString 用在一般物件上會顯示 [object Object] 的字串資訊但是用在 Array 上則會像使用 join(',') 的效果。 因為覆寫的關係所以 Array 的 toString 和 Object 的不同我們可以用 12345console.log(Object.prototype.toString.call([1, 2]));// -&gt; [object Array][1, 2].toString();// 1,2 我們現在可以透過 function 的建構子機制來建立物件，然後透過 prototype 來分享一些方法。但是這有一個問題，在上面我們曾經透過下面這種方式把資料存進物件中 1234567var map = {};function storePhi(event, phi) { map[event] = phi;}storePhi(&quot;pizza&quot;, 0.069);storePhi(&quot;touched tree&quot;, -0.081); 會發生一種問題是在 prototype 裡面加入的 methods 也會被輸出 12345678910111213Object.prototype.nonsense = &quot;hi&quot;;for (var name in map) console.log(name);// → pizza// → touched tree// → nonsenseconsole.log(&quot;nonsense&quot; in map);// → trueconsole.log(&quot;toString&quot; in map);// → true// Delete the problematic property againdelete Object.prototype.nonsense; 但是我們發現 toString 並沒有被 for in 輸出這是因為 JS 會區分 enumerable 和 nonenumerable 屬性，我們自己透過 prototype 加進去的屬性會被迭代屬於 enumerable 但是預設在 Object.prototype 裡面的不會，屬於 nonenumerable 要定義 nonenumerable 的屬性 1Object.defineProperty(Object.prototype,&quot;hiddenNonsense&quot;,{enumerable: false, value: &quot;hi&quot;}); 透過這種方式屬性被加進去了，但是不會被 for/in 取得。不過當我們用 &quot;hiddenNonsense&quot; in object 時還是會出現 true 為了區分屬性是物件自己的還是 prototype 的，我們有 hasOwnProperty(name) 這個方法來判斷。 當我們覺得問題都解決的時候，事實上還有一種狀況，就是開發者覆寫了 hasOwnProperty，在上面這種情況我們只想單純取得物件本身的屬性而不要 prototype 的東西，此時我們可以透過 Object.create(null) 這樣一來就沒有任何 prototype 的屬性了 或者 Object.hasOwnProperty.call(obj, &quot;property&quot;) 123456789101112var map = Object.create(null);map[&quot;pizza&quot;] = 0.069;console.log(&quot;toString&quot; in map);// → falseconsole.log(&quot;pizza&quot; in map);// → true// 除了上面這種方式，當 hasOwnProperty 被 override 之後我們仍可以用這種方式確保方法Object.hasOwnProperty.call(map, &quot;pizza&quot;);// trueObject.hasOwnProperty.call(map, &quot;toString&quot;);// false 當您呼叫 String() 函式時他會把傳進去的值轉成字串，透過 toString 這個方法，注意之前有提到有些物件的 toString 方法和預設並不相同，如 Array 我將透過稍微複雜的範例試圖解釋關於 polymorphism 以及一般物件導向的觀念。在下面這個專案我們將會寫一段程式透過表格中表示欄位(Table cell)陣列中的陣列資料，建立一個字串。這個字串包含著一個表格格式。意思是透過欄和列來呈現，列同時也會對齊。看起來就像下面這樣 name height country Kilimanjaro 5895 TanzaniaEverest 8848 NepalMount Fuji 3776 JapanMont Blanc 4808 Italy/FranceVaalserberg 323 NetherlandsDenali 6168 United StatesPopocatepetl 5465 Mexico 表格系統建立的方式將會透過建置函式取得每一個 cell 的寬高透過偵測一欄的寬度以及列的高度來畫出正確的尺寸接著組合它們變成一個字串 layout 程式會透過我們已經定義好的介面跟 cell 物件溝通進一步說透過這種方式 cell 將會是動態的，後續我們將會再加入一些樣式例如 header 的底線，同時我們也不用再修改 layout 部分的程式碼 下面是我們定義的介面minHeight() 傳回 cell 最小需要的高度(文字行數)minWidth() 傳回 cell 最少需要的寬度(文字字數)draw() 回傳一個 height 長度的陣列其中包含一系列的文字，這些文字也是代表 width 的字元寬。這是用來表示 cell 的內容 這邊將會大量使用高階的陣列方法，因為這也是比較好的方式 首先第一個部分是計算最小欄位寬的陣列組和列高的陣列組rows 變數會保存一個二維陣列組，內部的陣列代表一列rows 是一個陣列 裡面的 row 也是陣列[ row, row, row, [// It’s a row] ] 123456789101112131415161718// 從 rows 裡面計算出每一個 row 的高度function rowHeights(rows) { return rows.map(function(row){ return row.reduce(function(max, cell) { return Math.max(max, cell.minHeight); }, 0); });}function colWidths(rows) { return rows[0].map(function(_, index) { return rows.reduce(function(max, row){ // 一次先比每一個 row 的 col-inex 比出誰比較寬 // 最少需要多寬，就是取最大的寬 return Math.max(max, row[index]); }, 0); });} 當我們對變數名稱使用 _ 開頭或者整個變數都是由 _ 組成是讓我們人看到的時候可以直接知道這個變數將不會使用 rowHeights 應該不難理解，透過使用 reduce 方法去找出每一 row 陣列中最大的高，再透過 map 把這些高及合成一個陣列 heights colWidths 函式比較起來稍微難一點，因為最外層是使用一個 row 的陣列來取得欄位的數量，並不是直接用。剛剛忘記提到 map forEach filter 和其他類似的陣列方法都可以再傳入第二個參數，這個參數會取得當前元素的索引。如此一來我們就可以只透過 index 表示目前到了第幾個欄位 colWidths 類似 rowHeights 目的是要取得所有欄位最寬的值 12345678910111213141516171819202122function drawTable(rows){ var heights = rowHeights(rows); var widths = colWidths(rows); function drawLine(blocks, lineNo) { return blocks.map(function(block) { return block[lineNo]; }).join(&quot; &quot;); } function drawRow(row, rowNum) { var blocks = row.map(function(cell, colNum) { return cell.draw(widths[colNum], heights[rowNum]); }); return blocks[0].map(function(_, lineNo) { return drawLine(blocks, lineNo); }).join(&quot;\\n&quot;); } return rows.map(drawRow).join(&quot;\\n&quot;);} drawTable 函式使用內部輔助函式 drawRow 來畫出所有列然後把這些 rows 串在一起每一列之間隔一個 \\n drawRow 函式先把 row 陣列中的 cell 物件轉成 blocks一 row = 一 blocks 現在 blocks 使用字串的陣列來表示 cell 的內容，一個 row 對應一個 blocks 陣列。而裡面原本的單一 cell 例如本來是 cell.height 的值是 3776 現在就會換成 [“3776”] 來呈現，如果要加上底線則可能會像這樣 [“name”, “—-“] 一列的 blocks 擁有一樣的高，應該會彼此相連直到最後 接著在 drawRow 中呼叫 map （這邊看不懂） 123456789101112131415161718192021222324252627282930313233function repeat(string, times) { var result = &quot;&quot;; for(var i = 0; i &lt; times; i++) { result += string; } return result;}function TextCell(text) { this.text = text.split(&quot;\\n&quot;);}TextCell.prototype.minWidth = function() { // 格子內的文字會先用 `\\n` 拆成一個陣列，一行一個 element return this.text.reduce(function(width, line) { return Math.max(width, line.length); }, 0);};TextCell.prototype.minHeight = function() { return this.text.length; // 幾行}TextCell.prototype.draw = function(width, height) { var result = []; for (var i = 0; i &lt; height; i++) { var line = this.text[i] || &quot;&quot;; result.push(line + repeat(&quot; &quot;, width - line.length)); } return result;} Object.keys 會把屬性輸出成一個陣列，當然這跟上面提到的一致 nonenumerable 的屬性不會出現。 blocks -&gt; [[“name”, “—–”], [“height”, “——“]] rows Array[5][ TextCell, TextCell, TextCell, TextCell, TextCell] TextCell.text (Array) Array 常用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// 複製一份新的陣列var clone = array.slice(0);// 長度array.length// 排序 小-&gt;大array.sort(); // 有副作用，NO-COPY// 排序 大-&gt;小array.reverse(); // 有副作用，NO-COPY// 串連，合併陣列array.concat(another_array); // COPY// 搜尋陣列中的元素array.indexOf(&quot;1&quot;); // return index 找不到回傳 -1// 把陣列的元素串成一個字串array.join();// 從尾巴搜尋回來array.lastIndexOf(&quot;b&quot;);// 從尾巴移除元素array.pop();// 從尾巴加入元素array.push(ele);// 從頭移除元素array.shift();// 從頭加入元素array.unshift(ele);// 回傳陣列的參考，意為賦予的新變數記憶體是同一個位址array.valueOf();// 選擇部分元素，並回傳一個新的陣列array.slice(1, 3); // COPYarray.slice(從 index 元素開始, 到這個 index 之前一位)array..slice(-3, -1); // 可以用負數，最後一位是 -1 往回算// 刪除陣列中的元素，副作用 NO-COPYvar o = [1, 2, 3, 4];delete o[2];// #=&gt; [ 1, 2, &lt;1 empty slot&gt;, 4 ]// 刪除並且新增元素array.splice(1, 0, ele1, ele2 );array.splice(index, 刪除幾個, 加入元素1, 加入元素2); // 可用負數，回傳的是被刪掉的值的陣列，會從 index 開始塞資料// mapvar numbers = [1, 4, 9];var doubles = numbers.map(function(num) { return num * 2;});// #=&gt; doubles is now [2, 8, 18]. numbers is still [1, 4, 9]// 是否是陣列Array.isArray()// 如果陣列中所有元素都滿足就回傳 true 否則 false[1, 2, 3].every(function(element, index, array){})// #=&gt; true, false// element 當前元素, index 當前索引, array 整個陣列// 只要有一些符合就 truearray.some(function(element, index, array){});// 過濾並回傳新元素array.filter(function(element, index, array){ return })// 陣列遍歷array.forEach(function(element, index, array) {})// 元素一個一個濃縮合併[0, 1, 2, 3, 4].reduce(function(sum, current, index, array){}, init);array.reduceRight(); // 從右邊到左邊// keys 陣列元素一個一個取var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];var iterator = arr.keys();console.log(iterator.next()); // { value: 0, done: false }console.log(iterator.next()); // { value: 1, done: false }console.log(iterator.next()); // { value: 2, done: false }console.log(iterator.next()); // { value: undefined, done: true }// 搜尋元素array.includes(searchElement[, fromIndex])","link":"/2015/04/28/my-js-notes/"},{"title":"參透Javascript閉包與Scope Chain","text":"從上一篇文章中我們知道了每一個 function 有一個對應的執行環境 其中包含著一個由在該範圍內所有的變數，function 參考，參數定義所組成的 variable object(變數物件 VO)。 另外每一個執行環境中還定義了一個 scope chain 屬性，它就是一個記錄包含 自己的 VO + 所有上層執行環境的 VO 的集合。 如果我們用普通話的來說：一個環境的概念，可以想成是因為環境受到裡面變數記錄的影響，而這些實際影響環境的變數資料會被放在 variable object 裡面。 123scope = VO + 所有上層的 VO /* 範圍/環境 = 這些紀錄的總和 *//* 所以所謂的 scope chain */scope chain = [[VO] + [VO1] + [VO2] + [VO n+1]]; 確立一個 scope chain 的變數物件們現在我們知道 scope chain 就是用來保存這些變數物件，且我們的第一個變數物件就是當前執行環境物件自己的變數物件，剩下的 變數物件 就是上層執行環境或說父代執行環境的 1234567891011function one() { two(); function two() { three(); function three() { alert(&quot;I am at function three&quot;); } }} 這個範例很簡單的示範從 global context 我們呼叫的 one()，one() 呼叫 two()，接著在呼叫 three()，最後在 function three 發動一個 alert，下圖是當我們執行到 alert 時堆疊的概念圖 此時的 scope chain 就會是 three() scope chain = [[three() VO] + [two() VO] + [one() VO] + [Global VO]]; Lexical ScopeJS 中有一個挺重要的特性那就是直譯器採用 Lexical Scoping，它和 Dynamic Scoping 相反… 簡單的來說這個 Lexical Scoping 只不過是在說：函式內部定義的程式碼是根據定義時決定其值而不是動態決定。用上一篇的概念來解釋那就是變數 決定值 的時候是去哪個範圍(scope)找。 還是很難懂！好吧！會搞得這麼複雜呢我想應該是源自於對於 scope 翻譯翻的不好參考維基百科的定義 In computer programming, the scope of a name binding – an association of a name to an entity, such as a variable – is the part of a computer program where the binding is valid: where the name can be used to refer to the entity. OK 我們知道了英文說 scope 其實就只是在說明變數名稱該怎麼樣跟物件實例做關聯，關聯的範圍。至於這個 Lexical Scoping 讓我們來點實際範例看看什麼叫做 根據定義時決定 12345678910function start() { alert(args);}function server() { var args = &quot;parameter here.&quot;; start();}server(); // ReferenceError: args is not defined 如我我們照著上一篇執行環境的流程順序來看那麼 start() 的 VO 其實就只能夠去參考 start() 變數物件 和 Global 的變數物件 而已。 說明完 Lexical Scoping 我們回到上面的 one two three 的例子，不管呼叫的順序是怎樣，three() 永遠只能靜態的去參考 two() 層的定義，當然還有自己的，以此類推一層一層往上。 123456789(function a () { var a = 1; function b() { var b = 2; console.log(a); console.log(b); } b();}()); scope chain 的用途大概就是像上面這樣，就只是層層往上參考。而 Lexical Scoping 會這麼困難倒不是因為觀念，而是因為實作的時候，context 是在呼叫的時候才開始建立，配上靜態的 Lexical scoping 定義常常就會導致一些非預期的結果或行為。 最常見的例子就是 12345678910111213var alerts = [];for (var i = 0; i &lt; 5; i++) { alerts.push(function inner(){ alert(i); })}alerts[0](); // 5alerts[1](); // 5alerts[2](); // 5alerts[3](); // 5alerts[4](); // 5 第一次看這個範例碼通常都會覺得 alert(i); 會是輸出從 0 - 4這是最常發生對 function inner 混淆的地方。 inner 是在 global context 這邊被定義的，因為 for 沒有自己的 scopeOK 且該執行環境是在被呼叫的時候才建立，這個時候 i 早就是 5 了。 現在您明白其中的原由了。 解析變數的值下面這個範例輸出 a + b + c = 6 1234567891011121314function one() { var a = 1; two(); function two() { var b = 2; three(); function three() { var c = 3; alert(a + b + c); // 6 } }}one()​;​ 我們剛剛沒有認真的解釋關於 scope chain 的部分，現在先看看上面的例子，乍看之下我們知道 a b 並不在 function three 裡面，那麼這個範例是怎麼輸出 6 的 從 alert(a + b + c); 這行程式，當直譯器開始要找 a 的時候，它會不斷的到 scope chain 裡面去尋找，這個過程如下圖 一開始會到自己的 VO 去找，找不到換下一個一直到 Global 為止。如果都找不到則丟出 ReferenceError 的錯誤，所以上面這段小範例 a b c 都會找到值。 關於閉包在 Javascript 中，閉包常常被認為是種魔術，且只有進階的開發者才真的搞懂它，不過事實上對於閉包的了解其實源自於對於 scope chain 的了解， Crockford 說: An inner function always has access to the vars and parameters of its outer function, even after the outer function has returned… 簡單的說就是，位在內部的 function 永遠可以存取到外部的變數和參數，即使外部 function 已經執行完畢。再根據 MDN 說明，其實閉包就是一個特殊的物件，它有兩個含義： 它是一個 function。 它產生了一個 context 執行環境，配合上面的說明你就知道其實他只是幫你你記錄上一層有宣告的變數，沒錯就是那個 variable object。 Closures are functions that refer to independent (free) variables. In other words, the function defined in the closure ‘remembers’ the environment in which it was created. 12345678910function factory() { var brand = &quot;BMW&quot;; return function car() { alert(&quot;I am a &quot; + brand + &quot; car&quot;); }}var carMaker = factory();carMaker(); // I am a BMW car global context 有一個稱為 factory() 的函式，接著有一個變數叫做 carMaker ，這個 carMaker 儲存了 facotry 回傳的值。通常開發者會感到困惑的地方是為什麼 brand 還會存在，不是說 function 一旦執行結束就後就會不見嗎？那為什麼 brand 還會在。 然而如果我們來仔細看看關於執行環境的部分我們會看到 123456789101112131415161718// Global Contextglobal.VO = { factory: pointer to factory(), carMaker: 是 global.VO.factory 的回傳值 scopeChain: [global.VO]}// Factory 執行環境factory.VO = { car: pointer to car(), brand: 'BMW', scopeChain: [factory.VO, global.VO]}// car 執行環境car.VO = { scopeChain = [car.VO, factory.VO, global.VO]} 現在我們先看到當呼叫 carMaker() 的時候，實際上我們拿到 factory 回傳的值，這個回傳值回傳一個指向 car() 的指標，接著當我們進入 car 內部執行的時候這個 scope chain 是 [car.VO, factory.VO, global.VO] 現在呢需要 brand 這個變數的值所以會先找自己的 car.VO 找不到再往下找 factory.VO 就可以找到了。 從另一個角度來看其實就是雖然 function factory 本身的實例執行完後就消失了，可是因為 VO 還被參考，所以 GC 不會將其回收。 說到這邊我們已經深入的解釋完關於 scope chain ，lexical scoping 以及關於 colsures 和變數之間是如何運作的了。剩下的文章我們將來看看一些牽扯到上面議題的有趣情況 prototype chain 如何影響變數解析Javascript 幾乎所有東西都使用 prototype 的方式來實作繼承，除了 null, undefined。當我們試圖存取一個物件的屬性時，直譯器會試著解析在物件實例中的屬性，那如果找不到他就會繼續找 prototype chain，直到找到屬性或者檢索完畢整個 chain 所記錄的關聯。 那麼第一個有趣的問題來了，直譯器在解析一個屬性的時候到底是用 scope chain 還是 prototype chain？ 答案是都會用。當試著解析一個屬性或者識別的時候，scope chain 會先被用來找尋物件的所在，當物件被找到的時候接著就用該物件的 prototype chain 來找屬性名稱。 下面我們用兩段程式碼來解釋整個流程 12345678910var bar = {}function foo() { bar.a = &quot;Set from foo()&quot;; return function inner() { alert(bar.a); }}foo()(); // 'Set from foo()' 首先是 bar.a = &quot;Set from foo()&quot;; 這一行建立全域物件 bar 的 a 屬性。直譯器會到 scope chain 找尋 bar.a 並預期會在 global context 找到它。 現在換另外一個範例 1234567891011var bar = {};function foo() { Object.prototype.a = &quot;Set from prototype&quot;; return function inner() { alert(bar.a); }}foo()(); // 'Set from prototype()' 在執行時期，當 inner() 被呼叫的時候會先試圖在 scope chain 裡面解析 bar.a，而 bar 的實例，會在 global context 被找到 bar 然後搜尋 bar 裡面的屬性 a，然而 a 並沒有被設定在 bar 裡面，所以直譯器的下一步會檢索物件的 prototype chain 然後在 Object.prototype 裡面找到 a 上面的過程就是整個識別解析的流程，先在 scope chain 找到物件然後查看 prototype chain 直到屬性被找到為止否則就回傳 undefined 何時該使用閉包閉包是一個非常強大的概念，通常我們會在某些情況下使用 封裝這讓我們可以將一些不想外露的細節封裝在執行環境中，只露出想要 public 的部分。例如： 1234567891011121314151617var classicModulePattern = function(){ var privateVariable = 1; function privateFunction(){ alert('private'); } return { publicVariable:2, publicFunction:function(){ classicModulePattern.anotherPublicFunction(); }, anotherPublicFunction:function(){ privateFunction(); } }}();classicModulePattern.publicFunction(); Callbacks 回呼callback 可能我們最常用的一種閉包，典型瀏覽器中通常是採用單執行緒的 Event Loop，正常情況下，一個事件完成才會執行下一個事件。callback 讓我們能夠延遲函式的調用，非同步風格的寫法，我們常常用在回應當一個事件完成的時候。舉例來說當你對伺服器呼叫一個 AJAX ，我們通常會使用 callback 來處理伺服器回應的部分。 閉包參數我們也可以把一個閉包當作參數傳進 function 中，舉個例子我們透過傳入不同的閉包參數就可以完成不同的排列處理 何時不該使用閉包？雖然閉包很好用但因為效能的因素您還是應該謹慎使用 過多的作用域多個巢狀 function 是一個典型的狀況。記住每一個當你需要取得一個變數時，scope chain 一定會一層一層檢索，直到找到該物件或值，所以越多層會導致找尋時間變長。 記憶體回收Javascript 具有記憶體回收(Garbage Collection)的機制，指的是開發者不需要處理關於記憶體的議題。不過通常有自動回收機制，因為無法直接控制記憶體的部分容易導致程式記憶體洩漏進而造成效能問題。不同的 JS 引擎實作 GC 的方式明顯有差異，ECMAScript 並沒有定義該如何實作回收記憶體的方式，但為了提高效能與盡可能降低記憶體洩漏的問題大部份的引擎都遵循一樣的宗旨。一般來說記憶體回收處理器會在當物件不再被參考的時候將其釋放 Memory Leak (中文翻成記憶體漏洩)。內部記憶體泄漏指由於疏忽或錯誤造成程式未能釋放已經不再使用的內部記憶體的情況。內部記憶體泄漏並非指內部記憶體在物理上的消失，而是應用程式分配某段內部記憶體後，由於設計錯誤，導致在釋放該段內部記憶體之前就失去了對該段內部記憶體的控制，從而造成了內部記憶體的浪費。更確切的說 Memory Leak 造成的原因是某個被配置(allocated)的記憶體無法再被參考(referenced)，也無法被釋放(released)。那塊被配置的記憶體就無法被系統再使用，所以要看一個程式有否Memory Leak，很簡單的方法就是去看作業系統的實體記憶體使用圖，如果隨著時間增加，記憶體的使用量呈現明顯增加的趨勢，這個程式就極有可能有潛在的Memory Leak問題。 循環引用循環引用是在描述一種狀況，當 A 物件參考到 B，但是 B 物件又參考回 A 物件。針對舊版的 IE 參照一個 DOM 元素常常會造成記憶體洩漏。為什麼？因為在 IE JScript 引擎和 DOM 分別各自有自己的記憶體回收器，所以當從 JS 中參考一個 DOM 元素時，JS 回收器認為這是 DOM 回收器的工作，而 DOM 回收器又把這個任務指給 JS 回收器。結果就是兩個回收器循環引用。上面扯遠了，那這跟閉包有什麼關係。原因是在閉包中很容易寫出循環引用，讓我們來看一個實際的例子 1234567function example() { var el = document.getElementById('el'); el.onclick = function() { this.style.backgroundColor = 'blue'; } // el=null;} 看起來沒有循環參考的問題，但實際上呢？el物件的屬性參考到了一個函式，這函式卻擁有存取el物件的能力。因此循環參考就此形成。要破壞這種記憶體洩漏其實不難，上例程式碼中的 el=null 就可以達成這目的，當然也可以在一開始就不使用 el 變數。","link":"/2015/04/20/understand-closures-and-scope-chain/"},{"title":"Heroku 無法 fetch gem","text":"當我們在本機設定 gem 的時候有時候會採用直接從 github 下載的方式 1gem 'datetimepicker-rails', github: 'zpaulovics/datetimepicker-rails', branch: 'master', submodules: true 不過當我們要把程式碼部署到雲上的主機時，有些時候會碰上該機器無法去 fetch repo 的狀況 這個時候請參考這邊改變設定即可","link":"/2015/05/01/heroku-push-fail/"},{"title":"XML 筆記","text":"XML先從 XML 說起，XML 被設計用來描述資料。XML 看起來就像是 HTML，但他不是用來取代 HTML 的，HTML 設計的目的是用來呈現資料，而 XML 是紀錄資料。XML 本身並不會完成任何事情，他就是一種資料的紀錄結構 123456&lt;note&gt; &lt;to&gt;Tove&lt;/to&gt; &lt;from&gt;Jani&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don't forget me this weekend!&lt;/body&gt;&lt;/note&gt; XML 不像 HTML 預先定義好所有標籤，在 XML 中標籤是由開發者定義的。XML 是一種簡單的資料分享格式。在真實世界中，電腦系統和資料庫儲存的資料使用不同的格式，彼此不相容。而 XML 透過純文字的格式儲存，提供一種跟不相依於任何軟硬體的方式儲存資料。 XML 從根節點出發，一份 XML 文件只會有一個 root一個標準的 XML 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;note&gt; &lt;to&gt;Tove&lt;/to&gt; &lt;from&gt;Jani&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don't forget me this weekend!&lt;/body&gt;&lt;/note&gt; 每一個元素一定都要關閉，且元素名稱區分大小寫巢狀時一定要符合規則，屬性一定要用 &quot; 包起來。 一些特殊字元會有不一樣的意義，所以不能亂用這些字元共有 5 個 &lt; &gt; &amp; ' &quot; 但其中只有 &lt; 和 &amp; 是嚴格說起來被限制的。空白會保留不會跟 HTML 一樣標籤中連續多個空白會被縮到剩一個 註解 &lt;!----&gt; 元素的命名規則 區分大小寫 開頭必須要是英文或底線 不可以用 XML Xml 開頭 雖然可以用 英文，數字 -, _, . 但是 - 在某些系統會被當成減號，.則會當成連接屬性和物件的符號 名稱不能包含空白 可以用各種語言的字元，但要考慮系統是否支援 雖然沒有規則限制屬性和子元素該怎麼用，不過大原則是：屬性是用來放跟資料本身沒直接關係卻跟標籤元素有關係的資訊，例如 id 設計時的原則是只要資料有機會擴展就用子元素，因為屬性只能單純的放文字 namespace 提供一種方式避免元素衝突，透過 xmlns:ns=&quot;namespace URI&quot; 來定義，定義在起始的標籤。namespace 的 uri 並不會用來解析資訊，目的只是要給 namespace 定義一個唯一的名稱 三組 namespace 的放法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;root&gt;&lt;!--有設定 prefix 就要用 --&gt;&lt;h:table xmlns:h=&quot;http://www.w3.org/TR/html4/&quot;&gt; &lt;h:tr&gt; &lt;h:td&gt;Apples&lt;/h:td&gt; &lt;h:td&gt;Bananas&lt;/h:td&gt; &lt;/h:tr&gt;&lt;/h:table&gt;&lt;f:table xmlns:f=&quot;http://www.w3schools.com/furniture&quot;&gt; &lt;f:name&gt;African Coffee Table&lt;/f:name&gt; &lt;f:width&gt;80&lt;/f:width&gt; &lt;f:length&gt;120&lt;/f:length&gt;&lt;/f:table&gt;&lt;/root&gt;&lt;!--集中在 root 定義--&gt;&lt;root xmlns:h=&quot;http://www.w3.org/TR/html4/&quot;xmlns:f=&quot;http://www.w3schools.com/furniture&quot;&gt;&lt;h:table&gt; &lt;h:tr&gt; &lt;h:td&gt;Apples&lt;/h:td&gt; &lt;h:td&gt;Bananas&lt;/h:td&gt; &lt;/h:tr&gt;&lt;/h:table&gt;&lt;f:table&gt; &lt;f:name&gt;African Coffee Table&lt;/f:name&gt; &lt;f:width&gt;80&lt;/f:width&gt; &lt;f:length&gt;120&lt;/f:length&gt;&lt;/f:table&gt;&lt;/root&gt;&lt;!--直接在開始的標籤設定，但不用 prefix --&gt;&lt;table xmlns=&quot;http://www.w3.org/TR/html4/&quot;&gt; &lt;tr&gt; &lt;td&gt;Apples&lt;/td&gt; &lt;td&gt;Bananas&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;table xmlns=&quot;http://www.w3schools.com/furniture&quot;&gt; &lt;name&gt;African Coffee Table&lt;/name&gt; &lt;width&gt;80&lt;/width&gt; &lt;length&gt;120&lt;/length&gt;&lt;/table&gt; 因為 XML 支援不同的國際編碼，所以在一開始定義時要指定 encoding XML 的第一行定義又稱 prolog 這是可選的，通常會在這邊定義版本和編碼。預設是 UTF-8，XML 有提供 XML Validator 來驗證格式是否正確。一個通過驗證的 XML 跟格式正確的 XML 文件並不完全相同一個通過癌症的 XML 是格式正確加上符合文件類型定義的 XML 文件我們會用 Document Type Definitions(DTD)或者 XML Schemas 來替 XML 定義何謂合法的元素與屬性的規則。 驗證 XML 的文件格式分成兩種類型 DTD - 原生的文件類型定義 XML Schema - 一種 XML 格式的文件用來替代 DTD DTD文件型別定義(Document Type Definition)，DTD 的功能就是定義該類型文件所包含的元素(Element)，並定義每個元素的內容，包含子元素、文字內容與屬性規範各元素(Element)的排列組合方式，包含出現的順序與可出現的次數。順序性與重複性。 如果在 XML 裡面宣告 DTD 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE note [ &lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!ELEMENT to (#PCDATA)&gt; &lt;!ELEMENT from (#PCDATA)&gt; &lt;!ELEMENT heading (#PCDATA)&gt; &lt;!ELEMENT body (#PCDATA)&gt;]&gt;&lt;note&gt; &lt;to&gt;George&lt;/to&gt; &lt;from&gt;John&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don't forget the meeting!&lt;/body&gt;&lt;/note&gt;&lt;!--引用外部 dtd--&gt;&lt;!DOCTYPE note SYSTEM &quot;http://mydtds.com/note.dtd&quot;&gt; 上面的 DTD 解釋如下 &lt;!DOCTYPE note 宣告這個 XML root 是 note 接著跟在 note 後面用陣列 [] 圈起來 &lt;!ELEMENT note (to, form, heading, body)&gt; 宣告 note 至少要有這些東西，一個 () 是一個表示式 &lt;!ELEMENT br EMPTY&gt; 定義 br 元素為空的 &lt;!ELEMENT span ANY&gt; 定義 span 為任意元素 &lt;!ELEMENT to (#PCDATA)&gt; 可被解析的文字資料 &lt;!ELEMENT div (foo+)&gt; 定義 div 裡面至少要有一個 foo 或多個 一個或多哥 零或多 ? 零或一 簡單介紹完 DTD 結論就是這會用在一種情況當開發者分別處於不同團隊或公司要互相交換分享資料時用來確保雙方給的 XML 是否正確。因為 W3C 明確的定義當解析 XML 出現異常時必須終止，不能像 HTML 一樣容錯。 XML Schema一個 XML Schema 描述一個 XML 的結構功能就像 DTD 一樣一個 XML 符合基本結構規範稱為 Well formed一個 XML 針對 XML Schema 規則檢查後才能保證是 Well Formed 和 Valid XML Schema 使用 XML 的格式實作 DTD 的功能 12345678910&lt;xs:element name=&quot;note&quot;&gt; &lt;xs:complexType&gt; &lt;xs:sequence&gt; &lt;xs:element name=&quot;to&quot; type=&quot;xs:string&quot; /&gt; &lt;xs:element name=&quot;from&quot; type=&quot;xs:string&quot; /&gt; &lt;xs:element name=&quot;heading&quot; type=&quot;xs:string&quot; /&gt; &lt;xs:element name=&quot;body&quot; type=&quot;xs:string&quot; /&gt; &lt;/xs:sequence&gt; &lt;/xs:complexType&gt;&lt;/xs:element&gt; 上面這段 XML Schema 解釋 &lt;xs:element name=&quot;note&quot;&gt; 定義一個叫做 note 的元素 &lt;xs:complexType&gt; 在 note 裡面定義 note 是一個複雜型別 &lt;xs:sequence&gt; 設定這個 complexType 是一個元素序列 &lt;xs:element name=&quot;to&quot; type=&quot;xs:string&quot;&gt; 定義元素序列裡面有一個 to 元素型別是字串 XML Schema 比起 DTD 功能更強大，可以用 XML 語法結構定義比較清楚，支援型別限制也支援 namespace透過 XML Schema 可以對 XML 檔案附加其他描述的資訊同時可以驗證資料。 因為 XML Schema 也是一種 XML 所以也可以使用 XSLT XMLHttpRequest ObjectXMLHttpRequest 物件被用來和伺服器交換資料您可以透過 XMLHttpRequest 執行 更新網頁而不需要重新載入整個頁面 在頁面載入完成後對伺服器請求資料 從伺服器取得其他資料 在背後送資料給伺服器 如何建立一個 XMLHttpRequest 物件所有新的瀏覽器都支援此物件 1var xmlhttp = new XMLHttpRequest(); XML Parser所有新的瀏覽器都支援一個內建的 XML 解析器XML parser 可以轉換一個 XML 文件檔案成為一個 XML DOM 物件，意思是之後可以透過 JS 操作下面的簡易程式碼示範如何轉換 123456789101112131415xmlhttp = new XMLHttpRequest();xmlhttp.open(&quot;GET&quot;, &quot;books.xml&quot;, false); //open(method,url,async)xmlhttp.send();xmlDoc = xmlhttp.responseXML;txt = &quot;&lt;bookstore&gt;&lt;book&gt;&lt;title&gt;Hello Italian&lt;/title&gt;&lt;author&gt;ANDY&lt;/author&gt;&lt;/book&gt;&lt;/bookstore&gt;&quot;;if (window.DOMParser) { parser = new DOMParser(); xmlDoc = parser.parserFromString(txt, &quot;text/xml&quot;);} else { xmlDoc = new ActiveXObject(&quot;Microsoft.XMLDOM&quot;); xmlDoc.async = false; xmlDoc.loadXML(txt);} XPathXPath 是一種用來找到 XML 資訊的語法XPath 是根據 XML 需求而定義的局部語法XPath 使用路徑表示式來搜尋 XML 中的資訊XPath 包含著一組標準的函式庫XPath 是 XSLT 的主要元素之一XPath 也可以用在 XQuery XPointer 和 XLink XPath 使用路徑表示式來選取某個 XML 中的節點 Node 或符合規則的節點集合。這個表示式跟我們在電腦系統上面找檔案的路徑格式非常相似。目前 XPath 表示式可以被用在 Javascript, Java, XML Schema, PHP, Python, C, C++ 等等 XPaht 是 XSL 標準中的主要內容之一，如果沒有 XPath XSL 將無法建立 XSLT XPath 表達式 bookstore/book[1] 從 bookstore 子元素中選取第一個 book 元素，注意從 1 開始而不是 0 /bookstore/book[last()] 選最後一個 /bookstore/book[last()-1] 倒數第 2 個 /bookstore/book[position() &lt; 3] 前兩個 //title[@lang] 相對路徑比對到 title 標籤且有 attribute 名稱是 lang 的。注意在 [] 裡面通常指的是子元素的規則，加上 @ 就是元素本身的 attributes XLinkXLink 定義一種方式讓我們可以在 XML 文件中建立連結XLink 被用來在 XML 中建立超連結任何在 XML 中的元素都可以具有超連結的行為XLink 支援單純連結(類似 HTML) 以及擴展的連結(將多個資源連在一起)XLink 可以被定義在被聯結的外部檔案中 在 HTML 裡面 &lt;a&gt; 元素可以定義一個超連結，然後並沒有這樣的東西存在 XML 中，因為在 XML 是您定義元素。因此您不可能叫瀏覽器預測 XML 文件中什麼元素會有超連結的行為下面是 XLink 的範例 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;homepages xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;&gt; &lt;homepage xlink:type=&quot;simple&quot; xlink:href=&quot;http://www.w3schools.com&quot;&gt;Visit W3Schools&lt;/homepage&gt; &lt;homepage xlink:type=&quot;simple&quot; xlink:href=&quot;http://www.w3.org&quot;&gt;Visit w3c&lt;/homepage&gt;&lt;/homepages&gt; 為了能夠取得 XLink 的功能我們必須宣告 XLink 命名空間。而這個 namespace 是 http://www.w3.org/1999/xlink XML 相關技術整理 XML Extensible Markup Language一種簡單的資料結構格式類似 HTML XSL Extensible Style sheet Language XSL 由三個部分組成： XSLT 用來轉換 XML 的語言，用來把一個 XML 轉換成另外一種格式如 XHTML 的樣式結構與法 XPath 在 XML 中用來巡覽的語言，類似 CSS 中的 Selector XSL-FO 格式化 XML 的語言 XSLT 一種 XSL 用來把一個 XML 轉換成另外一種格式如 XHTML 的樣式結構與法 XML Schema 用 XML 取代 DTD 的功能 XLink 建立超連結的行為 XPointer 類似 HTML 中的錨點 CDATACDATA 在 XML 解析的時候會被忽略PCDATA 格式的文字會被解析會區分 PCDATA 的原因是因為元素裡面還能夠包含子元素不管是元素或者是元素內一般的內容文字都被歸類為 PCDATA 而 CDATA 就是不被解析的文字部分&lt; 和 &amp; 在 XML 元素中都是非法字元&lt; 字元被認定為非法字元的原因是因為解析器會認為這是一個元素的開始&amp; 不行則是因為這是一個 character entity 就是例如 &amp;amp; 或 &amp;gt; 這種格式編碼的開頭 一些文字像是 Javascript 包含很多的 &lt; &amp; 字元，為了避免錯誤 script 可以被定義成 CDATA 這樣一來就會被忽略，任何在 CDATA 段落裡面的只會被 XML Parser 忽略。 問題：您可以能想說那 CDATA 跟一般註解有什麼差別？ CDATA 仍然是文件的一部分，而註解不是。意思是告訴 Parser 就不要幫我解析了直接把全部的東西當作內容輸出在某些時候內容中含有 HTML 標籤或者是一些特殊字元﹙如﹕&lt;、&gt;、&amp;﹚，當這些字元出現在內容裡，通常都會出現 XML 分析錯誤的情況，這時候就必須將這些字元作些轉換的工作（如︰&lt; / &lt;、&gt; / &gt;、&amp; / &amp;）。 其實並不需要如此，CDATA 區段提供了一種通知剖析器的方法，說明 CDATA 區段所包含的字元沒有標記。 當 XML 剖析器遇到開頭的『』時，剖析器會停止報告並回到正常的剖析 定義 CDATA&lt;![CDATA[ 資料在這邊 像是 &lt; 這時就合法了]]&gt; 注意裡面不可以再放 ]]&gt; XSLXSL 代表的是 Extensible Stylesheet LanguageW3C 發展 XSL 主要是因為有 XML Stylesheet Language 的需求。 HTML 的樣式表是 CSSHTML 使用預先定義好的標籤，而這些標籤的意義在使用前就知道用途&lt;table&gt; 標籤在 HTML 裡面定義一個表格，接著瀏覽器就知道該怎麼呈現他。特元素加入樣式在 HTML 非常簡單，只需要在 CSS 中告訴瀏覽器哪個元素該使用什麼背景色或字體即可。 XML 的樣式表是 XSLXML 並沒有預先定義好的標籤，因此我們並不知道每個標籤是在做什麼的。一個 &lt;table&gt; 標籤可能跟在 HTML 一樣或者代表一個傢俱，或其他的東西，瀏覽器並不知道該怎麼呈現XSL 會描述該如何呈現 XML XSL 不只是單純的樣式表語言XSL 由三個部分組成： XSLT 用來轉換 XML 的語言 XPath 在 XML 中用來巡覽的語言，類似 CSS 中的 Selector XSL-FO 格式化 XML 的語言 XSLT 是用來把 XML 文件轉成 XHTML 文件或者其他 XML 文件的語言。 過程是 XML -&gt; XSLT -&gt; XHTML(another xml doc)並且大部份的瀏覽器都支援。 撰寫 XSL 一開始需要定義格式 1234&lt;xsl:stylesheet version=&quot;1.0&quot;xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&gt;&lt;xsl:transform version=&quot;1.0&quot; xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&gt; 為了能夠使用 XSLT 的元素，屬性和功能必須要先定義 XSLT 的 namespace 在文件最上面。 xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot; 指向 W3C XSLT 的命名空間，如果您使用這個命名空間那就必須要加入 version=&quot;1.0&quot; 的屬性 就跟 HTML 搭配 CSS 一樣，一個 XML 可以引入一個 XSL透過 &lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;cdcatalog.xsl&quot;?&gt; 一個 XSL 樣式由一個或一些規則組成，這些規則稱之為樣板 &lt;xsl:template&gt; ，首先我們透過樣板來建立規則，然後 &lt;xsl:template&gt; 標籤會有一個屬性 match ，我們用 match 來關聯到 xml 的 element。這個 match 可以關聯定義整個 XML，而這個 match 的值是用 XPath 表示式，例如 / 就是根，指的是整份文件 我們可以想成一個 template 從 match 的元素取資料並套用到裡面的樣板。 因為 XSL 也是一種 XML 所以第一行宣告還是 XML接下來會用 &lt;xsl:stylesheet&gt; 定義這份文件是一個 XSLT 當然要加上 xmlns 和 version 瀏覽器執行時起始點是 XML 然後 XML 載入 XSL ，XSL 取得 XML 中的資料並且呈現。 &lt;xsl:value-of&gt; 標籤是用來取得 XML 資料用的。透過 select 屬性來取得 XML Tag 中的資料 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;xsl:stylesheet version=&quot;1.0&quot;xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&gt;&lt;xsl:template match=&quot;/&quot;&gt; &lt;html&gt; &lt;body&gt; &lt;h2&gt;My CD Collection&lt;/h2&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr bgcolor=&quot;#9acd32&quot;&gt; &lt;th&gt;Title&lt;/th&gt; &lt;th&gt;Artist&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;xsl:value-of select=&quot;catalog/cd/title&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;xsl:value-of select=&quot;catalog/cd/artist&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt;&lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt; select 屬性的值一樣是使用 XPath Expression，XPath 運作的原理類似檔案系統路徑，從 root / 開始透過斜線一層一層對應 &lt;xsl:value-of&gt; 只會取得單一標籤，如果要迭代或者選取一整組則用 &lt;xsl:for-each&gt; 使用 for-each 可以把符合 select 規則的元素全部都取得然後全部一個一個套用內部的樣式。 另外要注意的是 select 的 XPath Expression 運作模式既然類似檔案系統，也就是說你可以使用相對路徑或者絕對路徑的方式。父元素已經取得的標籤，如果要繼續往內部取就像上面例子一樣就可以 123&lt;xsl:for-each select=&quot;catalog/cd&quot;&gt; &lt;xsl:value-of select=&quot;title&quot; /&gt;&lt;/xsl:for-each&gt; 除了選取之後 XPath Express 也可以像 CSS Selector 過濾一樣加上屬性過濾例如 &lt;xsl:for-each select=&quot;catalog/cd[artist='andy']&quot;&gt;但判斷邏輯就不像 CSS 這麼多種，只有4種，而且要注意 [] 並不是同層元素的屬性，而是子元素的值。如果要指定屬性則是&lt;xsl:for-each select=&quot;Factory/Car[@price&gt;=1100]&quot;&gt; 完整範例參考下面 = != &lt; &gt; 123456789101112131415161718192021222324252627282930313233&lt;!-- XML --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;car.xsl&quot;?&gt;&lt;Factory&gt; &lt;Car price=&quot;1000&quot;&gt; &lt;Brand&gt;Honda&lt;/Brand&gt; &lt;Type&gt;Civic&lt;/Type&gt; &lt;Displacement&gt;2000&lt;/Displacement&gt; &lt;/Car&gt; &lt;Car price=&quot;2000&quot;&gt; &lt;Brand&gt;Toyota&lt;/Brand&gt; &lt;Type&gt;Viso&lt;/Type&gt; &lt;Displacement&gt;1800&lt;/Displacement&gt; &lt;/Car&gt;&lt;/Factory&gt;&lt;!-- XSL --&gt;&lt;xsl:stylesheet version=&quot;1.0&quot; xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&gt; &lt;xsl:template match=&quot;/&quot;&gt; &lt;html&gt; &lt;body&gt; &lt;h2&gt;CAR&lt;/h2&gt; &lt;ul&gt; &lt;xsl:for-each select=&quot;Factory/Car[@price&gt;=1100]&quot;&gt; &lt;li&gt;&lt;xsl:value-of select=&quot;Brand&quot; /&gt;&lt;/li&gt; &lt;/xsl:for-each&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; &lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt; 如果要排序則使用 &lt;xsl:sort&gt; 元素，如下用法 1234567&lt;xsl:for-each select=&quot;catalog/cd&quot;&gt; &lt;xsl:sort select=&quot;artist&quot;/&gt; &lt;tr&gt; &lt;td&gt;&lt;xsl:value-of select=&quot;title&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;xsl:value-of select=&quot;artist&quot;/&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/xsl:for-each&gt; &lt;xsl:if&gt; 跟 filter 有點類似，但是是針對內部的元素 123456789&lt;xsl:for-each select=&quot;catalog/cd&quot;&gt; &lt;xsl:if test=&quot;price &amp;gt; 10&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;xsl:value-of select=&quot;title&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;xsl:value-of select=&quot;artist&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;xsl:value-of select=&quot;price&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/xsl:if&gt;&lt;/xsl:for-each&gt; &lt;xsl:choose&gt; 類似其他語言中的 switch 123456789&lt;xsl:choose&gt; &lt;xsl:when test=&quot;expression&quot;&gt; ... some output ... &lt;/xsl:when&gt; &lt;xsl:otherwise&gt; ... some output .... &lt;/xsl:otherwise&gt;&lt;/xsl:choose&gt; Web ServicesWeb Services 是網頁應用程式元件。Web Services 可以被網站發佈，搜尋與使用。這份筆記會說明 WSDL, SOAP, UDDI, RDF WSDL 意思是 Web Services Description LanguageWSDL 是一種基於 XML 的語言用來描述 Web Services SOAP 意思為 Simple Object Access ProtocolSOAP 是一種基於 XML 存取 Web Services 的協議SOPA 架構在 XML 之上 UDDI 代表的是 Universal Description Discovery and Integration 統一描述、發現和集成UDDI 是一個目錄服務讓公司可以搜尋 Web ServiceUDDI 被描述在 WSDL 裡面UDDI 透過 SOAP 溝通 RDF 代表的是 Resource Description FrameworkRDF 是一個框架，目的是在 Web 上描述資源RDF 一樣透過 XML 來撰寫 Web Services 是應用程式的組件Web Services 透過開放式協定Web Services 可以透過 UDDI 來找到Web Services 可以被其他應用程式使用HTTP 和 XML 是組成 Web Services 的基礎 因為所有主流平台可以透過瀏覽器存取網頁，但不同平台無法互相溝通。為了使這些平台能夠一起工作，而發展了網頁應用程式。網頁應用程式可以簡單地在網頁上執行，而這些都圍繞在瀏覽器標準上且可以被用在任何平台的任何瀏覽器上 Web Services 帶領網頁應用程式到了另一個境界透過使用 Web Services 您的應用程式可以發布自己的函式或訊息給其他人使用Web Service 使用 XML 來編譯，解譯資料。然後用 SOAP 來傳輸。透過 Web Services 您部門的 Win 2k 的帳單系統可以和 IT 部門的 Unix Server 溝通 Web Services 有兩種使用方式 可重複使用的應用程序的組件 連結已存在的軟體 Postman 基本操作Postman 介面被區分成兩個區塊，左邊的 sidebar 和右邊的 request builder。request builder 可以讓我們建立幾乎所有種類的 request。HTTP request 分成 4 個部分 URL, method, header, body URLURL 是我們首先要設定的東西，對某個網址發送請求，這個欄位有 autocomplete 的功能會記錄之前發送的紀錄URL 欄位旁邊讓我們可以選擇 method(GET, POST…)，接著點擊URL params 按鈕可以在下方開啟參數表單這些參數通常會直接帶到網址列(GET的時候)，這些參數並不會自動 URL-encoded 對著欄位點右鍵可以 EncodeURIComponent您可以分開輸入每一組 key/value 然後 Postman 會自動整合。如果您把這些參數直接帶入 URL 欄位 Postman 會自動幫你切割帶入 params Headers點擊 headers 按鈕可以顯示另外一個鍵值編輯器，您可以設定 header 資料。常用共通的 HTTP 規格的 header 屬性都可以透過 autocomplete 來找到，另外像是 Content-Type 的值也有列表。 被限制的 headers 和 cookies很不幸的一些 headers 被 Chrome 和 XMLHttpRequest 規格所限制，下面這些 headers 是被禁止發送的 _ Accept-Charset _ Accept-Encoding _ Access-Control-Request-Headers _ Access-Control-Request-Method _ Connection _ Content-Length _ Cookie _ Cookie 2 _ Content-Transfer-Encoding _ Date _ Expect _ Host _ Keep-Alive _ Origin _ Referer _ TE _ Trailer _ Transfer-Encoding _ Upgrade _ User-Agent _ Via 新版的 Postman 可以安裝 Postman interceptor 就可以使用這些禁止的 headers Cookies當您使用新版的 packaged postman app 他會執行在一個沙箱裡跟瀏覽器是分開的，如此是不能存取瀏覽器中的 cookie，這個限制仍然可以透過 interceptor 來克服。Postman 透過 interceptor 掌管了所有 request 的路由資訊。透過在 Header 中加入 “Cookie” 然後在 value 欄位使用 name=123 可以設定 cookie 或者讀取 Request body 和 parameter當我們要建構一個 request 的時候通常都需要處理 request body(就是 form post 出去的那些資料)，Postman 讓我們幾乎可以發送任何種類的 HTTP Request，body 編輯區分成 4 個區塊 form-data這種格式採用 multipart/form-data Content-Type 預設會編碼一個 web form 用來傳輸資料。這就類似在網頁上的 form 輸入完資料送出，不過根據 W3C 規範 form post 預設是採用 x-www-form-urlencoded multipart/form-data application/x-www-form-urlencoded 差異第二篇 使用 Postman 發送 SOAP教學 WSDLWSDL 代表的是 Web Services Description LanguageWSDL 使用 XML 寫成WSDL 就是一份 XML 文件WSDL 用來描述 Web ServiceWSDL 也被用來找尋對應的 Web ServicesWSDL 就是一份 XML 文件用來描述某個 Web Service 的 XML 文件，這份文件會紀錄 Web Service 的位置和 Method 怎麼操作，Service 會透露什麼訊息 WSDL 的文件結構12345678910111213141516&lt;definitions&gt; &lt;types&gt; Web services 資料格式定義 一個容器 &lt;/types&gt; &lt;message&gt; 用來溝通的資料定義 &lt;/message&gt; &lt;portType&gt; 支援的操作 &lt;/portType&gt; &lt;binding&gt; 針對特定 portType 的協定和資料格式 &lt;/binding&gt;&lt;/definitions&gt; 一份 WSDL 文件可以包含其他元素，例如擴展元素和 Service 元素，讓其可以把一些 WebService 的定義彙整到一份 WSDL WSDL Ports&lt;portType&gt; 元素幾乎是最重要的元素，用來描述一個 Web Service 關於其可以被執行的操作及包含的訊息，用程式語言來比喻一個 &lt;portType&gt; 元素可以被當成一個 function 函式庫或者一個 class WSDL Message&lt;message&gt; 定義關於一個操作的資料元素，每一個 message 可以由一個或多個 parts 組成，parts 可以想成是參數 WSDL Types&lt;types&gt; 元素用來定義資料類型，給 Web Service 使用。 WSDL Bindings&lt;binding&gt; 元素用來給不同的 prot 定義資料格式 簡易的範例1234567891011121314&lt;message name=&quot;getTermRequest&quot;&gt; &lt;part name=&quot;term&quot; type=&quot;xs:string&quot; /&gt;&lt;/message&gt;&lt;message name=&quot;getTermResponse&quot;&gt; &lt;part name=&quot;value&quot; type=&quot;xs:string&quot;/&gt;&lt;/message&gt;&lt;portType name=&quot;glossaryTerms&quot;&gt; &lt;operation name=&quot;getTerm&quot;&gt; &lt;input message=&quot;getTermRequest&quot; /&gt; &lt;output message=&quot;getTermResponse&quot; /&gt; &lt;/operation&gt;&lt;/portType&gt; &lt;portType&gt; 元素幾乎是 WSDL 最重要的元素，一個 portType 定義一個 Web Service 有哪些操作可以被執行，還有對應的 message。&lt;portType&gt; 定義 Web Service 的一個連接點，portType 就是一個函式庫然後呼叫的時候有一個對應執行 functionreturn 回傳值的時候有另外一個 function 就是 messagemessage 裡面的 part 就是參數 &lt;operations&gt; 又區分四種類型 只收資料 收資料，回傳資料 主動發送 request 然後等待 response 只送資料 123456789101112131415161718192021222324252627&lt;!-- 只收資料範例 --&gt;&lt;message name=&quot;newTermValues&quot;&gt; &lt;part name=&quot;term&quot; type=&quot;xs:string&quot;/&gt; &lt;part name=&quot;value&quot; type=&quot;xs:string&quot;/&gt;&lt;/message&gt;&lt;portType name=&quot;glossaryTerms&quot;&gt; &lt;operation name=&quot;setTerm&quot;&gt; &lt;!--實際 call 的 method name --&gt; &lt;input name=&quot;newTerm&quot; message=&quot;newTermValues&quot; /&gt; &lt;!-- 其實只負責關聯函式的參數部分 message 很重要，name 不重要 ，另一個角度思考就是一個要傳入或 return 的 object 格式 - 訊息格式。--&gt; &lt;/operation&gt;&lt;/portType&gt;&lt;!-- 一般發收資料 --&gt;&lt;message name=&quot;getTermRequest&quot;&gt; &lt;part name=&quot;term&quot; type=&quot;xs:string&quot; /&gt;&lt;/message&gt;&lt;message name=&quot;getTermResponse&quot;&gt; &lt;part name=&quot;value&quot; type=&quot;xs:string&quot; /&gt;&lt;/message&gt;&lt;portType name=&quot;glossaryTerms&quot;&gt; &lt;operation name=&quot;getTerm&quot;&gt; &lt;input message=&quot;getTermRequest&quot; /&gt; &lt;input message=&quot;getTermResponse&quot; /&gt; &lt;/operation&gt;&lt;/portType&gt; WSDL bindings 定義一個 Web Service 的 message 格式和協定的細節例如 123456789101112131415161718192021222324&lt;message name=&quot;getTermRequest&quot;&gt; &lt;part name=&quot;term&quot; type=&quot;xs:string&quot; /&gt;&lt;/message&gt;&lt;message name=&quot;getTermResponse&quot;&gt; &lt;part name=&quot;value&quot; type=&quot;xs:string&quot; /&gt;&lt;/message&gt;&lt;portType name=&quot;glossaryTerms&quot;&gt; &lt;operation name=&quot;getTerm&quot;&gt; &lt;input message=&quot;getTermRequest&quot; /&gt; &lt;output message=&quot;getTermResponse&quot; /&gt; &lt;/operation&gt;&lt;/portType&gt;&lt;binding type=&quot;glosaryTerms&quot; name=&quot;b1&quot;&gt; &lt;soap:binding style=&quot;document&quot; transport=&quot;http://schemas.xmlsoap.org/soap/http&quot; /&gt; &lt;operation&gt; &lt;soap:operation soapAction=&quot;http://example.com/getTerm&quot; /&gt; &lt;input&gt;&lt;soap:body use=&quot;literal&quot; /&gt;&lt;/input&gt; &lt;output&gt;&lt;soap:body use=&quot;literal&quot; /&gt;&lt;/output&gt; &lt;/operation&gt;&lt;/binding&gt; binding 元素有兩個屬性 name typename 您可以隨意定義一個 binding 的名稱，type 指向該綁定誰 portTypesoap:binding 有兩個屬性 style transportstype 可以是 rpc 或者 documenttransport 定義 soap 協定裡面的 operation 定義 portType 裡面的每個 operation 該揭露哪些訊息soapAction 指向該 method 的 url 對該網址 post WSDL 和 UDDIUDDI 是一個目錄服務，讓公司可以註冊或搜尋 Web ServiceUDDI 代表 Universal Description, Discovery IntegrationUDDI 是一個目錄用來儲存關於 Web Service 的資訊UDDI 是 Web Service 介面的一個目錄，這個介面透過 WSDL 描述UDDI 透過 SOAP 溝通 SOAPSOAP 代表 Simple Object Access ProtocolSOAP 是一種協定，用來存取 Web ServiceSOAP 架構在 XML 之上SOAP 是用來讓應用程式之間溝通的SOAP 透過網路溝通 一個 SOAP 訊息就只是一個普通的 XML 不過包含下面的訊息一個 Envelope 元素定義一個 XML 為 SOAP 訊息一個 Header 元素包含表頭資訊一個 Body 包含要回應的訊息一個 Fault 包含錯誤和狀態訊息 在 Header 裡面加上 mustUnderstand 屬性表示這個標籤一定要給 12345&lt;soap:Header&gt; &lt;m:Trans xmlns:m=&quot;http://www.w3schools.com/transaction/&quot; soap:mustUnderstand=&quot;1&quot;&gt;234 &lt;/m:Trans&gt;&lt;/soap:Header&gt; TODO 問題 用 .NET 實作 WebServices 然後用 OSX Post 取得資料？ ANS: 在 Window 8 底下 PostMan 對 localhost 開發伺服器發送 Post 成功 為什麼用 HTML Form 可以直接對 W3C http://www.w3schools.com/webservices/tempconvert.asmx?op=FahrenheitToCelsius丟資料會成功，但是 PostMan 失敗哪邊搞錯了 ANS: 用 PostMan 要在 x-www-form-urlencoded 放資料就會成功了 對自己的 Web Services(NET 版)測試用 Form 和 PostMan 丟資料 from-data, x-www-form-urlencoded, raw 的差異？ ANS: 在傳輸表單資料時候(Form) ，W3C 針對 Form 的內容定義了不同的類型，如果您希望傳送的是簡單的文字資料那麼 x-www-form-urlencoded 就能夠運作，這是預設的格式。不過如果您要傳送非 ASCII 文字或者 Binary 資料，那麼就要改用 form-data 模擬對 Sails 發送 SOAP 接到 XML 資料 6-1-1. 定義一個簡單的 WSDL(手刻)6-1-2. 從 Sails 發出一份 WSDL，用 SOAP UI 檢查6-2. 根據這份定義 User 要知道怎麼寫 SOAP Request6-3. 開發者也要知道會收到什麼資料，回傳什麼資料","link":"/2015/05/14/web-services/"},{"title":"IISExpress 使用 IP 連線","text":"這個需求是我在 OSX VM 底下用 Windows 開發 Web 時希望從 OSX 這邊或者給內網的其他使用者快速連到 Visual Studio 的 Development Server 而產生的。 因為 IIS Express 預設是綁定只能透過 localhost 網域名稱來連線，所以當您透過內網 IP 連線時會出現 HTTP Error 400. The request hostname is invalid. 錯誤。 此時只需要如下步驟設定，我們假設您 on 起來的 server port 是 9999 實際設定時請改成您的 port 號 用管理者權限使用指令1$ netsh http add urlacl url=http://*:9999/ user=&quot;NT AUTHORITY\\INTERACTIVE&quot; 修改 IISExpress 設定檔在 %USERPROFILE%\\Documents\\IISExpress\\config\\applicationhost.config 檔案中找到對應網站的設定，把這個屬性換成如下 bindingInformation=&quot;*:9999:*&quot; 123456&lt;site name=&quot;...&quot; id=&quot;...&quot;&gt; &lt;!-- application settings omitted for brevity --&gt; &lt;bindings&gt; &lt;binding protocol=&quot;http&quot; bindingInformation=&quot;*:5555:*&quot; /&gt; &lt;/bindings&gt;&lt;/site&gt; 搞定！！","link":"/2015/05/14/iisexpress-use-ip/"},{"title":"ES6 Generators 基礎","text":"在 Javascript ES6 的新功能中，有一個新品種的 function 稱為 generator 這個名字有點奇怪，不過它的行為在第一次看到的時候似乎更加奇怪。這篇筆記目的在解釋關於 generator 基本的運作原理。 執行到完成在我們談論關於 generator 時，第一件事情是對於標題下的 執行到完成， generator 是如何不同於普通函式。 不過您是否看懂上面這一小段，您一直都對於 function 有一個相當基本的認知那就是一旦函式開始執行，它就會一直執行到完成為止。 1234567891011121314setTimeout(function() { console.log(&quot;Settimeout excuted&quot;);}, 1);function foo() { for(var i=0; i&lt;1000; i++) { console.log(i); }}foo();// 1 - 1000// Settimeout excuted// 即使只差 1ms 還是要等 foo 跑完。 這邊 for 迴圈如果數字再大一點那就需要點時間，至少大於 1ms，然後您就發現 setTimeout 明明說好是 1ms 後發動卻無法中斷 foo 所以 setTimeout 就被卡在 event-loop 等待直到輪到它為止。 那如果 foo() 可以被中斷呢? 不會破壞我們的程式嗎?那的確是個挑戰，當我們採取多執行緒來寫程式的時候，不過好佳在我們用 Javascript 所以我們不需要擔心那些，因為 Javascript 永遠是單執行緒，意思是在一個時間點永遠只有一個 function 或指令在執行。 注意: Web Worker 是讓你可以啟動另一個完全分離的執行緒，給一部分的 JS 在其中執行的機制，跟您主要的執行緒是平行的。不在我們的程式使用多執行並發是因為兩個執行緒只能透過非同步事件來互相溝通。雖然是兩個平行的執行緒一旦要溝通還是要遵守 event-loop 的規則，一次只有一個動作，且還是一旦執行就要執行到完成。 執行 - 暫停 - 執行透過 ES6 generator 我們可以有不同的函式，它可以在執行到一半暫停，然後再回復執行。讓其他程式可以在暫停這段期間先跑。 如果您曾經得讀過關於並發或者執行緒程式設計的文章，您也許看過 cooperative 這個術語，其基本的意思是一個進程(process)，在我們 JS 的範例是 function 會自己決定何時應該允許中斷暫停。因此可以和其他的程式碼協同合作。這個觀念的對比是 preemptive 指出一個進程可能會違反原本的設計而中斷。 ES6 generator function 在其並發行為裡是可以協同合作的。在 generator function 裡面您可以使用新的關鍵字 yield 來從內部暫停。沒有東西可以從外部暫停一個 generator ，必須要透過 yield 從內部暫停。 然而一旦 generator 用 yield 暫停了自己，它就不能靠自己回復。必須要有個外部的控制行為來使其回復執行。稍後會解釋該如何做。 所以基本上，一個 generator 函式可以被暫停，重啟，隨您高興開開關關幾次。事實上您可以用一個無限迴圈來搭配 generator ，在一般 JS 程式中出現無限迴圈通常是寫錯了，不過搭配 generator 卻是合理的而且有時候您的確就是想要這麼做。 更重要的是，這個暫停和重啟不只單單是控制 generator 的執行流程，而且還提供了兩種方式在執行過程中傳遞輸入和輸出的訊息 在一般函式中您可以傳入參數(Parameters)然後 return 一個結果。在 generator 您可以透過 yield 把資料丟出來，然後傳回其他資料再回復執行。 怎麼寫？這一小段讓我們來開始介紹關於這些新功能的語法(syntax) 首先是這個新的 generator function 的宣告 123function *foo() { // ...} 注意到 * 了嗎? 這個新語法看起來有點奇怪，在其他語言(C, Object-C)中看起來像是函式要回傳一個指標。不過不要搞混，這只是一個符號用來判斷這是一個特殊的函式 generator。 您可能看過其他文章使用 function* foo(){} 而不是 function *foo(){}，兩種宣告都正確。 generator function 大概就是一個普通的 function ，只是在內部多了一些新的語法可以使用。 而最主要的新玩具就是我們上面提到的 yield，直接來看點範例 1234function *foo() { var a = 1 + (yield &quot;fooo&quot;); console.log(x);} 當 generator 執行到 yield 時會暫停，這個時候會把右邊的 expression 把就是 fooo 字串送出來，當 generator 再次啟動的時候無論資料有沒有送進去 generator 就會取得另外一個 yield expression，把 1 + yield expression 計算的結果。 yield 的意思我喜歡用佔位的概念來形容，有點像 hook 的觀念。 剛剛我說的有點讓你混淆，讓我們再來釐清一次 yield 第一個功能是暫停，當函式走到 yield 的時候會先停止，然後把右邊的 expression 丟到外面。停一下！這個 expression 跟待會要接回來的資料沒有關係。把 yield 想成佔位符，意思是停在這邊等別人把值丟進來，同時在我停下來的時候也可以丟個東西出去。有點類似 HTTP 的運作概念，執行到 yield 的時候對外部發送個 request 然後等待外部把資料送回來。再停一下！什麼外部？就是 generator 的實體物件。他會負責把資料再丟回來。丟回來的時候記住就不會再被那個 “fooo” 混淆了， “fooo” 丟出去後就沒有他的事了。 這個例子太難懂? 讓我們看點更完整的基本用法 123456789101112function *gen() { console.log('start'); var o = yield &quot;called&quot;; console.log(&quot;I am back and bring &quot; + o);}var a = gen(); // 第一次呼叫時是返回一個 generator 物件var b = a.next(); // 開始執行，到 yield 時會暫停執行並返回，返回值是一個物件console.log(b.value); // 他的 value 屬性是 yield 右側的 expression 的執行結果console.log(b.done); // 是否完成var c = a.next(&quot;something from outside&quot;); // 帶個值回去console.log(c.done); // 完成a.next(); // 如果再呼叫 next()，就會拋出例外 現在您應該看懂了兩種溝通方式了吧 您可以在任何 expression 的位置單純使用 yield，將其置放在 expression/statement 之中，然後輸出的部分就會是 undefined。 一個片段程式碼產生一個值稱之為 expression，expression 類似語言中的片語，一個短句。 statement 則是一句完整的句子，在 JS 中用 ; 結束當作一個句子。 通常一個 statement 是獨立的，只會完成某項任務，不過如果它影響了整個程式例如: 異動了機器內部的狀態，或者影響後面的 statement，這些造成的改變我們就稱為 side effect (副作用) 12345678function foo(x) { console.log(&quot;x: &quot; + x);}function *bar() { yield; // 只會暫停 foo(yield); // 暫停並等待傳入參數到 foo()} Generator IteratorIterator 迭代器實際上是一種特殊的行為，也可以表示一個設計模式。這個行為指的是讓我們可以透過呼叫 next()在一個排序的集合中，特定時間點下一次只取得一個值。舉例來說我們在[1, 2, 3, 4, 5]這個陣列上使用 iterator。第一次呼叫 next() 時我們會取得 1，第二次 2 以此類推當所有元素值都被回傳過後，next() 將會回傳 null, false 或者其他通知我們已經跑完所有元素的訊號。 剛剛提到我們在外部用來控制 generator function 的那個實體物件就是 generator iterator ，聽起來好像挺複雜的不過讓我們來看看實際上的例子 12345678// 假設我們有一個 generator functionfunction *foo() { yield 1; yield 2; yield 3; yield 4; yield 5;} 為了逐步從 *foo 這個 generator function 中取得 yield 傳出來的資料我們需要一個迭代器 1var it = foo(); // 再次強調，第一次呼叫 function 傳回一個迭代器 所以！！第一次像我們平常一樣呼叫 function 的時候並不會真的執行。 在我們的觀念裡這的確有點陌生。您可能也會好奇想知道為什麼不是用 var it = new foo() 因為剛剛不是說回傳一個 iterator 實體物件嗎? 好吧我真的不知道，等我知道了在告訴你。這邊暫時先不討論這個問題 XD 接著讓我們開始來使用 iterator 12var message = it.next();console.log(message); // #=&gt; {value: 1, done: false} 第一次迭代之後我們會拿到 yield 傳出來的資料。再次強調一遍不要把 yield 的觀念當作是 function ，把它分成兩次一次負責輸出，取得資料之後您可以修改操作然後再把您的值丟回去。留在 function yield 右邊的那個 expression 丟出來後就沒用了。不要被它干擾。 每一次我們呼叫 next() 都會取得一個物件這個物件有 value 和 done 兩個屬性。done 用來判斷迭代器是否執行完畢。 1234console.log( it.next() ); // { value:2, done:false }console.log( it.next() ); // { value:3, done:false }console.log( it.next() ); // { value:4, done:false }console.log( it.next() ); // { value:5, done:false } 執行到第五次我們發現 done 還是 false 那是因為技術上來說 generator 還沒有執行完成。yield 傳出資料了還在等待你傳回去繼續執行。所以我們仍然要呼叫最後一次。所以最後一次如下： 1console.log( it.next() ); // { value:undefined, done:true } 現在我們執行完全部的流程了但是我們最後一次並沒有拿到任何資料因為我們已經用盡了 yield ____ 在這個關鍵點，您也許想知道我可以從 generator 回傳值嗎？並且如果我這麼做那這個值會在 {value: , done: true} 這個物件的 value 嗎? 答案是 Yes 可以 12345678function *foo() { yield 1; return 2;}var it = foo();console.log( it.next() ); // { value:1, done:false }console.log( it.next() ); // { value:2, done:true } 等等…但也不可以 依賴 return 恐怕不是個好主意，因為當我們使用 for..of 的時候最後一個回傳的值會被捨棄 123456789101112function *foo() { yield 1; yield 2; return 3;}var it = foo();for(var i of it) { console.log(&quot;使用 for of &quot; + i);}// 使用 for of 1// 使用 for of 2 為了完整起見讓我們來看看完整的輸入和輸出是如何操作的 現在我要來回答您怎麼丟資料回去呢? 就是每個 next() 帶入的參數 1234567891011121314151617181920212223function *foo(x) { // you can use this to inspect // console.log(`x: ${x}, y: ${y}, z: ${z}`); var y = 2 * (yield (x + 1)); var z = yield (y / 3);; return (x + y + z);}var it = foo(5); // 取得 iterator 物件，並不執行console.log( it.next() ); // { value:6, done:false }// 第一次呼叫 x: 5, y: undefined, z: undefined// 執行到 var y 那邊停住，傳出 yield(x+1) = 6console.log( it.next( 12 ) ); // { value:8, done:false }// 送 12 進去所以 y = 2 * 12 = 24，第二次呼叫 x:5, y: 24, z: undefined// 到 var z 那邊停住，輸出 8 等待輸入...console.log( it.next( 13 ) ); // { value:42, done:true }// 送 13 進去所以 z = 13 所以第三次呼叫 x: 5, y: 24, z: 13// 第三次完成並取得 return value 42 你可以看到我們仍然可以透過參數來初始化 x，第一次初始化並建立 iterator 順便讓 x 等於 5。 第一次 next() 我們沒有傳入任何值因為第一次還沒有任何 yield 在等你傳值進去。那如果我們傳值了呢? 沒什麼不行，因為這個值會被丟掉。ES6 表示 generator function 會忽略用不到的值。不過有些還沒完全實作 ES6 的瀏覽器可能會出錯。 yield (x + 1) 先往外丟出 6 ，然後等你第二次呼叫 next(12) 所以 y 會是 2 * 12 = 24 接著 yield (y / 3) 就是 yield (24 / 3) 丟出 8 一樣等你把 13 丟進去所以 z = 13 最後 return (x + y + z) 等於 42，看這邊可能會頭暈。多看幾次。 for..ofES6 也提供一種方便的迭代語法，for...of 123456789101112131415function *foo() { yield 1; yield 2; yield 3; yield 4; yield 5; return 6;}for (var v of foo()) { console.log( v );}// 1 2 3 4 5console.log( v ); // still `5`, not `6` :( 如您所見，foo() 會先建立迭代器且 for..of 會自動去擷取它然後為您自動迭代取出每一個 yield express 吐回來的值。直到 done:true 出現。當 done 為 false 的時候他會自動擷取 value 屬性，注意不是物件。一旦 done: true 迴圈就停止，而且不會包含最後的 return 的值。 注意上面您可以看到 for..of 迴圈會忽略丟掉 return 6，而且因為沒有 next() 可以使用所以在這種情況下你就不能用 for..of 必須要自己操作。 結論OK! 現在您已經懂了 generator 的基本用法了。別擔心如果你現在有點混亂是正常的，我第一次看也是。很自然的您會想知道，這個新玩具可以在實際專案中做些什麼? 在您熟悉玩過上面這些範例程式碼之後您可能會問 如何把它用在錯誤處理方面? Generator 可以呼叫其他 Generator 嗎? 如何使用非同步的方式操作 Generator? 如果我有時間我會繼續翻譯系列文章 資源參考翻譯自The Basics Of ES6 Generators","link":"/2015/05/20/es6-generators/"},{"title":"Webpack 筆記","text":"動機今時今日所謂的網站正進化成網路應用程式，它不再只是單純的顯示圖片文字資訊，而包含著更多互動與操作行為，同時也意味著一個網站: 具有更多的 Javascript 可以在現代的瀏覽器上做更多事 較少全頁重新載入的行為 ➞ 甚至更多程式碼在單一頁面 其結果就是有更多程式碼出現在客戶端(Client side)有大量的程式碼需要被組織化。模組化系統提供一種方式讓我們可以切割我們的程式碼使其變成個別的模組。 如果您是實作派的可以直接看 跟著官方文件實作一遍 下面除了官方入門，同時也搭配 Pete Hunt 的 webpack-how-to 實作一遍常用的功能 模組化系統的風格針對如何定義模組之間的相依性，在 JS 世界中有很多不同的標準: &lt;script&gt; 標籤(不具備模組化系統) CommonJS AMD 以及其衍伸的標準 ES6 模組 其他 &lt;script&gt; 標籤當你不使用任何其他模組化系統，這是你在網頁中處理模組或說切割 JS 檔案的方法。 1234&lt;script src=&quot;module1.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;module2.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;libraryA.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;module3.js&quot;&gt;&lt;/script&gt; 這種方式通常一個模組會匯出介面到全域物件，即 window 物件，模組可以透過全域物件存取相依的介面或叫方法。常見的問題 在全域物件中產生衝突 載入的順序非常重要，錯了其他需要相依的函式庫就不能用 開發者必須要自己解決模組和函式庫之間相依性的問題 在大型專案中這一串載入的列表可能非常長，難以維護 CommonJS 同步 require這種方式採用同步風格的 require 方法，類似我們 C# 的 using, Ruby 的 require 或 load，透過這個方法載入相依的函式庫並匯出一系列介面一個模組可以透過在 exports 加上屬性(Property)或 module.exports 的值來設定其介面，這段話有點抽象換成白話一點的解釋: 根據 CommonJS 標準，一個檔案即一個模組。載入模組使用 require 方法，這個方法會讀取檔案並執行，最後回傳檔案內部 exports 的物件。 1234567891011121314151617181920212223// 基礎的用法require('module');require('../file.js');exports.doStuff = function () {};module.exports = someValue;// 簡易的範例/*** car.js ***/function Car() { this.run = function () { console.log(&quot;Car run...&quot;); } this.stop = function () { console.log(&quot;Car stop!!&quot;); }}var car = new Car();module.exports = car;/*** main.js ***/var Car = require(&quot;./car&quot;);Car.run(); // Car run... 明白了一點點用法後我們知道 CommonJS 載入模組是同步的。 優點 伺服器端模組可以被重複使用 已經有許多 npm 的模組採用這種風格 因為其語法和用起來簡單易懂 缺點 阻塞式的調用並不適合網路環境，因為網路溝通的 request 是非同步的 沒有支援多模組的平行載入實作 node.js browserify modules-webmake wreq AMD 非同步載入因為瀏覽器的需求以及同步 require 的問題，所以引進了一個非同步的版本 12345require(['module', '../file'], function(module, file) { /* code here */});define('mymodule', [&quot;dep1&quot;, &quot;dep2&quot;], function(d1, d2) { return someExportedValue;}); 優點 符合網路非同步載入的需求 可多模組平行載入 缺點 需撰寫比較多的程式碼，比較難讀寫(對開發者來說)和維護 看起來像是某種取巧的解法實作 require.js curl ES6 模組ECMAScript6 內建的用法 123import &quot;jquery&quot;;export function doStuff() {}module &quot;localModule&quot; {} 優點 靜態解析非常容易 未來將會是標準缺點 瀏覽器全面支援需要花些時間 非常少模組已採用此種方式 兼容的解決方案讓開發者選擇模組化的標準，讓已存在的程式碼可以運作，使其可以輕鬆的加入其他模組標準。 關於傳輸模組通常會在客戶端執行，所以必須從伺服器端傳輸到瀏覽器。 這邊有兩種關於傳輸模組的極端例子: 每一個模組一個請求 所有模組整合成一個請求 兩者都被廣泛的使用，但也都不是最佳的做法 關於一個模組一個請求 優點: 只有需要的模組會被傳輸，不會傳一堆不相關的東西 缺點: 太多 request 缺點: 因為 request 太多導致可能害應用程式初始化或者第一次載入時很慢 所有模組整合成一個請求 優點: 較少的請求數，程式開始的時候比較快 缺點: 不需要的模組也會被一併傳輸 分組傳輸一種比較彈性的傳輸，在上面兩種極端的方法中取得平衡的折中作法。在編譯所有模組時: 將系列模組區分成多個較小的區塊(程式碼片段)如此一來就不用在初始化的時候一口氣全部載入，只要根據需求載入即可 為什麼不僅僅只載入 Javascript?我們應該反問為什麼模組化系統只協助開發者處理 Javascript? 還有其他靜態資源檔案需要被處理: stylesheets images webfonts html for templating 還有其他 coffeescript ➞ javascript less stylesheet ➞ css jade ➞ html i18n ➞ something 1234require(&quot;./style.css&quot;);require(&quot;./style.less&quot;);require(&quot;./template.jade&quot;);require(&quot;./image.png&quot;); 因為上面這些動機，所以您找到了 webpack。 Webpack 是什麼?webpack 簡單說就是一個模組的封裝工具(module bundler)，由德國的 Tobias Koppers 所開發。webpack 會將模組與其相依性的模組, 函式庫, 其他需要預先編譯的檔案等整合產生此模組的靜態資源檔嫌太饒舌，那我們直接看官方的圖片，就是把我們常用的 .less, .scss, .jade .jsx 等等的檔案編譯成單純的 js + 圖片(圖片有時候也可以被編譯成 base64 格式的 dataUrl)。第一次接觸 Webpack 的人可能會忽略這個重點(小弟就是其一)，那就是編譯後的靜態資源檔真的就如圖上所示，只有 js + 圖片。css也會被編譯到 js 中，也就不需要在額外匯入。達到真正的模組化。看看下圖一隻編譯完成的檔案 為什麼不用其他 bundler?已存在的 bundler 針對大型專案並不是真的那麼適合，這裡指的是大型的 SPA。為什麼要創造 webpack 最重要的動機就是需要 Code Splitting 拆分程式碼，同時像是 css, 圖片等等靜態資源檔需要無縫整合。這邊的拆分程式碼指的是依照需求，功能來區分模組達到關注點分離。如果您曾經試過其他 bundler 他們並無法達到這個目的。大部份都只是個別組織 JS 檔案和靜態資源檔案。因此 webpack 為了滿足這個動機而誕生。 目標 能夠拆分相依性的關係結構變成程式碼片段，然後依據需求載入 盡可能減少初始化載入的時間 每一個靜態資源檔也應該要能被模組化 有能力整合其他第三方函式庫為模組 bundler 絕大部份能夠依照需求自訂修改 適合大型專案 Webpack 有哪些不同?Code Splitting 拆分程式碼webpack 在其相依性結構(Dependency tree)中有兩種相依的類型: sync 和 async。以非同步相依作為分割點，形成一個新的片段。當 chunk tree 程式碼片段之間的結構被優化之後，就會透過一個檔案整合發佈每一個 chunk 即每個片段程式碼。 loaders 載入器載入器當然是翻得不好，一般來說其意義就是負責載入安裝程式的角色，所以這邊我們還是稱其為 loader。雖然 webpack 本身只能夠處理 Javascript，不過因為有 loaders，可以被用來轉換其他資源為 Javascript ，透過這種方式每一個資源檔都可以被轉換成模組形式。換個方式來比喻其實 html 的 &lt;link rel=&quot;stylesheet&quot; /&gt; 就是一個 css 載入器的角色，又或者有用過 browserify 的人所熟悉的 transforms。其功能為轉換解析 ➞ 載入 ➞ 使用。 智慧型解析webpack 擁有更聰明的解析工具可以處理幾乎所有的第三方函式庫。甚至允許在相依性設定上使用表達式，例如: require(&quot;./templates/&quot; + name + &quot;.jade&quot;)。這幾乎能處理大部份的模組化標準(CommonJS, AMD) 擴充套件系統webpack 擁有豐富的擴充套件。大部份內部的功能都是架構在擴充套件之上。這使得我們能夠自訂客製 webpack 來滿足我們的需求，並且可以發佈成通用套件為 Open Source至此我們對於 webpack 有了一點概念性的了解。 安裝 webpacknode.js使用 webpack 之前我們需要安裝 node.js 以及其內建的套件管理工具 npm webpack接著就可以透過 npm 直接安裝 webpack 1$ npm install webpack -g 透過 -g 參數 webpack 會被安裝在系統全域環境同時具備 webpack 指令 在專案中使用 webpack在專案中使用 webpack 最好也讓專案相依於 webpack，即透過 npm 為專案安裝 webpack。透過這個方式我們可以選擇調整 webpack 的版本，而不必被強迫使用全域的版本。建立專案的步驟首先需要建立一個 package.json 設定檔或者直接使用 npm 指令來產生 1$ npm init 關於 npm init 會用互動的方式在指令介面問你的問題，如果專案不會公開出去的話其實也不是太重要接著一樣透過 npm 指令安裝 webpack 1$ npm install webpack --save-dev 版本一般來說 webpack 同時間會有兩個版本。穩定版以及 Beta 版本。Beta 版會加後綴 -beta 在版號後面。Beta 版本可能會部分實驗性或較不穩定缺少足夠測試的功能，對於需要較嚴謹的東西應該使用穩定版較佳。您可以透過指令來指定安裝的版本 1$ npm install webpack@1.2.x --save-dev 接著我們就可以來看看該如何使用 指令介面安裝全域指令1$ npm install webpack -g 單純編譯指令1$ webpack &lt;entry&gt; &lt;output&gt; entry傳入一個檔案或者路徑字串。您可以傳入多個程式進入點檔案(每一個檔案將會在啟動期間被載入)，entry 用實作的行為來說明就是那隻用來 require 其他模組的檔案。另外如果你使用 &lt;name&gt;=&lt;filename/request&gt; 的格式您可以替 entry point 建立一個別名。用法如下 12$ webpack bar=./entry.js &quot;[name].js&quot;&gt;&gt; output a bar.js file. 同時這個名稱也會被對應到設定檔 entry，太難懂！！沒關係我們換個實際例子來證明這段說明，首先我們建立一個 webpack.config.js 123456// webpack.config.jsmodule.exports = { output: { filename: &quot;[name].bundle.js&quot; }} 接著執行指令 12$ webpack FooBar=./entry.js&gt;&gt; Output a file that is named FooBar.bundle.js output參數: 表示欲輸出的路徑，其會被映射到設定檔中的 output.path 以及 output.filename 設定參數webpack 有很多參數能夠直接從指令去設定然後對應到設定檔，即 --debug 對應到 debug: true，--output-library-target 對應到 output.libraryTarget 套件有些套件被映射到指令的參數選項，即 --define &lt;string&gt;=&lt;string&gt; 會對應到 DefinePlugin Development 縮寫 -d等同於 --debug --devtool source-map --output-pathinfo，產生 source maps 檔案 Production 縮寫 -p等同於 --optimize-minimize --optimize-occurence-order，建置壓縮的程式碼 監視模式 –watch會一直監視所有的相依檔案當其改變時自動重新編譯，適用於開發模式持續性的更新編譯 指定設定檔 –config設定不同於預設的設定檔。如果您希望採用不同於預設 webpack.config.js 的設定檔可以採用 --config 來指定 顯示參數--progress: 顯示編譯的進度和訊息--json: 產生 JSON 格式的 stdout--color: 彩色模式--sort-modules-by, --sort-chunks-by, --sort-assets-by: 排序--display-chunks: 顯示模組區分的資訊--display-error-details: 顯示更多關於錯誤訊息 跟著官方文件實作一遍首先是您當然需要安裝 node.js 接著安裝 webpack。 1$ npm install webpack -g 開始組織專案建立一個空目錄來置放我們的檔案，在該目錄底下建立 entry.js 12// File: entry.jsdocument.write(&quot;It works.&quot;); 123456789&lt;!-- File: index.html --&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;bundle.js&quot; charset=&quot;utf-8&quot; /&gt; &lt;/body&gt;&lt;/html&gt; 執行 1$ webpack ./entry.js bundle.js 就會將我們的 entry.js 編譯成 bundle.js如果編譯成功，就會輸出類似下面的資訊 123456Hash: e97678c23acf8ee01956Version: webpack 1.9.10Time: 62ms Asset Size Chunks Chunk Namesbundle.js 1.44 kB 0 [emitted] main [0] ./entry.js 29 bytes {0} [built] 接著開啟 index.html 如下圖 第二個資源檔案接著我們模擬實際專案的狀況，匯入另外一個檔案 content.js 12// content.jsmodule.exports = &quot;It works from content.js&quot;; 然後編輯 entry.js 加入 require 12// File: entry.jsdocument.write(require(&quot;./content.js&quot;)); 更新瀏覽器得到如下圖 Webpack 會分析進入點檔案並取得相依的其他檔案。這些檔案(被稱為模組)也會被加入到 bundle.js。Webpack 會給每一個模組唯一的 ID 然後透過 ID 存取這些模組，這些模組都會被整合到 bundle.js 裡面。只有進入點的模組會在程式啟動時被執行。這個小範例示範了 require 以及當相依模組被 require 載入後執行的用法。 第一個 loader現在我們遇到一個問題，我們想要加入 css 到該應用程式中，Webpack 預設只能夠處理 JS 檔案，所以我們需要 css-loader 來處理 css 檔案。接著透過 style-loader 來把樣式套用到 DOM 上。 建立一個空的 node_modules 目錄(或者您要使用 npm init)，事實上直接使用 npm install 也是會自動建立 node_module 目錄。執行 1$ npm install css-loader style-loader 加入 style.css 123body { background: yellow;} 再次編輯 entry.js 12require(&quot;!style!css!./style.css&quot;);document.write(require(&quot;./content.js&quot;)); 重新編譯並重整瀏覽器得到 透過在匯入模組(在這邊就只是一隻檔案)前加上 ! 和 loader 的前綴字，該模組將會逐步透過每一個 loader 處理，一個 pipeline 的概念，一個處理完交棒給下一個處理，這些 loader 會將檔案中的內容根據特定需求轉換。在經過這些轉換的過程之後最終的結果就是一個 javascript 模組。 綁定 loaders實務上，我們並不希望一直重複撰寫這種長長的 pipe 方式，即 require(&quot;!style!css!./style.css&quot;);我們可以根據副檔名綁定或說設定其 loaders，如此一來我們就只要寫 require(&quot;./style.css&quot;) 改寫 entry.js 123// entry.jsrequire(&quot;./style.css&quot;);document.write(require(&quot;./content.js&quot;)); 透過指令的方式繫結 1234$ webpack ./entry.js bundle.js --module-bind 'css=style!css'# 有一點要注意的是因為 ! 在 bash 裡面有特殊意義所以當您想用 &quot; 替代 ' 請記得跳脫$ webpack ./entry.js bundle.js --module-bind &quot;css=style\\!css&quot; 您應該會看到跟上面黃色底一樣的結果 設定檔除非你是下指令狂，不然您應該不會希望每次指令都這麼長，這時我們可以把這些參數移到一個設定檔裡 webpack.config.js 123456789101112module.exports = { entry: &quot;./entry.js&quot;, output: { path: __dirname, // 此設定檔案所在的目錄 filename: &quot;bundle.js&quot; }, module: { loaders: [ { test: /\\.css$/, loader: &quot;style!css&quot; } ] }} 一旦您有了設定檔，現在你只需要執行 1$ webpack webpack 指令會試圖去載入當前目錄下的 webpack.config.js 整潔易看的輸出隨著我們的專案增長，編譯的時間可能會稍微長一點點。所以我們希望在編譯的時候有進度表以及我們希望輸出的資訊可以有顏色以便我們好觀察這個時候我們可以透過下面參數達成 1$ webpack --progress --colors 監視模式 watch又或許在開發時期我們不希望一直手動輸入指令 1$ webpack --progress --colors --watch Webpack 可以快取沒有改變的模組。 當使用監視模式，webpack 會觀察專案底下所有在編譯時會用到的檔案，如果這些檔案發生改變，馬上會重新編譯當快取被啟動的時候 webpack 會將所有模組存在記憶體中，如果模組沒有改變就會繼續沿用。 開發時期伺服器更好用的開發時期的伺服器 webpack-dev-server 1234# 安裝$ npm install webpack-dev-server -g# 啟動$ webpack-dev-server --progress --colors 提供一個 localhost:8080 的 express server ，讓我們在開發時期可以更快速的觀察結果，當然會自動編譯，同時自動更新頁面(socket.io)這個工具使用 webpack 的監視模式所以編譯的結果 這個開發伺服器使用了 webpack 的監視模式。同時他也會阻止 webpack 持續把編譯結果存到硬碟上，取而代之的這個結果會被保留在記憶體。不要誤會！這邊說的是如果你單純使用 webpack 監視模式，上例中的 bundle.js 檔案是會被產生的，但如果是 webpack-dev-server 則不會產生 bundle.js 那隻檔案。 webpack-how 跟著 Pete hunt 的文件再跑一輪這個段落我們會在翻譯以及實作 webpack-howto 來加深我們對 webpack 的理解，老實說因為官方的文件並不是非常完整。 1. 為什麼使用 webpack (Pete hunt 版) 它很像 browserify，但是他可以分割程式為多個檔案。例如您在一個單一頁面應用程式(SPA)中有數個頁面，那麼使用者只需要下載正在閱讀的那一頁，如果他切換到另個頁面，也不會重新下載共用部分的程式碼 大多數的情況下可以取代 grunt 或 gulp 因為他也可以封裝 css, 預先編譯的 css 語言, 預先編譯的 js 語言, 圖片以及其他東西 同時它支援 AMD 和 CommonJS 以及其他模組標準。如果您不知道該使用什麼，就用 CommonJS 2. 對於會用 Browerify 的開發者下面兩個指令是等價的 123$ browserify main.js &gt; bundle.js$ webpack main.js bundle.js 然而 webpack 比起 Browserify 更加強大，也因為支援許多功能，所以一般來說我們會將設定存放在 webpack.config.js 這隻設定檔。讓我們再來多練習一次，建立一個 webpack_sandbox 目錄，裡面自己放一些簡單的 main.js 主要的進入點程式，index.html 測試載入 bundle.js 是否正常運作，以及最重要的 webpack.config.js 如下 123456module.exports = { entry: './main.js', output: { filename: 'bundle.js' }} 這個 webpack.config.js 就只是 Javascript ，所以就像你平常寫 js 一樣修改它即可。 3. 如何執行 webpack一般來說我們常用的編譯指令如下，記住先切換到 webpack.config.js 所在的目錄底下然後執行 webpack 建置編譯開發版的檔案，只會運行一次 webpack -p 執行一次建置的任務，產生正式版(具有壓縮) webpack --watch 持續性編譯，即開發時期，每次一變更檔案就重新編譯(快速) webpack -d 包含產出 source maps，即 .js.map 檔案 4. 預先編譯的 JS 語言在 webpack 中有個跟 browserify 的 transforms 以及 RequireJS plugin 功能相等的東西，就是 loader。下面示範如何讓 webpack 載入 CoffeeScript 和 Facebook 的 JSX + ES6 支援(您必須要安裝 babel-loader coffee-loader)，因為 babel 內建搭載支援 JSX 所以您不需要再增加額外的 jsx-loader。 為了要實際測試，我們需要再目錄中建立一個 coffee, React 元件(JSX + ES6 支援)首先先測試 coffee 所以我們新增一隻測試的 coffee 123# File: audi.coffeevalue = &quot;It's from audi.coffee&quot; if true # it's coffeescript syntax.module.exports = value; 安裝 coffee-loader 12$ npm init$ npm install coffee-loader --save-dev 調整 webpack.config.js 123456789101112// File: webpack.config.jsmodule.exports = { entry: './main.js', output: { filename: 'bundle.js' }, module: { loaders: [ { test: /\\.coffee$/, loader: 'coffee-loader' }, ] }} 測試，在 main.js 中使用 1234567// File: main.jsdocument.write(&quot;Hey from main.js&quot;);document.write(&quot;&lt;br/&gt;&quot;);var audi = require(&quot;./audi.coffee&quot;);document.write(audi);document.write(&quot;&lt;br/&gt;&quot;); 接著我們來測試 jsx 與 React，記得先安裝 babel-loader 1$ npm install babel-loader --save-dev 調整 webpack.config.js 為 123456789101112module.exports = { entry: './main.js', output: { filename: 'bundle.js' }, module: { loaders: [ { test: /\\.coffee$/, loader: 'coffee-loader' }, { test: /\\.js$/, loader: 'babel-loader'}, ] }} 新增一隻 React 元件檔案 toyota.js 12345678910111213// File: toyota.jsexport default class Totota extends React.Component { constructor(props) { super(props); } render() { return ( &lt;div&gt; It's from toyota.js &lt;/div&gt; ); }} 最後 main.js(記得在 index.html 補上 React 的 JS) 12345678910111213// File: main.jsdocument.write(&quot;Hey from main.js&quot;);document.write(&quot;&lt;br/&gt;&quot;);var audi = require(&quot;./audi.coffee&quot;);document.write(audi);document.write(&quot;&lt;br/&gt;&quot;);document.write(&quot;&lt;div id='toyota'&gt;&lt;/div&gt;&quot;);var Toyota = require(&quot;./toyota.js&quot;);// 另外一種模組標準的寫法// import Toyota from &quot;./toyota.js&quot;;React.render(&lt;Toyota /&gt;, document.getElementById(&quot;toyota&quot;)); 每次在 require 的時候都要輸入附檔名也是挺麻煩的，所以 webpack 也提供您 require 不加副檔名的機制，為了開啟這個功能，我們必須要加入 resolve.extensions參數告訴 webpack 該處理哪些副檔名。 12345678910111213141516module.exports = { entry: './main.js', output: { filename: 'bundle.js' }, module: { loaders: [ { test: /\\.coffee$/, loader: 'coffee-loader' }, { test: /\\.js$/, loader: 'babel-loader' } ] }, resolve: { // 現在您可以把那些 require 中的副檔名去掉了 extensions: ['', '.js', '.json', '.coffee'] }}; 如果您是採用 webpack-dev-server 在修改 config 之後請記得重啟 如果檔名一樣會怎樣，在正常的專案底下不同類型的資源檔通常會用不同的目錄區隔，不過在這個簡單的範例中的確是有可能會重複的。webpack 其實會照上面 resolve 設定的陣列依序搜尋，找到了就不往下了。也就是如果有同名的 js 和 coffee 會處理 [檔名].js 而不管 coffee。 5. 樣式與圖片接著我們要來實作在模組中透過 require() 使用那些靜態資源檔。先示範在程式中我們會改成這樣參考資源檔，像 css, 圖片等等 123456require(&quot;./bootstrap.css&quot;);require(&quot;./app.scss&quot;);var img = document.createElement(&quot;img&quot;);img.src = require(&quot;./images/pretty.jpg&quot;);document.body.appendChild(img); 當我們 require css 或者 scss, less 等等的時候，webpack 會把 css 轉換一行的字串並封裝在 JS 中，然後當我們執行 require() 會幫我們插入 &lt;stype&gt; 標籤到該頁面而當我們 require 圖片的時候，webpack 則會把圖片轉換成 dataURI 或帶入連結。 當然這些都不是預設有的功能，你必須透過 loaders 告訴 webpack 該怎麼做，我們需要的 loaders，css-loader 和 style-loader 處理樣式，sass-loader 當然是處理 scss，url-loader 則負責處理圖片(檔案)類似。您也可以使用 file-laoder 不過 url-loader 可以設定限制檔案大小回傳 dataURI 或路徑。 這邊我們額外提一下上面說的流程中 css-loader 才是真正在解析 css 檔案，並且他會解析 css 中的 url(...) 轉換成 require(...) ，如此一來所有的資源都會依照 webpack 的處理方式載入，而 style-loader 收到這個輸出之後會把這些轉換完的結果注入 DOM 。 安裝 loaders 1$ npm install css-loader style-loader sass-loader url-loader --save-dev 設定 webpack.config.js 1234567891011121314151617181920212223// webpack.config.jsmodule.exports = { entry: './main.js', output: { path: './build', publicPath: 'http://andyyou.github.io/', // 圖片等需要路徑引用的資源檔加上網址 // 注意: 尾巴的 / 要記得加否則會產出類似 http://andyyou.github.io600e2b78b83128cc2be868b3971d0999.jpg 的路徑 filename: 'bundle.js' }, module: { loaders: [ { test: /\\.coffee$/, loader: 'coffee-loader' }, { test: /\\.js$/, loader: 'babel-loader'}, { test: /\\.css$/, loader: 'style!css' }, { test: /\\.scss$/, loader: 'style!css!sass'}, // =&gt; 透過 css-laoder 不只處理編譯好的 css, imports 同時包含 url(...) // { test: /\\.css$/, loader: 'raw!sass' }, // =&gt; 回傳編譯好的 css 程式碼單純只解析 imports 但不處理 url(...) { test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192' } // 當檔案小於 8K 的時候會產生 base64 格式的 dataURI 超過的話則直接帶連結 ] }, resolve: { extensions: ['', '.js', '.json', '.coffee', '.scss', '.css'] }} 6. 功能標籤我們想要某些程式碼只在特定環境下才執行，例如顯示偵錯訊息，又或者只在內部伺服器才開啟這個功能。因為我們是使用 webpack 來封裝編譯整個專案，所以很合理的可以加上一些 flag 讓 webpack 去替我們處理。我們可以直接在剛剛 main.js 中示範 12345678// main.jsif (__DEV__) { console.warn(&quot;It's dev environments&quot;)}if (__PRERELEASE__) { console.log(&quot;requre and show secret feature.&quot;)} 不過我們不是直接就可以使用魔術般的全域變數。我們還是需要告訴 webpack 才行下面這邊示範在 webpack 官方提到的 plugins 用法 123456789101112131415161718192021222324252627282930var webpack = require(&quot;webpack&quot;);var definePlugin = new webpack.DefinePlugin({ __DEV__: JSON.stringify(JSON.parse(process.env.BUILD_DEV || 'true')), __PRERELEASE__: JSON.stringify(JSON.parse(process.env.BUILD_PRERELEASE || 'false'))});module.exports = { entry: './main.js', output: { path: './build', // 編譯後的檔案放在這個目錄 // publicPath: 'http://andyyou.github.io/', // 圖片等需要路徑引用的資源檔加上網址 // 注意: 尾巴的 / 要記得加否則會產出類似 http://andyyou.github.io600e2b78b83128cc2be868b3971d0999.jpg 的路徑 filename: 'bundle.js' }, module: { loaders: [ { test: /\\.coffee$/, loader: 'coffee-loader' }, { test: /\\.js$/, loader: 'babel-loader'}, { test: /\\.css$/, loader: 'style!css' }, { test: /\\.scss$/, loader: 'style!css!sass'}, // =&gt; 透過 css-laoder 不只處理編譯好的 css, imports 同時包含 url(...) // { test: /\\.css$/, loader: 'raw!sass' }, // =&gt; 回傳編譯好的 css 程式碼單純只解析 imports 但不處理 url(...) { test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192' } // 當檔案小於 8K 的時候會產生 base64 格式的 dataURI 超過的話則直接帶連結 ] }, resolve: { extensions: ['', '.js', '.json', '.coffee', '.scss', '.css'] }, plugins: [definePlugin],} 接著我們就能夠用 BUILD_DEV=0 BUILD_PRERELEASE=1 webpack, 或者 BUILD_DEV=0 BUILD_PRERELEASE=1 webpack-dev-server --progress --colors來帶入參數，注意到 webpack -p 壓縮程式碼的時候會把不會執行的程式碼區塊給移除，所以我們不需要擔心洩露機密的程式碼到最後產出的檔案中。 7. 多個檔案(進入點程式, entrypoints)截至目前為止我們都只有一個 entry 即 main.js ，假設我們需要替個人資料頁和訂閱頁面各自加入自己擁有的 JS，因為我們不希望讓使用者在查閱個人資料時載入訂閱頁面需要的程式碼。所以我們需要打包成兩隻檔案，也就是這兩個頁面各自有自己的 entrypoint此時我們只需要修改設定檔 123456789101112131415161718192021222324252627282930313233343536// webpack.config.jsvar webpack = require(&quot;webpack&quot;);var definePlugin = new webpack.DefinePlugin({ __DEV__: JSON.stringify(JSON.parse(process.env.BUILD_DEV || 'true')), __PRERELEASE__: JSON.stringify(JSON.parse(process.env.BUILD_PRERELEASE || 'false'))});module.exports = { entry: { Main: './main.js', Profile: './profile.js', Feed: './feed.js' }, output: { path: './build', // publicPath: 'http://andyyou.github.io/', // 圖片等需要路徑引用的資源檔加上網址或路徑 publicPath: '/build/', // 因為有設定目錄，所以記得要補路徑，否則 require() 會取錯路徑。 // 注意: 尾巴的 / 要記得加否則會產出類似 http://andyyou.github.io600e2b78b83128cc2be868b3971d0999.jpg 的路徑 filename: '[name].bundle.js' // [name] 會使用 key 也就是上面大寫的 Main, Feed, Profile 等 }, module: { loaders: [ { test: /\\.coffee$/, loader: 'coffee-loader' }, { test: /\\.js$/, loader: 'babel-loader'}, { test: /\\.css$/, loader: 'style!css' }, { test: /\\.scss$/, loader: 'style!css!sass'}, // =&gt; 透過 css-laoder 不只處理編譯好的 css, imports 同時包含 url(...) // { test: /\\.css$/, loader: 'raw!sass' }, // =&gt; 回傳編譯好的 css 程式碼單純只解析 imports 但不處理 url(...) { test: /\\.(png|jpg)$/, loader: 'url?limit=8192' } // 當檔案小於 8K 的時候會產生 base64 格式的 dataURI 超過的話則直接帶連結 ] }, resolve: { extensions: ['', '.js', '.json', '.coffee', '.scss', '.css'] }, plugins: [definePlugin],} 設好之後，接著我們就可以透過 &lt;script src=&quot;build/Profile.bundle.js&quot;&gt;&lt;/script&gt; 針對個別頁面載入 8. 優化通用的程式碼假設上面的 Feed 和 Profile 有很多通用的部分(比如說 React 元件和通用的樣式)webpack 會分析他們哪些是共用的部分，如此一來共享的部分就會直接被快取，不用再重新載入一次。透過使用 new webpack.optimize.CommonsChunkPlugin 如下 123456789101112131415161718192021222324252627282930313233343536373839// File: webpack.config.jsvar webpack = require(&quot;webpack&quot;);var definePlugin = new webpack.DefinePlugin({ __DEV__: JSON.stringify(JSON.parse(process.env.BUILD_DEV || 'true')), __PRERELEASE__: JSON.stringify(JSON.parse(process.env.BUILD_PRERELEASE || 'false'))});var commonsPlugin = new webpack.optimize.CommonsChunkPlugin('common.js');// =&gt; 注意到這邊的參數會轉換成檔名輸出所以請記得加副檔名module.exports = { entry: { Main: './main.js', Profile: './profile.js', Feed: './feed.js' }, output: { path: './build', // publicPath: 'http://andyyou.github.io/', // 圖片等需要路徑引用的資源檔加上網址或路徑 publicPath: '/build/', // 因為有設定目錄，所以記得要補路徑，否則 require() 會取錯路徑 // 注意: 尾巴的 / 要記得加否則會產出類似 http://andyyou.github.io600e2b78b83128cc2be868b3971d0999.jpg 的路徑 filename: '[name].bundle.js' }, module: { loaders: [ { test: /\\.coffee$/, loader: 'coffee-loader' }, { test: /\\.js$/, loader: 'babel-loader'}, { test: /\\.css$/, loader: 'style!css' }, { test: /\\.scss$/, loader: 'style!css!sass'}, // =&gt; 透過 css-laoder 不只處理編譯好的 css, imports 同時包含 url(...) // { test: /\\.css$/, loader: 'raw!sass' }, // =&gt; 回傳編譯好的 css 程式碼單純只解析 imports 但不處理 url(...) { test: /\\.(png|jpg)$/, loader: 'url?limit=8192' } // 當檔案小於 8K 的時候會產生 base64 格式的 dataURI 超過的話則直接帶連結 ] }, resolve: { extensions: ['', '.js', '.json', '.coffee', '.scss', '.css'] }, plugins: [definePlugin, commonsPlugin],} 事實上 webpack 檢查的就只是重複 require 的部分，當多個 entrypoint 都有使用到某個模組，就可以透過上面的方式提出。如此一來在 html 則要加入 &lt;script src=&quot;build/common.js&quot;&gt; 否則會爆。這麼做就可以享受瀏覽器為我們快取檔案的優點。 9. 非同步載入CommonJS 標準屬於同步的處理方式但是 webpack 提供了一種方式來達到非同步處理相依性載入這通常對於 client 端有使用路由的狀況非常實用，假設您透過路由來取得的每個頁面，但是您不希望直接就下載所有程式碼直到程式運行真的需要該部分程式碼的時候才下載。這個時候我們就可以使用 require.ensure() 的方式來載入模組 下面是範例的程式碼，ensure 的第一個參數是相依的模組，類似於 RequireJS 的 define() 12345678910111213if (window.location.pathname === '/feed') { showLoadingState(); require.ensure([], function() { hideLoadingState(); require('./feed').show(); // 當這個函式被呼叫，模組保證被同步載入可以使用 });} else if (window.location.pathname === '/profile') { showLoadingState(); require.ensure([], function() { hideLoadingState(); require('./profile').show(); });} webpack 會幫您處理剩下的事情，產生因為非同步設定而需要額外 chunk 檔案有點難懂，沒關係我們現在先新增另外一個模組 benz.js 1module.exports = &quot;It's from module Benz&quot;; 然後在我們的 main.js 放入 123456if (window.location.pathname === '/profile.html') { require.ensure([], function () { console.log(require(&quot;./benz&quot;)); document.write(require(&quot;./benz&quot;)); })} 編譯之後會看到如下圖，官方文件提到的 chunk 實際上就是 webpack 處理過後依照需求區分的程式碼片段 webpack-dev-serverwebpack-dev-server 是一個小型的 node.js Express 伺服器，其使用 webpack-dev-middleware 來取得 webpack 封裝的結果。在運行時也有使用 socket.io 使其可以即時發送編譯後的資訊到客戶端同時這個開發伺服器也可以根據不同需求使用不同的模式，假設我們採用下面這組設定檔 12345678910module.exports = { entry: { app: [&quot;./app/main.js&quot;] }, output: { path: './build', publicPath: &quot;/assets/&quot;, filename: &quot;bundle.js&quot; }} 上面這組設定的意思您現在應該很請楚了，即我們有一隻進入點的程式(檔案)在 app/main.js ，webpack 將會打包 entrypoint 成 bundle.js 檔案到 bundle 目錄。同時我們也回顧一下光 entry 的設定就多種組合 1234567891011121314module.exports = { // 1 entry: { app: [&quot;./app/main.js&quot;] }, // 2 entry: &quot;./app/main.js&quot;, // 3 entry: { app: &quot;./app/main.js&quot; }, // 4 entry: [&quot;./a.js&quot;, &quot;./b.js&quot;],} 如果使用陣列的方式設定，所有的模組會在啟動時被載入，而最後一個檔案會被匯出。另外注意到如果適用第四種方式然後在 output 也使用了 [name] 那這個 name 預設是 main而想要多個 entrypoint 檔案的話則透過物件的格式，webpack 就會產生多個 entrypoint bundle。 預設一般模式(Inline mode)剛剛我們提到 webpack-dev-server 有不同的模式，現在我們就來瞭解一下其中一個 inline 模式。一般情況下 webpack-dev-server 會處理當前目錄的檔案(就是你下指令時的那個目錄)，除非您有指定 content-base 1$ webpack-dev-server --content-base build/ 使用了這個設定，webpack-dev-server 就會處理你指定的那個目錄，預設 webpack-dev-server 就會自動監視該目錄下的檔案，當發生改變就會自動重新編譯。不過這些編譯只會放到記憶體並和 publicPath 的路徑關聯，而不會產生實體檔案。當 bundle 已經存在在相同路徑時也就是已經產生檔案，記憶體中的會優先使用。舉上面一開始的設定檔為例，這個 bundle 封裝結果可以透過 localhost:8080/assets/bundle.js 存取 為了測試這個結果我們需要建立一個 html 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 當啟動 webpack-dev-server 之後，預設我們就可以透過 localhost:8080 來存取網站，而上面的設定檔加上了 publicPath 所以結果網址會是 localhost:8080/assets/ 即時更新模式(Hot mode)透過把專用的 script 加到 index.html，您的專案就會得到 live reload 的功能。 12345678910111213&lt;!DOCTYPE html&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- It is important that you point to the full url --&gt; &lt;script src=&quot;http://localhost:8080/webpack-dev-server.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 對了，這個功能當然也需要修改一點點設定 123456789module.exports = { entry: { app: [&quot;webpack/hot/dev-server&quot;, &quot;./app/main.js&quot;] }, output: { path: &quot;./build&quot;, filename: &quot;bundle.js&quot; }}; 然後執行指令時要加入 --hot 參數 1$ webpack-dev-server --content-base build/ --hot 即時更新模式 + 訊息顯示當您啟動了 webpack-dev-server 您也可以瀏覽 localhost:8080/webpack-dev-server/ 透過這個連結您不只會看到您的內容，同時上方會有一些訊息提示。並且如果您採用這個連結，檔案並不需要加入剛剛那支特殊的 webpack-dev-server script所以一般建議的開發流程我們的 html 不用特地加入 script 然後使用 localhost:8080/webpack-dev-server/ 來觀察其結果。 因為 index.html 大多數的時候不會需要靠 webpack 編譯(除非您改用 jade 或 slim)，所以當然不會被列在 watch 的檔案中。 webpack-dev-server 指令與參數一般來說所有的 webpack 參數同等於 webpack-dev-server 參數，不過 output 除外。當然您也可以透過 --config 來指定設定檔。下面是一些額外的參數 --content-base: 指定專案目錄 --quiet: 不要輸出任何資訊到 console --colors: 彩色的輸出資訊 --no-info: 去除一些不太必要的資訊 --host: 設定 hostname 或 IP --port &lt;number&gt;: 設定 port --inline: 內嵌一個 webpack-dev-server 到封裝裡 --hot: 加入 HotModuleReplacementPlugin 並切換到即時更新模式 hot mode ，注意不能加入該 plugins 兩次 --https: 啟用 https 協定 上面這些參數都可以加入 webpack.config.js 123456789module.exports = { // ... webpack.config.js stuff ... devServer: { contentBase: &quot;./build&quot;, noInfo: true, // --no-info option hot: true, inline: true }} 深入 loaders何謂 loaders ?loaders 就是轉換工具，用來把資源檔也就是我們的 js, css 等等這些模組轉換套用到程式上。它們是 node.js 中執行的函式，將資源檔當作參數取得其中的程式碼，轉換並傳回新的程式碼。舉例來說您可以使用 loaders 來告訴 webpack 如何處理並載入 CoffeeScript 或 JSX 功能 loader 可以被串連使用，即把一個資源檔從 A loader 交付給 B loader。講的太難懂，那我們先舉個在 Linux 底下所謂的 pipeline 的例子 ls | grep filename 在 Linux 底下我們可以透過 | 來做 pipeline，其行為就是先執行 ls 指令再把 ls 處理完的結果交給下一個指令。在上面的例子中 require(&quot;!style!css!./style.css&quot;); 就是一樣的意思把 style.css 交給 css-loader 先處理，處理完的結果再交給 style-loader。最終 loader 被預期傳回 Javascript，其他過程中的 loader 則可以傳回任意格式。 loader 可以套用同步或者非同步的行為 loader 運行在 node.js 環境中，且應該可以做到任何您想要的功能 loader 允許加入參數，其格式就像 HTTP 的 querystring 一樣，所以我們可以在設定檔或指令中帶入參數 loader 可以針對副檔名或正規表示式來設定要處理的檔案 loader 可以透過 npm 來發佈或安裝 除了正常 package.json 的 main，一般模組就我們在寫 JS 的 module.exports 也可以匯出 loader loader 可以存取設定檔 擴充套件可以賦予 loader 更多功能 loader 可以散播額外的任意檔案 其他 如果您對其他 loader 範例有興趣可以參考列表 解析 loaderloader 被解析的方式類似於模組。一個 loader 模組一般來說會需要輸出一個 function，且與 node.js 相容的 Javascript。在大部份的情況下我們透過 npm 來管理 loader不過您也可以將 loader 當作程式中的檔案來處理 參考(匯入) loader雖然這不是強制的，但依照慣例 loader 通常命名微 xxx-loader，而 xxx 就是其功能與描述的名稱也是我們在 pipeline 使用的名稱。例如 json-loader您也許會用完整名稱來引用該 loader(json-loader) 或者透過縮寫即 json關於 loader 命名慣例和搜尋的優先順序被定義在 webpack 設定檔的 resolveLoader.moduleTemplates 安裝如果 loader 存在，通常我們會直接透過 npm 安裝 12$ npm install xxx-loader --save$ npm install xxx-loader --save-dev 使用方式在您的專案中可以使用不同的方式來使用 loader 明確的寫在 require 中 在設定檔指定 直接透過指令參數設定 明確的寫在 require 中注意: 盡量避免使用這種方式，而採用設定檔的慣例來設定 loader這種方式是透過在 require 語句(或者 define, require.ensure) 中指定會採用的 loaders。透過 ! 將 loader 區隔。此時會相對於當前目錄去解析路徑 12345678require(&quot;./loader!./dir/file.txt&quot;);// =&gt; 使用在該目錄下的 loader.js 檔案來轉換 dir/file.txt 檔案require(&quot;jade!./template.jade&quot;);// =&gt; 使用 jade-loader (npm 安裝的模組) 來轉換 template.jaderequire(&quot;!style!css!less!bootstrap/less/bootstrap.less&quot;);// =&gt; 將 bootstrap/less/bootstrap.less 檔案透過 less-loader 先轉換成 css 再將結果傳給 css-loader 最後傳給 style-loader 在設定檔中指定您也可以透過正規表示式 RegExp 來設定 123456789101112{ module: { loaders: [ { test: /\\.jade$/, loader: &quot;jade&quot; }, // =&gt; jade loader 被用來處理 .jade 檔案 { test: /\\.css$/, loader: &quot;style!css&quot; }, // =&gt; style-loader 和 css-loader 被用來處理 .css 檔案 // =&gt; 下面是等價另一種格式的寫法 { test: /\\.css$/, loader: [&quot;style&quot;, &quot;css&quot;] }, ] }} 指令當然您也可以透過指令參數來設定對應的 loaders 1$ webpack --module-bind jade --module-bind 'css=style!css' 上面的指令會讓 jade-loader 對應處理 .jade 檔案，然後 style-loader 和 css-loader 針對 css 檔案 loader 參數(Query parameters)loader 可以透過在設定傳入參數，格式類似網址的 query string。這個參數只要在該 loader 後面加上 ? 舉例來說 url-loader?mimetype=image/png 注意: 至於 query string 的格式則是由 loader 來決定。通常會在該 loader 的文件上說明。大部份的 loader 參數的格式會是 ?key=value&amp;hey=hi 或者 ?{&quot;key&quot;: &quot;value&quot;, &quot;key2&quot;: &quot;value2&quot;}整個設定寫起來會如下 1require(&quot;url-loader?mimetype=image/png!./file.png&quot;); 用在設定檔中 1{ test: /\\.png$/, loader: &quot;url-loader?mimetype=image/png&quot; } 或者 12345{ test: /\\.png$/, loader: &quot;url-loader&quot;, query: { mimetype: &quot;image/png&quot; }} 使用擴充套件擴充套件就是文件上說的 plugins，它是透過 webpack.config.js 的 plugins 屬性來載入模組之中，如下面設定 123456789var webpack = require(&quot;webpack&quot;);module.exports = { plugins: [ new webpack.ResolverPlugin([ new webpack.ResolverPlugin.DirectoryDescriptionFilePlugin(&quot;bower.json&quot;, [&quot;main&quot;]) ], [&quot;normal&quot;, &quot;loader&quot;]) ]}; 其他擴充套件如果不是內建的 plugins 則通常需要透過 npm 來安裝，裝完之後照下面這樣使用即可 123456var ComponentPlugin = require(&quot;component-webpack-plugin&quot;);module.exports = { plugins: [ new ComponentPlugin() ]} 總結經過一輪練習之後，如果您要使用 webpack-dev-server 在設定上路徑會是比較需要注意的地方，然後就是記得 webpack-dev-server 的輸出會放在記憶體。雖然現在官方文件比較沒有詳細的範例，不過您還是可以找到其他。希望在這篇之後各位能夠對這個起手式有些認識也應該都具有使用 webpack 的基礎能力。 示範多檔編譯Webpack + React 中文Webpack with Railsreact-hot-loader深入了解 webpack plugins","link":"/2015/07/23/webpack/"},{"title":"Javascript Unicode","text":"為了理解 ES6 到底對於 Unicode 萬國碼有哪些新的支援。我們得從原因理解起。 Javascript 在處理 Unicode 時很有多問題關於 Javascript 處理 Unicode 的方式…至少可以說是很奇怪。這篇文章闡述在 Javascript 中存取 Unicode 的痛點以及 ES6 如何改善這個問題。 Unicode 基礎在我們深入探討 Javascript 之前，讓我們先確認當我們談到 Unicode 的時候說的是相同的事情。 有關 Unicode 的觀念其實非常簡單，把它想成一個資料庫，存取著您能想到的所有文字符號，且每一個文字符號都對應著一組數字。這個數字就叫編碼位置(Code point)，也有人稱碼點 代碼點。這個編碼位置是唯一的。透過這種方式可以簡單的存取特定文字符號而不用直接輸入符號本身。 例如: A = U+0041 a = U+0061 © = U+00A9 ☃ = U+2603 💩 = U+1F4A9 編碼位置通常使用 16 進制的格式，位元左邊捕 0 到至少 4 位，使用 U+ 當作前綴字。編碼可能的範圍從 U+0000 到 U+10FFFF 超過 110 萬個符號。為了確保其組織性，Unicode 把這個範圍的編碼區分成 17 個區段，各自由 65536 個編碼組成。如果你曾經看過 Wiki 百科上的翻譯，他翻成平面，由 17 個平面組成。 第一個平面稱作基本多文種平面 Basic Multilingual Plane, 簡稱BMP。這大概是最重要的一個。它包含了大部份常用的字符。一般使用英文的情況下您不會需要 BMP 以外的編碼來編輯文件。 BMP 以外剩下大概 1 百萬個符號屬於補充平面(Supplementary planes or Astral planes)補充平面的字非常好辨別: 如果某個字符需要超過 4 位元的 16 進制來表示那它就屬於補充平面。 現在我們有了對 Unicode 的基本認識了。來看看如何應用到 Javascript 的字串。 跳脫序列(Escape sequence)12345console.log('\\x41\\x42\\x43');// 'ABC'console.log('\\x61\\x62\\x63');// 'abc' 這個東西術語叫做 16 進制的跳脫序列(字元)。由 16 進制格式的 2 個位元組成代表一個編碼位置。舉例來說 \\x41 代表 U+0041。跳脫序列可以被用來表示編碼位置從 U+0000 到 U+00FF。 另外一種常見的跳脫序列的表示類型如下 12345console.log('\\u0041\\u0042\\u0043');// 'ABC'console.log('I \\u2661 JavaScript');// 'I ♡ JavaScript' 這種格式被稱作萬國碼跳脫序列，算了！還是記英文吧！Unicode escape squences 由16 進制格式 4 個位元組成精準的表達編碼位置，舉例來說: \\u2661 表示 U+2661 這種跳脫序列可以用來表示 U+0000 到 U+FFFF 範圍的萬國碼 Unicode 等於是整個基本多文種平面(BMP) 那麼..其他平面呢? 我們需要大於 4 位元來表示其他編碼位置啊! 我們要如何使用跳脫序列呈現它們? ES6 引進了新類型的跳脫序列: Unicode code point escapes 讓事情變得比較簡單 舉例來說: 12345console.log('\\u{41}\\u{42}\\u{43}');// 'ABC'console.log('\\u{1F4A9}');// '💩' U+1F4A9 在大括號之間您可以使用 6 位元的 16 進制，這麼一來就足夠表示所有的 Unicode 編碼。所以透過這種類型的跳脫序列您可以輕易的輸出任何您想用的符號 為了兼容 ES5 和舊有的環境，一個不是很好的解決方案出現了，就是使用成對編碼來代理 12console.log('\\uD83D\\uDCA9');// '💩' U+1F4A9 在這種情況下每一個跳脫字元(跳脫序列)代表一半的編碼位置，2 個代理編碼組成一個字符的 Code point。 注意到這個編碼沒辦法很直覺的看出其規則，這是有一套公式的 例如一個 C 字符大於 0xFFFF 就得對應到 &lt;H, L&gt; 成對的代理編碼 12H = Math.floor((C - 0x10000) / 0x400) + 0xD800L = (C - 0x10000) % 0x400 + 0xDC00 之後我們提到代理編碼指的就是兩個編碼其中之一 &lt;H,L&gt; 第一個的是 H, 第二個是 L 要反轉回來則是 1C = (H - 0xD800) * 0x400 + L - 0xDC00 + 0x10000 透過這種代理編碼的機制所有補充平面的編碼位置(U+010000 - U+10FFFF) 都可以使用。不過使用單一跳脫字元來表示 BMP 裡面的字，兩個跳脫字元(代理編碼)來處理剩下補充平面的字很容易讓人搞混，造成很多惱人的後果。 計算 JavaScript 字串的文字(符號)假設您想計算一個字串的文字有幾個，您會怎麼處理呢? 直覺的想法大概是使用 length 12345console.log('A'.length);// 1console.log('A' == '\\u0041');// true 上面這個例子 length 剛好是字元的數量，說有 1 個文字這很合理。很顯然的我們每一個文字只需要一個跳脫字元，但實際上卻不是這樣。例如: 1234567891011121314151617console.log('𝐀'.length); // U+1D400 注意這不只是全形Ａ// 2console.log('𝐀' == '\\uD835\\uDC00');// trueconsole.log('𝐁'.length) // U+1D401// 2console.log('𝐁' == '\\uD835\\uDC01');// trueconsole.log('💩'.length);// 2console.log('💩' == '\\uD83D\\uDCA9');// true 在內部 JavaScript 把補充平面的字符視為兩個跳脫字元(代理編碼)表示一個字。如果您在 ES5 兼容的瀏覽器輸出您會看到他把他視為兩個跳脫字元 length 為 2 ，人們對於字面上只顯示一個字但是 length 卻為 2 會產生困惑。 計算補充平面裡的文字回到剛剛的問題，那我們如何計算 JS 字串中有幾個字?這個小技巧針對代理編碼做處理，當我們認出這兩個跳脫字元會組成一個字的時候只計算一次 12345var regexAstralSymbols = /[\\uD800-\\uD8FF][\\uDC00-\\uDCFF]/g;function countSymbols(string) { return string.replace(regexAstralSymbols, '_').length;} 或者您也可以使用 Punycode.js，punycode.ucs2.decode 方法可以取得一個字串並回傳一個包含 Unicode 編碼位置的陣列。如此一來您就可以計算幾個字了。 在 ES6 您可以透過 Array.from 做類似的事情，透過使用字串的 iterator 來切割字串成為一個陣列 1234var astral = Array.from(&quot;𝐀𝐁💩&quot;);console.log(astral);console.log(astral.length);// 3 或者使用 ... 12console.log([...&quot;𝐀𝐁💩&quot;].length)// 3 使用上面提到的這些方法，我們可以解決計算幾個字的問題。 看起來一樣，但卻不一樣但是如果我們開始去賣弄我們從文章中學到的知識，計算文字的數量甚至更多複雜的操作例如下面這段程式碼 12console.log('mañana' == 'mañana');// false JavaScript 會告訴我們這兩個字串不一樣，但看起來明明就一樣。試著到這個網址看看 Javascript escapes 工具告訴我們其中的不同 12345678console.log('ma\\xF1ana' == 'man\\u0303ana');// falseconsole.log('ma\\xF1ana'.length);// 6console.log('man\\u0303ana'.length);// 7 第一個字串包含的是 U+00F1 是一個拉丁字小寫 N 加上波浪號。而第二個字串裡面的是 U+006E 拉丁字小寫 N 加上 U+0303 波浪號，兩個編碼合體成一個字。這樣你明白了為什麼他們不一樣了吧。 然而如果我們希望兩個字串計算結果都會是 6 個字呢?在 ES6 也相當直覺 123456var normalized = &quot;mañana&quot;.normalize('NFC'); // 把字串標準化console.log(Array.from(normalized).length);// 6console.log([...normalized].length);// 6 這個標準化 normalize 方法是內建 String.prototype 的方法，他會根據Unicode normalization的規則執行，找出那些字的差異，如果找到那種由兩個代理編碼組成的字卻長得跟另一單一編碼位置一樣的字，它會把它轉成單一的那種編碼。 123456789[...'mañana'].lenght // U+00F1// 6[...'mañana'].length // U+006E + U+0303// 6// 透過程式碼驗證var normalized = &quot;mañana&quot;.normalize('NFC');console.log(normalized[2] + &quot; = &quot; + normalized.charCodeAt(2))// ñ = 241, 241 轉成 16 進制 F1 為了向下相容 ES5 和舊環境可以使用這個Polyfill 事情還很複雜 - 計算其他組合式的代理編碼光上面這些還不夠完美，編碼位置可以有多種組合方式其結果看起來是一個字，但是卻沒有標準化的格式(或者說沒有相同樣子的字取代)。這種時後 normalization 就幫不上忙了。 大部份開發者應該很少遇到這類問題吧??? 12345678var q = 'q\\u0307\\u0323'.normalize('NFC') // q̣̇// 經過 normalize 還是 q\\u0307\\u0323console.log([...q].length);// 是 3 不是 1console.log([...'Z͑ͫ̓ͪ̂ͫ̽͏̴̙̤̞͉͚̯̞̠͍A̴̵̜̰͔ͫ͗͢L̠ͨͧͩ͘G̴̻͈͍͔̹̑͗̎̅͛́Ǫ̵̹̻̝̳͂̌̌͘!͖̬̰̙̗̿̋ͥͥ̂ͣ̐́́͜͞'].length);// 是 74 不是 6 此時您可以使用正規式來移除那些組合的符號 1234567var sample = &quot;Z͑ͫ̓ͪ̂ͫ̽͏̴̙̤̞͉͚̯̞̠͍A̴̵̜̰͔ͫ͗͢L̠ͨͧͩ͘G̴̻͈͍͔̹̑͗̎̅͛́Ǫ̵̹̻̝̳͂̌̌͘!͖̬̰̙̗̿̋ͥͥ̂ͣ̐́́͜͞&quot;;var pattern = /([\\0-\\u02FF\\u0370-\\u1DBF\\u1E00-\\u20CF\\u2100-\\uD7FF\\uDC00-\\uFE1F\\uFE30-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF])([\\u0300-\\u036F\\u1DC0-\\u1DFF\\u20D0-\\u20FF\\uFE20-\\uFE2F]+)/g;var stripped = sample.replace(pattern, function(ele, symbol, marks) { return symbol;});console.log(stripped.length);// 6 這種做法可以移除其他用來組合的符號，只留下那些我們要的字。這種解決方案甚至連 ES3 都能使用。 計算其他類型的字形集合(語素簇) Grapheme Cluster對於像 நி(U+0BA8 + U+0BBF = \\u0ba8\\u0bbf) 這種字集或者像韓文是由一堆母音和子音組成的例如 깍(ᄁ + ᅡ + ᆨ) 上面的邏輯仍然是相對粗糙。 Unicode 標準附件 #29 提供一個演算法用來判斷字形的邊界，就是怎麼樣算是人看的一個字。如果是為了給所有 Unicode 絕對精準的解決方案那麼時做這個邏輯可能是比較正解的方法。 反轉字串你可能覺得在 JavaScript 中反轉一個字串很簡單。對嗎?通常你會這麼做 123function reverse(string) { return string.split('').reverse().join('');} 看起似乎可行 12345reverse('abc');// 'cba'reverse('mañana'); // U+00F1// 'anañam' 然而當字串混雜著一些代理編碼即兩個編碼位置組合成的一個字或者補充字面裡的字時全部就都亂了套。 1234567reverse('mañana'); // U+006E + U+0303// 'anãnam'// 看吧！ `~` 跑到 `a` 上面了reverse('💩') // U+1F4A9// '��' =&gt; `'\\uDCA9\\uD83D'`// `💩` 大便符號完全錯誤因為兩個編碼位置反了 在 ES6 裡面修正了這個問題 1234console.log(Array.from(&quot;𝐀𝐁💩&quot;).reverse().join(''));// &quot;💩𝐁𝐀&quot;console.log([...&quot;𝐀𝐁💩&quot;].reverse().join(''));// &quot;💩𝐁𝐀&quot; 但仍然沒有解決涉及多個編碼組合成看起來像一個字的問題。 幸運的是有人解決了反轉字串遇到怪字這個問題，只要透過Esrever 1234567// 使用 Esrever (https://mths.be/esrever)esrever.reverse('mañana') // U+006E + U+0303// 'anañam'esrever.reverse('💩') // U+1F4A9// '💩' U+1F4A9 在字串方法中使用 Unicode 的問題除了陣列 reverse() 的行為外，這種問題也影響到字串的方法。 轉換編碼位置成文字(符號)String.fromCharCode 讓我們可以用 Unicode 編碼位置來建立一個字串，不過呢只有在基本多文種平面(BMP)範圍內是正常的(U+0000 到 U+FFFF)，如果我們用了在補充平面的字將會得到非預期的結果: 12345String.fromCharCode(0x0041); // U+0041// 'A' U+0041String.fromCharCode(0x1F4A9) // U+1F4A9// '' 是 U+F4A9, 而不是 U+1F4A9 而解決方法就是用上面提到的公式自己計算，並且把拆開的兩個編碼當作參數帶入 12String.fromCharCode(0xD83D, 0xDCA9);// '💩' U+1F4A9 16 進制在 C語言、Shell、Python、Java語言及其他相近的語言使用字首「0x」，例如「0x5A3」。 而在HTML，十六進制可以用「x」，例如 &amp;#x0041; 會等於 「A」。 如果你不想要自己處理這些麻煩的計算您可以使用 Punycode.js 提供的工具 12punycode.ucs2.encode([0x1F4A9]);// '💩' U+1F4A9 除了上面這些方法，幸運的是 ES6 也引入了新的方法 String.fromCodePoint() 就可以直接用來轉換補充平面裡面的字了 12String.fromCodePoint(0x1F4A9);// '💩' U+1F4A9 同時呢為了向下相容舊環境您可以使用 Polyfill。 從字串中取出一個字如果您想用 String.prototype.charAt(index) 來擷取第一個字符，遇上大便符號💩這種代理編碼類型的字，這個方法只能夠抓出第一個編碼。 123'💩'.charAt(0) // U+1F4A9// '\\uD83D'// U+1F4A9 代理編碼的兩個編碼中第一個是 U+D83D 在 ES7 的建議中已經有提出 String.prototype.at(index) 來處理這個問題了。 12'💩'.at(0) // U+1F4A9// '💩' U+1F4A9 同樣的在 ES5 和舊環境中還是可以找到 Polyfill 來處理。 從字串取得字的編碼位置類似於上面的狀況，如果您使用 Strint.prototype.charCodeAt(index) 來檢索字串中第一個字的編碼位置，您一樣會取得代理編碼 2 個編碼中的第一個編碼(就是上面提到的 H) 123'💩'.charCodeAt(0);// 0xD83D// 瀏覽器會給 10 進制 55357 換算之後的確是 D83D 再一次感謝 ES6，一樣提供了 String.prototype.codePointAt(index) 方法來解決這個問題。 12'💩'.codePointAt(0)// 0x1F4A9 遍歷字串中的每個字假設您想要用迴圈遍歷(就是一個字一個字取出)一個字串，分別對每個字做點處理。 在 ES5 裡我們可能要先處理成陣列 123456789101112131415161718192021function getSymbols(string) { var length = string.length; var index = -1; var output = []; var character; var charCode; while (++index &lt; length) { character = string.charAt(index); charCode = character.charCodeAt(0); if (charCode &gt;= 0xD800 &amp;&amp; charCode &lt;= 0xD8FF) { // 這邊我們假設不會出現那種只有一半的代理編碼 output.push(character + string.charAt(++index)); } else { output.push(character); } } return output;}var symbols = getSymbols('💩');console.log(symbols); 不意外的 ES6 又出來拯救我們了，在 ES6 裡只要用 for...of 就可以準確的取出每一個字。 1234for (let symbol of '💩') { console.log(symbol == '💩');}// true 其他問題Unicode 的確影響了很多 String Method 的行為，包含我們在這裡沒提到的 substring, slice 所以實作時請小心。 Unicode 在正規式中的問題匹配代碼位置(Code Point)與 Unicode 標量值(Unicode Scalar Values). 句點在正規式中只會匹配一個字元即我們上面說的一個編碼(U+0041)，本來這都很合理，但因為 JavaScript 採用了代理編碼的機制，用了兩個實際的編碼組合成一個字。一旦我們要匹配補充平面的字時，永遠不會匹配成功。 12/foo.bar/.test('foo💩bar')// false 讓我們再想想…還有什麼正規式的寫法可以匹配 Unicode 字符 12console.log(/^[\\s\\S]$/.test('💩'));// false 還是 GG ，事實證明正規式要匹配一個 Unicode 編碼位置並不是那麼直覺。 12console.log(/[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/.test('💩'));// true 當然啦！在實際開發時我是絕對不想寫這些正規式，光寫就暈了更何況還要 debug。為了取得上面那堆正規式我們可以偷吃步使用 regenerate 函式庫。它可以很輕鬆地幫我們產出這些正規式 1regenerate().addRange(0x0, 0x10FFFF).toString() 這個正規式可以匹配基本多文種平面，補充平面的字，甚至只有一個代理編碼。 只寫一個代理編碼在技術上是可行的，但因為他們不會對應到任何實際的字，所以應該避免。Unicode 標量值(Unicode Scalar Values)指的是所有的編碼位置但扣掉那些代理編碼的編碼位置下面是如何產出符合 Unicode Scalar Values 規則的正規式 12345regenerate() .addRange(0x0, 0x10FFFF) // 所有 Unicode 編碼位置 .removeRange(0xD800, 0xDBFF) // 減去第一位的代理編碼 .removeRange(0xDC00, 0xDFFF) // 減去第二位的代理編碼 .toRegExp() regenerate 可以協助我們建立那些複雜的正規式，用相對語意化的方式讓我們比較好維護。 ES6 替正規式加入了 u 修飾符(flag) 就是在正規式尾巴那些用來設定比對方式的參數例如 /[\\w]/g g 全域比對 i 忽略大小寫 gi 全域比對 + 忽略大小寫 現在多了 u 讓正規式用 . 在匹配時可以正確的匹配到補充平面裡的字 12345/foo.bar/.test('foo💩bar');// false/foo.bar/u.test('foo💩bar');// true 注意: . 仍然不會匹配到換行字元，當設定了 u flag 之後在兼容環境中等於是使用下面的程式碼 12345678regenerate() .addRange(0x0, 0x10FFFF) .remove( 0x000A, // &lt;LF&gt; 0x000D, // &lt;CR&gt; 0x2028, // &lt;LS&gt; 0x2029, // &lt;PS&gt; ).toString(); 補充平面的範圍設定先想想這種狀況 /[a-c]/ 這樣寫可以比對 U+0061 到 U+0063 即 a 到 c 。那如果換成 /[💩-💫]/ 勒?理論上應該是要匹配 U+1F4A9 到 U+1F4AB。 但實際上卻是… 12console.log(/[💩-💫]/);// SyntaxError: invalid range in character class 原因是實際上這個正規式長成這樣 12var pattern = /[\\uD83D\\uDCA9-\\uD83D\\uDCAB]/;// SyntaxError: invalid range in character class 我們原本想要的是從 U+1F4A9 到 U+1F4AB 但現在正規式卻變成先來一個 \\uD830 然後從 \\uDCA9-\\uD83D 範圍就錯了。 ES6 的 u flag 和新版 Unicode 表示法又一次解決了我們的困難 1234567891011121314151617181920212223242526272829303132333435console.log(/[\\uD83D\\uDCA9-\\uD83D\\uDCAB]/u.test('\\uD83D\\uDCA9'));// true// 匹配 U+1F4A9console.log(/[\\u{1F4A9}-\\u{1F4AB}]/u.test('\\u{1F4A9}'));// true// 匹配 U+1F4A9console.log(/[💩-💫]/u.test('💩'));// true// 匹配 U+1F4A9console.log(/[\\uD83D\\uDCA9-\\uD83D\\uDCAB]/u.test('\\uD83D\\uDCAA'));// true// 匹配 U+1F4AAconsole.log(/[\\u{1F4A9}-\\u{1F4AB}]/u.test('\\u{1F4AA}'));// true// 匹配 U+1F4AAconsole.log(/[💩-💫]/u.test('💪'));// true// 匹配 U+1F4AAconsole.log(/[\\uD83D\\uDCA9-\\uD83D\\uDCAB]/u.test('\\uD83D\\uDCAB'));// true// 匹配 U+1F4ABconsole.log(/[\\u{1F4A9}-\\u{1F4AB}]/u.test('\\u{1F4AB}'));// true// 匹配 U+1F4ABconsole.log(/[💩-💫]/u.test('💫'));// true// 匹配 U+1F4AB 可惜的是這個方法不能兼容 ES5 和舊環境，如果您真的必須要兼容舊環境那麼您可能只能使用 regenerate, 或其他類似的函式庫 來產出那些正規式進行匹配了。 真實世界中的其他 Bug 及該如何避免看到了吧！Unicode 在 JavaScript 中奇怪的行為造成許多問題。許多開發者在處理字串時並沒有考慮到補充字面的問題(舉手; 我就是其一)，甚至包含知名的函式庫 Underscore.string 的 reverse 也沒有處理關於補充字面產生的問題。 畢竟處理這些問題的確很麻煩，而且好像沒必要??? 在測試中參一坨屎吧 XD無論您正在寫什麼樣功能的 JavaScript 試著在測試行為的字串中加入 💩 然後看看會不會炸掉。這有助於您發現 Unicode 的問題。 結論一般處理單一語系的開發者其實不太容易注意到這些問題。這也是在學習 Babel 的過程中為了理解為什麼要特別強調 Unicode 而做些研究寫的學習筆記。","link":"/2015/05/21/js-unicode-issue/"},{"title":"參透 OOCSS","text":"OOCSS 的兩個核心觀念 分離結構(html tag 結構)與樣式(ui 的樣式) Separate structure and skin 分離容器(layout 佈局)與內容(直接包 content 的 tag) Separate container and content最後達到重複使用樣式的最高原則 搭配 BEM 的歸納邏輯如果套上 BEM 的規則那就是 123structure -&gt; container (block) -&gt; content (block | element)skin -&gt; modifier 先找出相同結構的 html tag structure 以 blog 系統為例 列表頁有文章的 meta-data, 文章頁也有 meta-data, html 的結構一樣但視覺 ui 長的不同。這些結構就可以定義一個 object 按照 OOP 的觀念但實際上只是 html 和 css 的組成 這邊有一點要強調不管是 BEM 或 OOCSS 甚至其他方法都提到不要讓樣式相依於結構。舉例如下 123&lt;div class=&quot;navbar&quot;&gt; &lt;span class=&quot;navbar-button&quot;&gt;Logo&lt;/button&gt;&lt;/div&gt; 1234.navbar &gt; span { /.../ } // 錯誤：這樣樣式就會相依於結構，一定要 .navbar 搭配子項目 span 才會成立/* 另外也不要直接用 tag 選擇器，會導致對元素依賴，實際的例子即 bootstrap 的 .btn 可以套用到 a, button 上 */.navbar-button { /.../ } // 此時應該獨立出一個 class name 針對該元素 第一步驟的重點在於找出可重複使用的 html 結構，概念上我們認為這個東西可以抽象化為一個物件 找出結構後，再來分析誰是容器, 誰是內容，透過這樣的明確的定義與分類讓我們的 css 容易維護與增加新功能而不會影響舊有的程式碼。舉上面 meta-data 的例子，這是開發時很常見的狀況 123456789101112131415161718/*post中的meta-data*/&lt;div class=&quot;post&quot;&gt; &lt;p class=”metadata”&gt; &lt;a&gt;Author name&lt;/a&gt;commented on&lt;a&gt;21-02-2010&lt;/a&gt;@ &lt;/p&gt;&lt;/div&gt;/*comment中的meta-data*/&lt;div class=&quot;comment&quot;&gt; &lt;p class=”metadata”&gt; &lt;a&gt;Author name&lt;/a&gt;commented on&lt;a&gt;21-02-2010&lt;/a&gt;@ &lt;/p&gt;&lt;/div&gt;/*userinfo中的meta-data*/&lt;div class=&quot;user-info&quot;&gt; &lt;p class=”metadata”&gt; &lt;a&gt;Author name&lt;/a&gt;commented on&lt;a&gt;21-02-2010&lt;/a&gt;@ &lt;/p&gt;&lt;/div&gt; 接著我們就會直覺得這樣做 123.post .metadata {css code}.comment .metadata {css code}.userInfo .metadata {css code} 一旦這麼做 meta-data 就會相依於容器，我們應該使用擴展的方式來做，結構只下基礎通用的樣式，而同樣結構不同樣式的部分我們透過擴展 class name 來做。這個時候就會建議使用 BEM 的命名原則 - 所以我們可以總結容器和內容在 OOCSS 裡都是屬於一種物件 123.metadata--post {css code}.metadata--comment {css code}.metadata--user-info {css code} 在使用 OOCSS 的過程中很容易掉入表面外觀語意的陷阱，例如 col-left, col-middle, bg-gray, text-border 這樣的命名。記得保持一種重點堅持以邏輯和語意來給元素命名，不要因為懶惰而隨意命名，例如 bg-red 應該用 bg-danger 從 code 方面著手，對 code 重構，找出重複的 css rules, 通常會是像設定 background 等針對外觀，也就是說把 skin 抽出來。 重點回顧與注意事項 Separate structure and skin 分離結構(html tag 結構)與樣式(ui 的樣式) Separate container and content 分離容器(layout 佈局)與內容(直接包 content 的 tag) 讓 css 不要具有相依性也是程式中所謂的低耦合的概念，透過 BEM + OOCSS 的拆分與命名原則可以達到 注意不要掉入表面外觀語意的陷阱，堅持以邏輯和語意來給元素命名 總結簡單的來說，OOCSS 即透過兩個主要的原則將我們的 css 分類與抽象化成物件，兩個原則分別為 Separate structure and skin 和 Separate container and content，接著實作的第一步先找出重複的結構就是 html ，再依據其周遭元素的關係分類成容器 container和內容 content 再依據不同頁面或者同結構不同長相的部分來做 skin。我們定義好的這一些 class name 就好比是一個一個的物件。 過程中低耦合，即減少選擇器的相依性是主要的重點。如此才能達到重複使用也不會產生改一個爆一個的狀況。低耦合的重點: 單純用 class name 選擇器，不要使用 tag, id 等，也不要從物件定義的外部來影響樣式。不使用 tag 意味著也不會限制使用的元素，class name 應盡可能讓所有元素都能套用。 堅持以邏輯和語意來給元素命名，搭配使用 BEM 實作起來更有規則 先下通用的基礎樣式，再使用擴展的方式來增加不同的 skin(modifier) 最後搭配 BEM 的圖示讓我們快速記住關係 123structure -&gt; container (block) -&gt; content (block | element)skin -&gt; modifier 參考資源OOCSS觀念篇","link":"/2015/08/11/understand-oocss/"},{"title":"再讀一遍 BEM","text":"前言BEM 不是什麼新東西了，會有這一篇純粹是因為之前都只是依樣畫葫蘆的去使用 BEM 看了幾篇 slider 就上沒有認真理解過。當然寫起來就滿頭包。這一篇花了一點時間歸納總結這個看似簡單卻實用的 css 組織的方法 介紹在那些比較小型的網站中，如何組織樣式 css 並不是很大的問題，就是進到該專案的目錄直接撰寫一些 css 或者是 sass。接著透過 sass 的 production 設定編譯它變成一個單一的 css 檔案然後從模組中整理取得 css 變成一個整潔的 package 然而當這個專案變得越來越大越來越複雜，如何組織這些程式碼就變成效能的關鍵。重點不只在花多少時間，還包括寫了多少程式碼，以及瀏覽器要載入多少檔案。當你處於團隊工作的狀況或需要高效能時這些尤其重要 對於那些長時間的專案或者前人留下來的程式碼當然也是很重要 方法其實有很多方法目的都在處理簡化 css 程式碼和組織這些 css 讓協同開發者可以維護。很顯然的在像是 Twitter Facebook 和 Github 這種專案會需要不過其他專案通常隨著需求增加其實很快的也會變成大量的 css OOCSS Object Oriented CSS - 透過 css 物件來分離容器和內容 SMACSS Scalable and Modular Architecture for CSS - 透過樣式指南或說規則來寫 css ，通常真對 css 樣式定義成 5 種分類 SUITCSS - 結構化 class 名稱和有意義的 - 連字號 ACSS Atomic CSS - 打破樣式組織的方式變成比較瑣碎的規則，像原子的概念一樣用多個 class 組出樣式，這些 class 通常具有不可分割性。 為什麼 BEM 超過其他不管你在專案中選擇哪中方式您都能得到結構化 css 和 ui 的好處。其中一些東西並沒有很嚴格的限制並且具有彈性。那些方法通常非常容易理解而且適用於團隊工作。與其我們自己提出 BEM 的優點，我們決定讓你看看其他人的看法 我選擇 BEM 的理由可以歸納成一點，比起其他方法它比較不會令人產生疑惑，還為我們想用的架構即 OOCSS 提供一個容易識別的術語 我很高興開始使用它，最終我得到了一個有秩序的東西。我得到了一個整潔的系統來命名元素。它釋放了在我腦袋中佔據的大量資源，因為即使像是替元素 class 命名這種微不足道的小事卻意外地佔據大量的大腦資源。 不像 OOCSS 它並不是為了處理關於 css 全部的模組化，反倒是像是命名空間的概念，透過 class 名稱建立各自獨立的 css 模組，並且不會互相干擾 BEM 是一個非常有幫助，強大且簡單的命名慣例，讓我們前端的程式碼更好閱讀，好理解，容易維護，容易擴展，更強健也更明確 BEM Blocks, Elements and Modifiers你不會感到太意外，BEM 就是這些關鍵處理原則的縮寫 - Block, Element, 和 Modifier。一套嚴格的命名規則可以在另一篇命名的文章找到 舉下面 Github 網站為例來說明 Block - 一個獨立的區塊具備自己特有的意義，例如: header, container, menu, checkbox, input Element - Block 的一部分並且不具有獨立自己特有的意義，這些元素依賴 Block 的意義。例如: menu item, list item, checkbox caption, header title Modifier - Block 或 Element 上的特殊標記，用來改變原來行為或外觀例如: disabled, highlighted, checked, fixed, size big, color yellow 運作的機制與原理讓我們來看看在頁面上的一個特定元素怎麼透過 BEM 來實作。我們將從 Github 的樣式指南中取出 button 通常我們需要一個普通的按鈕針對大多數的出現在界面上的狀況然後其他兩種不同的狀態。因為 BEM 透過 class 選擇器來套用樣式，所以我們可以將樣式套用在任何元素上(例如按鈕的樣式套用到 button, a 甚至 div)。這個時候重點就是採用下面這種規格來命名 block--modifier--value 1234567&lt;button class=&quot;button&quot;&gt; Normal button&lt;/button&gt;&lt;button class=&quot;button button--state-success&quot;&gt;Success button&lt;/button&gt;&lt;button class=&quot;button button--state-danger&quot;&gt;Danger button&lt;/button&gt; 123456789101112131415161718.button { display: inline-block; border-radius: 3px; padding: 7px 12px; border: 1px solid #D5D5D5; background-image: linear-gradient(#EEE, #DDD); font: 700 13px/18px Helvetica, arial;}.button--state-success { color: #FFF; background: #569E3D linear-gradient(#79D858, #569E3D) repeat-x; border-color: #4A993E;}.button--state-danger { color: #900;} 延伸閱讀想知道更多範例可以閱讀Building My Health Skills - Part 3 優點 模組化 - Block 的樣式不應該相依於頁面中其他任何元素，亦為一個 Block 不管放在哪裡都要長得一致，因此永遠不會因為濫用 css 繼承規則的部分就是因為不斷堆疊樣式產生肥大的樣式而降低效能。同時這樣做也具備了讓我們可以輕鬆把一個已經做好的樣式轉換到另外一個專案 重複使用性 - 可以用不同的方式來組合各自獨立的 Block 達到重複使用性也減少 code 的數量，也比較好維護。如果你已經有設計指南或公司內部的一些規則那麼它就能協助你有效率的區分，建立，定義 Block 結構化 - BEM 讓我們的 css 具有容易理解的特性與結構，簡單易維護，不用再一直記著樣式之間的耦合關係。 命名Phil Karlton 說過在電腦科學的領域只有兩個困難的問題: cache invalidation 和命名 cache invalidation 快取無效化背後的意義就是什麼時候該把暫存刪掉 這是已知的事實，而正確的樣式指南可以明顯的增加開發的速度，debug 和在既有的程式中實作新功能的速度。很不幸的大部份的 css 沒有任何架構和命名規則。這導致 css 長久以來都是處於異常難以維護的狀態。 這個 BEM 的方法確保每一個開發者使用相同的慣例，正確的命名讓我們未來在修改維護時相對輕鬆 block 封裝一個獨立的區塊，上面說過這個區塊需要具備自己的意義。而 block 可以被嵌入其他 block 之中並與其互動，同時維持一致的語意。注意這裡並沒有優先順序或者繼承的概念。也不要使用 DOM 來表示整個區塊 命名：block 的名字可以由英文，數字和連字號組成，目的是將 css class 的命名格式化，當然也可以加入一些簡短的前綴來達到命名空間的效果例如 .block HTML：不要讓侷限 block 套用的元素標籤，任何 DOM 元素只要使用該 class 就能套用 block 的樣式 css： 只使用 class name 選擇器 不能直接用 tag 或 id 來選元素 在頁面上不能相依其他 blocks 或 元素 element 為 block 的一部分並且相依於 block 的意義，舉例來說就像是 list 中的 item 即為一個 element 命名：element 的命名可由英文，數字，連字號(破折號)或底線組成，css class 的格式為 block 的名字加上兩個底線 __ 再加上 element 名稱 舉例來說 .block__elem HTML：任何在 block 內的 DOM node 就可以是一個 element，在給定的 block 內所有的 element 都具有相等的語意 css： 同樣只用 class name 選擇器 不用 tag 或 id 在頁面上不能相依於其他 block 或元素 .block_elem { color: #042 }; 正確 .block .block__elem { color: #042; } 錯誤 modifier 是 block 或 element 上的特殊註記，用來改變外觀，行為，或狀態舉例來說就是一個 button 可以有正常可點擊的狀態和 disabled 停止使用的狀態，要注意的是這是附加的樣式不能單獨存在一定要搭配原來的 block/element 才行 命名：同樣的 modifier 名稱可以由英文，數字，連字號(破折號)和底線所組成，css class 格式為 block 或 element 名稱加上兩個 dash .block--mod, .block__mod--mod .block--color-black HTML：modifier 是額外的類別名稱讓我們可以加在 block 或 element 來使用，一個 modifier 只能被用在 block 或 element 並且要保留原來的 class，不能用 modifier 取代掉原來的 block / element &lt;div class=&quot;block block--mod&quot;&gt;正確&lt;/div&gt; &lt;div class=&quot;block block--size-big block--shadow-yes&quot;&gt;正確&lt;/div&gt; &lt;div class=&quot;block--mod&quot;&gt;錯誤，取代了原來的類別&lt;/div&gt; css：直接使用 class name 選擇器 .block--hidden { display: none; } 基於 block 層來調整底下的元素 .block--mod .block__elem element 的 modifier .block__elem--mod 備註 sass 用法123456.block { &amp;__element { } &amp;--modifier { }} 總結簡單說來所謂的 B.E.M 就是用 block, element, modifier 三種分類針對 UI 去分析區分歸納，最後協助我們替 class name 命名的一組嚴格規則block 為一個具有獨立意義的區塊，獨立的意思就是在每個頁面甚至在別的 block 裡面行為外觀都要一致。element 則是相依於 block 就是 block 的子項目，沒有自己獨立的意義，其意義與使用時要依附在 block 底下modifier 是一種特殊的註記用來調整改變 block/element 的外觀(樣板)，行為，狀態明白這三種定義讓我們可以去歸納介面上的 css 該怎麼組織分類進而管理 因為一個 block 不能相依於其他標籤，獨立不相依真正的意義就是在任何頁面甚至是嵌入其他 block 外觀行為都要一致，不綁定不限制只能在特定元素使用。舉例來說就像 bootstrap 的 .btn 可以在 a, button 甚至 div 都能套用。當 block 之間不會互相污染或被連動影響那麼我們在撰寫修改上就不怕有太多不預期的行為 最後就是該怎麼用：block/element/modifier 都只用 class name 選擇器，不依賴 css 的繼承或是像 .nav &gt; h1 這樣的方式。好處是可以大幅減少過度被覆寫或不斷被繼承而沒有實際效果的 css，只有單一階 css selector 就能選到元素效能也相對提升第一個是 block 就用一般英文數字命名，實際上三者都是英數加上 _ - 來完成命名如果是 element 則用 __ 加在 block 和 element 中間例如：block__elem最後一個 modifier 則是 -- 例如：block--mod 或 block__elem--mod如果名字較複雜有兩個英文單字則中間用一個 - 連結 如 block__nav-item--disabled 撰寫的流程為先分析 ui 再照規則寫 css 就好了，再透過下面範例快速掌握 123456&lt;form class=&quot;form form--theme-xmas form--simple&quot;&gt; &lt;input class=&quot;form__input&quot; type=&quot;text&quot; /&gt; &lt;input class=&quot;form__submit form__submit--disabled&quot; type=&quot;submit&quot; /&gt;&lt;/form&gt; 123456.form { /* ... */ }.form--theme-xmas { /* ... */ }.form--simple { /* ... */ }.form__input { /* ... */ }.form__submit { /* ... */ }.form__submit--disabled { /* ... */ } 參考資源BEM 101getbem","link":"/2015/08/11/understand-bem-again/"},{"title":"OSX EL - Install Apache, MySQL, PHP Note","text":"Use Apache OSX 10.11OSX 10.11 仍然內建 Apache 12345$ sudo apachectl start$ sudo apachectl stop$ sudo apachectl restart$ apachectl configtest # 測試設定檔$ httpd -v # Apache version 設定 document rootOSX預設有兩個網頁根目錄 System Level - 所有使用者使用同一個全域根目錄 /Library/WebServer/Documents/ User Level - 每個使用者有自己的根目錄 ~/Sites 從 10.7 之後 Apple 不再提供介面來管理必須要透過指令介面設定, 而使用 User Level 可以避開很多權限的問題所以一般建議使用 User Level User Level 設定123456$ mkdir ~/Sites# 加入 `[username].conf`$ cd /etc/apache2/users$ sudo vi [username].conf$ ls -ahl# -rw-r--r-- 1 root wheel 298 Jun 28 16:47 username.conf [username].conf 使用者網站設定 12345&lt;Directory &quot;/Users/username/Sites/&quot;&gt;AllowOverride AllOptions Indexes MultiViews FollowSymLinksRequire all granted&lt;/Directory&gt; 12345678910111213141516171819$ sudo vi /etc/apache2/httpd.conf# 解開註解# LoadModule authz_core_module libexec/apache2/mod_authz_core.so# LoadModule authz_host_module libexec/apache2/mod_authz_host.so# LoadModule userdir_module libexec/apache2/mod_userdir.so# LoadModule include_module libexec/apache2/mod_include.so# LoadModule rewrite_module libexec/apache2/mod_rewrite.so# LoadModule php5_module libexec/apache2/libphp5.so# Include /private/etc/apache2/extra/httpd-userdir.conf# 處理另外一個設定檔$ sudo vi /etc/apache2/extra/httpd-userdir.conf# 解開註解# Include /private/etc/apache2/users/*.conf# 因此, 我們一開始建立的 /etc/apache2/users/[username].conf 就能夠使用$ sudo apachectl restart # 重啟套用設定# 造訪 http://localhost/~username/ 即可看到網站, 而網頁檔案放置在 ~/Sites 設定檔的 Include 關聯 /etc/apache2/httpd.conf 解開 Include /private/etc/apache2/extra/httpd-userdir.conf之後便能夠使用 /etc/apache2/extra/httpd-userdir.conf 針對使用者目錄來設定而 httpd-userdir.conf 解開 Include /private/etc/apache2/users/*.conf 之後所有在 /etc/apache2/users的 .conf 設定就會被套用 System Level 設定設定允許 .htaccess 來複寫預設值 1234567$ sudo vi /etc/apache2/httpd.conf# AllowOverride All# 解開註解# LoadModule rewrite_module libexec/apache2/mod_rewrite.so# LoadModule php5_module libexec/apache2/libphp5.so$ sudo apachectl restart 安裝 MySQL1234567891011121314151617181920212223242526272829303132333435363738394041$ brew install mysql# 需要開機啟用的話$ ln -sfv /usr/local/opt/mysql/*.plist ~/Library/LaunchAgents# homebrew suggested, notice before setting need to stop mysqld$ unset TMPDIR$ mysql_install_db --verbose --user=`whoami` --basedir=&quot;$(brew --prefix mysql)&quot; --datadir=/usr/local/var/mysql --tmpdir=/tmp# 加入設定檔$ cp -v $(brew --prefix mysql)/support-files/my-default.cnf $(brew --prefix)/etc/my.cnf# 預設 MySQL 沒有密碼執行下列指令$ $(brew --prefix mysql)/bin/mysql_secure_installation# 移除重新安裝$ brew remove mysql$ brew cleanup$ launchctl unload -w ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist$ rm ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist$ sudo rm -rf /usr/local/var/mysql# 透過 brew services 操作# https://github.com/Homebrew/homebrew-services$ brew tap homebrew/services # install brew services$ brew services start mysql$ brew services stop mysql$ brew services restart mysql$ brew services list# 登入 MySQL$ mysql --host=localhost --user=root -p# 建立使用者mysql&gt; CREATE USER '[username]'@'localhost' IDENTIFIED BY '[password]';mysql&gt; SELECT User,Host FROM mysql.user;mysql&gt; GRANT ALL PRIVILEGES ON * . * TO '[username]'@'localhost';mysql&gt; FLUSH PRIVILEGES;# 設定使用者密碼mysql&gt; SET PASSWORD FOR '[username]'@'localhost' = PASSWORD('[password_here]'); 詳細建立角色權限 phpMyAdmin 安裝下載 phpMyAdmin 解壓縮並移至 document root 目錄 12345$ cd phpmyadmin$ mkdir config$ chmod o+w config# Visit http://localhost/~[username]/phpmyadmin/setup# After save file move config.inc.php to phpmyadmin folder 問題 apache2: Could not reliably determine the server’s fully qualified domain name, using 127.0.0.1 for ServerName 解法 1234$ sudo vi /etc/apache2/httpd.conf# 修改 ServerName 隨意指定一個網址$ apachectl configtest# &gt; Syntax OK ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/tmp/mysql.sock’ (2) 1234567$ ps -ef | grep mysql$ kill -9 [id]# Check /tmp/mysql.sock exists# 檢查設定檔 $(brew --prefix)/etc/my.cnf$ touch /tmp/mysql.sock # 預設$ brew services start mysql Warning: mysqli::mysqli(): (HY000/2002): No such file or directory 1234$ cd /var$ sudo mkdir mysql$ ln -s /tmp/mysql.sock mysql/mysql.sock$ brew services restart mysql 解法 參考資源 Starting and Stopping Background Services with Homebrew Install MySQL on Mac OSX using Homebrew Get Apache, MySQL, PHP and phpMyAdmin working on OSX 10.11 El Capitan","link":"/2015/10/04/osx-el-apache-mysql-php/"},{"title":"第一次用 jspm 就上手","text":"何謂 jspm ?jspm (javascript package manager) 號稱是完全支援(無摩擦)瀏覽器載入的套件管理工具 jspm 也是一套套件管理工具，採用 SystemJS 來處理模組載入 當然內建也就支援動態的 ES6 模組載入 可以直接從 npm, Github 載入任何模組標準所寫得模組程式(ES6, AMD, CommonJS, global) 任何自訂的registry例如 npm 也可以透過 Registry API 來註冊連結 開發時，會將 ES6 檔案和編譯後的 plugins 分開載入 產品上線時，優化成一個 bundle ，也可透過指令將 bundle 分層或單獨執行 入門 安裝 jspm 指令 建立專案 初始化專案的設定檔 安裝來自任何 registry 的套件 安裝 jspm 指令1$ npm install jspm -g 建立專案12$ cd my-project$ npm install jspm --save-dev 上面這個步驟不是必須的，但官方建議在專案安裝一個屬於專案自己的 jspm 版本，這可以確保當系統更新的時候專案的 jspm 版本並不會被影響，在目錄底下執行 jspm -v 可以顯示該專案的版本。 此時我們沒有 package.json 所以下 --save-dev 不會把設定加到 package.json 中。 初始化專案的設定檔123456789$ jspm init# Package.json file does not exist, create it? [yes]:# Would you like jspm to prefix the jspm package.json properties under jspm? [yes]:# Enter server baseURL (public folder path) [.]:# Enter jspm packages folder [./jspm_packages]:# Enter config file path [./config.js]:# Configuration file config.js doesn't exist, create it? [yes]:# Enter client baseURL (public folder URL) [/]:# Which ES6 transpiler would you like to use, Traceur or Babel? [traceur]: 這個指令會協助我們設定 package.json 和 config.js(jspm 預設)。注意到當目錄為空的時候 jspm init 會試圖自動幫我們處理下面這些項目 baseURL: 這個設定指的是相對於在 server 上的 public folder 通常是 /，也就是 package.json 應該放置的專案根目錄，或者說當網址為根的時候該如何對應到此專案目錄。 jspm packages 目錄: jspm 會將其他相依的檔案安裝在這裡。 config 檔案路徑: 這個是 jspm 的設定檔也應該要跟 package.json 一樣放在專案的根目錄 client baseURL: 這個 URL 設定瀏覽器如何存取被託管在 server 上的目錄 transpiler: 設定使用的 compile to js language(ES6+ to ES5)。可以在任何時間透過 jspm dl-loader --babel 來修改這個選項。也可以直接在 jspm 的設定檔中透過 babelOptions 或 traceurOptions 修改。 如果你需要重新設定這些屬性，可以直接修改 package.json 接著執行 jspm install 或 jspm init 來更新 而如果想要重新發動 jspm 的詢問來更新檔案可以執行 jspm init -p 安裝來自任何 registry 的套件 例如: Github, npm …首先 registry 的意義是一個可以註冊的地方或空間。對應到程式開發領域的話指的就是像 Github, npm, gem Nuget, apt, yum 。開發者可以把自己的程式(函式庫)註冊並上傳發佈的套件管理站點或系統。 透過下面的指令可以從任何 registry 安裝 12345$ jspm install npm:lodash-node$ jspm install github:components/jquery$ jspm install jquery$ jspm install myname=npm:underscore$ jspm install [registry]:[package name] 多個套件安裝可以在同一個指令用空白隔開，上面的例子我們看到了無論是 npm 或 github 都可以透過這種方式安裝。 大部份的 npm 套件安裝不需要再加上額外的設定，這是因為 npm 站點使用專案設定規範適用於所有 Node 和 npm-style 的程式碼，也因此相容 jspm Github 的套件或說程式碼就可能需要對 jspm 補些設定 所有安裝項目的設定會存放在 package.json，而 jspm_packages 目錄和設定檔可以透過執行 jspm install 全部重建，所有相依的第三方元件仍然是透過 package.json 來紀錄設定。 原則上你不該把這些第三方的程式碼一起加入版控。 簡單來說，jspm 是透過 system.js 來處理載入模組這件事。而載入模組這件事為什麼需要處理，是因為在 js 的世界裡存在較多的標準，ES6+ 的標準又還沒普及，所以通用的載入器需求就產生了，白話文即不管你是用 CommonJS 或 AMD 甚至 ES6 寫的東西都要能夠被載入，但 jspm 並不是唯一可以處理這個問題的工具。 一個 nodejs 專案是透過 package.json 來管理相依的函式庫或套件，而 jspm 主要也是透過 package.json 來組織其設定，它會根據解析 package.json 的結果在 config.js 裡加上 system.js 以及自己需要的設定。也因此 config.js 只要透過 jspm install 就可以根據 package.json 的資料重建設定檔。 搞懂 npm, jspm, webpack 的使用上的差異我們依照模組標準開發出一個函式庫模組並丟到 npm 給大家用，npm 這個詞意義上又分成 npm-cli 指令和 npm 這個集合套件的站點，所以這邊我們提的 npm 指的是指令的部分，例如 npm install 這樣的指令來處理安裝，移除，管理的指令。 而 webpack 或 browserfiy 它們是處理模組封裝和載入的工具，意思是把你寫的 js 打包，大略的實作行為就是你在程式中用 require 來載入其他檔案最後輸出一隻打包的 js，所以安裝的部分還是用 npm ，而載入則由 webpack 這類的工具負責。 那 jspm 呢？第一個不同點就是除了你可以透過 npm 安裝專案專屬 jspm 外(用來鎖定版本)，其他套件或函式庫你都是用 jspm install [library name] 的方式來安裝。那設定呢？基本上上面就提到了; 如果你是採用 node 或 npm-style 的函式庫或模組是不用設定的，因為 jspm 會幫你把設定加到 config.js 裡面。 下面整理 jspm v.s npm + webpack 的流程順序 12345step 1. jspm 下載模組並安裝 (使用 npm 下載並安裝)step 2. 在 package.json 中紀錄設定，而程式碼安裝到 `jspm_packages` (npm 一樣把設定記錄到 package.json 檔案裝到 node_modules)step 3. 分析 package.json 後在 config.js 產生設定 (使用 webpack 自己手動寫設定)step 4. 撰寫程式碼，載入並應用模組step 5. 執行 jspm bundle (執行 webpack ./main.js ./bundle.js) 實作現在我們就可以開始在程式中撰寫載入的部分了。為了更加明白其運作。這次的練習會包含 建立一個 jspm 專案 先試著寫 ES6 語法來測試 安裝 jsx, react 撰寫一個簡單的 React Component bundle &amp; 優化 123456789101112$ mkdir jspm_new_project&gt; 建立一個空的目錄$ jspm init&gt; 初始化專案，注意 transpiler 選 babel$ jspm install jquery&gt; 試著安裝 jQuery, 我們先試著用基本的 jQuery 搭配 ES6 寫點範例$ mkdir -p assets/js/lib$ mkdir -p assets/js/components&gt; 模擬真實狀況組織 js 目錄 建立 assets/js/lib/Cat.js 1234567891011export default class Cat { constructor (name) { this.name = name; } yell () { var result = `${this.name}: meow`; console.log(result); return result; }} 建立 assets/js/main.js 來載入我們的小貓類別 12345678import $ from 'jquery';import Cat from './lib/Cat';var cat = new Cat(&quot;Mily&quot;);$(function() { $(&quot;.animal&quot;).text(cat.yell());}); 建立 index.html 來使用 main.js，伺服器部分先用簡單的 python -m SimpleHTTPServer 起一個 server 來測試當然如果你會其他方式例如使用 express 或者架設 apache 等也可以 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;jspm sample&lt;/title&gt; &lt;script src=&quot;jspm_packages/system.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;config.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;span class=&quot;animal&quot;&gt;&lt;/span&gt; &lt;script&gt; System.import('assets/js/main'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 開啟瀏覽器輸入 http://localhost:8000/ 第一階段我們驗證了 ES6 語法和 jQuery 運作相當正常，接著我們要來試著寫一個 React Component 試試。首先要注意的是 jspm 預設只會載入 .js 副檔名，而且只處理純 js 即使我們知道 Babel 能處理 JSX 但如果你直接照著寫是會出錯誤的。要解決這個問題我們需要 jsx loader plugin 因此我們需要先安裝 jsx 和 react 1$ jspm install jsx react 在 assets/js/components/ 建立一個 Dog.jsx 123456789101112131415import React from 'react';class Dog extends React.Component { constructor(props) { super(props); } render() { return ( &lt;div&gt;{this.props.name}: bark!!!&lt;/div&gt; ); }}export default Dog; 回到 main.js 要注意上面說過 jspm 預設不處理 jsx ，而且就算你把副檔名換成 .js 還是會出錯，正確的用法是只要有用到 jsx 語法的檔案副檔名都應該是 .jsx接著在 import 的時候要記得副檔名和 ! 如下面範例 import Dog from './components/Dog.jsx!'。 對了！因為 main.js 也要用 jsx 語法所以記得將其副檔名也換掉喔，index.html 裡面的 System.import 也要加入特殊語法。 1234567891011121314import $ from 'jquery';import React from 'react';import Cat from './lib/Cat';import Dog from './components/Dog.jsx!'var cat = new Cat(&quot;Mily&quot;);$(function() { $(&quot;.animal&quot;).text(cat.yell());});React.render(&lt;Dog name=&quot;Wally&quot;/&gt;, document.getElementById(&quot;dog&quot;));/* 警告: Warning: `require(&quot;react&quot;).render` is deprecated. Please use `require(&quot;react-dom&quot;).render` instead.*/ 修改 index.html 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;jspm sample&lt;/title&gt; &lt;script src=&quot;jspm_packages/system.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;config.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;span class=&quot;animal&quot;&gt;&lt;/span&gt; &lt;span id=&quot;dog&quot;&gt;&lt;/span&gt; &lt;script&gt; System.import('assets/js/main.jsx!'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 至此我們已經玩完一輪基本的使用方式了 - 完整範例上面示範的方式是在 html 頁面加上 SystemJS loader 和 config.js 基本上我們需要啟動一個 server 才能存取，不過您也可以透過下面這種方式直接存取檔案 Mac 的 Chrome 使用者可以執行 /Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome --allow-file-access-from-files &amp;&gt; /dev/null &amp; Firefox 先切換到 about:config, 搜尋 security.fileuri.strict_origin_policy 把值改成 false 這個時候 config.js 的 baseURL 就要設成 . 這樣才能正常運作 最佳化12345$ jspm bundle assets/js/main --inject# 一般 JS$ jspm bundle assets/js/main.jsx! --inject# JSX 的指令格式 之後 system.js 就會自動取得這個 bundle.js 另外還可以使用 jspm bundle-sfx assets/js/main 來建立一個獨立的 bundle script 如此一來就不用在 html 中使用 config.js 和 system.js 結論總結來說 jspm 試圖從安裝函式庫到封裝全部一起處理，且盡可能不需要你去設定。整體用起來到還是蠻簡潔的。要用類似 webpack-dev-server 的可以參考 jspm-server。似乎 webpack 有的東西都在慢慢補齊中。不過以 React 的立場來看 webpack 的資源和參考還是多一點。 因為前端工具更新的速度實在太快了這邊想對目前用過的東西做點簡單的總結 Grunt gulp 本質上是任務管理工具 所以我們可以組織打包，測試，任何想做的事等於幫我們建立一堆指令 webpack, browserify, RequireJs 處理模組與相依性管理 所以只要在設定檔設定哪個檔案類型該怎麼處理(封裝編譯)，它就會幫你處理編譯模組以及模組載入 Grunt, gulp 和 webpack 這類工具處理問題的角度不同，一個是讓你組織各種任務，一個是針對檔案類型處理如何編譯，壓縮，封裝，載入 npm 本質上為模組(函式庫)的管理工具 + 簡易的任務工具 安裝，移除，顯示資訊。 透過 package.json 執行寫在裡面的 script jspm 概念上為 npm + webpack(但目前沒有 webpack 功能那麼全面) 因為除了是一個模組(函式庫)的管理工具外還使用 System.js 處理模組載入的部分 資源 jspm React with JSPM","link":"/2015/08/13/jspm-getting-started/"},{"title":"第一次用 CSS - Flexbox 就上手","text":"Flexbox 是一種新的 CSS 3 佈局模式, 在這之前 CSS 有四種佈局模式 block inline table positioned 在 Flexbox 和 Grid 出現之前, 開發者大量濫用 float 來達成一些複雜佈局的需求, 但本質上 float 並不是用來協助我們佈局的, 它只是一個舊有的對齊屬性.雖然 float 可以達成我們的目的, 但它伴隨著一些限制和問題, 您應該有過使用 float 搭配 clearfix 的經驗吧. 現在 CSS 3 引進了兩種新的佈局方式用來取代被我們大量濫用的 float 和 table mode Grid 將佈局區分成 rows 和 columns, 有點類似 table 但比其更強大. 不過關於 Grid 的規格仍然在開發中, 還不能使用. Flexbox 根據單一的行或列分配空間, 類似 float 調配控制元素的位置尺寸概念, 但更好用! Flexbox 規格已經完成而且今時今日多數的主流瀏覽器都支援 Flexbox 簡史明白創造這種佈局模式的動機是幫助我們學習這東西一個非常好的開始. Tab Atkins Jr : 大約在 2000 - 2009 後期, Mozilla 試著要讓 XUL Layout model 正名為 Flexbox, 我第一次得知這份草稿是在 2009 年, 但我想這應該可以追朔到 2007 年. 但這過程並沒有什麼結果; 只有 WebKit 實作一部分標準, 而且即使是 Firefox 也不符合該標準, 因為大部份的事情根本還沒被確認.接著在 2010 年左右我加入了 WG 其中的第一個任務就是替 Firefox 整理這份草稿(整份重寫), 大概在一兩年後 Microsoft 提交了第一份 Grid 標準的草稿, 我一樣是使盡全力處理(重寫)我這麼做的目標就是要取代那些因為 float, table, inline-block 等等而延伸的複雜佈局技巧, 身為一個網頁開發者我不得不這麼做.那一堆人們為了佈局而產生的奇技淫巧(hack)通常不是怎麼高明, 很難記憶, 而且往往有一堆惱人的限制, 所以我希望讓佈局模型可以更好用一點, 在處理同樣的問題時可以更簡單, 方便並且相對完整. 簡而言之: Flexbox 和 Grid 被創造出來明顯的是為了取代 float, table 等等問題而產生的 hack. 共有 3 種 Flexbox 規格?你也許聽過有 3 個 Flexbox 的規格書, 沒錯! 共有三個版本的規格書, 不過只有一個是我們要關注的. 2009 年的版本: display: box 現在已經不再跟 Flexbox 有任何關係 2011 過渡期版本: display: flexbox 只是草稿, 只被 IE10 實作, 如果可能的話應該避免使用 2012 最終版: display: flex 注意: 每一個規格在 display 屬性上使用不同的關鍵字, 如果您正在閱讀其他關於 Flexbox 的文章可以很輕易的判斷該篇文章在討論的是哪個版本.如果你看到的文章不是 display: flex 那麼你可以不看了 Flexbox 佈局具備單一方向性如同上面提到, Flexbox 會依據單一 row(橫向) 或 column(垂直) 方向放置內容項目, 讓我們來看看這句話的意思是: 一個 Flexbox 佈局由一個 flex container 組成, 裡面包含著 flex items 這個 flex container 可以設置水平或垂直, 我們可以簡稱這個特性為主軸 main axis flex container 內部第一層的子元素會遵循 main axis 的方向排列, 這些子元素可以彈性調整他們的大小, 自動擴展去使用 container 內部那些未被使用的空間, 或者自動縮小以避免超出範圍. 透過巢狀內嵌多個不同方向的 flex container 可以完成複雜的佈局. Flexbox 屬性關於 Flexbox 有非常多的屬性, 所以我會建議你如果有時間參考一下CSS Tricks Flexbox Guide這邊文章非常詳細的介紹了所有的屬性 不要被嚇到了. 雖然 Flexbox 有非常多的屬性可以設定, 但是也有一系列的預設值, 所以我們可以透過很少的程式碼來建立複雜的佈局. 123.flex-container { display: flex;} 單單一行 CSS 程式碼我們完成了下面這些功能 套用 .flex-container 的元素成為一個 flex container 內部第一層的子元素會變成 flex item 預設 Flex item 會依照水平的方式排列 Flex item 會依照程式碼的順序排列 Flex item 會在 container 內從左至右排列 Flex item 的尺寸會依照正規的 width 屬性或內容自身的寬, block-box(div etc) 不會自動長滿 100% 如果沒有足夠的空間, 那麼 Flex item 會自動依照寬度 width 的比例去縮小, 直到空間完全不足 scrollbar 才會出現 如果需要收縮, 則每一個 Flex item 都會收縮相同的值 Flex item 會自動展延高度使其與其他 Flex item 中最高的那個相等 對於這只有一行的 CSS 的確是包含蠻多的邏輯! 你還可以修改其中任何一個行為, 不過我希望能夠讓讀者明白關於 Flexbox 的強大 瀏覽器的支援 注意 IE 10 支援 Flexbox 不過是使用過渡時期的版本 display: flexbox 那麼對於 IE 10 以前的版本呢如果你不在乎不支援 Flexbox 的瀏覽器破版, 有點的不同, 如果是這樣你就不需要在做其他處理. 這種行為有個術語叫做優雅降級(graceful degradation)當瀏覽器看到它不懂的東西 - 例如: display: flex 他就會整個忽略, 對我們來說這是件好事, 因為這表示所有 Flexbox 的屬性都會被忽略.您設定成 Flex container 的元素會用原本的行為運作通常應該是 display: block 就結果來說整個佈局中 block 會垂直排列 搭配 Modernizr 的優雅降級如果你不能不管那些古董瀏覽器, 您可以透過 Modernizr 提供一個舊版使用 float-base 的佈局Modernizr 是一個 Javascript 函式庫, 它會自動偵測瀏覽器的功能然後在 html 或 body 元素加上一系列的樣式, 讓我們可以根據是否支援來撰寫替代性(舊版 float-base)的樣式 以 Flexbox 的例子來說如果瀏覽器不支援 Flexbox 那麼就會有一個 .no-flexbox class 被加在 html tag 上面, 如此一來我們就可以用下面的樣式來試著用其他的樣式取代 12345678.parent { display: flex; }.child { flex: 1; }.no-flexbox { .child { float: left; width: 50%; } .parent::after { @include clearfix(); }} 好處是您可以透過舊有的方式來針對 .no-flexbox 的部分做 CSS 的撰寫, 如果未來不再需要支援這些老舊的瀏覽器只要把 .no-flexbox 部份的樣式移除即可 不過還是有一點要注意, 當你使用 Modernizr 2.8.3 時 IE 10 並不會出現 .no-flexbox 你可以改用IE專屬的條件式註解語法 &lt;!--[if IE 10]&gt;&lt;![endif]--&gt;, autoprefixer, 或者直接更新使用 Modernizr 3+ 新版已經排除掉這個問題. Flexbox 教學 - 背景關於 Flexbox 佈局 模組目前處在 W3C 最後的草稿階段, 其目標如同上面提到的希望提供一種更有效率的方式處理元素的佈局, 對齊, 在一個容器內分散排列的方式, 甚至是不知道該元素的尺寸或者說動態調整, 這也是為什麼會叫 Flexible Box 在 Flex 佈局背後的核心觀念是賦予一個 container 容器具有能力去修改子項目的尺寸(width/height)以及排列順序, 好讓我們可以填滿容器裡的空間更具體的說好讓我們可以去適應各種尺寸裝置的螢幕. 一個 Flex container 可以擴展其子項目填滿容器裡的空間或者是收縮以防止超出容器. 更重要的是 direction-agnostic 這是 W3C 定義的術語 To make it easier to talk about flexbox layout in a general way, we will define several direction-agnostic terms here to make the rest of the spec easier to read and understand. 指的是那一系列處理方向的術語, 這跟原本的 block, inline 等佈局方式相反, 意思是指原本的佈局形式, 項目本身會具方向性例如: block 會垂直堆疊, inline 會水平排列, 而 Flex item 本身不需要知道該怎麼處理方向和排列, 是由 container 控制. 原本的方式類似在做平面設計排版, 缺少彈性去支援大型複雜的專案尤其是當裝置螢幕切換方向, 改變尺寸, 伸縮那些狀況. 備註: Flexbox 佈局相對適合用於應用程式中的元件, 小型的佈局. 對於複雜佈局來說 Grid 會相對適合. 基礎知識和術語由於 Flexbox 代表的是一整個模組, 是一系列排版的邏輯而不只是單一的 CSS 屬性, 意思是它牽扯到很多東西和屬性.其中有些屬性是要用在 Flex container 的, 另一些則是用在子項目 Flex item 如果說一般的佈局架構在 block 和 inline 的方向性上, 那麼 Flexbox 佈局則基於 flex-flow 方向, 參考下圖, 這邊就是解釋了上面提到的 w3c 定義的那些術語, 透過圖片我們很清楚的可以明白關於 Flexbox 的核心概念. 在這一小節重點是跟以往下 CSS 屬性有些不同, Flexbox 佈局的使用和樣式設定上區分成 Flex container - 設定為 display: flex 的元素 Flex item - 在 Flex container 內部第一層直接與 container 接觸到的標籤, 可以是文字或其他標籤 e.g div span container 的設定會影響 item, 位於內部的 item 也有些屬性可以覆寫 container 的設定, 為了方便說明下面開始我們會用 container 和 item 分別表示這兩者 基本上 item 會依照 main axis 主軸排列, 從 main-start 到 main-end 和 cross axis 橫軸從 cross-start 到 cross-end 排列 main axis - 即 Flex container 的主軸, 任何在內部第一層直接和 container 連接的項目稱為 Flex item 都會遵循這個主軸排列, 要注意的是這個主軸不一定要是水平的, 根據 flex-direction 屬性的設定可以改變方向性 main-start|main-end - 在 container 內部的 item 會根據主軸從 main-start 開始向 main-end 排列放置 main-size - 因為 flex-direction 屬性的設定可以改變方向性, 依據主軸方向該 item 的寬或高就是 main-size, 其屬性值來自於 item 的 width 或 height cross axis - 側軸(橫軸)指的是垂直於主軸的另外一個維度向性, 他的方向性會根據主軸而改變, 相依於主軸. cross-start|cross-end - item 會依照 Flex Line 排列放置, 類似於主軸的概念, 只不過這是另外一個維度 cross size - 概念與 main-size 相同, 不過換成側軸上 item 的寬或者高 Flex Container 屬性 display這個屬性用來定義產生一個 flex container; 一旦設定 flex 其第一層子項目就會變成 flex item.屬性值有 flex, inline-flex. 另外注意 CSS columns 在 flex container 中是沒有作用的. flex container 並不是一般的 block, 也因此我們常常在用的一些控制位置, 對齊的屬性在這個容器中並不適用也就是說在 item 設定 column-*, float, clear, vertical-align 都是沒有作用的. 但是!! 對容器本身是有用的. flex 和 inline-flex 對於內部的 item 使用起來並沒有差異, 差別是容器本身的行為, inline-flex 容器本身就會類似 inline 一樣不會預設佔滿一 row 123.container { display: flex; /* or inline-flex */} flex-direction 此屬性用來設定主軸的方向, 基本上是單向的佈局概念, item 可以水平或垂直排列, 一次只能設定一種方向 123.container { flex-direction: row | row-reverse | column | column-reverse;} row - 預設的屬性值, 在文字方向設定 direction: ltr; 時 row 就是由左至右, 反之 rtl 則由右至左 row-reverse - 反向的 row column - 跟 row 的概念一樣不過這是垂直的 column-reverse - 跟 row-reverse 概念相同, 但是是垂直的 flex-wrap 預設 flex item 只會排成一排, 你可以修改這個屬性當 item 塞不下的時候換行 123.container{ flex-wrap: nowrap | wrap | wrap-reverse;} nowrap - 預設值, 只會有一行 wrap - 多行, 塞不下就換行 wrap-reverse - 多行, 反向排列 flex-flow這是 flex-direction 和 flex-wrap 的縮寫版預設值是 row nowrap 123.container{ flex-flow: &lt;‘flex-direction’&gt; || &lt;‘flex-wrap’&gt;} justify-content 設定主軸的對齊方式, 這個屬性可以協助我們分配容器中扣除 item 的空間, 其行為是當所有可伸縮的長度及邊距都完成計算後剩下的空間才輪到 justify-content 來分配 123.container { justify-content: flex-start | flex-end | center | space-between | space-around;} flex-start - 預設值, item 對齊主軸的起始點(邊界), 後續的 item 一個接著一個 flex-end - item 從主軸的終點邊界開始往回排列, 注意到我們在 Flexbox 裡 item 的順序是獨立出來的, 不要把順序和排列該對齊的位置搞在一起. center - item 置中, 換個角度看就是把剩下個空白平均分給兩邊 space-between - item 被平均分配到主軸上, 也就是說剩下的空間平均分到到 item 之間的間隔, 注意頭尾是貼齊邊界. 也就是說如果沒有多餘的空間其效果跟 flex-start 一樣 space-around - 把剩餘的空間平均分配到 item 的兩邊, 頭尾並不會貼齊邊緣, 類似下了左右的 margin. align-items 這個屬性用來設定 item 該如何沿著側軸(cross axis)對齊排列, 要注意主軸跟側軸的關係, 因為不見得主軸就是橫向的.根據大部份的情況, 把它想成用來處理垂直置中的屬性比較好記. 是指每個個別的 item 跟怎麼跟側軸對齊 123.container { align-items: flex-start | flex-end | center | baseline | stretch;} flex-start - 貼齊側軸的起始點 cross-start. flex-end - 貼齊側軸 cross-end 排列 center - 置放於側軸的中央 baseline - item 會對齊 baseline stretch - 預設值, 自動把 item 的高長滿 container align-content 這個屬性比較像是垂直版的 justify-content, align-items 是以 item 的角度對齊, 而 align-content 比較像是根據 row 的高這個角度, 這個屬性的行為就是分配剩下的空間, item 高都計算完成之後, 該如何剩餘的空間. 注意, 當只有一行的時候這個屬性沒有效果 123.container { align-content: flex-start | flex-end | center | space-between | space-around | stretch;} flex-start - 對齊 container 側軸的起始點(cross-start)一行一行排列, 在一般水平為主軸的情況下看起來像是整塊對齊 top flex-end - 對齊側軸尾巴(cross-end) center - 整塊置中, 意思是剩餘的空間上下留白 space-between - 頭尾對齊邊緣, 剩下的空間分配到 item 之間的間隔 space-around - 把剩餘的空間平均分配到 item 的兩邊, 頭尾並不會貼齊邊緣, 類似下了左右的 margin. 不過這次是側軸的方向. 小結概略來說 container 決定 item 排列方向, 用 justify-content, align-content 來處理分配剩餘空間, 對齊. 側軸方向上還可以針對 item 該怎麼對齊用 align-items 甚至可以輕鬆完成每個項目同高, 或是各自有自己的高, 內部 item 可以依照比例伸縮, 且不會超過容器.可動態適應各種不同的螢幕尺寸. Flex Item 屬性 order 預設來說 item 會依照程式碼出現的順序排列, 然而 Flexbox 強大之處就是你可以設定 order 來調整排列順序, 順序用一個整數來表示, 也可以使用負數, 不過下面的 flex-grow 就不能用負數 123.item { order: &lt;integer&gt;;} flex-grow 此屬性用來讓 item 具有伸展擴大的能力, 使用一個沒有單位的整數(負數不是合法的值), 如果有剩餘的空間就會依照數字的比例去伸長 item.舉例來說如果所有的 item 的 flex-grow 都設為 1 那麼當需要展延的時候所有 item 會分配到相同的長度. 如果你賦予其中一個 item 的 flex-grow: 2這個 item 就會被分配到比較多的空間. 或者更確切的例子假設容器 1000px, 有三個 item 各為 200px 加上 margin: 0 20px, 如此一來 1000 - (200 + 20 * 2) * 3 = 280這 280px 會依據 flex-grow 設定的比例去分配 另外需要注意的就是如果 item 設為 flex-grow: 0 則不參與空間分配 123.item { flex-grow: &lt;number&gt;; /* default 0 */} flex-shrink當空間不足時使 item 具有縮小的功能即依照比例縮小, 同樣負數無效舉例來說容器 200px 三個 item 各自 100px 加上 item 有 margin: 0 10px 那麼三個 item 的總寬是 (100 + 10 * 2) * 3 = 360總共超過 160px, 所以為了要能夠塞進容器裡, 現在我們需要砍掉 160px, 如果設定是 1:1:1 的話就是 160/3=53.33 也就是每個 item 要砍掉 53.3px也就是說在 flex-shrink 裡數字越大砍掉越多. 123.item { flex-shrink: &lt;number&gt;; /* default 0 */} flex-basis設定 item 的初始值, 即在 flexbox 機制開始分配剩餘空間調整 item 大小之前賦予一個初始值, 預設值是 auto當 flex-basis 不設定或設為 auto 的時候則 item 的尺寸會根據自身的屬性(width)加上 content 的寬度去計算, 概念上我們可以把其當成是 min-width. 123.item { flex-basis: &lt;length&gt; | auto; /* default auto */} flexflex-grow, flex-shrink, flex-basis 的濃縮寫法第一個參數 flex-grow, 第二個是 flex-shrink 第三個是 flex-basis 預設值為 0 1 auto 123.item { flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]} W3C 文件建議我們善用這個屬性取代其他三者 align-self 剛剛上面我們看過了 align-items 不過 align-items 是從 flex container 的角度讓所有的 item 設定同一個值, 而 align-self 則是從 item 的角度去設定, 可以讓我們達到某一個 item 覆寫不同值 123.item { align-self: auto | flex-start | flex-end | center | baseline | stretch;} 再次強調 float, clear, vertical-align 對於 item 是沒有作用的. 小結簡單來說 container 處理整體的方向, 空間開如何分配而 item 的屬性部分就是 order 順序, 和當空間超出去或不夠的時候 item 該如何動態增減其長度這個部分主要是針對 main size. 參考 a-guide-to-flexbox cssreference 好用的手冊","link":"/2015/09/09/understand-flexbox/"},{"title":"React Virtual DOM vs Incremental DOM vs Ember’s Glimmer","text":"這篇文章翻譯自 React Virtual DOM vs Incremental DOM vs Ember’s Glimmer: Fight 在這篇文章我們將要探討三個用來動態建立操作 DOM 的技術。當然我們也會測試紀錄其效能並且找出誰比較快。最後我們當然會分享為什麼我們選擇了其中之一用在我們的專案上。 介紹在網路上有許多關於操作 Document Object Model(DOM) 的框架和函式庫。在他們之中有三個值得我們注意，因為他們的核心專注在提升效能上。React.js, Ember.js, 和最近開始崛起的 Incremental DOM。 而 React.js 和 Ember.js 提供更多功能不僅僅是建立和更新 DOMIncremental DOM 只專注在建立 DOM 樹狀結構以及讓他們可以動態更新。下面我們將探索這些框架或函式庫誰比較快一點。 在我們深入介紹分析之前如果你不是網頁設計師你也許會問什麼是 DOM 操作？通常網站是透過我們定義不同的元素 element 來構成一個樹狀結構，透過這個樹狀結構的物件來呈現網站，而這些我們稱為元素的東西就是 HTML 規範所定義的那些標籤 透過組織這些元素，開發者可以建立他們想要的網站。而 DOM 就是將一個網站的外觀透過元素來表示，例如我們可以透過 &lt;input&gt; 轉換成使用者看到的輸入框這些標籤元素是 W3C 定義的然後瀏覽器的開發商實作，最後當我們在 HTML 檔案中使用時即會呈現該元素。也因此我們可以理解隨著我們對於 UIUX 的需求，我們很常會需要動態去更新這些元素，就是當使用者與之互動時產生變化。 除了幫助我們把資料跟視覺呈現的 VIEW 繫結在一起外，上面提到的函式庫通常也會協助我們有效率的去更新 DOM。一般來說一系列的操作會對應到呼叫一系列的 DOM API 而這些呼叫會自動打包成一個呼叫或者是自動精簡調用的次數。舉例來說假設來說當我們更新了資料之後我們可能需要 移除該元素 加入新元素 修改新加入元素的屬性 所以我們會直接透過呼叫 DOM API 來執行這些變更。然後網站就會立即的呈現出我們的異動。但是這樣一步一步操作是很浪費效能的。如果換成透過虛擬模型的機制這些步驟可以被精簡到剩下一步 樣板 Templates一種非常好用且流行的一種方式就是透過樣板來建立 DOM 結構。開發者可以使用特定語法來告訴編譯器如何轉換成 DOM 結構即 HTML 文件。樣板大多看起來就像是增強版的 HTML 就是 HTML 多了一些額外的語法(.erb, .ejs)，也可能完全是另外一種(.jade, .slim)雖然樣板用起來非常直覺但並不是所有函式庫都偏好這種方式，舉例來說 React 就偏好使用 JSX，算是擴展 JS 的一種語法而不是 HTML，他允許我們在 JS 中插入一些類似 HTML 的語法另一方面 Ember 則偏好使用 Handlebars 樣板引擎 Incremental DOM 並不偏好特定樣版引擎，雖然說是不偏好特定但是 closure-templates 正默默地在開發中。Incremental DOM 也可以搭配 superview.js, starplate 甚至是 JSX React.js 的 Virtual DOMVirtual DOM 是 React 開發者給這套 DOM 操作引擎取的名字。Virtual DOM 提供一系列方法來讓函式庫知道該如何建立一個在記憶體中的 DOM 樹狀結構同時也讓其知道該如何更新那些綁定繫結的資料。關於 Virtual DOM 最重要的部分就是其辨識差異的邏輯。一旦模型被改變就會對應到記憶體中的 DOM 副本，接著這套演算法就會找出最少次數的操作來完成所有的更新 DOM 的動作。 優點 快速的辨識差異演算法 輕量化，在行動裝置上也可以使用 非常多媒體，個人 Blog 強力推薦 即使沒有 React 也可以使用 多個前端能夠使用 缺點 所有 DOM 副本都在記憶體中(高記憶體使用) 靜態和動態元素沒有分別 另外 React 已經著手在開發偵測那些靜態元素以減少檢查是否需要更新的元素數量 Ember 的 GlimmerGlimmer 是 Ember.js 最新渲染引擎的名字。 Glimmer 是 Ember 開發者試圖要在 Ember 中加入 React Virtual DOM 優點但既有的 API 仍然相容的成果Glimmer 幾乎是全部重寫 Ember 的渲染引擎並且沒有使用任何 Virtual DOM 的程式碼 在 Glimmer 中分成靜態和動態的元件，因此降低了需要確認是否更新的元素，這樣的區隔可以被實現多虧了 Handlebar 的樣板 另外一個 Glimmer 和其他解決方案的關鍵差異在於節點儲存和比對的方式。Glimmer 透過類似串流方式的物件而不是類似於 DOM 節點的物件。為了找出哪個節點需要被更新，Glimmer 的節點資料會一直跟最新得到的節點資料做比對，如果資料沒有異動就完全不需要執行任何動作 優點 快速的差異比對演算法 靜態與動態元素區隔 完全相容於 Ember 的 API 使用記憶體的部分較少 缺點 只能夠搭配 Ember 使用 只有一個前端能使用 Incremental DOMIncremental DOM 試圖要帶來更簡單的方式來處理這個問題，不在記憶體中保存整個 DOM 副本也不產生輕量化的物件型態來儲存樹狀結構的資料。Incremental DOM 使用的就是原本的 DOM 來找出資料異動的元素。你可能會問為什麼？如果這件事這麼簡單，就不需要有其他的解決方案啦它其實就是在速度和記憶體中取得一個平衡，Incremental DOM 透過移除多餘的 DOM 副本其結果就可以減少一些記憶體的使用。在實務上當然在檢查差異的時候也會降低一些速度，降低記憶體的使用主要是為了行動裝置和一些記憶體有限的裝置。 優點 降低記憶體的使用 簡單的 API 容易和許多前端框架整合 缺點 並不像其他兩者這麼快，不過這點還有點爭議下面我們會看實際的測試資料 較少社群使用 效能測試我們將挑選 dbmonster test app 來做一系列的測試，dbmonster 是一個簡單的應用程式它模擬應用程式更新大量資料時的狀況這個程式是原本是 Ember 團隊用來測試效能的，我們將使用 React, Ember 1.x 和 2.x (都具備 Glimmer) 還有 Incremental DOM所有的測試都在 Linux (Core i5-5200U CPU) 的 Chromium 46 版本執行。每個測試執行 5 次然後平均 在這兩張圖中顯示記憶體回收的時間，如同預測 Incremental DOM 在這個部分非常有效率在 MajorGC 的部分非常接近 Incremental DOM 但到了 MinorGC 就突然被拉開了。不過在上兩張圖比較有意思的是關於Ember 在 1 和 2 之間的改進的程度 在渲染輸出與繪圖方面 Ember 則表現得比其他人還要突出，Incremental DOM 則因為降低了記憶體影響了速度，在這方面 React 仍然保持第二名且非常接近 Ember 這張圖則顯示出因為長時間停止導致 Chrome 決定要移除的 frames 數量 這個數據越大將會導致有感的閃一下畫面。這一次 Incremental DOM 再次勝出，因為其花比較少的時間在 GC 意味著更多的時間可以去畫 frames其他三者差異不大 一個圖表上無法顯示出來比較重要的點是當使用瀏覽器時 Incremental DOM 感覺會比較快因為幾乎是及時回饋，不會閃一下。觀察其他收集的資料顯示 Incremental DOM 調用 Javascript 呼叫的次數相對少。不過我們還是得說 Incremental DOM 只是動態更新 DOM 的一套函式庫，而 React 和 Ember 可以處理更多事情，像是事件啊，資料的傳入等等 可以參考一下這個測試的彙整表 總結Virtual DOM, Glimmer, 和 Incremental DOM 在處理動態 DOM 操作與更新這方面都是不錯的選擇。不過因為 React 這陣子較多人在參與以及容易整合雖然使用較多的記憶體不過這個問題影響卻越來越小因為行動裝置搭載了越來越大的記憶體。Incremental DOM 的確是令人驚艷。我們期待看到 Incremental DOM 整合到其他函式庫。 React 和 Ember 事實上都取得在實務上的平衡並且二者採用了不同的方式，不過當要挑選一個函式庫時我們傾向優先關注在是否有大量使用者和是否容易整合。不過凡事還是要謹慎求證，你應該質疑這篇文章所說的並且實際跑一次自己的效能測試。","link":"/2015/11/30/virtual-dom-vs-incremental-dom-vs-glimmer/"},{"title":"認識 ES6 Decorator","text":"在這篇文章中我們將要探討如何使用 ES7 的新功能. ES6 新增了一個簡單更具可讀性的語法讓我們可以建立類別(class). 搭配 ES6 匯入匯出模組的語法讓我們的程式更加清楚易懂. 而 Decorators 讓我們可以在設計時期透過註記的方式修改類別與屬性.在 ES5 物件實字(Object Literal)支援值可以使用任意的表達式(Expression)而 ES6 類別單純只支援值使用函式表達式或稱作函式常量(Function Literal)現在 Decorator 讓 JS 具備了可維護性與可讀性的宣告式語法 Object Literal 是一個透過 , 逗號分隔的鍵值對列表, 再透過一個大括號包起來. 12345// object literal 又稱物件實字let obj = { name: 'andyyou', age: 28,} Function Literal 函式表達式或稱作函式常量 - 即定義一個不具名的 function, 單純觀察下面的範例會覺得其類似於一個 function 得宣告片段, 除了語法看起來像一段表達式和並沒有宣告函式名稱 123456789// Function Literalvar func = function () { console.log('I am a function');}// 具名 Functionfunction F() { console.log('I am a function');} 簡單說就是我們會對 class 或 property 使用 decorator 何謂 Decorators?如果你不熟悉 Decorator, 他們類似於一種標記或描述資料(metadata), 不過不同的是它們會被附加套用在類別, 方法, 或者屬性上.概念上就是你可以透過附加的方式來操作定義. 這麼說非常抽象讓我們看看範例: 123456789101112// 可否測試function Testable(target) { target.isTestable = true}@Testableclass OurClass {}// 接著我們就可以確認這個類別是否可以測試OurClass.isTestable // =&gt; true 上面那個 @Testbale 就是 decorator 語法, 我們用白話文來說就是透過像加註解或標記的方式讓類別或屬性增加其他功能.如果我們想要傳入參數也就是一個動態的註記函式, 我們可以透過 factory pattern 123456789101112function testable(isTestable) { return function(target) { target.isTestable = isTestable }}@testable(true)class OurClass {}console.log(&quot;OurClass: &quot;, OurClass.isTestable); // =&gt; OurClass: true 小結來說一個 decorator 是 一個表達式 一個 function 可以在其參數中取得目 target, name, property, descriptor 選擇性的回傳一個 descriptor 用來安裝在目標物件上 透過宣告的方式加入 Mixins在程式語言的概念中 Mixin 是我真的覺得好用的功能(事實上在這裡它不叫 Mixin 稱為 traits)因為在大多的開發過程我們只是要把一些功能, 方法抽出來重複使用, 實務上常遇到不好決定到底該歸納到什麼類別. 如果你要說介面(Interface)那又扯遠了 簡單的說 mixin 就是把一些功能抽出去獨立一個模組, 根據不同語言其本質可能是另一個類別或函式等等.所以我們需要的其實就是如何把這些函式或者方法抽出去和合併的方式.在 ES5 時我們可以使用 Object.assign 來合併(merge) prototype, 背地裡其實是 Polyfill 例如使用 underscore 或 lodash 的 _.extend 實作. 1$ npm i -S object.assign 123456789101112131415var assign = require('object.assign');function CarAbility() {};CarAbility.prototype.run = function () { console.log('Car is running');}function ToyotaCar() {}assign(ToyotaCar.prototype, CarAbility.prototype);var car = new ToyotaCar();car.run(); // =&gt; Car is running 而在 ES6 當我們透過新的語法 class 來定義類別的時候, 我們並不能簡單的使用 prototype 當做 mixin. 且預設所有的方法(Medthod)並不是 enummerable 這是 JS 中物件底層的屬性簡單的說就是 for in 會不會將其列舉出來. Object.assign 只會合併那些物件中 enummerable 的方法此時我們可以改用物件來作為 mixin 接著透過 Object.assign 將其套用到目標類別上 1234567891011121314const CarAbility = { run() { console.log('foo') }}class BMWCar {}Object.assign(BMWCar.prototype, CarAbility)let car = new BMWCar();car.run(); 這是一種指令式的風格, 那如果我們可以在宣告類別的時候合併呢? 讓我們來建立一個簡單的 decorator 來完成這個需求 12345export function mixins(...list) { return function (target) { Object.assign(target.prototype, ...list) }} 然後我們就可以使用 ES6 的匯入語法 注意從這邊開始因為使用了 ES6 的語法所以你會需要 Babel 來編譯 123456789101112131415import {mixins} from './mixins'const CarAbility = { run() { console.log('I am running'); }}@mixins(CarAbility)class AudiCar {}let car = new AudiCar();car.run(); Traits既然我們已經可以透過上面的方式實作 mixin, 那為什麼還要有個 Traits, 原因是有些情況您需要更多的控制權, 當你只想合併想要的功能時, 或者遇到不同物件卻有相同名稱的函式的狀況.Traits 讓我們可以避免合併時的名稱衝突, 我們可以排除方法或者是透過 alias 別名的方式改變方法的名稱 關於實作面, 我們可以透過CocktailJS這個函式庫輕鬆實作 Traits, 這個函式庫包含了 annotations, traits 以及讓 class 具備更多陳述式的用法(或者說從外部合併屬性或方法的寫法) 這裡為了單純只說明觀念我們只使用traits-decorator, 它是一個實驗 decorator 和 bind-operators 的函式庫 12345678910111213141516171819202122232425import {traits} from 'traits-decorator';// 使用 class 為 traitsclass CarTraitClass { run () { console.log('I am running'); }}// 使用 object 為 traitsconst CarTraitObject = { start () { console.log('The car is started'); }}@traits(CarTraitClass, CarTraitObject)class HondaCar {}let car = new HondaCar();car.run(); // =&gt; I am runningcar.start(); // =&gt; The car is started 再次提醒如果你用 babel 實作需注意目前 @ 語法要啟用 experimental 即 stage 0 1$ babel [source].js -o [destination].js --stage 0 名稱衝突剛剛上面有提到關於衝突的部分, 假設我們現在遭遇到 traits 甚至是類別本身的方法名稱產生衝突的狀況, 就是名字一樣 123456789101112131415161718192021222324import {traits} from 'traits-decorator';// 使用 class 為 traitsclass CarTraitClass { run () { console.log('[class] I am running'); }}// 使用 object 為 traitsconst CarTraitObject = { run () { console.log('[object] I am running'); }}@traits(CarTraitClass, CarTraitObject)class HondaCar {}let car = new HondaCar();car.run(); 重新編譯在執行會產生錯誤(編譯時不會出錯) 1throw new Error('Method named: ' + methodName + ' is defined twice.'); 很明顯的是因為我們的 run 定義了 2 次, 此時 Traits 讓開發者負責去解決這個衝突, 這部分和 mixin 不太一樣, mixin 的話會讓後面載入的方法覆寫掉前面的. 為了解決這個問題我可以排除我們不想要的 method 或者為其創造一個別名 1234567891011121314151617181920212223242526import {traits, excludes} from 'traits-decorator';// 使用 class 為 traitsclass CarTraitClass { run () { console.log('[class] I am running'); }}// 使用 object 為 traitsconst CarTraitObject = { run () { console.log('[object] I am running'); }}// 別名的用法// @traits(CarTraitClass, CarTraitObject::alias('drive'))@traits(CarTraitClass, CarTraitObject::excludes('run'))class HondaCar {}let car = new HondaCar();car.run(); // =&gt; [class] I am running 您可能注意到一個奇怪的小東西 :: 這是 bind-operator 基本上 bind operator 就是 .bind() 的縮寫, ::this.method = this.method.bind(this)::Car.run 會等於 Car.run.bind(Car) 而 :: 和 @ 這些語法在 Babel 都還處於實驗階段, 所以如果您要使用就必須要自己設定開啟 stage 0 總結透過這種方式我們說我們可以在設計時期就可能是類別已經寫好了的情況下透過註記來增加功能, 不要用的時候也可以輕易移除. 參考 ES 7 descorator javascript-decorators exploring-es7-decorators","link":"/2015/10/15/explore-es2016-decorator/"},{"title":"Chrome Dev tool 筆記","text":"Element Panel ⌥⌘I 開啟 Dev Tool 選取元素的方式 對元素點右鍵 -&gt; Inspect 開啟 Dev Tool -&gt; 點擊 Dev Panel 左上角 bar 的箭頭 ICON -&gt; 選取元素 ⌘⇧C -&gt; 選取 編輯樣式 選定一個 Element 之後右邊 panel 會顯示該 Element 之樣式 開關樣式 新增或刪除樣式 右上角 -&gt; Change state(hover, active, focus, visited) Computed -&gt; 觀察 box model 點擊連結切換到 Source Shift + 點擊 CSS rule 的顏色會轉換 e.g. hex to rgb 編輯樣式時，選取某個字串 -&gt;Command+D會把一樣的都選起來 Source Panel 進入 Source panel ⌘S 可以暫時編輯檔案並存到瀏覽器的 Storage 右鍵 -&gt; Local Modifications 可以檢視歷史紀錄 Console12345678910111213console.log();console.assert(false, 'Information'); // 錯了就噴第二個參數console.count('go'); // go: 1console.count('go'); // go: 2console.log(&quot;document body: %O&quot;, document.body);console.group(&quot;Authenticating user '%s'&quot;, user);console.log(&quot;User authenticated&quot;);console.groupEnd();console.log('%c Hello', 'color: orange;'); // %c 使用 cssconsole.log(&quot;%O &quot;, document.body); // %O Javascript Objectconsole.log(&quot;%O &quot;, document.body); // %o DOM 詳細 Console API 學會查看 Error，切換到 Source 在 Source panel 下 ESC 開啟第二層 Console 123456$('selector') // 稱為 blind// 如果載入 jQuery 預設的 blind 會被覆寫// 回傳的是一個陣列inspect($('#title')) // 選取元素並切換到 Element Panel$0 // 當前選取的 Element$1 // 上一個 Source panel 右上角的 Pause on 按鈕打開的話，下次噴錯就會暫停 Source panel 左下角的 {} 按鈕可以把 minifed 檔案轉換成較易讀的格式 Local Storage 切換到 Resource panel Network panel Refresh 之後會記錄每個 Request ⇧ + Refresh 鍵強制全部重載 Size = Transfer size Content = Actual size 最底下的 Bar 有總和 Waterfall 裡面淺色的部分代表發出 request到回應即開始傳輸資料的時間 實心的部分代表開始下載資料 顏色的意義 HTML 藍色 JS 橘色 CSS 綠色 圖片 紫色 右邊垂直的藍色線代表 DOM loaded 意為瀏覽器解析完畢 HTML to DOM 右邊垂直紅色線則表示圖片等資源下載完畢 CSS 放在 JS 之前 Timeline 顏色的意義 Loading 藍色 執行 Script 黃色 Rendering 紫色 Painting 綠色 Size vs Content","link":"/2016/01/28/chrome-dev-tool/"},{"title":"深入 React 生命週期","text":"各種情況的生命週期流程大致上元件執行生命週期方法的情形可分為四種 初始化，第一次 render getDefaultProps() getInitialState() componentWillMount() render() componentDidMount() props 發生改變時 componentWillReceiveProps(nextProps) shouldComponentUpdate(nextProps, nextState) componentWillUpdate(nextProps, nextState) render() componentDidUpdate(prevProps, prevState) state 發生改變時 shouldComponentUpdate(nextProps, nextState) componentWillUpdate(nextProps, nextState) render() componentDidUpdate(prevProps, prevState) 元件 unmount 卸載時 componentWillUnmount() 當遇到複合式元件的狀況時，子元件的生命週期從父元件 render 之後開始發動 一旦父元件發生改變，子元件的 componentWillReceiveProps 還是會觸發。也就是每次父元件更新，子元件都會重新渲染(Update流程) 當使用 React.createClass 建立一個 component 時， render 是生命週期方法中必須的。 當 render 被呼叫時會去檢查 this.props, this.state 並且只能回傳一個 component 意即其他元素都要包在這個元件底下。 render return null 或者 false 則表示不渲染輸出，背地裡 React 則是輸出 &lt;noscript&gt; 標籤。 不可以在 render 裡面操作修改 state 和 props。 getInitialState 一定要回傳物件或 null，在元件被 mounted 之前僅被呼叫一次。 getDefaultProps 如果回傳一個物件，會和所有元件的實例物件共用，傳址不是傳值。 第一次初始化的流程 displayName 用來設定元件名稱 getDefaultProps() 當元件類別被建立時就會觸發，且和所有實例物件共享 getInitialState() 開始渲染元件時初始化 componentWillMount() 準備掛載 DOM 之前觸發 render() 執行輸出 如果裡面有其他的子元件則依據上面的流程 getInitialState() -&gt; componentWillMount() -&gt; render() -&gt; componentDidMount() componentDidMount() DOM 完成之後立即觸發(會等到子元件都完成才觸發) 更新的流程 componentWillReceiveProps(nextProps) 這邊使用 setState 不會再觸發一次 render。初始化不會被觸發 shouldComponentUpdate(nextProps, nextState) 元件是否要更新 componentWillUpdate(nextProps, nextState) 將要更新之前，不可以用 setState render() componentDidUpdate(prevProps, prevState) 呼叫 setState 不會 re-render 的方法 componentWillMount() componentWillReceiveProps() 存取 DOM 的適當時機 componentDidMount() 不得使用 setState 的事件 shouldComponentUpdate(nextProps, nextState) componentWillUpdate(nextProps, nextState) render()","link":"/2015/12/17/react-lifecycle/"},{"title":"Javascript Array 筆記","text":"方法範例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137// pushvar arr = [1, 2, 3];var result = arr.push(4); // result: 4, arr: [1, 2, 3, 4]// popvar arr = [1, 2, 3];var result = arr.pop(); // result: 3, arr: [1, 2]// lengthvar arr = [1, 2];arr.length; // 2// unshiftvar arr = [1, 2, 3];var result = arr.unshift(0); // result: 4, arr: [0, 1, 2, 3]// shiftvar arr = [1, 2, 3];var result = arr.shift(); // result: 1, arr: [2, 3]// splice 拼接// Array.splice(start_index, remove_num, element01, element02...)var arr = [1, 2, 3, 4, 5];var result01 = arr.splice(2, 1, 6); // result01: [3], arr: [1, 2, 6, 4, 5]var arr = [1, 2, 3, 4, 5];var result02 = arr.splice(2, 0, 6); // result02: [], arr: [1, 2, 6, 3, 5, 6]// 沒移除元素會放在該 index 元素會被往後推var arr = [1, 2, 3, 4, 5];var result03 = arr.splice(2, 0, 6, 7, 8) // result03: [], arr: [1, 2, 6, 7, 8, 3, 4, 5]// slice 切片var arr = [1, 2, 3, 4, 5];var result01 = arr.slice(1, 3); // result01: [2, 3], arr: [1, 2, 3, 4, 5]var arr = [1, 2, 3, 4, 5];var result02 = arr.slice(-2); // result02: [4, 5], arr: [1, 2, 3, 4, 5]var arr = [1, 2, 3, 4, 5];var result03 = arr.slice(-2, 0); // result03: [], arr: [1, 2, 3, 4, 5]var arr = [1, 2, 3, 4, 5];var result04 = arr.slice(0); // result04: [1, 2, 3, 4, 5], arr: [1, 2, 3, 4, 5]// indexOfvar arr = [1, 2, 3, 4, 5];var result01 = arr.indexOf(3); // result01: 2var arr = ['a', 'ab', 'abc', 'abcd'];var result02 = arr.indexOf('a'); // result02: 0var result03 = arr.indexOf('b'); // result03: -1var result04 = arr.indexOf('ab'); // result04: 1// lastIndexOfvar arr = [1, 2, 3, 2, 1];var result01 = arr.lastIndexOf(1); // result01: 4var arr = ['a', 'ab', 'abc', 'ab', 'a'];var result02 = arr.lastIndexOf('a'); // result02: 4var result03 = arr.lastIndexOf('b'); // result03: -1var result04 = arr.lastIndexOf('ab'); // result04: 3// some 陣列是否有元素符合測試var arr = [1, 2, 3, 4, 5];var result01 = arr.some(function (element, index, array) { return element &gt; 3}); // result01: truevar result02 = arr.some(element =&gt; element &gt; 5); // result02: false// every 陣列中是否所有元素都符合測試var arr = [1, 2, 3, 4, 5];var result01 = arr.every(function (element, index, array) { return element &gt; 3}); // result01: falsevar result02 = arr.every(element =&gt; element &lt; 6); // result02: true// join 串聯成字串var arr = [1, 2, 3, 4, 5];var result = arr.join(','); // result: &quot;1,2,3,4,5&quot;// sort 由小排到大var arr = [5, 4, 3, 2, 1];var result = arr.sort(); // result: [1, 2, 3, 4, 5], arr: [1, 2, 3, 4, 5]var arr = ['c', 'b', 'a', 0];var result = arr.sort(); // result: [0, 'a', 'b', 'c'], arr: [0, 'a', 'b', 'c']// reverse 由大排到小var arr = [1, 2, 3, 4, 5];var result = arr.reverse(); // result: [5, 4, 3, 2, 1], arr: [5, 4, 3, 2, 1]var arr = [0, 'a', 'b', 'c'];var result = arr.reverse(); // result: ['c', 'b', 'a', 0], arr: ['c', 'b', 'a', 0]// concat 組合並回傳一個新的陣列(flat element)var a = [1, 2];var b = [3, 4];var c = a.concat(b); // a: [1, 2], b: [3, 4], c: [1, 2, 3, 4]var d = [...a, ...b]; // a: [1, 2], b: [3, 4], d: [1, 2, 3, 4]var e = a.concat(0, [3, 4]); // e: [1, 2, 0, 3, 4]// forEachvar arr = [1, 2, 3, 4, 5];arr.forEach(function (element, index, array) { console.log(element, index, array);});// 1, 0, [1, 2, 3, 4, 5]// 2, 1, [1, 2, 3, 4, 5]// 3, 2, [1, 2, 3, 4, 5]// 4, 3, [1, 2, 3, 4, 5]// 5, 4, [1, 2, 3, 4, 5]// 注意: 例外無法阻止 forEach 停止// map 遍歷所有元素至參數 callback 然後回傳一個新的陣列var arr = [1, 2, 3, 4, 5];var result01 = arr.map(function (element) { return element + 10;}); // arr: [1, 2, 3, 4, 5], result01: [ 11, 12, 13, 14, 15 ]var arr = [1, 4, 9];var result02 = arr.map(Math.sqrt); // arr: [1, 4, 6], result02: [1, 2 ,3]// filter 過濾元素，產生新陣列var arr = [1, 2, 3];var result = arr.filter(function (element) { return element &gt; 2;}); // arr: [1, 2, 3], result: [3]// reduce 從左至右當作累加器把陣列變成單值var arr = [1, 2, 3, 4, 5];var result = arr.reduce(function (previous, current, currentIndex, array) { return previous + current;}, 100); // result: 115// reduceRightvar arr = ['ab', 'bc', 'de'];var result = arr.reduceRight(function (pre, cur, index, arr) { return pre + cur;}, 'I am initial:'); // result: &quot;I am initial:debcab&quot;// 其他補充var a; // a: undefinedvar b = a += 2; // a: NaN, b: NaN =&gt; undefined += 2 =&gt; NaNvar a = null;var b = a += 2; // a:2, b: 2 Array.forEach 額外補充根據 MDN 的定義 arr.forEach(callback[, thisArg]) 當我們要在 forEach 的匿名函數中使用 this 我們可以透過 thisArg 來設定。如果不設定(undefined, null)或者不用 var self = this; 的方式保留 context，那麼預設會是指向 global 123456789101112131415var sum = 100;function Counter () { this.sum = 0;}Counter.prototype.add = function (arr) { arr.forEach(function (el, i, arr) { this.sum += el; })};var o = new Counter();o.add([1, 2, 3]);console.log(o.sum); // 0console.log(sum); // 106 在 Chrome 或者 Firefox console 底下執行的確會執向 global，但是在 nodejs v5.6.0 底下結果卻是 12console.log(o.sum); // 0console.log(sum); // 100 要注意。 正確的範例如下 1234567891011121314function Counter () { this.sum = 0;}Counter.prototype.add = function (arr) { arr.forEach(function (el, i, arr) { this.sum += el; }, this); // &lt;-- here this &quot;thisArg&quot;}var o = new Counter();o.add([1, 2, 3]);console.log(o.sum); // 6console.log(sum); // undefined callback methods filter (has thisArg) some (has thisArg) every (has thisArg) forEach (has thisArg) map (has thisArg) reduce reduceRight","link":"/2016/02/16/javascript-array-methods/"},{"title":"React Native Push Notifications","text":"在 React Native 中的 Push NotificationsReact Native 官方在 v0.13+ 之後支援 Push notifications 然而在這篇文章撰寫時仍然未實做完所有功能。現階段只支援靜態的推播通知，另外關於錯誤處理的功能也還在開發中Error handling React Native v0.12對於上面的說法你可能有些疑問，事實會說在 0.13 支援是因為 0.12 的推播功能有些 Bug 不過在 0.13 時已經處理掉了。其實 0.12 也可以用，這篇文章會包含如何修好該 Bug 的步驟。 步驟為了要能夠在 React native 中使用推播通知的功能我們需要完成下面的步驟 匯入 Push Notification 函式庫 加入表頭檔路徑 (header path) 修改 AppDelegate.m 建立憑證與開啟推播功能 撰寫程式碼完成功能 匯入函式庫第一步我們要做的就是加入 PushNotificationIOS 函式庫。這一步在官方文件中已經說明得非常清楚了你可以選擇看官方的或者下面的說明 使用 Xcode 開啟專案 在左邊檔案導覽區塊中展開 Library 目錄 透過 Finder 開啟專案並且找到 node_modules/react-native/Libraries/PushNotificationIOS 把這個 RCTPushNotification.xcodeproj 拖到 Libraries 目錄下 現在這個函式庫已經被加入到專案中了，下一步我們需要連結 binary 檔案。 點擊左側導覽區中的專案檔如下圖 1 的地方然後切換到 Build Phases 2 把 libRCTPushNotification.a 拖到 Link Binary With Libraries 如上圖 3 處 對大部分的 React native 函式庫來說加入專案中並關聯就完成設定了。不過如果我們是要使用 PushNotification 函式庫我們還需要其他的設定 加入表頭檔路徑到此函式庫已經被夾到專案中了，我們需要加入表頭檔路徑(Header Path)。這個步驟只有在當我們在編譯時需要用到函式庫內容才會需要做例如 PushNotificationIOS 和 LinkingIOS 否則這個步驟是可以省略的。要加入 Header Path 如下步驟 一樣點擊導覽區的專案如下圖 1 處 切換到 Build Settings 圖 2 搜尋 header search paths 如圖 3 Header Search Paths 欄位的路徑上點擊兩下 加入新的路徑如圖 4 取得該 Library 需要的檔案的路徑如圖 5 一般 React Native app 要填入的路徑 $(SRCROOT)/node_modules/react-native/Libraries 請確認一下該路徑後面是 recursive 如圖 6 加入的 Header Search Path 的意義，在原生 Obj-C 這個路徑就是當我們要 import 函式庫時該去哪些路徑找檔案勒就像是 JS 中 require 預設的路徑是 node_modules如此一來我們在 AppDelegate.m 匯入的時候才找得到檔案 修改 AppDelegate.m這個 PushNotificationIOS 函式庫使用了一些 Obj-C 的方法來完成註冊與接收推播訊息。然而這些方法只能夠在 AppDelegate 中使用。想想也很合理的，因為他是 Obj-C 的方法，因此我們需要加入一些程式碼將資料從 AppDelegate 傳到 PushNotificationIOS 第一步我們需要匯入 RCTPushNotificationManager.h 到 AppDelegate.m 1#import &quot;RCTPushNotificationManager.h&quot; 第二件事我們需要加入幾行程式碼 1234567891011// Required for the register event.- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken{ [RCTPushNotificationManager application:application didRegisterForRemoteNotificationsWithDeviceToken:deviceToken];}// Required for the notification event.- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)notification{ [RCTPushNotificationManager application:application didReceiveRemoteNotification:notification];} 少了這幾行程式，資訊將無法被傳遞到 PushNotificationIOS 替 v0.12 修補 Bug只有在專案使用的 React Native 版本是 0.12 或更早之前的才需要下面步驟這是舊版的 Bug 他導致了在 iOS8 以後的手機系統無法正常推播，意味著 0.12 遇上最新的 iOS 會不正常。下面的步驟則是修好這個 Bug 在 Xcode 中到 Library 目錄下打開 RCTPushNotification.xcodeproj/RCTPushNotificationManager.m 捲到大概 155 行 如果你使用的是 v0.11 或更早的版本 換成下面這段程式碼 123456789101112131415UIApplication *app = [UIApplication sharedApplication];if ([app respondsToSelector:@selector(registerUserNotificationSettings:)]){UIUserNotificationSettings *notificationSettings = [UIUserNotificationSettings settingsForTypes:(NSUInteger)types categories:nil];[app registerUserNotificationSettings:notificationSettings];[app registerForRemoteNotifications];} else {[app registerForRemoteNotificationTypes:(NSUInteger)types];} 如果使用的是 v0.12 換成下面的程式碼 123456789101112131415UIApplication *app = RCTSharedApplication();if ([app respondsToSelector:@selector(registerUserNotificationSettings:)]){UIUserNotificationSettings *notificationSettings = [UIUserNotificationSettings settingsForTypes:(NSUInteger)types categories:nil];[app registerUserNotificationSettings:notificationSettings];[app registerForRemoteNotifications];} else {[app registerForRemoteNotificationTypes:(NSUInteger)types];} 存檔然後 Bug 就修復了 現在我們已經把 React native 專案需要的部分都處理好了，接下來要使用推託我們必須要取得憑證 憑證設定也許你可能知道推播功能是透過 Apple 的 Server 傳到你的程式。並且為了讓功能能夠運作我們需要取得一些憑證這部分 Parse 有提供一份非常詳細的教學針對本文的部分只需要 step 1 Creating the SSL certificate 和 step 2 Creating the Provisioning Profile 一旦你完成這個步驟我們就可以開始使用推播功能了 使用推播功能在 React native 中推播功能的 API 非常直覺。也可以透過官方的文件來學習。 概覽用法首須我們需要在 Javascript 中匯入 PushNotificationIOS 1234567var { AppRegistry, StyleSheet, Text, View, PushNotificationIOS // &lt;- 加入這一行} = React; 取得權限在本機上要使用這個功能需要跟用戶要權限，要注意的是模擬器並不能夠使用推播必須要在實機上測試。 1PushNotificationIOS.requestPermissions(); 註冊事件當使用者註冊了接收遠端通知的時候會被觸發，透過這個事件可以取得裝置的 token 123PushNotificationIOS.addEventListener(‘register’, function(token){ console.log(‘You are registered and the device token is: ‘,token)}); 通知事件當收到推播通知的時候，繫結的函式會被觸發 123PushNotificationIOS.addEventListener(‘notification’, function(notification){ console.log(‘You have received a new notification!’, notification);}); 錯誤處理事件在這個時間點你不會看到 PushNotificationIOS 產生任何錯誤。一般來說在 iOS 例如你的憑證失效時你應該會取得錯誤訊息或者是在模擬器執行的時候，不過現階段這些錯誤都不會觸發 你可以持續關注Pull Request來看此功能是否被整合或者有其他更好的做法。 該如何傳送一個推播通知為了要能夠發送推播我們會需要一個後端和憑證，這個部分我們有下面幾種做法 使用服務採用外面的服務例如 Parse 或者 Urban Airship 建立自己的後端程式 NodeJS - node-apn Ruby - houston 憑證過程中我們可能還需要一些憑證這個時候可以參考StackOverflow的解答 參考How to use Push Notifications in React-Native (IOS)","link":"/2015/12/08/how-to-use-push-notification-in-react-native/"},{"title":"NodeJS path","text":"範例筆記 12345678910111213141516171819202122232425262728293031323334353637383940/** * 詳細教學 * http://www.tutorialspoint.com/nodejs/nodejs_path_module.htm */// 正常化path.normalize('/1/../2'); // =&gt; /2// 把所有路徑整合在一起並且正常化path.join('a', 'b'); // =&gt;'a/b'path.join('a', './b'); // =&gt; a/b'path.join('a', '/b'); // =&gt;'a/b'path.join('/1', '/2/3', '../4'); // =&gt; /1/2/4// 從第一個路徑，照著後面切換最後回傳絕對路徑path.resolve('/from', '/to/path1', '/to/path2'); // =&gt; /to/path2path.isAbsolute('/'); // =&gt; true// 從 from 到 to 的相對路徑path.relative('..', './A/B'); // =&gt; [project]/A/B// 回傳該檔案所在的目錄path.dirname('node_modules/bin/webpack'); // =&gt; node_modules/binpath.dirname('./node_modules/bin/webpack'); // =&gt; ./node_modules/bin// 回傳路徑最後的部分，包含副檔名path.basename('node_modules/bin/webpack'); // =&gt; webpackpath.basename('/1/2/3.js'); // =&gt; 3.js// 只取副檔名 + .path.extname('/1/2/3.js'); // =&gt; .js// 將路徑解析成物件path.parse('/1/2/3.js'); // =&gt;// 從物件轉成字串path.format({ root: '/', dir: '/1/2', base: '3.js', ext: '.js', name: '3' }); // =&gt; /1/2/3.js","link":"/2015/12/17/nodejs-path/"},{"title":"從&lt;琅琊榜&gt;學 Redux","text":"前言這篇文章希望從另外一個角度來看關於 Redux 的機制與運用，在網路上各式的教學文章中值得先推薦的自然是官方教學如果英文不是很好的可以參考繁體中文版。這是小弟認為要學習 Redux 必讀的文件。另外還有A cartoon intro to redux也是值得一讀的好文可以加深記憶。 接著就讓我們開始吧，當然最後如果有任何錯誤，也歡迎您的指教。 一個中國的古代智慧先別管 Flux, Redux,React 等術語了，在我們深入任何程式碼與實作之前讓我們先來聊一下關於中國的古裝宮廷劇的橋段。雖然連續劇上演的可能並不是古代真實的狀況，但就讓我們假設這樣的過程是對的。就讓我們從當紅電視劇 《琅琊榜》來聊起，相信你我都知道這樣的流程。當梁皇大大決定了要加封蕭景琰從郡王變成親王，這個時候皇上要做的就是下旨，下旨之後接著就需要一份實體的聖旨或稱詔書來完成整個流程。這份聖旨當然不是任何人都能撰寫的，它通常需要由內閣按照一定格式完成。聖旨完成之後，接著就需要太監們去負責傳旨這個流程，太監總管自然是可以差遣底下的太監去正式的宣旨，在這過程中我們合理的推測太監總管是會通知像是禮部這類單位去準備親王穿的新衣服等等。好了，我們已經講完了關於單一資料流與 Redux 了！？ 角色與其職上面的沒頭沒腦地說明讓你開始想關掉這篇文章了嗎？讓我們先用較為通俗的比喻來對應這個流程，雖然這的確不是很精確。但我相信在學習過程中多少能有點幫助。開始介紹各個角色與其對應之前先讓我們來看看 Redux 的世界裡有哪些主要角色？ state action action creator reducer store state 事件的狀態首先介紹的就是 state ，少了這個 state 那麼是無法交織出精彩的宮廷劇。這個 state表示的是一件事情的狀態，用上面的例子來說就是蕭景琰是不是親王。 action 聖旨在古代朝廷裡舉凡重要大事例如：加薪升職或者出兵打仗基本上都是需要聖旨，這個聖旨也就只是一份記錄下來，具備特定格式的文件。而在 Redux 中剛好有這麼一個角色，它就是 action 。基本上他就是一個單純的物件，記錄著要做什麼事，就像聖旨一般。 如下就是一個 action 在程式中的樣子 1234var action = { type: '加封親王', name: '蕭景琰' // 取自&lt;琅琊榜&gt;} action creator 內閣這個角色在劇中通常我們會忽略，因為他的任務好無聊啊！就只是把要 執行的事情 格式化成特定的文件。講白一點，梁帝只說了一句話：加封蕭景琰為親王。自然就要有人來幫他寫完這份聖旨。 下面即 action creator 在程式中的範例：本質是一個 function 回傳 object ，這個 object 即 action 123456function actionCreator(data) { return { type: '加封親王', name: '蕭景琰' // 取自&lt;琅琊榜&gt; };} store 梁帝身旁的太監總管 - 高湛簡單來說，梁帝得知任何情報消息都是靠他，甚至要發聖旨也要靠他。在一般情況下太監總管幾乎等於皇上的 狀態管理中心 ，而且 就只有一個 ，管理一個國家和管理程式的狀態一樣複雜，如果到處都可以發動命令修改狀態那總會有狀態因為時間差不一致的狀況。 而要在程式中建立一個 store 我們需要先從 redux 匯入 createStore 接著如下建立 1var store = createStore(reducer) reducer 實際宣旨的太監 - 負責實際的狀態變更當太監總管把任務交代下來，底下的太監就要去執行任務，reducer 才是真正變更了狀態的角色。 雖然在劇中不是挺重要的角色，但在 Redux 所有的狀態都是由它進行異動的，要牢記的是 reducer 本質上是一個 function，必須要回傳 state 物件，最重要的是它永遠是傳入當前的 state 和 action 接著處理完後回傳另一個完整的 state ， 表示式為 (state, action) =&gt; newState。 流程在開演之前有些幕後工作要完成，首先是太監總管(store)要知道怎麼使喚部下(reducer)。 1store = createStore(reducer) createStore() 等於是前置作業，如此一來太監總管就知道該怎麼分派任務。當皇上下旨後，我們會需要內閣(action creator)的協助，得到一份聖旨(action)，接著太監總管(store)就分派(dispatch)聖旨(action)給底下的太監們(reducers)去執行。 1store.dispatch(action) 如果皇上想要知道事情的狀態那就得問太監總管 1store.getState() 另外就是當聖旨宣布後，太監總管應該也要順便通知禮部等單位進行後續的準備 1store.subscribe(listener) 這個 listener 就是當聖旨頒佈後後續要做的事，很合理的該單位總是也該知道事情進行到哪了，此時這個 function 便可以透過 getState() 來取得消息，不過要注意的是;這個太監總管不會先行通知，只會在發佈了聖旨後才會通知各部(listener)。 看到這邊我們才驚覺原來在古代的中國早就知道單一資料流的好處 XD。 而所謂的 Redux 概略的比喻就是各司其職的這些角色搭配運作流程的規範。最後讓我們先看一下概略示意虛擬碼： 12345678910111213141516171819202122232425262728293031323334353637// 注意: Javascript 的變數與 function name 並不支援中文// action typeconst 加封七珠親王 = '加封七珠親王';// action creatorfunction 內閣撰寫聖旨加封 (人名, 官位) { // 傳回一個 action return { type: 加封七珠親王, name: 人名, level: 官位 }}// reducerfunction 負責的太監甲 (state, action) { switch (action.type) { case: 加封七珠親王: return { ...state, { ...state[action.name], level: action.level } }; default: return state; }}// storevar 太監總管 = createStore(太監們)// actionvar 聖旨 = 內閣撰寫聖旨加封('蕭景琰', '親王')太監總管.dispatch(聖旨) 總體來說這邊只希望你記住三件事： 太監總管只有一個; 整個應用程式的 state，被儲存在一個樹狀物件放在唯一的 store 裡面。 要執行任何重大事件都需要聖旨; 改變 state 的唯一的方式是發出一個 action，也就是一個描述發生什麼事的物件。 實際去宣旨的是太監(reducer); state 的轉變必須只能在 reducer 撰寫，這永遠是一個 (state, action) =&gt; newState 的 function。 實作 Redux上面段落扯了這麼多，是希望用一個通俗的說明，讓您先大略明白整個流程，有個概念，接著我們就要以實作流程來說明。我相信目前網路上的教學不論詳細程度還是文章的質量都很難比官方教學來得好，但就是因為該文件太詳細了，有些緣由對於初學者來說不太好掌握，所以這個部分我希望能夠快速帶你走過一遍個人的實作流程，讓你能夠掌握每一個角色，有了概念後建議您搭配官方教學來深入學習。 從規劃 state 物件開始為了讓事情單純一點，我們將使用 Boilerplate 以避開一些繁瑣的設定，讓你能夠先專注在 redux 上。這個樣板包含了下面這些工具與函式庫的相關設定： webpack webpack-dev-server babel hot-reload react 建立專案指令如下： 123456&gt; git clone https://github.com/gaearon/react-hot-boilerplate.git demo // demo 可換成你喜歡的專案名稱&gt; cd demo&gt; npm install&gt; npm install redux -S# npm start 便可以開啟網站 現在，假設我們只有一個陣列 todos 要維護，這個 state 物件 結構如下 123{ todos: []} 注意：這個 state 物件就是我們整個應用程式唯一的狀態管理中心，我們一般無法直接操作它，一切都是透過 store 管理，reducer 改變。 列舉出需要實作的行為 - action type我們只會實作一個行為 ADD_TODO 用來解釋每個角色之間的使用與關係，接著用你喜歡的編輯器開啟 demo 目錄之後，我們先建立 src/actions.js，我們使用 string 來替這些行為命名，這就是 action type。把 action type 宣告為常數並匯出不是必須的，你的確可以單純用字串就好，不過為了減少錯誤與重構的好處我們還是使用了常數的方式。 12345678910111213141516/* file: src/actions.js */// action typeexport const ADD_TODO = 'ADD_TODO'/** * action creator * 有一個 action type 就需要對應一個 action creator 用來格式化需要的資料 * 本質是一個 function 回傳一個 object 裡面包含著要執行的行為和需要的資料 */export function addTodo() { return { type: ADD_TODO }} 透過 root reducer 定義資料結構在此我們不深入探討原理，只需要知道使用 combineReducers() 傳入的物件參數等於我們最後會得到的 state 物件。 建立 src/reducers.js 並輸入程式碼如下： 1234567891011121314/* file: src/reducers.js */import {combineReducers} from 'redux'import {ADD_TODO} from './actions'/** * root reducer 就是決定 state 屬性的地方 */const rootReducer = combineReducers({ // 這邊等於 state 規劃的 property todos})export default rootReducer 透過 reducer 實作變更 state 的行為用一個舊有的經驗來比喻，combineReducers 的參數部分所定義的物件，就像是我們在規劃資料庫時定義資料表(Table)一般。至於內部欄位還得靠真正被傳進去的那些 reducer 。所以實際的欄位操作得在 reducer 定義。 123456789101112131415161718192021222324252627282930313233/* file: src/reducers.js */import {combineReducers} from 'redux'import {ADD_TODO} from './actions'/** * root reducer 就是決定 state 屬性的地方 */const rootReducer = combineReducers({ // 這邊等於 state 規劃的 property todos})/** * reducer: 依據 rootReducer 的屬性實作 reducer 這個 function * 注意: action 除了 type 外，還要包含修改 state 所需要的資料 * 這個資料可能是索引或者要加入的資料 * */function todos (state = [], action) { switch (action.type) { case ADD_TODO: return [ ...state, action.todo ] // 處理不符合 action.type 的部分，一定要回傳 state default: return state }}export default rootReducer 記住! reducer 是一個純函式遵循著 (state, action) =&gt; newState 的結構規範，且不得在內部產生任何 side effect。簡單說 reducer 這個函式的工作就是把 state 和 action 當作參數傳入，回傳另外一個變更後的 state，這個 state 因為不能有 side effect 所以回傳的是另外一個全新的物件。 再次強調 (state, action) =&gt; newState 所以就算你傳入的 action 跟該 reducer 無關，你也要再把 state 傳回去。記住上面的表示式，非常重要。 action 只是一個聖旨記錄了要執行的事情，而 reducer 才是實際處理 state 的地方。 根據 reducer 所需，收斂整理出需要的資料，完善 action creator 和 action這一步會隨個人習慣有所差異，有人能夠在一開始就把 action 需要的資料都定義好，但對於反應較慢的小弟我來說反過來從 reducer 推回去比較直覺一點。 重點是 action 除了 action.type 即我們的任務之外還要包含處理這個任務所需要的資料。而剛剛的 reducer 我們先假定了有 action.todo，所以讓我們回到 src/actions.js 來完善他們 123456789101112/* file: src/actions.js */// Action Typeexport const ADD_TODO = 'ADD_TODO';// Action Creatorexport function addTodo(todo) { return { type: ADD_TODO, todo }} store 的建立與實際測試到了這一步，我們可以來釐清這些角色之間的關係與該如何使用，開啟 src/index.js ，刪去預設產生的程式碼，改寫如下 123456789101112131415161718/* file: src/index.js */// 匯入 action creator: addTodoimport {addTodo} from './actions'import { createStore } from 'redux'import rootReducer from './reducers'var store = createStore(rootReducer);var unsubscribe = store.subscribe(() =&gt; { console.log(store.getState())});console.log('Initial:', store.getState());store.dispatch(addTodo('Hello, Redux')); 相信到這邊你已經明白 redux 的流程是怎麼回事了。 先設計一個單純只負責呈現的 component這部分我們要開始參透 redux 如何和 react 搭配使用，我假設你已經很了解 react ，因為這篇文章訴求是說明概念，因此就不在檔案架構上做太多分類切割。 我們的這個 component 其實就只需要 一個 input 用來把資料丟進 todos 這個陣列 一個 button 觸發儲存的行為 一個 ul li 結構用來顯示 todos 當然下面這樣的做法在實務上不是很好，但希望可以協助你方便觀察理解角色之間的應用，所以我就把他們全部放在一個檔案裡。 開啟 src/App.js 編輯程式碼如下 1234567891011121314151617181920/* file: src/App.js */import React, { Component } from 'react';export default class App extends Component { render() { const {todos} = this.props; return ( &lt;div&gt; &lt;input type='text' ref='input' /&gt; &lt;button&gt;Add&lt;/button&gt; &lt;ul&gt; { todos.map((todo, index) =&gt; &lt;li key={index}&gt;{todo}&lt;/li&gt;) } &lt;/ul&gt; &lt;/div&gt; ); }} 測試 component為了方便觀察所以並沒有把剛剛測試 store 的程式碼移除，釐清角色之間的關係而後依據目錄拆分檔案會更有幫助： 1234567891011121314151617181920212223/* file: src/index.js */import { addTodo } from './actions'import { createStore } from 'redux'import rootReducer from './reducers'var store = createStore(rootReducer);import React from 'react'import { render } from 'react-dom'import App from './App'var unsubscribe = store.subscribe(() =&gt; { console.log(store.getState())});console.log('Initial:', store.getState());store.dispatch(addTodo('Hello, Redux'));render( &lt;App todos={['A', 'B']} /&gt;, document.getElementById('root')) 將 component 與 store 連線store 和我們的 component 並不會無緣無故自訂就關聯起來，可以見得的是我們需要一個介面或一個做法來將他們倆關聯起來，而要將 store 與我們的 component 連線我們就需要 react-redux。 1&gt; npm install react-redux -S 接著在 src/index.js 完成程式碼如下 123456789101112131415161718192021222324252627/* file: src/index.js */import React from 'react'import { render } from 'react-dom'import { addTodo } from './actions'import { createStore } from 'redux'import App from './App'import rootReducer from './reducers'// 匯入 Providerimport { Provider } from 'react-redux'var store = createStore(rootReducer);var unsubscribe = store.subscribe(() =&gt; { console.log(store.getState())});console.log('Initial:', store.getState());store.dispatch(addTodo('Hello, Redux'));render( &lt;Provider store={store}&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')) 看看上面的程式碼是不是很容易聯想到我們以前從資料庫取資料的流程，我們會需要針對特定的資料庫例如 MySQL, PostgreSQL 的 provider 函式庫，而在 redux 我們則是透過 Provider 這個方式提供一個介面讓我們的 component 能夠和 store 連線上，而實際上該如何使用還是得靠元件內部來實作。 最後實作 App 內部123456789101112131415161718192021222324252627282930/* file: src/App.js */import React, { Component } from 'react'import {connect} from 'react-redux'import {addTodo} from './actions'class App extends Component { render() { var {dispatch, todos } = this.props; return ( &lt;div&gt; &lt;input type='text' ref='input'/&gt; &lt;button onClick={(e) =&gt; dispatch(addTodo(this.refs.input.value))}&gt; Add &lt;/button&gt; &lt;ul&gt; { todos.map((todo, index) =&gt; &lt;li key={index}&gt;{todo}&lt;/li&gt;) } &lt;/ul&gt; &lt;/div&gt; ); }}function select (state) { return state;}export default connect(select)(App); select 和 connect 是什麼？connect 的用途概念上比較容易理解，我們已經有 Provider 了，但我們還是需要主動去連線。而 select 如果你用資料庫的概念來想也就非常清楚了，雖然我有一個資料庫但我並不總是要全部的資料，透過 select 可以讓我們選取我們要的部分就好。但是在上面的範例我們是全取。 總結如此我們已經走完了一遍最基礎的部分，也對各角色有了概念上的理解，這和實際原理其實有些落差。不過在學習的過程中我希望提供另一個角度的看法。當然小弟很清楚這篇文章還有很多有缺失的地方，所以才會建議當你對 redux 的掌握度有些許的進步之後一定要回頭看看官方的教學。 針對 App 的功能操作列出需要的 action type 根據 action type 實作 action creator 與定義回傳的 action，記住 reducer 需要的資料只能從這來 先構思完整的 state 結構，盡可能保持一階的結構類似資料庫正規劃 針對資料的處理 root reducer 和 reducer 透過 combineReducers() 組合 state 與對應的 reducer，概念上類似於資料庫的 Table 列表 一個 reducer 純函式 (state, action) =&gt; newState 是針對 state 撰寫處理狀態修改的邏輯 每一個 reducer 都需要針對未知的動作類型(action.type)做處理，無論如何都要傳回 state 透過 createStore(reducer) 建立一個 store。 透過 react-redux 的 Provider 來把 store 與 component 關聯起來 component 內部透過 connect 連線並取得資料，搭配 select (只是一個 filter 的 function) 資源 官方教學 繁體中文版 介紹 Redux 卡通版","link":"/2016/01/04/redux/"},{"title":"[譯] 透過重新實作來學習參透閉包","text":"原文出處: 連結 話說網路上有很多文章在探討閉包(Closures)時大多都是簡單的帶過。大多的都將閉包的定義濃縮成一句簡單的解釋，那就是一個閉包是一個函數能夠保留其建立時的執行環境。不過到底是怎麼保留的？ 另外為什麼一個閉包可以一直使用區域變數，即便這些變數在該 scope 內已經不存在了？ 為了解開閉包的神秘面紗，我們將要假裝 Javascript 沒有閉包這東西而且也不能夠用嵌套 function 來重新實作閉包。這麼做我們將會發現閉包真實的本質是什麼以及在底層到底是怎麼運作的。 為了這個練習我們同時也需要假裝 Javascript 本身具備了另一個不存在的功能。那就是一個原始的物件當它如果被當成 function 調用的時候是可以執行的。你可能已經在其他語言中看過這個功能，在 Python 中你可以定義一個 __call__ 方法，在 PHP 則有一個特殊的方法叫 __invoke這些方法(Method)會在當物件被當作 function 調用時執行。如果我們假裝 Javascript 也有這個功能，我們可能需要這麼實作: 1234567891011let o = { n: 42, __call__() { return this.n; }};// 當我們把物件當作 function 一樣調用時o(); // 42, 當然現在你會得到 `TypeError: o is not a function` 的錯誤// 譯者註: 之後遇到這種呼叫的情況，請使用 o.__call__() 這邊我們得到一個普通的物件，我們假裝我們可以把它當做 function 來呼叫，然後當我們這個做的同時其實我們是執行一個特殊的方法 __call__ 如果你真的要實作記得用 o.__call__()。 譯者註: 注意! 呼叫 可調用物件 例如上面的 o() 都要換成 o.__call__() 假如您想實作的時候。 現在讓我們先來看看一個簡單的閉包範例。 1234567891011121314151617181920function f() { // 下面這個變數是 f() 的區域變數 // 通常，當我們離開 f 的 scope 時，這個變數 n 就應該要被回收了 let n = 42; // 嵌套的 function 參考了 n function g() { return n; } return g;}// 讓我們透過 f() 來建立一個 g 函數let g = f();// 理論上這個變數 n 在 f() 執行完畢之後就應該要立即被回收，對吧？// 畢竟 f 已經執行完畢了，而且我們也離開了該 scope// 那為什麼 g 可以繼續參考一個已經被釋放的變數呢？g(); // 42 外層的 function f 有一個區域變數，然後裡面的 function g 參考 f 的區域變數。 接著我們把內層的 g 回傳指派給 f scope 外的變數。但我們好奇的是如果 f 執行完畢被釋放了，那為什麼 g 仍然可以取得已被釋放的 f 的區域變數呢？ 這個的魔法便是 - 一個閉包不僅僅只是一個 function。它是一個物件，具有建構子和私有資料。然後我們可以它當作 function 來使用。那如果 Javascript 沒有閉包這種用法，我們必須自己實作它呢？這就是我們接下來要看到的。 12345678910111213141516171819202122232425262728class G { constructor(n) { this._n = n } __call__() { return this._n; }}function f() { let n = 42; // 這就是一個閉包 // 這個內層的 function 其實不只是一個 function // 它其實是一個可以被調用的物件，然後我們傳入 n 到它的建構子 let g = new G(n); return g;}// 透過呼叫 f() 取得一個可以被調用的物件 glet g = f();// 現在就算原來從 f 拿到的區域變數 n 被回收了也沒關係// 可被調用的物件 g 實際上是參考自己私有的資料g(); // 42 如果您曾看過 ECMAScript 規範，可能會對實際上是參考自己私有的資料這句話產生一些疑問，先別急著否定。這邊不過是試著用另外一個較淺的角度解釋。 這邊我們把內部的 function g 用一個 G class 的實例物件(即 new 出來的物件) 取代，然後我們透過把 f 的區域變數 n 傳進 G 的建構子，藉此將變數儲存在新的實例物件私有的資料中。最終我們可以取得 f 的區域變數(n)。 OK! 各位觀眾這就是一個閉包的行為。閉包就是一個可調用的物件，可以把透過建構子把傳入的參數保留在私有的空間中。 更深入的問題？聰明的讀者已經發現還有一些行為我們還沒解釋清楚或者說我們的模擬實作是有漏洞的。讓我們來觀察其他的閉包範例 1234567891011121314151617181920function f() { let n = 42; // 內部函數取得變數 n function get() { return n; } // 另外一個內部函數也同時存取 n function next() { return n++; } return { get, next };}let o = f();o.get(); // 42o.next();o.get(); // 43 在這個範例中，我們得到兩個閉包同時參考變數 n 。其中一個函數的操作變數會影響另外一個變數取得得值。但如果 Javascript 沒有閉包，單靠我們上面的實作行為將不會一樣。 1234567891011121314151617181920212223242526272829303132333435class Get { constructor(n) { this._n = n; } __call__() { return this._n; }}class Next { constructor(n) { this._n = n; } __call__() { this._n++; }}function f() { let n = 42; // 這邊的閉包我們一樣換成可調用的物件 // 它們可以將參數傳入建構子，進而將值保留起來 let get = new Get(n); let next = new Next(n); return { get, next };}let o = f();o.get(); // 42o.next();o.get(); // 42 跟上面一樣，我們取代了內部 function get 和 next 的部分改成使用物件。它們是透過將值保留在物件內部進而取得 f 的區域變數，每一個物件具有自己私有的資料。同時我們也注意到其中一個可調用物件 操作 n 並不會影響另外一個。這是因為它們是傳 n 的值 value而不是傳址 reference。白話文就是複製了一分資料。並不是操作變數本身。 為了要解釋為什麼 Javascript 的閉包會參考到相同的 n 即記憶體位置是一樣的。我們需要解釋變數本身。在底層，Javascript 的區域變數跟我們從其他語言理解的觀念並不相同，它們是負責動態分配與計算參考(reference)的物件的屬性，稱為 LexicalEnvironment 物件。Javascript 的閉包其實會有一個參考指向到整個 執行環境, 上下文, Context 的 LexicalEnvironment 物件，而不是特定的變數。 如果您對於 scope 與 context 還不是很了解強烈建議您觀賞這篇 讓我們來修改我們的可調用物件讓其可以取得一個 lexical environment 而不是 n 。 1234567891011121314151617181920212223242526272829303132333435363738class Get { constructor(lexicalEnvironment) { this._lexicalEnvironment = lexicalEnvironment; } __call__() { return this._lexicalEnvironment.n; }}class Next { constructor(lexicalEnvironment) { this._lexicalEnvironment = lexicalEnvironment; } __call__() { this._lexicalEnvironment.n++; }}function f() { let lexicalEnvironment = { n: 42 } // 現在這個可調用變數是透過一個參考 lexical environment 來改變 n // 所以現在變更的是同一個 n 了 let get = new Get(lexicalEnvironment); let next = new Next(lexicalEnvironment); return { get, next }}// 現在我們實作的物件行為跟 javascript 一致了// 還是請注意如果您要時作，記得 o.get() 要換成 o.get.__call__() 喔let o = f();o.get(); // 42o.next();o.get(); // 43 上面實作我們將區域變數 n 換成 lexicalEnvironment 物件，然後具有一個屬性 n 。這時 Get 和 Next 的物件實例所存取的便是同一個參考(reference)即 lexical environment 物件。所以現在修改的就是相同的地方了。基本上這就是一個閉包的行為。 結論閉包是一個物件而且當它們是函數時我們可以直接調用。而事實上任何一個 Javascript 中的函數都是一個可被調用的物件也稱作 function object 或者 functor 當它們被執行或者說被實例化時會帶有一個私有的 lexical environment 物件。而想要更了解關於這個物件的看官們可以參考Lexical environment。在 Javascript 不是 function 創造閉包，function 本身就是一個閉包。 老實說譯者本身還是比較喜歡理解 context 與 variable object 的說明，接著用 一個閉包是一個函數能夠保留其建立時的執行環境 這句話來記憶。不過原作者從這個角度來解釋的確是可以概略的理解整個運作機制，希望這篇文章能讓你有所收穫。","link":"/2016/02/23/master-closure/"},{"title":"開發時期，CarrierWave 重產不同 version 圖片","text":"當增加不同 version 的尺寸需要對已上傳的圖片從新產生新尺寸的圖片時 1&gt; rails c 輸入 1234Attachment.all.each do |att| att.image.recreate_versions! att.save!end","link":"/2016/02/23/carrierwave-recreate-version/"},{"title":"關於 delete 變數詭異行為與解釋","text":"問題發生在當我們撰寫下面程式碼的時候所發現的奇怪行為。 123456789101112131415161718var a = 1;b = 2;console.log(a); // 1console.log(b); // 2// 使用瀏覽器測試請使用 window 如果是用 node 的 REPL 環境那請改成 globalconsole.log(window.a); // 1console.log(window.b); // 2// 但接下來這麼操作delete a; // false 不能刪delete b; // true 可以刪a; // 1b; // undefined 解釋首先根據ECMA-262 §10.3,的定義 Variable environment 是一種特定型別的 Lexical environment，我們沒辦法透過任何方式直接存取。 一個 Lexical environment 用來記錄執行環境的資訊，可以把它想成是一個物件，我們會把在一個執行環境 Context的變數，函數都存在這個物件的屬性上針對函數那些定義的參數(Parameter)也會被記錄，舉例來說 function foo (a, b)() 中的 a 和 b 就會被記在 foo 的執行環境資訊中。 一個 Lexical environment 也有一個連結可以連結到外在的 Lexical environment 就是所謂的 scope chain。這個機制可以協助我們取得目前執行環境以外的變數，舉例來說就是 function 裡面可以拿到 global 的變數。 一個 Variable environment 就只是 Lexical environment 的一部份，本質上就是透過 var 宣告在執行環境中的變數或函數。 使用了 var上面的 a 使用了 var 根據 ECMAScript 定義會被記錄在 Variable environment 根據定義 Variable environment 是不能手動刪除的。也就是說除非用了 eavl，否則是不能被 delete 的。 1234567var a = 1;delete a; // falseconsole.log(a); // 1// 記得清除整個環境eval('var a = 1; delete a; console.log(a)'); // undefined 沒使用 var當我們賦值卻沒有用 var，Javascript 會嘗試在 Lexical environment 尋找同名的參考。最大的不同是 Lexical environment 是嵌套的，就是它可以關聯到外面其他的 Lexical environment。當在本地找不到的時候就會往上層去找，換句話說每個 Lexical environment 都有個爸爸，而最外層的就是 global所以當我們不使用 var 而宣告一個變數時會開始在各個 scope 尋找同名變數，最終 Javascript 會拿一個 window(global) 的屬性來當作參考。而物件的屬性是可以刪除的。 結論就是第一個 var 的變數被放在 Variable environment 是不能 delete 的而第二個沒有 var 的變數它是 global 的屬性。 然後你就會問我，那為什麼第一個 a 可以用 window.a 取得，因為全域的 variable object 就是 global(window) 本身。但誰是屬性誰放在variable environment是有差的，因為程式碼看起來沒差所以會搞死人啊。","link":"/2016/02/25/variable-delete-operate/"},{"title":"[譯] CSS 載入的未來","text":"這週閱讀到這篇有意思的文章，於是便動手寫下間單的翻譯，如果有理解錯誤的地方歡迎指教。 Chrome 正在試圖改變當 &lt;link rel=&quot;stylesheet&quot;&gt; 寫在 &lt;body&gt; 的行為，從 blink-dev 的文章並不能很清楚的知道其優點。所以這篇文章想要深入的介紹這點。 blink 是 Chrome 和 Opera 渲染引擎，而 blink-dev 是其開發社群 目前的 CSS 載入機制123456&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/all-of-my-styles.css&quot;&gt;&lt;/head&gt;&lt;body&gt; …content…&lt;/body&gt; 當 CSS 段落在渲染時，會讓使用者瞪著白白的頁面直到 all-of-my-styles.css 完全下載完畢。 通常我們會把站內所有的 CSS 封裝成較少，可能只有一兩個資源檔，但這同時也意味著使用者需要下載大量的樣式設定(CSS Rules)卻沒有在該頁面使用。因為一個網站包含著各種不同的頁面與元件，而這些東西需要套用不同的樣式規則，如果因此分拆成許多檔案而產生大量的請求 request 這在 HTTP/1 是非常耗效能的。 不過在 SPDY 和 HTTP/2 卻不是這樣，傳輸許多分散的小資源只會增加一點點的開銷，並且這些東西可以個別暫存(cached)。 12345678910&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/site-header.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/article.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/comment.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/about-me.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/site-footer.css&quot;&gt;&lt;/head&gt;&lt;body&gt; content&lt;/body&gt; 這樣一來就解決了許多問題，我們可以拆成很多小檔案個別載入，不過也意味著當我們在 &lt;head&gt; 下 &lt;link&gt; 時，得要知道這些頁面各自需要哪些資源。另外，瀏覽器在開始輸出之前，仍然得下載所有的 CSS。如果出現一個下載比較慢的 CSS 例如 /site-footer.css將會造成渲染的東西延遲。請觀察範例。 現階段載入 CSS 較先進的機制123456789101112131415161718192021222324&lt;head&gt; &lt;script&gt; // https://github.com/filamentgroup/loadCSS !function(e){&quot;use strict&quot; var n=function(n,t,o){function i(e){return f.body?e():void setTimeout(function(){i(e)})}var d,r,a,l,f=e.document,s=f.createElement(&quot;link&quot;),u=o||&quot;all&quot; return t?d=t:(r=(f.body||f.getElementsByTagName(&quot;head&quot;)[0]).childNodes,d=r[r.length-1]),a=f.styleSheets,s.rel=&quot;stylesheet&quot;,s.href=n,s.media=&quot;only x&quot;,i(function(){d.parentNode.insertBefore(s,t?d:d.nextSibling)}),l=function(e){for(var n=s.href,t=a.length;t--;)if(a[t].href===n)return e() setTimeout(function(){l(e)})},s.addEventListener&amp;&amp;s.addEventListener(&quot;load&quot;,function(){this.media=u}),s.onloadcssdefined=l,l(function(){s.media!==u&amp;&amp;(s.media=u)}),s} &quot;undefined&quot;!=typeof exports?exports.loadCSS=n:e.loadCSS=n}(&quot;undefined&quot;!=typeof global?global:this) &lt;/script&gt; &lt;style&gt; /* The styles for the site header, plus: */ .main-article, .comments, .about-me, footer { display: none; } &lt;/style&gt; &lt;script&gt; loadCSS(&quot;/the-rest-of-the-styles.css&quot;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; 上面程式碼，我們有一些內嵌的樣式(inline style)來讓我們可以快速的渲染初始化的樣式，接著把那些還沒取得樣式的部分隱藏起來，然後開始透過 Javascript 非同步下載剩餘的樣式。這些剩餘的 CSS會覆寫掉在 .main-article 和其他選擇器內的 display: none。 這種第一次先快速的初始化渲染，然後持續匯入的方法是許多效能專家所推薦的。 為 CSS 傳送進行最佳化處理 How we make RWD sites load fast as heck Optimizing the Critical Rendering Path 看看範例 原作者實作了wiki-offline並將狀況紀錄如下圖 上面這張圖片是在 3G 的環境下測試。 不過這樣的方法還是有些不足的地方: 需要一個輕量的 Javascript 函式庫不幸的，因為 WebKit 的實作。當 &lt;link rel=&quot;stylesheet&quot;&gt; 一被加到頁面時，WebKit 會阻塞渲染(render)，直到樣式都被載入，即使這個樣式是透過 Javascript 加入的。 在 Firefox 和 IE/Edge，透過 JS 加入的樣式完全是非同步載入。Chrome 當前穩定版本然仍是遵循WebKit 的行為，不過在 Canary 已經跟 Firefox/Edge 一樣了。 載入流程被限制在兩個階段(Inline css and A css file)根據上面的模式，內嵌 CSS(inline CSS) 透過 display: none 隱藏尚未套用樣式的內容，然後非同步得載入 CSS 之後呈現內容。如果您需要增加多個 CSS 檔案那麼結果可能就是內容不按順序出現 檢視範例 如果內容還在異動的過程結果周圍的廣告就先出現這通常會讓使用者覺得不開心就關閉你的網站了。 因此被限制在只有兩個載入階段，你必須要決定哪些是第一次渲染時就要出現，哪些是比較晚的。當然，你希望上方的區塊越快顯示越好，不過所謂”上方的區塊”取決於 viewport 可視區域的大小。最後你可能決定定義一個尺寸範圍套用在所有人身上。 如果你想讓事情更加複雜，當然你可以選擇客製 CSS 相依屬性來建立 CSS 之間渲染的相依性 更簡單，更好的方式12345678910111213141516171819&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- HTTP/2 push this resource, or inline it, whichever's faster --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/site-header.css&quot;&gt; &lt;header&gt;…&lt;/header&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/article.css&quot;&gt; &lt;main&gt;…&lt;/main&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/comment.css&quot;&gt; &lt;section class=&quot;comments&quot;&gt;…&lt;/section&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/about-me.css&quot;&gt; &lt;section class=&quot;about-me&quot;&gt;…&lt;/section&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/site-footer.css&quot;&gt; &lt;footer&gt;…&lt;/footer&gt;&lt;/body&gt; 這個概念是透過每一個 &lt;link rel=&quot;stylesheet&quot;&gt; 在其下載樣式時去阻塞跟在後面的內容，但允許前面的內容先開始渲染。樣式表(CSS)本身的載入機制是平行的，但是套用樣式卻是要照順序的。這讓 &lt;link rel=&quot;stylesheet&quot;&gt; 的行為類似為 &lt;script&gt; 假設說 site-header, article, footer 的樣式已經載完了，但剩下的還沒，其行為如下： Header: 已輸出 Article: 已輸出 Comments: 未呈現，在該標籤之前地 CSS 還沒載完(./comment.css) About me: 未呈現，在該標籤之前地 CSS 還沒載完(./comment.css) Footer: 未呈現，在該標籤之前地 CSS 還沒載完(./comment.css)，即使自己的 CSS 已經載完了 這讓我們可以照順序輸出頁面。您甚至不需要決定哪些是”上面的區塊”，只要在元件之前匯入元件需要的 CSS 即可。 不過你還是需要注意當使用內容決定佈局(layout system)，例如 table, flexbox 時，在載入期間應避免內容異動。這不是現在才產生的問題了，只是在逐步顯示這種機制之下更常遇到。如果你看不懂這段在描述什麼看一下下面的影片就知道了。 意思是說雖然 flexbox 已經很不錯了，但 Grid 還是更推薦的 Layout system。 Chrome 的改變HTML規範並不涵蓋網頁渲染時是否應該或該如何被 CSS 阻塞，並且也不鼓勵把 &lt;link rel=&quot;stylesheet&quot;&gt; 寫在 body 中，不過所有瀏覽器都允許這麼做。 當然他們也都各自使用了自己的方式處理在 body 中的 &lt;link&gt; Chrome &amp; Safari: 一旦發現 &lt;link rel=&quot;stylesheet&quot;&gt; 就停止渲染(render)，直到發現的樣式被載入完畢。往往導致在 &lt;link&gt; 上面還未渲染的內容被卡住。 Firefox: &lt;link rel=&quot;stylesheet&quot;&gt; 在 &lt;head&gt; 中會阻塞渲染直到所有發現的樣式都被載入完畢。在 body 中的話不會阻塞渲染，除非 head 裡已經有樣式阻塞住這可能會導致 FOUC (Flash of unstyled content) ，就是畫面先以預設的樣子呈現後閃一下才套上樣式。 IE/Edge: 中斷分析器直到樣式載完，不過允許 &lt;link&gt; 上面的內容渲染(render)。 我們偏好像 IE/Edge 的行為，所以 Chrome 將會跟隨這樣的機制。目前 Chrome/Safari 的行為就只是會卡比較久的時間，Firefox 的行為相對較複雜一些，不過有一些小技巧。 Firefox 處理方式因為 Firefox 不會因為 body 中的 &lt;link&gt; 阻塞渲染。我們需要一點小技巧來避免 FOUC。幸虧有個非常簡單的方式就是透過 &lt;script&gt; 中斷解析器讓他等一等待處理狀態的樣式 12&lt;link rel=&quot;stylesheet&quot; href=&quot;/article.css&quot;&gt;&lt;script&gt; &lt;/script&gt;&lt;main&gt;…&lt;/main&gt; 這個標籤不能完全沒有內容，所以我們需要留一個”空白”。 實際執行的結果查閱範例 Firefox 和 Edge/IE 將會循序的載入輸出，而 Chrome 和 Safari 則是先看到空白的頁面一陣子直到CSS 全部載完。目前 Chrome/Safari 的行為比起把樣式連結放在 &lt;head&gt; 也沒有差到哪去，所以現在就可以開始使用這個方式，很快的 Chrome 將會往 Edge 的機制修正，這麼一來渲染會更加迅速。 以上就是一個簡單的技巧協助我們加快速度並逐步載入 CSS","link":"/2016/02/18/future-of-loading-css/"},{"title":"Vue.js in Slim 語法的小問題 Slim::Parser::SyntaxError","text":"當我們使用 Vue.js 搭配 slim 時(事實上 Angular 應該也有相同的問題)時 12345678910div id=&quot;app&quot; p {{message}}javascript: new Vue({ el: '#app', data: { message: &quot;Hello, Vue.js&quot; } }) 立馬收到Slim::Parser::SyntaxError的錯誤訊息。 但是改成這樣卻又正常 1div id=&quot;app&quot; {{ message }} 好啦！答案很明顯了就是我們有地方寫錯，讓 slim engine 誤會了。 這邊紀錄一下解法： 補上屬性第一個最簡單的方式就是幫 p 補上隨意一個屬性 12345678910div id=&quot;app&quot; p class=&quot;&quot; {{ message }}javascript: new Vue({ el: '#app', data: { message: 'Hello Vue.js', } }) 加上 [], (), {} 任何一種12345678910div id=&quot;app&quot; p () {{ message }}javascript: new Vue({ el: '#app', data: { message: 'Hello Vue.js', } }) 使用 |1234567891011div id=&quot;app&quot; p | {{ message }}javascript: new Vue({ el: '#app', data: { message: 'Hello Vue.js', } }) 修改設定上面的解法都是因為 slim 預設會把 {} () [] 和 tag 後面接的 property=value 當作屬性(attributes)來解析。所以我們只要把 {} 拿掉就正常了。 新增或修改 config/initializers/slim.rb 加入 1Slim::Engine.set_options :attr_list_delims =&gt; {'(' =&gt; ')', '[' =&gt; ']'}","link":"/2016/02/25/vue-in-slim-delims-problem/"},{"title":"Javascript 三種宣告的差異","text":"關於下面這三種宣告的差異 123var a = 0;a = 0;window.a = 0; var a = 0;當我們在全域使用這樣的宣告時，就是替 global execution context 在 variable object 中建立一個變數。在瀏覽器中這個 variable object 同時有個別名叫做 window 並且它是一個 DOM 是 window 物件而不只是一般的物件。(在一般非瀏覽器的實作這可能是對的)。上面這個 var a = 0 的結果就是你在 window 中建立了一個屬性 a 且不能刪除。它同時也在第一行程式執行之前被定義，注意在 IE8 之前在 window 建立的屬性並不屬於 enumerable 意思是你不能用 for..in 去遍歷。在 IE9, Chrome, Firefox, Opera 這些屬性是 enumerable 的。 12345678910111213141516171819var car = { name: 'Lexus RX200t' };// 測試 toString 是否存在物件中console.log('toString' in car); // trueconsole.log(typeof car.toString); // function// 但，當我們用 for..in 卻看不到for (var k in car) { console.log(k); // 只有 &quot;name&quot; 輸出}// 一個屬性是否是 enumerable 要看物件本身的 enumerable 屬性設定// 我們可以透過 property descriptor 來觀察var d = Object.getOwnPropertyDescriptor(car, 'name');console.log(d.enumerable); // true// 要拿到所有能用的屬性則是 getOwnPropertyNamesconsole.log(Object.getOwnPropertyNames(Object.prototype)); 解釋 Enumerable a = 0在全域的情況下，隱含式的在 window 建立屬性。注意這並沒有在 variable object 建立變數，所以一個普通的屬性是可以被 delete 刪除的。強烈建議不要這麼做。這會導致您的程式產生疑義語意不清。 window.a = 0顯式的宣告一個 window 的屬性，同樣是可以刪除的。 進一步 this.a = 0 呢在全域的情況下，this 指向 window 所以這跟 window.a = 0 是一樣的 當 var 的時候，發生了什麼事當我們透過 var 定義了一個變數名稱(指的是 var n = 0，n 這個識別符號)，這個變數名稱會發生在任何程式碼執行之前詳細解釋請參考 12345678910111213console.log('foo' in window); // trueconsole.log(window.foo); // undefinedconsole.log('bar' in window); // falseconsole.log(window.bar); // undefinedvar foo = 'foo'; // 看懂上面有無記錄在 variable object 和單純 property 的差異了嗎？bar = 'bar';console.log('foo' in window); // trueconsole.log(window.foo); // fooconsole.log('bar' in window); // trueconsole.log(window.bar); // bar","link":"/2016/03/01/variables-differents/"},{"title":"重讀 Axel 的 Javascript 中的 Expression vs Statement 一文","text":"前言原文在此，對於 Axel 的文章一直有種雖然短卻難以讀透的感覺。這篇文章是再讀一次的翻譯搭配自己的理解說明，如有錯誤歡迎指教。 註: 下面一些範例當我們在瀏覽器 console 執行時，回傳值與程式執行的順序在 Chrome 與 Firefox 會有差別。注意一下箭頭符號就知道哪個是 return 了。例如 12345678910&gt; function foo () {console.log('foo');}&gt; foo();// 在 Chrome 是fooundefined// 在 Firefox 是undefinedfoo 1. Statements 述句和 Expressions 表達式一直以來，在讀技術文章的時候您一定不陌生這兩個詞，因為小弟過去對於這種細枝末節並不是很重視，加上計算機背景又不深厚。所以對於一些文章和概念的掌握度一直不是很精確。這次重讀一遍 Axel 的文章，希望能夠對 javascript 有更深入的理解。 事實上，在 javascript 中能夠清楚的分辨 expressions 和 statements 的差異對於撰寫程式碼是有一定的幫助，可以避免掉入一些陷阱。 簡單來說一個表達式 expressions 會產生一個值，我們會在撰寫它的地方期望得到一個值。舉例來說像是調用 function 中的引數(arguments)，或者指定式 = 的右邊都屬於 expressions 的位置。 參數(parameters)，引數(arguments) parameters 即在 function 中定義必須在呼叫程序時傳遞，可以用來取值的符號(變數名稱) arguments 是實際呼叫時，傳入的值 下面的每一行都是一個 expression： 123myvar100 + xfn(&quot;a&quot;, &quot;b&quot;) 而大體來說述句 statements 即執行動作，完成特定任務。賦值，迴圈和 if 述句都是 statements 的例子。在我們實際撰寫的程式碼中到底是怎麼區分的呢？讓我們看看 MDN 上定義的 if 述句 1234if (condition) statement1[else statement2] 要明白這些事情我們得先從 syntax 開始講起，基本上程式是透過一系列規定好的語法組成，稱為 syntax ，它類似於我們人類語言中的文法，不管是中文還是英文。一個程式要遵循著 syntax 並且由一系列 statements 組成的。 javascript 直譯器在解析程式碼時對於語法結構，即這些程式碼出現的位置會有對應的處理方式。 另外，拿上面的例子來說，任何 javascript 預期會有 statements 的地方你都可以使用 expressions，例如在 statement1 的地方呼叫一個 function。這個 function 就稱作 expression statement 屬於一種特殊的 statement ，這個 function 自然可以 return 一個值，同時也可以在內部產生一些 side effect，不過如果我們重點擺在一些 side effect 部分時，通常就會回傳 undefined。如下圖 通常一個 statement 是獨立的，只會完成某項任務，不過如果它影響了整個程式例如: 異動了機器內部的狀態，或者影響後面的 statement，這些造成的改變我們就稱為 side effect (副作用) 反過來，我們不可以在預期是 expression 的地方換成 statement。例如我們不可以在 function 的引數的地方改成 if 述句。 歸納一下關係如下： syntax statements expression statements expressions 2. statements 與 expressions讓我們看一下這兩段類似功能的程式碼，我們可能會更加清楚它們之間的分別。 if 條件式語句和條件運算子(三元運算子)123456var x;if (y &gt;= 0) { x = y;} else { x = -y;} 上面這幾句程式碼無疑都是 statements，另外 expression 也有個對應的寫法和上面這段程式碼完全等價 1var x = (y &gt;= 0 ? y : -y); 在等號和分號之間的就是一個 expression，其中的 () 不是必須的，但加上去比較容易閱讀。 分號; 與 逗號,在 javascript 中 statement 之間我們可以用 ; 分號來區分和串連。 1foo(); bar() 而 expression 也有一個鮮為人知的 , 運算子可以用來串連。 1foo(), bar() 兩個 expression 都會執行，但是返回最後面的。 123456$ 'a', 'b''b'$ var x = ('x', 'y')$ x'y' 3. 容易產生誤會的 expressions (看起來像 statements)有些 expressions 看起來像是 statements。下面我們會列出一些容易產生疑義的例子逐一討論。主要是因為它們會因為不同的位置產生不同的行為。 物件實字(Object Literal)與程式碼區塊(Block)下面這段範例是一個物件實字，屬於 expression ，用來產生一個物件 123{ foo: bar(3, 5)} Object Literal 是一個透過 {} 與 , 逗號分隔的鍵值對列表就是 var o = {name:'Object'} 這樣的寫法。 同時它還是一個符合規範的 statement，因為它具備了： block: 一段 statement 放在 {} 中 label: 我們可以在任何一段 statement 之前放上一個 label，在這邊 label 是 foo: statement: 一個 expression statement bar(3, 5) 所以 {} 到底是一個 block 還是物件實字，你可能會說是物件那讓我們來看看下面這個奇怪的例子 123456789101112131415161718192021222324252627282930313233343536373839404142// 在看這個奇怪的範例之前讓我們先看看一些 javascript 的行為// 當我們把非數字相加時&gt; 1 + 'string''1string'&gt; 1 + undefinedNaN&gt; 1 + null1&gt; 1 + [2,3,]&quot;12,3&quot;&gt; 1 + {name: 'andyyou'}&quot;1[object Object]&quot;// 上面的範例我們得知，除了 undefined 和 null，基本上 js 會把物件先 `toString()` 再相加。&gt; [].toString()&quot;&quot;&gt; [1, 2, 3].toString()&quot;1,2,3&quot;&gt; var o = {};&gt; o.toString();&quot;[object Object]&quot;// 有了上面的基礎知識之後，讓我們來看看這令人嚇尿的行為&gt; [] + {}&quot;[object Object]&quot;// 好！這題如我們所料，[] 產生 &quot;&quot; 加上 {} 產生 &quot;[object Object]&quot;// 先問你個問題: + 兩邊的運算元能不能互換而結果不變// 你可能回答: 是！！！// 但....&gt; {} + []0 上面程式碼最後一句的 {} 是一個 block 所以執行完之後接 +[]。 12&gt; +[]0 嚇尿了吧！除了 if, 迴圈外 javascript 也具有獨立的 block。下面這段程式碼說明了 label 和 block 的用法: 12345678function test (printTwo) { printing: { console.log('One'); if (!printTow) break printing; console.log('Two'); } console.log('Three');} 執行的結果 12345678&gt; test(false)&quot;One&quot;&quot;Three&quot;&gt; test(true)&quot;One&quot;&quot;Two&quot;&quot;Three&quot; 從上面驗證了 {} 的語法如果遇到 statements 的位置，就會被當成 statements，而如果在 expressions 的位置就會被當解析成一個值。 1234567&gt; {} + [];// 就是一個最好的例子，{} 被當作 statement 就是一個 block// 如果換成&gt; var x = {};// 那他就是一個 expression 代表一個值 - 一個物件 讓我們接著看下一個例子。 Function expression 與 function 宣告下面的程式碼是一個 function expression 1function () {} 你也可以給 function expression 一個名稱 1function foo () {} 在當作 function expression 時上面的 function 名稱 foo 只存在在 function 內部能使用，舉例來說像是一個遞迴。你可能困惑了，我們到底在說啥？看看下面的例子，我們要說的是當 function 放在 statements 和 expressions 不同位置時的差異 1234var fn = function me(x) { return x &lt;= 1 ? 1 : x * me(x-1)} // = 等號右邊是一個 expression 的位置fn(10); // 3628800console.log(me); // ReferenceError: me is not defined 具名的 function expression 和函數宣告的寫法看起來是沒有區別的。但實際上這兩者的效果截然不同，function expression 產生一個值(一個 function)。函數宣告則產生一個行為，即建立一個變數，然後它的值是一個 function。而且只有 function expression 可以被立即調用，函數宣告不行。 從上面這幾點看來能夠區分 expression 和 statement 挺重要的。 4. 使用物件實字與 function expression 當作 statements我們已經看到有一些 expression 和 statement 語法上是沒有區別的。這意味著相同的程式碼會有不同行為取決於它出現在 expression 的位置或者是 statement 位置。為了防止產生疑義。javascript 會禁止 expression statement 使用 {} 或 function 開頭。 換句話說就是在 javascript 認定為 statement 的位置，使用了 expression 會變成 expression statement。這並不是 expression，所以產生一些特殊的狀況 {} 會被當作 block 解釋，function 開頭的語法會被當作函數定義。所你當你想要使用這兩者為開頭撰寫 expression statement 時，你可以放上 () 可以確保位於一個 expression 的位置。 這就是 statement 或者 expression 所延伸的問題，也可以說造成我們極度混亂的根源。讓我們來看看 eval 和立即調用函式： evaleval 會解析他的引數當做一句 statement。如果你希望 eval 回傳一個物件你就需要在物件實字外圍放上() 12345&gt; eval(&quot;{foo: 123}&quot;);123&gt; eval(&quot;({foo: 123})&quot;);{foo: 123} 下次再閱讀文件的時候是不是更有感覺了。 立即調用函式立即調用函式的部分 12(function () { return &quot;abc&quot; }())'abc' 如果你省略了 () 如下，你就會得到一個語法錯誤的訊息。function 宣告不可以匿名。 12function () { return &quot;abc&quot; }()SyntaxError: function statement requires a name 就算替 function 加上名稱還是噴錯 12function foo() { return &quot;abc&quot; }()SyntaxError: syntax error 因為函數宣告不能立即調用(IIFE)，不過除了使用 () 還有些技巧，當我們硬要要把某段程式當做 expression 執行時，可以使用一元運算子 + 或 !，不過和()的方式比起來這會影響回傳結果，如果你不在意的話這也是一種方式。 123&gt; +function () { console.log(&quot;hello&quot;) }()NaNhello 這個 NaN 是 + 遇上 undefined 的結果，喔！對了還有一種是透過 void 的方式 123&gt; void function () { console.log(&quot;hello&quot;) }()undefinedhello 連續使用立即調用函式當你在連續呼叫 IIFE 的時候必須要注意不要忘記分號 ; 結尾 123(function () {}())(function () {}())// TypeError: undefined is not a function 上面的程式碼會產生錯誤因為 javascript 以為第二行的 () 是要拿第一行產生的結果當作一個函數來呼叫。 123(function () {}());(function () {}())// OK 下面範例因為 javascript 自動補上分號的功能，使用一元運算子的話 ; 可以省略。 123void function () {}()void function () {}()// OK javascript 會自動補上分號是因為接在第一行之後的 void 並不是可以接下去的語句(符合規範能串在一起的寫法)。 另外關於 javascript 自動補上分號有幾項建議如下： 在 return，break，continue，++，– 五種 statement 中，換行字元可完全等於 ;。 var，if，do while，for，continue，break，return，with，switch，throw，try，debugger 關鍵字開頭，以及空的 statement，上一行會自動補上分號。 遇到 expression statement 和 function expression 情況非常複雜，後面請務必要加上分號。 凡 ( 和 [ 開頭的 statements 前面或上一句不加非常危險。 想要更深入明白 ASI，請參考。 總結 syntax : 語法(文法)，該怎麼組織 statements 與 expressions。 expressions : 會產生一個值，其意義就是代表一個值的表式例如 x + y。 statements : 完成某項任務的操作。賦值，條件判斷，宣告都算是 statements; if (condiction) { console.log('WoooW!') }。 expression statements : 屬於一種 statement，其產生一個值(或說回傳一個值)，並完成某項任務。例如：x += 1 或者在 statement 執行一個 side effect 的函數呼叫。 在 statements 位置放入 expressions 要小心(即 expression statement)，因為 javascript 對於 expression 和 expression statement 解釋行為是不一樣的。 下面這兩種語法對於其位置尤其需要注意 function statement 位置: 當作函數宣告，即建立一個變數它的值是一個 function。，不能立即調用。 expression 位置: 為 function expression 產生一個為 function 的值，可以被立即調用(IIFE)。 {} statement 位置: block 一個程式碼區塊，例如 for, label 的 block。 expression 位置: 物件實字，建立一個值 - 物件。","link":"/2016/03/06/expressions-vs-statements-in-js/"},{"title":"Cache 筆記","text":"瀏覽器 cache 是一種機制，透過特定狀態告知瀏覽器不需要重新下載檔案 cache 最早使用 Expires 和 Pragma，現今主要使用 Cache-Control 來控制 cache 大略流程，在實際下載檔案之前發生： cache 的實際處理機制存在瀏覽器中，也就是我們需要透過指令(cache-directives)告訴瀏覽器該怎麼處理 瀏覽器設定為不提供 cache ，完全忽略下面步驟直接請求資源 瀏覽器發送請求，此時可包含 cache-request-directive 這部分的資訊主要是拿來和 server 協商比對用的 伺服器判斷是否有更新並回傳通知 cache-response-directive 不需更新則回傳 304 Header 2 至 3 步驟用來判斷是否發出下載資源的請求，如果在 1 的狀況則發出請求，因為不帶任何 Date, Etag 資訊所以就會重新拉一份回來 常用 directives 列表 - Cache-Control no-store 完全不存 cache no-cache 會存 cache 但是每次重新請求 = 無視 cache max-age 判斷是否要重新請求檔案，在一定秒數之內不需要重新請求，除非遇上 max-stale private | public 判斷該使用者能否使用 max-stale 指定資源過期 must-revalidate 定義上類似 no-cache 但是更嚴格，會跟原始 server 比對而不是 proxy 。如果 max-stale 過期整份文件包含子請求都會更新。實際運作則是交由瀏覽器自行判斷是否更新。 s-maxage 用於 CDN 如果 max-age 也存在會覆寫 max-age 簡言之，除了瀏覽器直接關閉 cache 功能外，其他都需要和 server 端協商並透過 cache-directives 決定行為 除了 Cache-Control 還有 Date, Etag 驗證權杖, Last-modified 用來資訊判斷是否重新請求(現今多使用 Cache-Control) Etag - If-None-Match: [hash] Date(傳送), Last-modified(回覆) - If-Modified-Since Etag 格式分成寬鬆和嚴謹 12ETag: &quot;1234abcd&quot; 嚴謹ETag: W/&quot;1234abcd&quot; 寬鬆 在 client 端過期的資料本應要更新，但如果 server 端的資料也沒有更新，我們就沒有理由再去下載已存在於快取中相同的資料，因此 Etag 就是用來確認這件事 關於 Etag 我們唯一要做的就是確認 server 有提供此功能，之後 browser 會幫我們處理後續流程 1234567client --&gt; serverclient &lt;-- server Etag: 'x234dff' Cache-Control: max-age=120 單位是秒 ...client --&gt; server 拿著資料去 server 比對 CDNCDN 就是卡在 server 與 users 之間的另外的 server 我們將網址的 Name Server 指向 CDN。CDN 會到我們的 server cache 資料，協助我們管理 DNS &amp; Cache 的部分，也擋在我們服務之前所以偶而可以協助擋 DDoS A Beginner’s Guide to HTTP Cache Headers 淺談 cache - ★★★★★ 推薦 Google - HTTP 快取 Cache Control 與 ETag 初探 HTTP 1.1 Cache 機制 w3c 規範","link":"/2016/03/08/cache-notes/"},{"title":"line-height 問題筆記","text":"line-height 歸納 line-height 有五種屬性可用，預設是 normal 他會拿 font-size * 1.2 normal number ex: 1.2, 1.8 =&gt; 倍數 unit ex: 18px, 2em, 3rem, etc… percentage ex: 90% inherit =&gt; line-height from parent inline box12345containing-box line-boxes (會看一行中的 line-height 誰最高來決定，所有內容共用此水平垂直線) inline-box (影響高的設定：line-height, 中文每一個單`字`是一個 inline-box，英文的話則是一個 word 為一個 inline-box), (設定為 inline 的 tag) content-area (影響高的設定：font-size, 隱形的區塊，純文字沒有圖片的情況下 box-model 的高決定權在 line-height) character 影響 box 高度的規則只有 height 和 line-height，一個 tag 如果沒設 height 的話最後決定高度的一定是 line-height 要說 font-size 也是因為預設 line-height = font-size * 1.2 使用 inherit 時，用百分比效能較差，用數值最佳 font-size: 12px, line-height: 0 在只有文字的情況下，parent tag 不會被撐開，但是放入圖片就會被撐開。codepen 實現多行垂直置中外層包一個如下屬性的 container 即可 12line-height: [height];font-size: 0; 資源 MUKI - 深入 CSS 之 line-height 應用 深入常見 vertical-align 問題 css行高line-height的一些深入理解及应用","link":"/2016/03/08/line-height-notes/"},{"title":"[譯] Houdini: 你還沒聽說！這可能是 CSS 開發中最令人興奮的事！","text":"其實…我想說這可能是最令我感到興奮..但又害怕頭痛的功能… - 原文連結 你曾經想要使用某個 CSS 的新功能，但是最後卻因為這個功能瀏覽器還未全面支援而放棄了嗎？甚至更糟糕的狀況，瀏覽器已經支援了但卻充滿問題。我敢打賭這些情況你肯定遇過了。如果上面這種情形你曾經遇過，那麼你是應該關心一下 Houdini。 Houdini 是 w3c 新的任務團隊，他們的終極目標就是解決上面這些問題 - 讓瀏覽器更迅速廣泛的支援 CSS 新特性。這個計畫試圖透過提供一系列新的 API，也是第一次讓開發者可以擴充 CSS 本身的能力。透過 hook 的方式讓我們可以在瀏覽器渲染的過程動點手腳。 Hooks 簡易說明：Hooks 英文翻譯為鉤子，在程式術語中所表達的是在程式特定位置埋入一段預留的程式碼，用來呼叫其他對應的程式碼。可以大略想成在某個片段先空出一個位置，這個位置可以在事後再放入動作，不放也沒關係。 不過具體來說這到底是什麼意思？這麼做真的好嗎？還有這樣做到底能在我們的開發過程提供些什麼幫助。 在這篇文章，我將試著回答這些問題。不過在這之前我們必須要先搞清楚，到底我們在今時今日遇到什麼問題，為什麼我們需要做這些改變。接下來我們將會更具體的說明 Houdini 是什麼東西和這傢伙會怎麼解決這些問題，並且列出目前開發中一些令人興奮的功能。最後我將提供一些比較具體實例的說明。 Houdini 試圖要解決什麼問題？每一次當我寫了一篇文章來介紹一些 CSS 的新功能時總是會有人留言像是 這實在太棒了! 不過我們可能要再等個 10 年才能使用 我能體會這種毫無建設性的留言….從過往的歷史來看，這的確需要花上好幾年的時間從功能提案到廣泛採用。而其中最關鍵的原因是唯一讓 CSS 增加新功能的方式就是透過下面這個標準流程。 因為瀏覽器本身牽涉太廣泛，對於這樣的流程我本身沒有任何反對意見。當然我們也知道這會耗掉很長的時間。舉例來說 flexbox 首次提案是在 2009 年，而時至今日我們還是見到開發者在抱怨支援的瀏覽器不夠。這個問題正緩慢的解決中，因為幾乎所有的瀏覽器都會自動更新，不過即使是現代瀏覽器(Modern Browser)在功能提案到實際能使用該功能還是有一段挺長的時間。 有趣的是並不是所有 Web 領域的東西都處在這樣的情況，看看最近的 Javascript，為什麼 Javascript 可以發展如此迅速 從上圖這種流程，構想提案到實際用在產品上有時候只需要幾天的時間。例如：我已經在產品上使用了 async/await 的功能。這個功能甚至還沒有一個瀏覽器支援。 你還可以看到兩個社群截然不同的狀況，在 Javascript 社群你可以聽到人們開始在抱怨更新速度太快，而在 CSS 社群則多是看到一堆人在抱怨學那麼多東西沒用，還需要非常久的時間才能使用。 那為什麼我們不可以使用 CSS Polyfills？看完 Javascript 的流程第一個直覺的想法是那我們也來為 CSS 提供 Polyfills，聽起來可能蠻可行的，如果有 Polyfills 那麼 CSS 也可以像 Javascript 一樣快速的演進，不是嗎？可惜的是，這並不像想的那麼容易，用舊有技術實現新的功能或 API 在 CSS 中異常的困難，在大部分的情況下會整個犧牲掉效能。 Javascript 是一個動態語言，意味著我們相對容易用 Javascript 替 Javascript 補上 Polyfills。對 CSS 來說我們相對很少使用 CSS 來做 Polyfills。一般頂多就是使用轉譯器來產生 CSS 例如 PostCSS 就是這樣的東西。如果你想直接對 DOM 結構或者元素的 Layout，位置加上 Polyfills，那麼我們就必須要在客戶端執行對應的邏輯程式。 不幸的是瀏覽器對於這方面並不提供任何簡單的方式。 下圖我們簡單的歸納瀏覽器從收到 HTML 文件到顯示在螢幕上概略的流程。藍色區塊就是 Javascript 能夠控制結果的關鍵點 在上圖中我們認知到身為一個開發者，你對於瀏覽器解析 HTML 和 CSS 轉換成 DOM, CSSOM 的過程幾乎沒有控制權，尤其在瀏覽器對元素佈局以及渲染方面。唯一在這個過程中我們能夠掌握的就是 DOM 的存取，是不是該換 CSSOM 做些開放了。不過這邊先提一下 Houdini 網站上提到的改良 CSSOM的部分：確認跨瀏覽器行為不一致以及缺少關鍵功能的問題。 關於缺少關鍵功能部分，舉例來說，瀏覽器中的 CSSOM 並不會顯示跨站存取的樣式規則，而且會直接忽略那些它看不懂的樣式，這也意味著如果你想增加一個瀏覽器未支援的功能，你是不可以使用 CSSOM。反而要用 DOM 去找到 &lt;style&gt; 和 &lt;link rel=&quot;stylesheet&quot;&gt; 自己取得 CSS 然後解析再把它們補回 DOM。當然，更新 DOM 通常也表示瀏覽器必須要重新執行整個流程。 雖然整個流程重新渲染看起來並不會造成非常嚴重的效能問題，甚至這可能已經是常出現的情況，不過如果我們需要處理像是 scoll window resize mouse keyboard 這些事件，大量的更新次數可能就會很明顯地看出變慢了。更慘的是當你發現大部分的 CSS Polyfills 都有它們自己的解析方式和套用邏輯，而解析和套用是非常複雜的事情，導致這些 polyfills 通常不是很肥就是容易出錯。 總結上述所說的就是，現階段如果你想要瀏覽器對於呈現做些不同的行為那麼你就必須要靠 DOM 去調整。 但，為什麼我需要修改瀏覽器內部的渲染引擎？對我來說，這絕對是能夠回答整篇文章最關鍵的問題。如果你已經看到這邊，請仔細的閱讀這個部分! 看到這邊我很肯定有一部份的人會想：我根本不需要這個。我只是建置一個一般的網頁，我不會想去對瀏覽器內部動手腳。如果你是這麼想的，那麼我強烈建議你先停一下，去檢查過去你已經用在開發中的那些技術。對瀏覽器套用樣式的流程取得一些存取權限和 hooks 並不是只為了創造一些很屌的火力展示 - 這主要是希望給開發者和框架作者有更多的解決方案，功能去完成下面這兩件事： 統一跨瀏覽器樣式的不同行為 開發新功能或者解決相容性問題 - 補上新功能的 polyfills ，讓我們可以快點使用到這些新技術 如果你曾使用過像是 jQuery 這類的函式庫，你已經受惠於這種功能！事實上，這也是現今大多數前端框架或函式庫的主要賣點。Github 上 5 個流行的 Javascript 專案 - AngularJS, D3, jQuery, React, Ember 都處理了很多跨瀏覽器不同行為的問題。 不過上面說的是 Javascript 的部分，現在讓我們來想想關於 CSS 和所有跨瀏覽器的問題。即便是最流行的 CSS Framework 像 Bootstrap，Fundation 也聲明跨瀏覽器相容性的問題他們並沒有完全處理 - 只是避開那些問題。跨瀏覽器 CSS 的 bug 不只在過去存在，即使是今天也還存在像是 [flexbox` 的問題](https://github.com/philipwalton/flexbugs)。 想像一下如果任何 CSS 的樣式規則可以確保在任何瀏覽器有著一致的行為那我們的開發生涯該是多麽美好。再進一步如果任何你從 Blog，Conferences 或 Meetup 得知的新功能像是 CSS Grids, CSS Sanp points, Sticky positioning 我們馬上就能夠在今天開始使用，而你需要做的就是從 Github 下載程式碼。 這就是 Houdini 的理想。這個未來正是該工作團隊試圖實現的目標。你說你根本不想去撰寫那些 polyfills 也沒關係，但你大概會想使用吧！？畢竟只要有人寫出 polyfills 我們就可以從中得到幫助。 那麼 Houdini 現階段有什麼功能正在開發？如同上面提到的，開發者對於瀏覽器渲染的過程沒有太多存取控制的機會，現階段只能從 DOM 下手。 為了解決這個問題，Houdini 團隊將提倡了一些新的規範，關於在渲染流程中賦予開發者其他部分的控制權。下圖顯示新的規範中開發者可以操作的部分。注意規範中灰色區塊是已規劃但還未被寫入規範的。 下面我們將簡介每個新的規範並且說明其功能。完整的清單請查閱Houdini Drafts CSS Parser APICSS Parser API 目前還未被寫入規範，意思是這邊提到任何內容極有可能會改變。不過基本來說它的概念是讓開發者可以擴充 CSS Parser ，提供新的語法結構，舉例來說：新的 media 語法，新的偽類 pseudo-classes 等等 一旦解析器知道關於新的結構，它就可以正確地將其運用在 CSSOM 上。 CSS 屬性與值的 APICSS 已經具有客製屬性的功能，並且在之前的文章說明過對此感到非常興奮。CSS 屬性與值的 API除了自訂屬性將更進一步使其具備型別。 關於加入型別有非常多的好處，不過大體來說最大的賣點就是讓開發者可以客製 transition 和 animate。這在今天是辦不到的。不懂！？看看下面的例子 1234567body { --primary-theme-color: tomato; transition: --primary-theme-color 1s ease-in-out;}body.night-theme { --primary-theme-color: darkred;} 上面的例子如果 night-theme class 被加到 &lt;body&gt; 元素那麼該頁面有參考 --primary-theme-color 屬性的值將會慢慢的從 tomato 轉換到 darkred。如下範例 123p { color: var(--primary-theme-color);} 在現階段，如果你要完成這個功能你得為每一個元素撰寫 transition，因為現在過渡效果是跟在元素上並不是跟著屬性。另一個有趣的功能就是註冊 hook，提供開發者一個方式來修改自訂屬性的最終值，用在 polyfills 方面這可能是非常實用的。 CSS Typed OMCSS Typed OM大概就是目前 CSSOM 第二版的概念。目的是解決當前 CSS 模型的問題，也包含 CSS Parser API 和 CSS 屬性和值 API 追加的新功能。 Typed OM 另外一個主要的目標是改善效能。將 CSSOM 目前使用的字串值換成具意義型別，因此在Javascript 操作的表現會得到顯著效能的提升。 CSS Layout APICSS Layout API提供開發者撰寫自己的佈局模組。透過佈局模組意味著任何東西可以被傳入 display 屬性。這將是第一次開發者有辦法透過原生的方式改變佈局提供像是 display: flex 和 display: table 這樣不同的模組。 例如 Masonry Layout 流瀑式版型 這樣複雜的佈局方式在今天是不可能單單只透過 CSS 就完成的。雖然它的效果令人驚艷但可惜的是通常都有效能相關的問題，在低階的裝置上尤其明顯。 CSS Layout API 讓開發者透過 registerLayout 的方法，允許註冊一個 layout 的名稱，然後用一個 Javascript class 來組織邏輯。下面就是一個簡單的範例 1234567891011registerLayout('masonry', class { static get inputProperties() { return ['width', 'height'] } static get childrenInputProperties() { return ['x', 'y', 'position'] } layout(children, constraintSpace, styleMap, breakToken) { // Layout logic goes here. }} 如果你感受不到上面範例的意義，也不用擔心。最主要的是說你可以像下面範例這樣使用，你只要找到別人寫好的例如 masonry.js 接著在 CSS 中使用就好了。 123body { display: layout('masonry');} CSS Paint APICSS Paint API 和 Layout API 非常類似，不過它提供一個 registerPaint 方法。開發者可以在 CSS 中使用 paint() 函式，透過傳入的名稱產生一個 CSS 圖片。這邊有個簡單的範例就是繪製一個有顏色的圓形 12345678910111213141516registerPaint('circle', class { static get inputProperties() { return ['--circle-color']; } paint(ctx, geom, properties) { // Change the fill color. const color = properties.get('--circle-color'); ctx.fillStyle = color; // Determine the center point and radius. const x = geom.width / 2; const y = geom.height / 2; const radius = Math.min(x, y); // Draw the circle \\o/ ctx.beginPath(); ctx.arc(x, y, radius, 0, 2 * Math.PI, false); ctx.fill(); }}); CSS 的用法如下 1234.bubble { --circle-color: blue; background-image: paint('circle');} 現在套用 .bubble 的元素會產生一個藍色圓形的背景圖。這個圓會跟元素尺寸一樣且置中。 Worklets關於上面列出的規範和一些範例你可能會想知道你該把它們放在哪裏？答案是 worklet scripts。worklets 類似於 Web workers，它允許我們匯入 script 檔案，可以在不同的階段執行 Javascript 程式碼，並且它不相依於主要執行緒。worklet script 為了確保效能會嚴格的限制能夠操作的型別。 捲軸效果和動畫雖然針對捲軸效果(scrolling)和動畫方面還沒有官方的規範，不過這是 Houdini 其中一個備受期待的功能。最終 API 會允許開發者將程式邏輯放在一個負責組織執行的 worklet，而不是主要執行緒上。這個東西會支援修改一些 DOM 的屬性。透過這種方式就可以只更新特定屬性，而不是全部重新渲染。 如此一來開發者就可以容易的做出高效能的 scrolling 和動畫類型的應用，例如 sticky scroll header 或是平行捲動 parallax 的效果。你可以在使用案例中得知這些 API 試圖要解決的問題。 儘管還沒有正式的官方規範，實驗性的開發已經在 Chrome 上展開了。事實上 Chrome 團隊目前正在使用這些主要的 API 實作 CSS Snap point 和 Sticky positioning。這是很驚人的，因為這意味著 Houdini API 有足夠的效能讓 Chrome 新功能採用。如果你仍然擔心 Houdini 效能的問題，你可以看看下面這個影片以及原始碼 那我現在可以做些什麼？如同上面提到的，我想每一個網站開發者都應該關注 Houdini。這將是讓我們開發生活變得更美好的未來。即使你不會直接使用 Houdini 規範內定義的東西，你幾乎會用到架構在它之上的許多東西。雖然這個未來還不會立即到來，但它可能比我們想的還要快到來。 所有主流瀏覽器的廠商在 2016 年初已經在雪梨有場面對面的會議交流，對於 Houdini 的建置與開發沒有太多異議。可以說 Houdini 是否會成為下一件大事已經不是個問題，問題應該是何時導入比較恰當。 當然瀏覽器供應商對於建置這些新功能自有一些優先順序，通常會根據那些使用者迫切需要的功能為優先。所以如果你關心這個關於樣式與佈局的擴展功能，你希望可以不用等待瀏覽器開發商經過漫長的開發程序，就使用 CSS 的新功能請告訴那些相關的開發成員你需要這個功能。 另一方面你可以透過提供一些真實世界的使用案例，就是那些你想做的功能但現今技術卻異常難實現。已經有一些案例列在這個 Github 專案。你可以透過發個 Pull Request 來加入協作。 Houdini 開發團隊真的希望能夠從網頁開發人員中取得真正需求與問題，使這些功能更加完善周到。因為通常參與規格書制訂的工程師只專注在瀏覽器身上，他們並不知道應用程式開發者的痛點。全靠我們來告訴他們了。 參考資源 CSS-TAG Houdini Editor Drafts - W3C 最新草稿 CSS-TAG Houdini Task Force Specifications - 官方 Github 專案 Houdini Samples - 實驗範例 原文出處","link":"/2016/03/31/introduce-houdini/"},{"title":"RaspberryPi with node 安裝筆記","text":"安裝完 NOOBS 之後… 設定123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&gt; raspi-config # 設定語系，時區&gt; startx # 開啟圖形化介面# 更新軟體&gt; sudo apt-get -y update&gt; sudo apt-get -y upgrade&gt; sudo apt-get -y dist-upgrade# 更新韌體&gt; rpi-update&gt; reboot# 安裝遠端桌面&gt; sudo apt-get install xrdp # Microsoft Remote Desktop 即可連線# 安裝酷音&gt; sudo apt-get install scim-chewing# 安裝中文字體&gt; sudo apt-get install ttf-wqy-microhei ttf-wqy-zenhei xfonts-wqy# 安裝 node-arms&gt; wget http://node-arm.herokuapp.com/node_latest_armhf.deb&gt; sudo dpkg -i node_latest_armhf.deb# (安裝 node 錯誤)dpkg: regarding node_latest_armhf.deb containing node: nodejs-legacy conflicts with node node (version 4.2.1-1) is to be installed. node provides node and is to be installed.dpkg: error processing archive node_latest_armhf.deb (--install): conflicting packages - not installing nodeErrors were encountered while processing: node_latest_armhf.deb# (除錯)&gt; sudo apt-get remove nodered&gt; sudo apt-get remove nodejs nodejs-legacy&gt; sudo apt-get remove npm # if you installed npm# 安裝 PhantomJS&gt; sudo apt-get install g++ flex bison-doc bison gperf ruby ruby-dev perl libsqlite3-dev sqlite3 libfontconfig1-dev icu-doc libicu-dev libfreetype6 libssl-dev libpng12-dev libjpeg8-dev ttf-mscorefonts-installer fontconfig build-essential chrpath git-core openssl&gt; git clone git://github.com/ariya/phantomjs.git&gt; cd phantomjs&gt; git checkout 2.1.1&gt; ./build.py&gt; sudo chmod -x ~/phantomjs/bin/phantomjs&gt; sudo chmod 775 ~/phantomjs/bin/phantomjs&gt; sudo ln -s /home/pi/phantomjs/bin/phantomjs /usr/bin/ dpkg 常用指令123456789101112&gt; dpkg -l package_name # 列出該 package 相關資訊&gt; dpkg -l | less # 列出系統中所有安裝的軟體&gt; dpkg -L package_name # 列出該 package 所有檔案擺放位置&gt; dpkg -S file_name # 搜尋 file 所屬 package&gt; dpkg -i package_name # 安裝軟體&gt; dpkg -r package_name # 移除軟體&gt; dpkg -x package_name.deb target_dir # 解 .deb 檔案成數個檔案&gt; dpkg -i --force-overwrite-i package_name # 強制安裝軟體&gt; dpkg -i --force-all package_name # 強制安裝軟體&gt; dpkg -r --purge --force-deps package_name # 強制移除軟體&gt; dpkg --get-selections # 列出系統中所有安裝的軟體&gt; dpkg --pending --remove # 移除多餘的軟體 參考 裝置 基本安裝含無線網路 Raspberry Pi 安裝中文輸入法與字型 安裝 Node 除錯，含 v1, v2 安裝 Node 含開機自動執行設定 常用軟體 編譯 PhantomJS 安裝 PhantomJS","link":"/2016/03/08/raspberrypi-with-node/"},{"title":"SSL 相關筆記","text":"如何自己簽一張 SSL 憑證用於測試概覽下面簡易介紹了 SSL 是如何實作以及在整個流程中各個憑證所扮演的角色。 一般網頁傳輸是透過非加密的方式，意思是每一個人只要透過工具都可以存取，並且窺視所有的傳輸內容。可以見得的，這可能造成一些問題。尤其是在安全和隱私方面，例如信用卡與銀行交易的資訊。安全套接層協議(Secure Socket Layer)也就是 SSL 是用來加密這些伺服器與客戶端傳輸的資料。簡單說就是保證兩個應用程式之間通訊的機密和完整性，也可驗證對方的身份。 SSL 使用我們所知道的非對稱式加密，也就是我們常說的公鑰加密的方式(PKI，Public Key Cryptography)公鑰加密，這種方式總共會有兩把鑰匙(兩個加密檔)，一把是 Public 一把 Private。任何加密的資料，只能透過對應鑰匙解密。也就是說當一筆資料透過伺服器上的私鑰加密，那麼就只能透過對應的公鑰解開，反之亦然。更白話的說就是鑰匙產方通常握有私鑰，將公鑰交給信任之對象，之後要產生的加解密都靠私鑰，而信用對象的加解密都用公鑰。 如果 SSL 已經使用了公鑰對傳輸資料加密，那為什麼我們還需要一張憑證？技術面的回答是這張憑證本來就不是必須的。因為資料已經被加密，沒那麼簡單被第三方破解。然而憑證在溝通過程中扮演了一個關鍵的角色。一張憑證需要一個被信任的憑證發行機構(CA)簽署(Signed)來確認憑證的擁有者聲稱的資訊是正確的。少了被信任的簽章，資料仍然會被加密，但您所溝通的對象卻不一定跟你想的一樣。如果沒有憑證那麼偽裝式的攻擊會更容易發生。 具體來說 SSL 實際運作在第四層傳輸層 Transport Layer (TCP/UDP) 與第七層應用層之間。主要的協定或者我們說任務分成 SSL Handshake Protocol, SSL Change Cipher Spec Protocol, SSL Alert Protocol和 SSL Record Protocol SSL Handshake在開始溝通之前要先互相確認身份，遵循的規則，加密演算法或密鑰交換演算法。 SSL Change Cipher用來變更雙方傳輸加解密的演算法與驗證的規格。 SSL Alert當發生錯誤時用來傳遞錯誤訊息。 SSL Record Protocol確認資料的完整性以及沒有被篡改。 流程1 瀏覽器發送請求給 Server 包含瀏覽器支援的加密演算法資料與 TLS/SSL 版本 Server 使用自己的私鑰加密 CA 憑證給瀏覽器，同時附加一把公鑰 瀏覽器收到加密資料後嘗試使用網站的公鑰解密，這一步是為了確保憑證在傳輸過程中沒有被竄改 驗證 CA 的訊息內容之後確認網站的真實性 Server 也丟出目前支援的加密演算法和 TLS/SSL 版本，決定兩者都支援的方式 產生一組 Session Key (加密金鑰) 並用 Server 的公鑰加密 Server 用私鑰解開得知 Session Key 使用雙方協議好的 Session Key 對接下來的資料進行加解密 實作 - 步驟 1 產生一把私鑰我們會使用 openssl 來產生RSA加密演算法的私鑰和 CSR(Certificate Signing Request)憑證請求檔第一步我們需要先產生私鑰 1$ openssl genrsa -out server.key 2048 實作 - 步驟 2 產生 CSRCSR 憑證請求檔是要發給認證機構，簡單說其功用就是把你的個人資料填好附上私鑰交給認證機構來做簽證的動作 1$ openssl req -new -key server.key -out server.csr 實作 - 步驟 3(選用) 移除 Key 的密碼12$ cp server.key server.key.org$ openssl rsa -in server.key.org -out server.key 實作 - 步驟 4 產生自簽憑證1&gt; openssl x509 -req -days 3650 -in server.csr -signkey server.key -out server.crt Let’s Encrypt參考資源 說明 Apache 使用 创建并部署自签名的 SSL 证书到 Nginx SSL憑證設定教學 Let’s Encrypt 教學 - 中文 Let’s Encrypt 教學 Let’s Encrypt on OSX","link":"/2016/04/12/self-signed-ssl-and-others/"},{"title":"Docker 入門筆記 - OSX","text":"首先需要先安裝 Docker Toolbox，工具包包含下面幾種工具 Docker Machine Docker Engine Docker Compose Kitematic command-line environment shell Oracle VM VirtualBox 整個流程為 安裝 Docker Toolbox 在 container 中執行 image 檔 在 Docker Hub 瀏覽可用的 image 檔 建置自己的 image 並 push 到 Docker Hub 因為 Docker 的常駐服務程式(daemon)採用 Linux 規範的核心功能，所以我們不能直接在 OSX 中執行。因此需要使用 docker-machine 來建立掛載一個虛擬機器，並且用這個虛擬機器來執行 Docker。 如果 Docker 安裝在 Linux 系統中那麼 Docker client, Docker daemon, 還有任何 Docker 容器都可以直接在本機上執行。 而在 OSX 中 Docker daemon 預設是執行在一個輕量的 Linux VM，整個 VM 被配置在記憶體中，約佔 24MB啟動時間約 5 秒。 執行 建立或開啟 docker-machine 1234567891011121314151617181920212223242526272829# 建立$ docker-machine create# 刪除$ docker-machine rm [name]# 重建$ docker-machine create --driver virtualbox default# 常用$ docker-machine [start|stop|restart|status]# 設定檔在 ~/.docker/machine/machines/default# 列表$ docker-machine ls# 連結 shell 到 default 機器$ eval &quot;$(docker-machine evn default)&quot;＃ 啟動 docker$ docker run hello-world# 顯示正在執行的 docker container$ docker ps# 安裝之後的正常開機流程$ docker-machine start$ eval &quot;$(docker-machine env default)&quot; Docker machine 運行著 Docker Engine，Engine 的部分提供我們 Docker 的核心功能。我們可以使用 image 和 container。container 意思就像是一個 instance，而 image 檔就像是 class。 docker run hello-world 中 run 是建立和執行一個 container，最後 hello-world 則是 image一個 container 等於是一個基本的 Linux 系統，而 image 則是您希望安裝到這個 container 的軟體。 docker 常用操作12345678910111213141516171819202122232425262728293031323334353637383940414243# 執行 image# docker run [image_name] [arguments]$ docker run docker/whalesay cowsay boo# local images 列表$ docker images# docker run 流程 -&gt; 檢查本地端是否有 image -&gt; 沒有的話到 docker hub 下載 -&gt; 有的話沿用# -&gt; 只有在有更新的時候才會重新下載# Dockerfile 不只可以指定環境該安裝什麼軟體，還可以指定該執行哪些指令# 建置 image，切換到 Dockerfile 目錄$ docker build -t docker-whale .# docker 建置流程 -&gt;# 1. 首先確認所有需要的資料正確# Sending build context to Docker daemon# 2. 載入 image# FROM docker/whalesay:latest# 3. 執行安裝與指令# 上傳 Docker Hub# 0. 上傳的 image 需要用帳號當作 namespace 例如: andyyou/ubuntu# 1. 打標籤或是在 docker build -t 的時候就設好# 2. push 到 docker hub# 打標籤$ docker tag 32d9cb7369aa andyyou/node:latest$ docker tag [image id] [repo_account/image_name]# 登入$docker login# 推上 docker hub$ docker push# 刪除 local image，可用 id 或 name$ docker rmi -f 7d9495d03763$ docker rmi -f docker-whale# 刪除 container$ docker rm -f [container_id/container_name] Docker with Node, MongoDB下面為如何設定 Docker 容器搭配 MongoDB 與 NodeJS 的簡短介紹。我們將一步一步的介紹關於設定與過程中可能遇到的問題。在我們熟悉 Docker 搭配 Node, MongoDB 的操作之後，我們將具備足夠基本知識來使用 Docker MongoDB12345678910111213141516171819202122232425262728# 下載 Mongo image$ docker pull mongo:latest# 啟動/執行 MongoDB container$ docker run -v &quot;$(pwd)&quot;:/data --name mongo -d mongo mongod --smallfiles# -v &quot;$(pwd)&quot;:/data 會把當前目錄對應到 /data# 列出正在執行的 container$ docker ps# 列出所有的 containers$ docker ps -a# 移除 container$ docker rm [container_id]# 建立一個新的 mongo container 連接到已經開啟的 mongo container 並執行連線# --rm 是退出之後就移除$ docker run -it --link mongo:mongo --rm mongo sh -c 'exec mongo &quot;$MONGO_PORT_27017_TCP_ADDR:$MONGO_PORT_27017_TCP_PORT/test&quot;'# 連線到已在執行的 container，先連線在執行 mongo$ docker exec -it 67d1db81df31 bash$ mongo$ db.col.insert({&quot;a&quot;: 4})$ db.col.find().pretty()$ mongodump --db test --out /data/test-backup # 匯出 db$ mongorestore --db test-restored /data/test-backup/test # 還原 Node123456789101112131415161718# 下載 node image$ docker pull node:latest# 執行$ docker run -it --rm node # -it 參數表示保持 STDIN 和配置一個 TTY, --rm 當退出 node 的時候關閉 container# 建立一個 container 並且 mounted 到 mongo$ docker run -it --name node -v &quot;$(pwd)&quot;:/data --link mongo:mongo -w /data -p 8082:3000 node bash# 建立 nodeapp container$ docker run --name nodeapp -v &quot;$(pwd)&quot;:/data --link mongo:mongo -w /data/app/sandbox -p 8082:3000 -d node npm start# 顯示目前 container 的狀態$ docker logs nodeapp$ docker logs -f nodeapp# 顯示連線 IP$ docker-machine config 資源 Getting started 參考 設定 AWS 和 Docker Cloud Debian 8 基本安裝 Mongo with Node 教學 持續更新指令 錯誤處理 DevOps","link":"/2016/04/15/docker-note/"},{"title":"CSS Grid 介紹","text":"當我們要建置複雜的網站時 Grids 是非常重要的。其重要性我們可以從大量的 CSS 框架中窺知ㄧ二，因為幾乎所有的框架都有提供網格(Grids)系統來加速開發。隨著 CSS Grid 規範的出現，將來我們將不需要額外的樣式就可以使用網格。另外的好處就是我們將不需要再依賴 inline 和 float 來完成那些佈局需求在這篇文章我們將要介紹一些網格基本的用法，然後透過實作一個基本的部落格佈局來理解其用法。 瀏覽器的支援度即使在這篇文章撰寫的現在仍然只有 IE10+ 和 Edge 支援 Grid Layout - 所以這意味著暫時我們還不能在正式的專案上使用。不過我們還是可以透過開啟實驗功能 chrome://flags 讓 Chrome 支援，Firefox 則使用 about:config 的 layout.css.grid.enabled 屬性調整。 另外的方式是使用 polyfill。透過上面的這些方式我們可以開始使用網格功能。 注意：IE 目前實作的是舊版的規格。不幸的這意味著它可能跟最新的規格不相容。所以當您在實作本文的練習時建議使用 Chrome 或 Firefox。 網格系統(grid system)術語當我們在設計與執行元素的佈局時 CSS 的網格系統類似於表格的作用。然而比起表格，它有更多的功能與彈性。在這一小節我們要探討一些術語，這些術語是我們在使用網格時會需要理解的。 fr 單位：fraction Flexible Lengths 這個單位我們用來設定可用空間的比例，意思是我們會用在 grid-rows 與 grid-columns 上。根據規範的定義空間比例的分配會在 row 或 column 的內容或長度一些非彈性的尺寸設定完成之後處理，即分配剩下閒置的空間。 lines：線用來定義元素的邊界，可以設定為垂直或水平的。下圖呈現四個垂直與四個水平的線。 tracks：兩線之間的空間稱為 tracks。如下圖有三個垂直和三個水平的 track cells：cell 即一個基本單位或說網格中的格子，如下圖我們總共有 9 個 cell，或者說用 4 條線組出來的最小單位。 areas：區域 area 是一個透過任意數 cell 組成的方形，或者說用 4 條線組出來的就是 area。所以我們可以說一個 track 也是一個 area，一個 cell 也是一個 area 在 Grid 中設定元素的位置讓我們從最基本的部分開始，在這一節我們將會學會如何使用 grids 幫元素定位到特定位置。為了要使用 CSS Grid 我們會需要一個父元素和一或多個子元素，下面我們示範一個簡單的用法 12345678&lt;div class=&quot;grid-container&quot;&gt; &lt;div class=&quot;grid-element item-a&quot;&gt;A&lt;/div&gt; &lt;div class=&quot;grid-element item-b&quot;&gt;B&lt;/div&gt; &lt;div class=&quot;grid-element item-c&quot;&gt;C&lt;/div&gt; &lt;div class=&quot;grid-element item-d&quot;&gt;D&lt;/div&gt; &lt;div class=&quot;grid-element item-e&quot;&gt;E&lt;/div&gt; &lt;div class=&quot;grid-element item-f&quot;&gt;F&lt;/div&gt;&lt;/div&gt; 在我們處理完 HTML 的結構之後第一個我們要先套用 display: grid 或者 display: inline-grid 在我們的父元素上 12345.grid-container { display: grid; grid-template-columns: 200px 10px 0.3fr 10px 0.7fr; grid-template-rows: auto 20px auto;} 上面範例中的 grid-template-columns 和 grid-template-rows 屬性用來設定 rows 和 columns 的各種寬的值。我們在 grid-template-columns 中定義了 5 個 columns 10px 的欄位替兩個元素之間插入一些空白的空間。第一個欄位 column 是 200px 寬。第三個欄位使用 0.3 意思是剩下空間的 30% 而第五使用 0.7 也是針對剩餘空間的部分。 在 grid-template-rows 第一個參數使用 auto 讓列(row)可以依據內容展開擴展需要的空間。20px 的部分則表示下一 row 我們用其來顯示列跟列之間的間隔空間。 See the Pen CSS Grid Layout Demo 1 by andyyou (@andyyou) on CodePen. 觀察第二欄的元素 B ，我們就是拿它來當作間隔，如果您不設定子元素的位置那麼預設瀏覽器會依序把子元素放進 cell，超過的部分會放到下一列。也就是說第二列(row)還有四個 column 的位置。 為了讓元素放置到特定的 cell 我們需要設定位置，在我們開始解釋如何設定之前先看看下面這張圖 在這個範例中，我們將會採用 line-based placements 基於線的配置，這種方式的意思是線在我們的網格(Grid)系統中扮演指揮的角色負責元素的位置配置與範圍管理。讓我們拿元素 B 來當作範例，水平橫向來看 B 從垂直的 3 號線開始到 4 號線結束，縱向來看從水平的 1 號線到 2 號線。我們使用 grid-column-start 來指定起始的垂直線，以這個範例來說就是 3 ，grid-column-end 為 4 以此類推最後我們得到的樣式如下 123456.element-b { grid-column-start: 3; grid-column-end: 4; grid-row-start: 1; grid-row-end: 2;} 同樣的要把元素放置到 F 位置 CSS 樣式如下 123456.element-f { grid-column-start: 5; grid-column-end: 6; grid-row-start: 3; grid-row-end: 4;} 建立基本的佈局現在我們知道了關於如何設定網格系統的基礎用法了，讓我們來建立一個簡單的部落格設計佈局。我們假設這個部落格會有 header，footer，sidebar和兩個 section 1234567&lt;div class=&quot;grid-container&quot;&gt; &lt;div class=&quot;grid-element header&quot;&gt;Header&lt;/div&gt; &lt;div class=&quot;grid-element sidebar&quot;&gt;Sidebar&lt;/div&gt; &lt;div class=&quot;grid-element main&quot;&gt;Main&lt;/div&gt; &lt;div class=&quot;grid-element extra&quot;&gt;Extra Info&lt;/div&gt; &lt;div class=&quot;grid-element footer&quot;&gt;Footer&lt;/div&gt;&lt;/div&gt; 這邊我們要先記住標籤的順序並不會對 Grid 配置的位置造成任何影響，只要我們不改變 CSS，即使您把 footer 標籤放到 header 的上面也不會造成任何改變。當然我們不建議您故意這樣做，這邊的核心觀念是一旦啟用 grid 那麼元素的位置配置就由網格系統決定而不是標籤的順序。現在我們需要做的就是弄清楚 grid-row-end 這些屬性到底該設置什麼值。就像上面的範例首先我們先畫一個簡單的格線示意圖來決定這些值 我們現在稱那些垂直的線為 column 線，因為我們靠它來決定 column 的位置，而水平的線則是 row 線 從上面這張圖我們可以得知 header 會從 1 號 column 線(垂直線)到 4 號 column 線，而 row 的部分則是從 1 號 row 線(水平線)到 2 號。 123456.header { grid-column-start: 1; grid-column-end: 4; grid-row-start: 1; grid-row-end: 2;} 同樣的 extra content 從 column 3 到 column 4，row 5 到 6 CSS 如下 123456.extra { grid-column-start: 3; grid-column-end: 4; grid-row-start: 5; grid-row-end: 6;} 照著規則設定其他元素，最後結果下面的範例 See the Pen CSS Grid Layout Demo 3 by andyyou (@andyyou) on CodePen. 結論CSS Grid 讓我們可以輕鬆的建立複雜的佈局，這麼一來整份 CSS 也將更容易維護，我們不需要再與 float, position, z-index 這些屬性奮鬥，另外一個好處就是把顯示的佈局和標籤結構分離。還有就是即便是動態的內容也能夠處理，如下面影片 參考資源 Grid Introduce Flexbox vs Grid","link":"/2016/05/04/css-grid/"},{"title":"requestAnimationFrame 筆記","text":"在 Javascript 我們曾經只有一種方式來處理跟特定時間有關的循環事件: setInterval()。簡單說就是當你需要重複某些任務時(依據時間)。您就會用到這個方法。對於動畫來說需要每秒 60 個 frames 人類才會覺得是順暢平滑的，因此我們可能會寫出像下面這樣的程式碼 123setInterval(function () {}, 1000/60) 除了這個方式，還有另外一種方式就是使用 requestAnimationFrame ，當然這個東西已經出現很久了，不過在這之前，大多的時候我都不需要自己造輪子，也不太有機會需要對於動畫有深入的處理。因為自己開發一些輪子的需求所以這篇文章會了解一些關於 requestAnimationFrame 的基本用法。 簡單說使用 requestAnimationFrame 有下面幾點好處 瀏覽器可以優化，讓動畫更平滑順暢 該暫停的動畫不會繼續使用 CPU 省電 最簡單的範例12345function repeatOften () { requestAnimationFrame(repeatOften)}requestAnimationFrame(repeatOften) 啟動/停止requestAnimationFrame 會回傳一個 ID 我們可以用這個 ID 來取消它，就類似 setTimeout, setInterval。下面我們用 jQuery 簡單的展示一個範例 1234567891011121314var globalID;function repeatOften () { $('&lt;div /&gt;').appendTo('body'); globalID = requestAnimationFrame(repeatOften);}$(&quot;#start&quot;).on(&quot;click&quot;, function() { globalID = requestAnimationFrame(repeatOften);});$(&quot;#stop&quot;).on(&quot;click&quot;, function() { cancelAnimationFrame(globalID);}); 參考 polyfill CSS-Tricks","link":"/2016/05/12/using-request-animation-frame/"},{"title":"Openshift 筆記","text":"常用指令1234567891011121314151617181920212223242526272829303132# 安裝 rhc$ gem install rhc$ rhc setup&lt;!--more--&gt;# 建立 app$ rhc app create [app name] ruby-2.0 postgresql-9.2# 設定好 database.yml# 顯示 app 相關資訊$ rhc show app [app name]# DB migration$ rhc ssh [app name] # SSH 至 app 環境$ cd app-root/repo$ bundle exec rake db:create RAIS_ENV=production$ bundle exec rake db:migrate RAILS_ENV=production# 修改 Server$ rhc env set OPENSHIFT_RUBY_SERVER=puma -a [app name]# 重啟$ rhc app restart [app name]# 查看錯誤 Logs$ rhc tail [app name]# 查詢 PostgreSQL$ rhc port-forward -a [app name]# 接著再用介面上的帳密登入 123456789production: adapter: postgresql encoding: unicode pool: 5 database: &lt; %=ENV['OPENSHIFT_APPNAME']%&gt; host: &lt; %=ENV['$OPENSHIFT_POSTGRESQL_DB_HOST']%&gt; port: &lt; %=ENV['$OPENSHIFT_POSTGRESQL_DB_PORT']%&gt; username: &lt; %=ENV['OPENSHIFT_POSTGRESQL_DB_USERNAME']%&gt; password: &lt; %=ENV['OPENSHIFT_POSTGRESQL_DB_PASSWORD']%&gt; 資源 完整教學 解決 rails 4.2 無法啟動 bug database.yml 範例","link":"/2016/04/16/openshift-note/"},{"title":"響應式設計中百分比 % 的問題","text":"問題為了要能夠解釋得更清楚我們需要實作一小段跟我們會遇到的問題相關的程式碼 1234.list-item { float: left; width: 33%;} 現在您可能會想知道關於上面這段程式碼有什麼問題，看起來這樣並不明顯，好！假設這是一個三欄(column)的網格，就算你知道 33% + 33% + 33% = 99% 並不是 100%。但在大多數的情況下並不會有什麼問題，不過這誤差的 1% 如果遇到容器像是 1400px 時就是 14px，那就是一個蠻大的誤差了。那為什麼我們不直接調整百分比的精度呢? 我們是可以將它降低到 1.4px 甚至是 0.14px 那麼一來就不會有問題啦 1234.list-item { float: left; width: 33.33%;} 實際上…關於流質網格(Fluid Grid)破版的問題，…其實就只是誤差造成縫隙或偏移。所謂響應式設計(RWD)依照 Ethan Marcotte 所定義: 就是流質網格，響應式圖片，加上 Media Query 所構成。但關於流質網格卻有一個比較麻煩的問題，就是計算捨入的部分是錯誤的。當我們使用百分比設定欄位時，瀏覽器必須要根據螢幕，viewport 及可視區域將其轉換為實際的像素(pixel)。在這個轉換的過程中 Chrome, Safari, Opera 等瀏覽器全部產出錯誤的值。 Fluid：英文為液態，液體，流質定義為一種物質可持續性的改變形狀以適應周圍的壓力或容器流質網格：網格尺寸會根據父元素尺寸自動調整，簡單說即我們定義最外圍的尺寸後就像液體一樣格子會自動變形去適應尺寸 所謂的錯誤主要是因為這是需要被定義在 CSS 規範的問題。但由於 CSS 並沒有規範瀏覽器對於百分比計算精度應該要到小數第幾位，舉例來說如果 6 個欄位的網格 100% ÷ 6 = 16.666667% ，那麼在一個 1000px 的可視區域 viewport 中一欄(column)的寬就是 166.66667px，但因為沒有規範，所以瀏覽器廠商各自使用自己的規則，如果瀏覽器使用四捨五入那麼在我們這個範例我們就會得到 167px 結果就是 167 x 6 = 1002 就會超出 viewport 範圍。如果捨去變成 166px 那最終我們會少 4px。 IE6 7 採用前者就是進位，這也意味著常常會超出我們想要的尺寸，WebKit 採用後者以避免破版，Opera 甚至直接在百分比動手腳把 16.66667% 直接換成 16%，結果就是一個欄位(column)的寬跟我們要的整整誤差 6px。好！在你開始罵這些開發商之前，請先想想這是因為 CSS 規範沒有定義規則啊！ 更糟糕的狀況？不幸的是，如果您同時也使用百分比來設定這些間隔(gutters)尺寸如 pedding 之類的，那麼這問題真的會非常糟糕。過去(約 2012 年)大部分佈局的方式都是採用 float 的方式，即網格中格子位置必須仰賴大量計算來完成。假設我們有一列 12 欄的網格透過百分比設定 width, margin, padding，那麼第 12 欄的位置需要前面 11 欄的 padding, margin, width 來計算，也就是說包含自己在內會有 56 次機會計算產生誤差2(padding) + 2(margin) + 1(width) = 5; 11 * 5 + 1(margin itself) = 56，假如每一次計算都誤差 1px 那麼就會有 56px 的誤差。 在你知道這點之後也就不奇怪為什麼 mediaqueri.es 網站上這麼多設計都沒有凸顯區塊邊緣的設計，因為如此一來就這個計算的誤差就比較不明顯一點。 您可以檢視範例來看看各個瀏覽器誤差的情況 那有什麼辦法?首先，我得先對那些自適應(adaptive)網頁設計的提倡者說，我明白你看到這邊非常開心。的確! 採用自適應的方法能良好的運作，因為 Adaptive Web Design 預先對 viewport 尺寸定義然後當遇到那些不符合的尺寸時則採用小一級例如：預先設計了 1024 和 960 寬的 viewport 如果遇到 1000 就採用 960 的設計。因為不使用流質網格所以完全避開了關於百分比誤差的問題。但這裡並不是要說 AWD 就是比較好的做法，只是稍微提一下採用 AWD 的話不會遇到這個問題。 響應式(Responsive) vs 自適應(Adaptive) 響應式和自適應設計共同點; 都是要處理在不同裝置下瀏覽網頁的問題，可讀性，版型等等。 最大的部分在於 RWD 是透過 Fluid Grid 和元素使其自動符合視窗或父元素尺寸，而自適應 AWD 則是預先定義可視區域的尺寸然後透過 JS CSS 等方式去套用版型樣式 最佳解決方案您可能注意到我剛剛並沒有提到 Firefox 計算的問題。Firefox 實作了一個較為先進的方式稱為 sub-pixel 渲染取代捨入計算的方式，Firefox 會替所有 CSS 屬性保留 sub-pixel 值，當元素的位置需要相依其他元素時就會把 sub-pixel 拿出來計算。這個效果相對接近設計師的期望。 IE8 也採用了 sub-pixel 顯然是為了補救 IE7 非常糟糕的計算方式。WebKit 與 Opera 以及那些使用捨去值策略的瀏覽器還沒有採用 sub-pixel 的方式。 而其中一個解決方式就是我們可以等到所有瀏覽器都採取 sub-pixel 的方式渲染，不過這可能需要等待非常久的時間。這篇文章試圖要找出解決方案而不是被動的等待，幸運的是下面有一些方式是我們今天可以採用的。 關於 CSS3 Flexbox?由於我們仍會在 Flexbox 的設計中使用百分比，如此一來或多或少還是會受到進位誤差的影響，因此 Flexbox 並不是佈局的萬能藥。 盡可能移除使用百分比的部分首先，我們必須要認同將所有佈局 Layout 每個屬性例如間隔的 padding 等都用百分比處理只是那些龜毛，強迫症開發者的樂趣，我們並不需要完全採用百分比。 第一個問題是因為在 CSS2 時盒子模型(Box model)中 padding 和 border 並不包含在元素寬內，意思是如果我們設定一個元素的寬為百分比，我們也必須使用百分比去設定 padding margin，否則計算上一定會出現不符合 100% 的狀況，但如果把 box-model 換成 box-sizing: border-box ，padding 和 border 就會包含在 width 裡，意思是我們就不需要在被迫在這些屬性上使用百分比，就可以使用固定的值 em, rem, px 等。針對網格邊界之間的間隔空間比較好的做法是使用 padding 而不是 margin。所有內容與間隔都套用保持一致比例，這樣一來比起當要顯示出邊界的樣式時才個別因為對齊的關係加上容器元素(wrapper)，前者的優點大於後者。 所以結論就是當使用 border-box 時，間距的部分 margin padding 就不會再遇到數學計算捨入的誤差問題。但在 width 方面仍然會有這個問題，不過以 12 欄來說我們把最大誤差從 56px 降低到 11px 。雖然很不錯了，但對使用者來說還是會被注意到這樣的瑕疵。 不讓捨入誤差累加捨入誤差真正的問題是因為在設計佈局時這些誤差常常是會累加的，為了要取得一個格子的左邊界定位我們必須要依賴前面同層的格子來計算，因為 float 需要依據上一個元素來排位置。那假如我們有辦法直接指定左邊界呢? 就是說如果可以就直接設定從父元素左邊界到本身的距離，然後其他元素遵循一樣 float 的排版呢? 事實證明是可以這樣做的。大約從 2004 年這個技術就已經被使用了稱為 container relative floats，這也是 Drupal 的 Zen 樣板使用的核心技術。雖然乍看之下這招不怎麼高明，但事實證明這個做法還蠻牢靠的。這個方法主要是透過在每個網格套用下面的 CSS 12float: left;margin-right: -100%; 接著每一個格子設定 margin-left 值是從父容器左邊界到其定位的距離。下面是一個簡單的範例 123456789101112131415161718.item1 { float: left; width 40%; margin-left: 0; margin-right: -100%;}.item2 { float: left; width: 40%; margin-left: 40%; margin-right: -100%;}.item3 { float: left; width: 20%; margin-left: 80%; margin-right: -100%;} 注意您也可以反過來設定網格對應右邊界的距離 float: right 然後 margin-left: -100%;。不過這個原理到底是啥？首先思考一下 margin-right: -100% 這個 -100% 就是外層容器的寬，接著再想想一個 float 元素 的 margin-right 是會影響緊鄰地下一個 float 元素，假如我們設定 margin-right: -10px 那麼它右邊的元素(格子)就會從原本的位置往左偏移 10px 就是減 10px。 邏輯上 -100% 意味著下一個元素應該要偏移減去容器寬的距離，不過有個重點就是如果減掉過大的值讓元素超過父容器邊界時結果並不會超出左邊界。簡言之就是 float 元素在排列位置時不用在管前面元素右邊界的位置(原本是從上一個元素的右邊界開始計算，現在不是)，只要看自己和父容器左邊界的距離就好。 試試這個範例 如果你對這個做法有一種好像 absolute 定位的感覺，覺得很不可靠，那是因為你應該沒注意到關鍵的不同點，absolute 的方式會使元素完全脫離文件排版的一個規則順序之中，且 absolute 不會影響周圍其他元素的位置，但 container-relative 的設定是可以透過 clear 移除的。這是關鍵，因為當 float 項目搭配這樣的用法就可以無視其他元素的右邊界位置，但設定 clear 時下邊界仍可以產生影響換行。這表示我們可以透過設定上一個網格或項目 clear 來換行產生新 row ，這是 absolute 辦不到的。 由於我們的網格不再被其他周圍的兄弟元素影響，我們就不再受到 HTML tag 的順序限制。如此一來我們就可以很簡單地把 HTML 中排序的第一個元素放到列的中間或者隨意把 row 中的網格任意調整位置順序。 但是這麼做我們還是沒有完全修好誤差的問題！不過我們已經減少定位相關的計算過程，現在只剩一個值就是和父元素的距離。不過這個值仍然受到捨入誤差的影響，也就是或多或少還是會遇到 1px 的誤差。不過幸運的是因為大部分的網站使用者並沒有強迫症，這樣微小的誤差並不太容易被注意到。 如果內容本身是有質量的使用者不會特別去注意那 1px 設計上的誤差，不過還有一個替代的解決方案可以幫助我們實作甚至減少這 1px 的誤差。 真的可以處理 1px 的誤差？如果您的網格 float 是往左靠，因為所有的元素都是向左對齊，所以最可能的狀況那 1px 的誤差都會顯示在最右邊的那格。即便所有列 row都對齊，這 1px 也蠻容易被發現，但如果我們把這些很明顯的地方換成對齊右邊，如此一來誤差的 1px 會被放到頁面的中間就比較不會被注意到。 使用 Zen Grids關於為什麼需要使用 CSS 預編譯器實作 RWD，那是因為例如使用 Sass 可以簡化一些我們需要的設計同時處理那些用純 CSS 會比較為複雜的地方。那麼 Zen Grids 是如何處理關於捨入誤差呢？透過使用 Zen Grids 預設就透過 border-box 來處理網格的間隔搭配 container-relative 方式，提供一些輔助方法(Methods)讓我們可以簡單的改變對齊的方向。 使用 Sass 與 calc() 處理除了 Zen Grids 的做法，透過 Sass 我們還有一些簡單的方式可以協助我們 使用除法1234567891011.list-item { float: left; width: (100%/3);}// or.list-item { float: left; width: percentage(1/3);} 透過這兩種方式 Sass 會自動幫我們把精度輸出到小數以下第五位，雖然沒有完全解決問題但是有幫助的。 使用 CSS 的 calc()現在最新的做法則是使用 calc() 這麼做是把問題交還給瀏覽器去處理，而對於那些還沒支援的瀏覽器則交給 Sass 12345.list-item { float: left; width: (100% / 3); width: calc(100%/3);} 結論 使用 Sass 計算方式 e.g 100%/3 使用 calc(100%/3) float 的情況下用 border-box 搭配 padding 以及 margin-right: -100% Container relative float 技術，將誤差往中間移 資源 Responsive Design’s Dirty Little Secret A Tale of CSS and Sass Precision","link":"/2016/05/20/responsive-design-dirty-secret/"},{"title":"Vue + webpack 起手式","text":"介紹前端的世界變化之快速，從 2010 開始小弟經歷了 jQuery, Backbone, Angular, 到 React。這一路走來雖然學習到了許多高明開發者融合於框架或函式庫中的智慧，卻也因為不斷快速變化感到疲憊。時至 2016 小弟認為在實務與理想之間取得一個完美平衡的前端框架大概就屬 vue.js 了。 當然這前端世界裡並沒有萬能藥可以完美的處理所有問題，不過 vue.js 的精美，不只容易與傳統 MVC 框架(Rails, ASP.NET MVC)等結合，當要使用最新的設計模式如 Flux, redux 等也都是沒問題的，再加上易學與一些你肯定能感受到作者從實戰淬煉出來的特性。因此在 2016 我也決定轉戰 vue.js。 隨著 Javascript 社群快速的演進，很可怕一個問題是 - 專案的環境設定，關於那些 tooling 這不只是 React 的問題，當你想使用 ES2015 的新語法，方便的持續整合與測試，匯入匯出模組時，我們就需要設定這些專案工具。 雖然 vue 本身有提供指令介面 vue-cli 讓我們快速建立專案，但對這些相關技術和設定有些瞭解肯定能幫助你執行更多客製的行為。 從頭自己一點一點設定有一些好處: 每個專案都有不同的需求，您可以根據自身的需求來設定 我們也提到 Javascript(nodejs) 的世界變得很快，如果有局部的套件壞了那我們也比較清楚該怎麼處理 直接使用別人的 start-kit 也許會多裝了一堆你不需要的東西 這篇文章將會透過實作介紹最基本的概念，使用 webpack 設定一個基本的 vue 專案 Part 1 基本目錄架構1. 建立專案與 package.json1234$ mkdir [project_name]$ cd [project_name]$ npm init -y$ npm install vue -S 我們先把需要的程式與目錄結構準備好，需求是使用 Vue + ES2015 來開發。第一步在根目錄建立一個 index.html 下面是一個簡單的 vue 範例 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Vue.js v2&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;{{ message }}&lt;/div&gt; &lt;script src=&quot;dist/bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意到兩件事 我們使用 dist/build.js 這個檔案在編譯之前是不存在的 這個語法是 vue.js 處理的 建立 src 目錄與 src/main.js 檔案，這邊您可以隨您自己的偏好組織專案架構 12345678import Vue from 'vue'new Vue({ el: '#app', data: { message: &quot;Hello Vue&quot; }}) 在這一步我們已經完成一個簡單的 Vue 專案，但是關於建置編譯的設定我們還未完成。 123Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.關於 v2 之後值得注意的地方，便是我們不能直接將元件掛載到 html 或 body 上。 Part 2 webapck 建置設定1. 安裝 webpack, webpack-dev-server 與相關 loaders 為了專注在基本的說明，本次更新已將一些不屬於基本功能的模組移除。 12# 2016-10-04 更新$ npm i webpack webpack-dev-server webpack-merge css-loader style-loader file-loader url-loader babel-loader babel-core babel-plugin-transform-runtime babel-preset-es2015 vue-loader vue-hot-reload-api -D 123456789101112131415161718&quot;dependencies&quot;: { &quot;vue&quot;: &quot;^2.0.1&quot;},&quot;devDependencies&quot;: { &quot;babel-core&quot;: &quot;^6.17.0&quot;, // babel 核心程式 &quot;babel-loader&quot;: &quot;^6.2.5&quot;, // webpack 使用的 babel 編譯器 &quot;babel-plugin-transform-runtime&quot;: &quot;^6.15.0&quot;, // 預設 babel 會在每一隻編譯檔案注入 polyfill 的程式碼，為了避免重複而將這部分抽出去。詳細說明：http://babeljs.io/docs/plugins/transform-runtime/ &quot;babel-preset-es2015&quot;: &quot;^6.16.0&quot;, // 支援 ES2015 語法 &quot;css-loader&quot;: &quot;^0.25.0&quot;, // webpack 使用於處理 css &quot;file-loader&quot;: &quot;^0.9.0&quot;, // webpack 使用於處理檔案 &quot;style-loader&quot;: &quot;^0.13.1&quot;, // webpack 將 css 整合進元件中 &quot;url-loader&quot;: &quot;^0.5.7&quot;, // 編譯匯入檔案類型的資源，把檔案轉成 base64 &quot;vue-hot-reload-api&quot;: &quot;^2.0.6&quot;, // 支援 Hot Reload &quot;vue-loader&quot;: &quot;^9.5.1&quot;, // 使用 Vue Component Spec &quot;webpack&quot;: &quot;^1.13.2&quot;, &quot;webpack-dev-server&quot;: &quot;^1.16.1&quot;, // webpack 開發伺服器 &quot;webpack-merge&quot;: &quot;^0.14.1&quot; // 合併 webpack 設定參數} 2. 裝完 loaders 後，撰寫設定 webpack.config.js根目錄下建立與撰寫 webpack.config.js 1234567891011121314151617181920212223242526272829var path = require('path')var config = { entry: path.join(__dirname, 'src', 'main'), output: { path: path.join(__dirname, 'dist'), filename: 'bundle.js', publicPath: '/dist/' }, module: { loaders: [ { test: /\\.js$/, loader: 'babel', exclude: /node_modules/ } ] }, resolve: { extensions: ['', '.js', '.vue'], /** * Vue v2.x 之後 NPM Package 預設只會匯出 runtime-only 版本，若要使用 standalone 功能則需下列設定 */ alias: { vue: 'vue/dist/vue.js' } }}module.exports = config Failed to mount component: template or render function not defined. (found in root instance) 123若您看到上面錯誤訊息，這是由於 Vue 2 之後分成 standalone 完整版與 runtime-only 版。差異在於完整版包含了編譯器，支援 template 以及使用了瀏覽器的 API。而 NPM 模組預設只會匯出 runtime-only ，若要加入 compiler 和 template 支援則需增加 webpack 的設定。 3. 設定 babel 的部分根目錄建立 .babelrc 簡化 webpack.config.js，這是因為 babel 6 之後把功能拆散了，要用就要裝。同時也可以用 .babelrc 來設定，如果不使用這個檔案我們就需要在 webapck.config.js 設定。 .babelrc 1234{ &quot;presets&quot;: [&quot;es2015&quot;], &quot;plugins&quot;: [&quot;transform-runtime&quot;]} 另外 package.json 和環境變數也能夠設定，不過為了單純起見我們選擇建立 .babelrc 。當然您也可以選擇設定在 package.json 中。 package.json 123456789101112{ &quot;name&quot;: &quot;YOUR PROJECT NAME&quot;, ..., &quot;babel&quot;: { &quot;presets&quot;: [ &quot;es2015&quot; ], &quot;plugins&quot;: [ &quot;transform-runtime&quot; ] }} 上面我們已經完成基本的設定，雖然我們一口氣安裝了很多 loaders 但相關設定我們只先設定了 babel 的部份。到了這一步我們的專案架構已經可以被編譯執行了。 1234# 如果在這一步您想先執行編譯看看可以安裝全域的 webpack$ npm i webpack -g$ webpack$ open index.html # 編譯後檢視內容 編譯之後點擊 index.html 即可以運行。眼尖的讀者可能會好奇，那我們剛剛有裝 vue-loader 那是在幹嘛的？ Part 3 使用 vue-loader 與 .vuevue-loader 的用途是提供一種更方便的組織方式讓我們把元件即一個 component 中需要的 js 行為, css 樣式, template 樣板放在一個 .vue 的檔案中。 1. 修改 view首先讓我們先修改 index.html ，加入 &lt;app&gt; 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Vue.js v2&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;app&gt;&lt;/app&gt; &lt;/div&gt; &lt;script src=&quot;dist/bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2. 匯入元件接著我們在 main.js 把元件 app.vue 加入 components，在這邊我們是反向的推導回去，從想怎麼使用接著反著建立程式檔案。 1234567import Vue from 'vue'import App from './app.vue'new Vue({ el: '#app', components: { App }}) 3. 新增元件最後我們新增一個 app.vue 檔案 123456789101112131415161718192021222324&lt;template lang=&quot;html&quot;&gt; &lt;div&gt; &lt;div class=&quot;message&quot;&gt; {{ message }} &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data () { return { message: 'Helo, Vue.js 2.0' } }}&lt;/script&gt;&lt;style lang=&quot;css&quot;&gt;.message { color: pink; font-size: 1.4em;}&lt;/style&gt; 4. 更新 webpack.config.js這個時候如果直接執行 webpack 編譯會產生錯誤，因為我們還沒設定 webpack.config.js 處理 .vue 檔案的部分 12345678910111213141516171819202122232425262728293031323334353637var path = require('path')var config = { entry: [ 'webpack/hot/dev-server', path.join(__dirname, 'src', 'main') ], output: { publicPath: '/dist/', path: path.join(__dirname, 'dist'), filename: 'bundle.js' }, module: { loaders: [ { test: /\\.js$/, loader: 'babel', exclude: /node_modules/ }, { test: /\\.vue$/, loader: 'vue' } ] }, resolve: { /** * Vue v2.x 之後 NPM Package 預設只會匯出 runtime-only 版本 */ alias: { vue: 'vue/dist/vue.js' }, extensions: ['', '.js', '.vue'] }}module.exports = config 再次執行 webpack 編譯，我們的 app.vue 可以正常運作了。 Part 4 HMR / Hot Reload 如果您有發現修改之後卻沒有改變的問題，請注意關於路徑部分，取得的是編譯後的實體檔案還是 webpack-dev-server 使用記憶體中的內容 Hot Module Replacement 或稱 Hot Reload 是 Javascript 世界中近期很熱門的新技術，簡單的說就是當你在開發時，你一存檔，改寫的部份就即時更新元件到執行環境。大致上流程就是 處於開發 app 階段，撰寫程式碼 打開瀏覽器觀察 app 行為 app 在瀏覽器畫面上運作 當你發現一些 bug 或行為不如您所預期您通常會編輯程式碼，然後重新載入 使用 HRM 時，當你一存檔 webpack 就會偵測那些改變的部分並更新瀏覽器 重點是一些關於狀態的資料並不會被洗掉 要完成這功能，我們會需要 webpack-dev-server 以及套件 vue-hot-reload-api。然後執行。 在這之前，我們需要修改一下 webpack.config.js 加入 webpack/hot/dev-server 123456789101112var webpack = require('webpack')var config = { entry: [ 'webpack/hot/dev-server', path.join(__dirname, 'src', 'main') ], ... plugins: [ new webpack.HotModuleReplacementPlugin() ]} 接著，您可以選擇在全域安裝 webpack-dev-server 12$ npm i webpack-dev-server -g$ webpack-dev-server --inline --hot 又或者使用我們早先已安裝在專案中的 webpack-dev-server，一般來說會建議使用專案相依的這個。 需要在 package.json 加上 scripts 123&quot;scripts&quot;: { &quot;dev&quot;: &quot;webpack-dev-server&quot;} 然後執行： 1$ npm run dev 為了觀察出我們是否有正確的啟用 hot reload 我們修改 app.vue 1234567891011121314151617181920212223242526272829303132333435363738&lt;template lang=&quot;html&quot;&gt; &lt;div&gt; &lt;div class=&quot;message&quot;&gt; {{ message }} &lt;/div&gt; &lt;div&gt; {{ count }} &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data () { return { message: 'Helo, Vue.js 2.0', count: 0 } }, mounted () { this.handle = setInterval(() =&gt; { this.count++ }, 1000) }, destroyed () { clearInterval(this.handle) }}&lt;/script&gt;&lt;style lang=&quot;css&quot;&gt;.message { color: pink; font-size: 1.4em;}&lt;/style&gt; 打開 http://localhost:8080 然後異動 app.vue css 與 template 的部分觀察看看變化。至此我們已經跑完一次基本的用法。 文章剩下的部份則是整理一些 webpack 的指令與設定。 webpack 編譯指令1234$ webpack [source] [destination]$ webpack src/v1.js dist/v1.bundle.js$ webpack bar=./src/v2.js &quot;dist/[name].bundle.js&quot;# &gt;&gt; output dist/bar.bundle.js 12# 指定設定檔$ webpack --config [webpack.config.js] 注意 require 的 path 分成 函式庫 相對路徑 絕對路徑 函式庫：什麼都不加，單純 library name 相對路徑：./ 開頭 絕對路徑：/ 開頭 資源 webpack 令人困惑的地方 - 英 webpack 令人困惑的地方 - 中 補充關於 Babel 一步一步設定 webpack Demo 快速指令流程 &amp; 程式碼片段123456789101112131415161718192021222324252627282930313233$ npm init -y$ npm i webpack -D# Add webpack.config.js# Add scripts to package.json# Setup webpack-dev-server$ npm i webpack-dev-server -D# 由於 prod &amp; dev 會需要不同的設定因此我們需要至少兩份設定檔# 有許多實作方式如下：# 1. 維護多份設定檔，透過 `--config` 指定不同的檔案# 2. 把設定組織成一份 Library# 3. 在一份檔案中依據 `環境` 或 `指令` 套用不同設定# 使用 webpack-merge，合併設定更方便$ npm i webpack-merge -D$ npm i css-loader style-loader -D$ npm i file-loader url-loader -D# 強大のplugin# npm i npm-install-webpack-plugin -D# 安裝處理 ES2015$ npm i babel-core babel-loader babel-plugin-transform-runtime babel-preset-es2015 -D# 加入 .babelrc# 加入 loader 設定# (Optional)安裝 vue-loader$ npm i vue-loader vue-hot-reload-api -D# 安裝 vue 與所需的模組 1234{ &quot;presets&quot;: [&quot;es2015&quot;], &quot;plugins&quot;: [&quot;transform-runtime&quot;]} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374var path = require('path')var webpack = require('webpack')var merge = require('webpack-merge')var precss = require('precss');var autoprefixer = require('autoprefixer');var T = process.env.npm_lifecycle_eventvar common = { entry: { main: path.join(__dirname, 'src', 'main'), venders: path.join(__dirname, 'src', 'venders') }, output: { path: path.join(__dirname, 'dist'), filename: '[name].bundle.js' }, module: { loaders: [ { test: /\\.js$/, loader: 'babel', exclude: /node_modules/ }, { test: /\\.vue$/, loader: 'vue' }, { test: /\\.css$/, loaders: ['style', 'css', 'postcss'] /* include: path.join(__dirname, 'src') */ }, { test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: 'url', query: { limit: 10000, name: path.posix.join(__dirname, 'public', '[name].[hash:7].[ext]') } } ] }, resolve: { extensions: ['', '.js', '.vue', '.json', '.css'] }, postcss: function () { return [precss, autoprefixer]; }}if (T === 'dev' || !T) { var config = merge(common, { devServer: { historyApiFallback: true, hot: true, inline: true, progress: true, stats: 'errors-only', host: process.env.HOST || '0.0.0.0', port: process.env.PORT }, devtool: 'eval-source-map', plugins: [ new webpack.HotModuleReplacementPlugin() ] }) config.entry.main = ['webpack/hot/dev-server', config.entry.main] module.exports = config}if (T === 'build') { module.exports = merge(common, {})} 1234&quot;scripts&quot;: { &quot;build&quot;: &quot;webpack&quot;, &quot;dev&quot;: &quot;webpack-dev-server&quot;}","link":"/2016/10/04/webpack-notes/"},{"title":"[譯] scroll-behavior 滑順的捲動效果","text":"眾所皆知 HTML 錨點(anchor link)透過給定標籤 id 屬性跳到頁面上特定位置的功能。不過這個效果感覺上就像是閃一下就切換到該位置。為了使用體驗上的感覺有時候網站會設計一種平滑捲動到該位置的效果。 在過去這樣的效果通常會透過 jQuery 來達成，但有時候一些簡單的頁面為了達成這個功能就需要載入一堆函式庫或框架這未免有點矯枉過正。最新的 Javascript 提供了一個更有效率，加強原生 window.scrollTo 的方式。 一個標準的錨點已經是一個被廣泛使用的基本技巧: 透過這種方式就算新的 smooth scroll 滑順捲動的語法不被支援就的方法仍然會運作，就是跳到該位置。 123&lt;a href=&quot;#dest&quot;&gt;Click to somewhere&lt;/a&gt;...&lt;p id=&quot;dest&quot;&gt;This is the target&lt;/p&gt; 要注意的是頁面內容要超過可視區域就是至少 scroll bar 要出現，如果瀏覽器已經在畫面上顯示出兩者且沒得捲就沒有效果。因此我們需要在連結和錨點之間補上一些內容。 兩種方式由於 Smooth Scrolling API 有兩種，一種是 CSS, 一種則是 Javascript。也因此造成混亂的原因是部分瀏覽器有支援上不一致。 CSS 的方式非常簡單，只要在該元素設定 scroll-behavior: smooth; 123body { scroll-behavior: smooth;} 注意是 behavior 而不是 behaviour 這個方式非常方便不過目前只有 Firefox 支援，查閱 Can I Use。 Javascript然後是 Javascript 的方式 12345678var anchor = document.querySelector('a[href=&quot;#dest&quot;]')var target = document.getElementById('dest')anchor.addEventListener('click', function (e) { if (window.scrollTo) { e.preventDefault() window.scrollTo({'behavior': 'smooth', 'top': target.offsetTop}) }}) 注意到 window.scrollTo 跟現有的 Javascript 在參數上有些不同，如果你直接用在 Chrome 下，您就會出現參數數量不對的錯誤，所以實務上要應用還是需要額外做些處理。 另外這種方式有一個缺點，那就是我們不能自訂 timing function。 延伸上面的 script 已經可以讓單一的錨點正常的運作，不過這種方式有點面對大量連結的時候有點麻煩。假如我們在這個頁面有幾個錨點都要這功能，那麼我們可以簡單的實作如下。 1234567891011121314151617181920var applyScrolling = function (arr, cb) { for (var i = 0; i &lt; arr.length; i++) { cb.call(null, i, arr[i]) }}// 注意如果有使用 router 那麼自訂一個 class 可以避免一些問題var anchors = document.querySelectorAll(&quot;a[href^='#']&quot;)if (window.scrollTo) { applyScrolling(anchors, function (index, el) { var target = document.getElementById(el.getAttribute('href').substring(1)) el.addEventListener('click', function (e) { console.log(target) e.preventDefault() // 這邊跟新的 method 參數是不同的。 window.scrollTo(0, target.offsetTop) }) })} 譯者小結目前在 Firefox 下兩種方式都可以使用，而 Chrome 則需要額外的開啟設定。本文就是先記錄一下這些新的屬性與 API。 參考 Smooth Page Scroll in 5 Lines of JavaScript","link":"/2016/06/01/smooth-page-scroll/"},{"title":"Node 實作 jwt 驗證 API","text":"基於 token 的驗證機制在今天，我們應該常常能看到大量使用 token 來處理驗證的服務，由於大部分的網站服務開始大量使用 API，於是 token 就成了處理驗證使用者最好的方式。我們的應用程式選擇使用 token 驗證機制有些非常重要的原因，最主要是因為: 對於伺服器來說它具備 stateless(無狀態), scalable(擴展性) 移動裝置也能一併使用 可將驗證結果導向其他應用程式 更安全 誰已經使用 token 驗證機制大多您已經使用的 API 或網站服務已經使用 token 的方式像是 Facebook, Twitter, Google+, Github 等等 為什麼 token 會被大家接受在我們開始了解 token 的運作原理和優點之前我們先來看看過去的做法 Server based authentication 基於伺服器的驗證機制 由於 HTTP 協定是不儲存狀態的(stateless)，這意味著當我們透過帳號密碼驗證一個使用者時，當下一個 request 時它就把剛剛的資料忘了。於是我們的程式就不知道誰是誰，就要再驗證一次。過去我們的應用程式記得使用者的方式就是把資料存放在伺服器。伺服器透過 session 紀錄而儲存有幾種不同的方式，可以被存在記憶體或者是硬碟。 大略的說從 HTTP 是無法保持狀態開始，然後人們因為動態網頁的需求，需要辨別使用者或之前的操作於是有了 cookie 讓客戶端能夠紀錄資訊，在每次請求的時候附上這些資訊以提供伺服器處理。接著基於一些安全性的需求我們透過發放編號 session id的方式，把那些不希望被竄改的資訊存在伺服器記錄。之後透過 session id 來辨別使用者。 本文並非要深入探討舊有的方式所以我們簡單理解 session 會話期間(意義為進行一系列活動/溝通之期間)於網路協議時包含連線 &amp; 維持狀態的行為與資訊就是一種讓我們解決保持狀態問題的方法。 下圖就是伺服器的工作流程。 使用者對伺服器發出內容請求 伺服器回應內容給客戶端 當使用者登入時，伺服器會把登入資料儲存在 session 中，第一次進來的時候伺服器會發放一組號碼牌(session id)給使用者 下次同一個使用者(瀏覽器)再進來的時候，伺服器就可以靠 session id 來判斷這位使用者 這樣的方式陪伴著我們好多年，不過在 web 與 mobile 應用爆發性成長的今日，這樣的方式就顯現出一些問題，尤其是在擴展方面。 伺服器驗證機制的問題其中幾個最主要的問題: sessions: 每一次使用者驗證，必須建立一組紀錄在伺服器上。通常會存在記憶體中，當驗證的使用者越多存放的資料就越多。 擴展性: 由於 session 存在記憶體這就會造成擴展時的問題，當我們使用一些雲端服務增加伺服器執行負載平衡的時候把這些重要的資訊存在記憶體就會受到一些限制。 跨站: 當我們想要讓程式的一些資料交換給其他程式或行動裝置使用的時候就會遇到 cros 跨網域存取的問題。想像一下如果我們需要在一個手機 app 中呼叫原本程式中的 API 就會遇到。 CSRF 偽造跨站請求: 我們仍可能會遇到偽造跨站請求的問題，當使用者已經登入的時候 就可能會遇到這類的攻擊。 不過在這些問題中最大的問題還是屬於擴展性。 token 驗證機制如何運作基於 token 的驗證機制屬於無狀態的方式，我們不並需要在伺服器儲存任何關於使用者的資料。這個概念本身就是為了處理上述的那些問題。少了 session 表示我們的程式在使用負載平衡擴展伺服器時就不用因為這些資料交換的問題而受到限制。 雖然實作有很多種方式，不過大致上流程如下: 使用者提供帳密發出驗證請求 程式驗證憑證 程式提供回傳一個簽署過的 token 給客戶端 客戶端儲存 token ，後續請求都必須要一併包含這個 token 伺服器驗證 token 然後才回傳資料 每一道 request 都要包含 token。這個 token 應該要被包含在 HTTP header 中，也因此這種方式達成了 stateless 的特性。接著我們就可以將伺服器的存取限制設定為 Access-Control-Allow-Origin: *。關於 ACAO header 中設定為 * 同時表示這不允許請求提供憑證例如: HTTP 憑證, 客戶端的 SSL 憑證或 cookie。下圖顯示整個流程 一旦通過驗證我們就會擁有 token，我們就可以透過這個 token 做出許多應用。我們可以基於 token 建立授權甚至是傳遞給第三方應用使用。透過 token 我們就可以決定哪些行為可以放行。 token 的優點最大的好處就是擴展性和 stateless。因為 stateless 的關係我們的程式隨時都可以導入負載平衡。如果我們使用 session 那麼當使用者登入之後要繼續後續的動作就必須要把資料送回同一台伺服器。然後就可能對伺服器造成壓力。一旦採用 token 那麼這些問題就不用再擔心了。 安全性token 不像 cookie，它會在每一次 request 的時候都要帶一次，因為沒有被存放到 cookie 中也就沒有機會被其他客戶端的程式直接存取。甚至是您將 token 儲存在 cookie 中，cookie 也只是一種儲存方式而不是實際驗證機制。 token 也會過期，所以使用者會被要求在登入一次，這協助我們提高安全性。這裡提到 token revocation 的概念，讓我們可以指定某個 token 失效或者是一整組基於同一個授權的 token。 擴展性token 也可以讓我們的程式共享權限。舉例來說我們透過連結到社群平台驗證登入像是 Facebook 或 Twitter。又例如當我們在 Buffer 給予 Twitter 權限那麼我們就可以透過 Buffer 發文到 Twitter 上。使用 token 我們就可以提供特定權限或功能給第三方的應用程式。 跨平台與網域稍早我們提到 CORS，當我們需要增加其他的服務或程式我們就需要提供存取權限給該網域或程式。又比如我們有一個 API 只負責提供資料，這個時候我們或許就會使用 CDN 來處理 CORS 的問題。如果我們可以直接把伺服器的設定換成 1Access-Control-Allow-Origin: * 我們的資料或服務就可以提供給任何網域或程式來使用，當然你會說有安全性的問題，不過別忘了我們現在有 token 協助我們去驗證使用者。 標準關於建立 token 我們有一些選擇。在下面的章節我們會深入關於 API 安全性的議題，不過主要會介紹 JSON Web Tokens 標準。jwt.io提供了一些方便的除錯工具與函式庫支援的圖表。可以看到大部分的語言都有支援。 JSON Web Token 解析近年來 API 盛行不管是 Open Data 等，也就造成一個程式想要充分發揮潛能，常常會需要從其他地方取得資料，與第三方的程式整合。想想 Facebook 提供 API 讓我們可以取得資料和登入功能，Facebook 即所謂提供我們這些第三方應用存取其資料的例子。而這些都是透過 API 完成的。 現在當我們討論到關於我們自己打造自己的 API，不管是誰要完成這件事都需要面對一個問題，那就是如何確保 API 的安全性。上面我們已經探討過基於 toke 的驗證機制。現在我們要來討論的事關於 JSON Web Tokens 這個標準以及我們如何建置它。 JSON Web Token 是啥?JSON Web Tokens 又稱 JWT 發音是 jot 從名字不難看出資料是透過 JSON 傳遞的。這裡有關於 JWT 的規格草稿，不過它並不好讀。JWT 可以在不同的語言中使用包含 .NET, Python, NodeJS, Java, PHP, Ruby, Go, Haskell 等。所以基本上在各種情況下我們都能夠使用。JWT 不相依於其他東西是可以獨立使用的: 它會包含自己所有需要的資料，意味著 JWT 是可以會傳送關於自身的基本資料，一個 payload 通常指的是使用者的資訊以及一個 signature 簽章。 JWT 可以被輕易的傳送: 因為 JWT 自身就包含了必須的資料且不依賴其他東西，因此當我們要透過 API 驗證的時候它可以完美的透過 HTTP header 或者網址來傳遞。 那麼一個 JWT 到底長啥樣?要辨別一個 JWT 非常簡單，它就是三個字串透過 . 合在一起 1aaaaaaaaaa.bbbbbbbbbbb.cccccccccccc 解析一個 JWT我們很容易的就可以看出這是透過 . 連結三個不同的部份它們各自代表的是: header: 標頭資訊 payload: 處理的內容實際資料 signature: 簽章 Headerheader 包含兩個部分 宣告型別是 JWT 使用的演算法，在這個例子中是 HMAC SHA256 1234{ &quot;typ&quot;: &quot;JWT&quot;, &quot;alg&quot;: &quot;HS256&quot;} 一旦將上面的資訊使用 base64encode 我們就會得到第一個部分的 token 1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 你可以拿著上面的 token 去 jwt.io 網站上使用工具試試。 Payload關於 payload 大體來說就是需要處理的實際資料內容，這個 payload 通常會是整個 JWT 中比較重要的資料又稱 JWT Claims 即紀錄這個 JWT 的主張或者說本次傳輸主要的目的，主張是比較抽象的描述但具體來說就是資料。我們將想要傳送的資料和一些附加的資訊放在這裡。Claims 可以不只一個，為了不產生疑義後續我們將使用英文術語 - JWT Claims。 Registered Claims關於 Claims 即傳遞的資料並不是必須的，不過根據規範我們可以使用下面這些預先定義好的 Claims 名稱讓我們可以使用: iss: 發行者的 token sub: 主題的 token aud: 接受者(聽眾)的 token exp: 這可能是 Registered Claims 最常用的，定義數字格式的有效期限，重點是有效期限一定要大於現在的時間 nbf: 生效時間，定義一個時間在這個時間之前 JWT 不能進行處理 iat: 發行的時間，可以被用來判斷 JWT 已經發出了多久 jti: JWT 唯一的識別值，可用來防止 JWT 被重複使用，尤其在一次性的 token 特別好用 Public Claims我們所建立的公開資訊例如使用者姓名等等。 Private Claims發行者與訂閱者自行溝通定義的 Claims Name 與資料 payload 範例下面這個範例有兩個 registered claims(iss 和 exp)以及兩個 public claims(name, admin) 123456{ &quot;iss&quot;: &quot;andyyou.github.io&quot;, &quot;exp&quot;: 1465700328092, &quot;name&quot;: &quot;andyyou&quot;, &quot;admin&quot;: true} 第二部分的 JWT 編譯過後就是 1eyJpc3MiOiJhbmR5eW91LmdpdGh1Yi5pbyIsImV4cCI6MTQ2NTcwMDMyODA5MiwibmFtZSI6ImFuZHl5b3UiLCJhZG1pbiI6dHJ1ZX0 Signature 簽章第三個部分就是簽章，這個簽章由下面三個部分組成 header payload secret 看看範例程式碼便知是如何得到 12var encodedString = base64UrlEncode(header) + '.' + base64UrlEncode(payload)HMACSHA256(encodedString, 'secret') secret 的部分由伺服器持有，也因此伺服器才有辦法驗證 token 和簽發 16srTK4rBbOqlWj7le2hrwFP-iayHblLdhgVFIYU3gVg 最終得到的 JWT 就如同一開始提到的由兩個 . 串接三個編碼 1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhbmR5eW91LmdpdGh1Yi5pbyIsImV4cCI6MTQ2NTcwMDMyODA5MiwibmFtZSI6ImFuZHl5b3UiLCJhZG1pbiI6dHJ1ZX0.6srTK4rBbOqlWj7le2hrwFP-iayHblLdhgVFIYU3gVg 總結來說 JWT 可以跨平台跨語言，讓不同的裝置應用或服務之間溝通，同時這個 token 可以搭配 URL, POST 參數, 或者 HTTP 標頭來傳遞使用。透過 JWT 讓我們可以快速方便的賦予 API 驗證機制。 Nodejs 實作接下來讓我們透過 Node 與 Express 實踐一個簡單的 API 然後透過 POSTman 來測試。這個範例主要的工作流程 個別有公開和需要授權的路由 使用者需要帳密通過驗證取得 token 使用者將 token 儲存在客戶端，之後的每一次請求都將包含此 token 收到請求後會驗證 token ，當 token 正確才回傳資料 建構專案目錄結構首先我們先來看看這個 Node 應用程式的檔案架構，為了單純我們會將大部分的邏輯都寫在 server.js 1234567$ mkdir simple-api$ cd simple-api$ npm init --yes$ mkdir -p app/models$ touch app/models/user.js$ touch config.js$ touch server.js 123456├── app│ └── models│ └── user.js├── config.js├── package.json└── server.js 在實務上您應該盡可能分拆與組織檔案，而不是把全部的邏輯都放在一起。 設定設定 package.json 12345{ &quot;name&quot;: &quot;simple-api&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;main&quot;: &quot;server.js&quot;} 接著安裝我們需要用到的套件與函式庫 1234567$ npm i express body-parser morgan mongoose jsonwebtoken -S# express: 輕量化的 web framework# mongoose: MongoDB 的 ORM 套件，我們使用它來操作資料庫# morgan: HTTP request logger，會於 console 輸出 request 的資訊# body-parser: 協助我們取得 POST request 的資料# jsonwebtoken: 建置/驗證 JWT 設定 Model我們需要定義一個使用者的資料模型 Model，之後會用它來建立使用者資料，這個步驟是因為我們使用 MongoDB 搭配 Mongoose，所以我們要建立 app/models/user.js 來定義 Model, Schema。 12345678var mongoose = require('mongoose')var Schema = mongoose.Schemamodule.exports = mongoose.model('User', new Schema({ name: String, password: String, admin: Boolean})) 應用程式設定檔 (config.js)通常程式會有一些設定的資料像是連線字串, secret 加密字串, 這些資料我們通常會彙整在一個檔案以方便日後調整。 1234567module.exports = { 'secret': 'ilovera', 'database': 'mongodb://localhost/jwt_dev'}// secret: 加密與驗證 token// database: 連線字串 到這一步我們已經完成大部分的前置作業，接著要進入核心部分 server.js Node 應用程式在這一隻檔案中我們將會 載入套件與資料模型等就是我們先前安裝的那些 express, body-parser, morgan 和 Model 的部分 載入與配置設定 建立基本路由 建立 API 路由 POST http://localhost:8080/api/authenticate 確認帳密是否與資料庫吻合，如果正確就回傳 token 這個路由本身不需要驗證 GET http://localhost:8080/api/api 隨機回傳資訊，這個路由需要授權也就是需要 token 才能存取 GET http://localhost:8080/api/users 列出所有使用者，同樣這個路由也需要授權 這支程式的基本功能 12345678910111213141516171819202122232425262728293031// 載入 server 程式需要的相關套件var express = require('express')var app = express()var bodyParser = require('body-parser')var morgan = require('morgan')var mongoose = require('mongoose')// 載入 jwt 函式庫協助處理建立/驗證 tokenvar jwt = require('jsonwebtoken')// 載入設定var config = require('./config')// 載入資料模型var User = require('./app/models/user')var port = process.env.PORT || 8080mongoose.connect(config.database)app.set('secret', config.secret)// 套用 middlewareapp.use(bodyParser.urlencoded({extended: false}))app.use(bodyParser.json())app.use(morgan('dev'))app.get('/', function (req, res) { res.send('Hi, The API is at http://localhost:' + port + '/api')})app.listen(port, function () { console.log('The server is running at http://localhost:' + port)}) 完成檔案之後可以使用 node server.js 來測試，瀏覽 http://localhost:8080 應該要能看到 Hi, The API is at http://localhost:8080/api 的文字。因為我們有使用 morgan 所以應該也要能在 console 看到像 GET / 200 2.846 ms - 43 的資訊。 建立使用者帳號OK! 現在我們的程式能運作了，讓我們先來建立一組帳密。因為我們的主題是要了解 jwt 的運作流程所以這邊為了方便我們直接透過呼叫一個路由 /setup 直接建立一組帳密。在 app.get('/') 路由下面新增一組路由 12345678910111213app.get('/setup', function (req, res) { var andyyou = new User({ name: 'andyyou', password: '12345678', admin: true }) andyyou.save(function (err) { if (err) throw err console.log('User saved successfully') res.json({success: true}) })}) 值得注意的是在正式環境，密碼的部分不應該像上面的作法直接儲存明碼，應要加密。 接著重啟 server node server.js 瀏覽 http://localhost:8080/setup 就會建立使用者。查看資料庫應會如下圖 顯示使用者現在我們可以來實作使用者列表的 API 了，在這一步我們會使用 express.Router() 這麼做的好處是之後我們可以把整包相關的路由掛載到某個前綴路徑上。比如說我們有 /, /users, edit 等路由，透過 app.use('/api', 路由實力物件) 的方式產出 /api, /api/users, /api/edit 1234567891011121314var api = express.Router()// TODO: authenticate// TODO: verify tokenapi.get('/', function (req, res) { res.json({message: 'Welcome to the APIs'})})api.get('/users', function (req, res) { User.find({}, function (err, users) { res.json(users) })})app.use('/api', api); 每一次修改程式碼都需要重啟，不然我們就需要使用像是 nodemon 12$ npm install -g nodemon$ nodemon server.js 剛剛我們加了兩道 API 現在我們可以透過 postman 來測試看看 Imgur Imgur 現在我們可以顯示出列表了但在實務上我們大概都不希望任何人都能存取我們的這些資料，接著就是重點我們要透過驗證來保護這些資料只讓特定的使用者查詢。 驗證機制透過 http://localhost:8080/api/authenticate 路由我們將允許那些通過驗證的人存取，這個過程我們會驗證帳密，然後建立派發 token一旦使用者獲得 token，就會將其暫存在客戶端，之後每一個 request 都需要這個 token。接著伺服器端會透過 middleware 的方式在每個存取的過程驗證。 12345678910111213141516171819202122232425api.post('/authenticate', function (req, res) { User.findOne({ name: req.body.name }, function (err, user) { if (err) throw err if (!user) { res.json({ success: false, message: 'Authenticate failed. User not found'}) } else if (user) { if (user.password != req.body.password) { res.json({ success: false, message: 'Authenticate failed. Wrong password'}) } else { var token = jwt.sign(user, app.get('secret'), { expiresIn: 60*60*24 }) res.json({ success: true, message: 'Enjoy your token', token: token }) } } })}) 接著透過 postman 測試我們剛完成的功能，首先 method 要換成 POST，然後參數的部份要切到 Body 使用 x-www-form-urlencoded。這個步驟我們使用 postman 模擬實際在網頁中送出 post 的過程。可以順便測試一下當密碼錯誤時是否回傳正確的資訊。 Imgur 驗證 token到了這一步我們已經實作了三道路由 /api/authenticate, /api, /api/users。最後的任務自然是要存取的過程時要驗證 token。現在我們需要建立路由的 middleware ，賦予 API驗證機制，其中 /api/authenticate 是不需要被保護的。需要注意的是 middleware 擺放的位置會影響是否要驗證。要驗證的路由必須要 middleware 之後。 12345678910111213141516171819202122232425262728var api = express.Router()// authenticate apiapi.use(function (req, res, next) { var token = req.body.token || req.query.token || req.headers['x-access-token'] if (token) { jwt.verify(token, app.get('secret'), function (err, decoded) { if (err) { return res.json({success: false, message: 'Failed to authenticate token.'}) } else { req.decoded = decoded next() } }) } else { return res.status(403).send({ success: false, message: 'No token provided.' }) }})// Others APIs// /api// /api.usersapp.use('/api', api); 這個過程我們使用 jsonwebtoken 套件來協助我們處理驗證，重要的是那個 secret 要跟我們派發時的一致。經過 middleware 的處理我們就可以判斷使用者是否通過驗證。 測試 middleware經過 middleware 中介軟體的處理我們在 api 的每一道路由(在設定 middleware 之後)都會先執行 middleware。於是我們就在這個過程處理 token 判斷是否要放行。現在我們就可以再次使用 postman 來測試，因為 jwt 的傳遞可以透過 header, body, URL Query 三種方式所以在 postman 中我們可以切換到 GET 然後使用 header 標頭方式來測試 without token Imgur with token Imgur 當然我們也能透過 query string 的方式來通過驗證。通過實作我們大致理解了 API 驗證在 Node 的實作思路，下面附上完整 server.js 程式碼 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899var express = require('express')var app = express()var bodyParser = require('body-parser')var morgan = require('morgan')var mongoose = require('mongoose')var jwt = require('jsonwebtoken')var config = require('./config')var User = require('./app/models/user')var port = process.env.PORT || 8080mongoose.connect(config.database)app.set('secret', config.secret)app.use(bodyParser.urlencoded({extended: false}))app.use(bodyParser.json())app.use(morgan('dev'))app.get('/', function (req, res) { res.send('Hi, The API is at http://localhost:' + port + '/api')})app.get('/setup', function (req, res) { var andyyou = new User({ name: 'andyyou', password: '12345678', admin: true }) andyyou.save(function (err) { if (err) throw err console.log('User saved successfully') res.json({success: true}) })})var api = express.Router()api.post('/authenticate', function (req, res) { User.findOne({ name: req.body.name }, function (err, user) { if (err) throw err if (!user) { res.json({ success: false, message: 'Authenticate failed. User not found'}) } else if (user) { if (user.password != req.body.password) { res.json({ success: false, message: 'Authenticate failed. Wrong password'}) } else { var token = jwt.sign(user, app.get('secret'), { expiresIn: 120 }) res.json({ success: true, message: 'Enjoy your token', token: token }) } } })})api.use(function (req, res, next) { var token = req.body.token || req.query.token || req.headers['x-access-token'] if (token) { jwt.verify(token, app.get('secret'), function (err, decoded) { if (err) { return res.json({success: false, message: 'Failed to authenticate token.'}) } else { req.decoded = decoded next() } }) } else { return res.status(403).send({ success: false, message: 'No token provided.' }) }})api.get('/', function (req, res) { res.json({message: 'Welcome to the APIs'})})api.get('/users', function (req, res) { User.find({}, function (err, users) { res.json(users) })})app.use('/api', api)app.listen(port, function () { console.log('The server is running at http://localhost:' + port)}) 觀察不同套件產生之 Tokenjsonwebtoken 產生的 token 範例 1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyIkX18iOnsic3RyaWN0TW9kZSI6dHJ1ZSwiZ2V0dGVycyI6e30sIndhc1BvcHVsYXRlZCI6ZmFsc2UsImFjdGl2ZVBhdGhzIjp7InBhdGhzIjp7Il9fdiI6ImluaXQiLCJhZG1pbiI6ImluaXQiLCJwYXNzd29yZCI6ImluaXQiLCJuYW1lIjoiaW5pdCIsIl9pZCI6ImluaXQifSwic3RhdGVzIjp7Imlnbm9yZSI6e30sImRlZmF1bHQiOnt9LCJpbml0Ijp7Il9fdiI6dHJ1ZSwiYWRtaW4iOnRydWUsInBhc3N3b3JkIjp0cnVlLCJuYW1lIjp0cnVlLCJfaWQiOnRydWV9LCJtb2RpZnkiOnt9LCJyZXF1aXJlIjp7fX0sInN0YXRlTmFtZXMiOlsicmVxdWlyZSIsIm1vZGlmeSIsImluaXQiLCJkZWZhdWx0IiwiaWdub3JlIl19LCJlbWl0dGVyIjp7ImRvbWFpbiI6bnVsbCwiX2V2ZW50cyI6e30sIl9ldmVudHNDb3VudCI6MCwiX21heExpc3RlbmVycyI6MH19LCJpc05ldyI6ZmFsc2UsIl9kb2MiOnsiX192IjowLCJhZG1pbiI6dHJ1ZSwicGFzc3dvcmQiOiIxMjM0NTY3OCIsIm5hbWUiOiJhbmR5eW91IiwiX2lkIjoiNTc1Y2UxYTBkY2I1NDUwZDFhNzIwZjljIn0sIl9wcmVzIjp7IiRfX29yaWdpbmFsX3NhdmUiOltudWxsLG51bGxdfSwiX3Bvc3RzIjp7IiRfX29yaWdpbmFsX3NhdmUiOltdfSwiaWF0IjoxNDY1NzMxNjU4LCJleHAiOjE0NjU3MzE3Nzh9.toeuSCZ6M0XcjS1p2Tn1h30HQIOQmrBKRsAsgaWvx9g jsonwebtoken token 解析 payload 部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061{ &quot;$__&quot;: { &quot;strictMode&quot;: true, &quot;getters&quot;: {}, &quot;wasPopulated&quot;: false, &quot;activePaths&quot;: { &quot;paths&quot;: { &quot;__v&quot;: &quot;init&quot;, &quot;admin&quot;: &quot;init&quot;, &quot;password&quot;: &quot;init&quot;, &quot;name&quot;: &quot;init&quot;, &quot;_id&quot;: &quot;init&quot; }, &quot;states&quot;: { &quot;ignore&quot;: {}, &quot;default&quot;: {}, &quot;init&quot;: { &quot;__v&quot;: true, &quot;admin&quot;: true, &quot;password&quot;: true, &quot;name&quot;: true, &quot;_id&quot;: true }, &quot;modify&quot;: {}, &quot;require&quot;: {} }, &quot;stateNames&quot;: [ &quot;require&quot;, &quot;modify&quot;, &quot;init&quot;, &quot;default&quot;, &quot;ignore&quot; ] }, &quot;emitter&quot;: { &quot;domain&quot;: null, &quot;_events&quot;: {}, &quot;_eventsCount&quot;: 0, &quot;_maxListeners&quot;: 0 } }, &quot;isNew&quot;: false, &quot;_doc&quot;: { &quot;__v&quot;: 0, &quot;admin&quot;: true, &quot;password&quot;: &quot;12345678&quot;, &quot;name&quot;: &quot;andyyou&quot;, &quot;_id&quot;: &quot;575ce1a0dcb5450d1a720f9c&quot; }, &quot;_pres&quot;: { &quot;$__original_save&quot;: [ null, null ] }, &quot;_posts&quot;: { &quot;$__original_save&quot;: [] }, &quot;iat&quot;: 1465731658, &quot;exp&quot;: 1465731778} ** jwt-simple token sample** 1eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJfaWQiOiI1NzVjZTFhMGRjYjU0NTBkMWE3MjBmOWMiLCJuYW1lIjoiYW5keXlvdSIsInBhc3N3b3JkIjoiMTIzNDU2NzgiLCJhZG1pbiI6dHJ1ZSwiX192IjowfQ.pZ3KHGGZwjgDryrLrAzKkfmTv4xJbekQGX3UCe8Fm1Q ** jwt-simple token 解析 payload** 1234567{ &quot;_id&quot;: &quot;575ce1a0dcb5450d1a720f9c&quot;, &quot;name&quot;: &quot;andyyou&quot;, &quot;password&quot;: &quot;12345678&quot;, &quot;admin&quot;: true, &quot;__v&quot;: 0} 小結透過上面的實作，我們對於 jwt 和如何實作有了基本的理解。 參考資料來源 The Ins and Outs of Token Based Authentication The Anatomy of a JSON Web Token Authenticate a Node.js API with JSON Web Tokens Build an App with Vue.js: From Authentication to Calling an API Session 介紹 使用 JWT OAuth 2.0 筆記 Postman 使用筆記","link":"/2016/06/09/implement-jwt-with-understanding/"},{"title":"手把手深入理解 webpack dev middleware 原理與相關 plugins","text":"本文將對 webpack 周邊的 middleware 與 plugin 套件等作些介紹，若您對於 webpack 還不了解可以參考這篇彙整的翻譯 webpack dev server 是什麼?webpack dev server 是一個開發伺服器，內建 webpack 使用的 live reloading 功能。 那 webpack dev middleware 是啥?它就是一個用來組織包裝 webpack 使其可以變成中介軟體，或稱中間件的容器。回想一下 express 你大概可以明白關於 middleware 的用途，就是在輸入到輸出的過程中 加工 的一種手段。單純說 middleware 的話我們可以想成一系列任務, 動作(actions stack)，不只 express 有，在 Ruby 中的 rake 也具備這種機制。 先看看web dev server的說明 The webpack-dev-server is a little node.js Express server, which uses the webpack-dev-middleware to serve a webpack bundle. 從頭說起的話就是 webpack 本身只負責打包編譯的功能 bundle, webpack-dev-server 當然就是協助我們開發的伺服器，這個伺服器底層是靠 express 來實作的，接著思考一下我們要如何更新(live reload)呢? 當然是需要取得 webpack 編好的資料啊，於是就需要在從 request 到 response 的過程中透過 express 的 middleware 取得資料，而方法就是透過 webpack-dev-middleware 。 比起直接編譯成檔案，webpack-dev-middleware 這個套件還多了一些好處: 不需要一直寫入磁碟，所有產生的結果會直接存在記憶體 在監視模式(watch mode)下如果檔案發生異動，middleware 會馬上停止提供舊版的 bundle 並且會延遲請求的回應直到編譯完成，如此一來我們就不需要去觀察編譯是否結束了 webpack hot middleware 是什麼?我們都知道 webpack dev server 有提供一種Hot Module Replacement/Hot Reloading 熱替換的功能。在一般 webpack-dev-server 的時候我們會在 webpack.config.js 加入 new webpack.HotModuleReplacementPlugin() 或設定來啟用。而 webpack hot middleware 是給 webpack-dev-middleware 用的。就是讓我們在一般的 server 上加上熱替換的功能，總結來說就是 webpack-dev-middleware + webpack-hot-middleware 即可讓我們用 express 客製一個有熱替換功能的 webpack 開發伺服器。 使用 webpack-dev-server 當中介軟體webpack 提供了 express 的 middleware 讓我們可以處理一些靜態資源檔而不是使用 express.static。要達成這項功能，我們需要安裝 webpack-dev-middleware 和 webpack-hot-middleware 1$ npm i webpack express webpack-dev-middleware webpack-hot-middleware -D 安裝完成套件之後，首先我們需要設定一個 webpack.dev.config.js 檔案，並且在 entry 中加上 webpack/hot/dev-server 和 webpack-hot-middleware/client 12345entry: [ 'webpack/hot/dev-server', 'webpack-hot-middleware/client', 'client/index.js'] 這個 webpack.config 主要是給開發伺服器用的，由於這時的匯出都會存在記憶體中，因此 path 可以直接設為根 12345output: { path: '/', publicPath: 'http://localhost:8080/scripts/', filename: 'bundle.js'} 最後補上任何您所需要的 loaders，最重要的是記得。 123plugins: [ new webpack.HotModuleReplacementPlugin()] 接著下來我們開始來撰寫這個開發環境的設定檔和 express 程式。我們會匯入 webpack，webpack-dev-middleware， webpack-hot-middleware 和 express。 若需要搭配樣板引擎請自行安裝 ejs 或 jade 1234var express = require('express')var webpack = require('webpack')var WebpackDevMiddleware = require('webpack-dev-middleware')var WebpackHotMiddleware = require('webpack-hot-middleware') 載入套件之後，使用 express 建立一個 http 應用程式與路由 12345app = express()router = express.Router()router.get('/', MainController)app.use(router) 上面只是一個一般的 Server 應用，為了達成 webpack 的神奇黑魔法我們需要匯入 webpack 的設定 1var config = require('./webpack.dev.config') webpack 的角色就是我們的編譯器，透過下面的程式碼建立編譯器的 instance 1var compiler = webpack(config) 重點來了，我們有了伺服器 express，有了編譯核心 webpack，接著我們需要 wrapper 來打包 webpack 將其合進 express 的 middleware stack 中。 1234app.use(WebpackDevMiddleware(compiler, { publicPath: config.output.publicPath, stats: { colors: true }})) publicPath 就是我們想要存取前端 bundle 的網址，路徑，位置。然後我們要再加上 webpack-hot-middleware 使其具備熱替換的功能。 123app.use(WebpackHotMiddleware(compiler, { log: console.log})) 最後則是 express 的監聽事件 123app.listen(8080, function () { console.log('Listening on 8080')}) 完整的 server 程式碼如下 123456789101112131415161718192021222324252627var express = require('express')var webpack = require('webpack')var WebpackDevMiddleware = require('webpack-dev-middleware')var WebpackHotMiddleware = require('webpack-hot-middleware')var config = require('./config/webpack.dev.config')var compiler = webpack(config)app = express()app.set('views', './views')app.set('view engine', 'ejs')app.use(express.static('public'));app.use(WebpackDevMiddleware(compiler, { publicPath: config.output.publicPath, stats: { colors: true }}))app.use(WebpackHotMiddleware(compiler))var router = express.Router()router.get('/', function (req, res, next) { res.render('index', { message: 'Hey there!'});})app.use(router)app.listen(8080, function () { console.log('Listening on 8080')}) 換個思路假設我們並不是要實作一個全站 SPA 的站，實務上我們的確會遇到需要拆分為許多 view .html 的狀況，這種情況下我們會希望自己客製的這個 server 就像 webpack-dev-server 一樣，當然，這邊只是要指出做法，如果一樣您當然就直接用 webpack-dev-server 就好了。 根據上面這個需求最簡單的方式就是透過 express.static(__dirname) 讓 express 直接 return raw 檔案。 html-webpack-plugin小弟認為在學習的過程中，最重要的就是搞懂動機，而這個 html-webpack-plugin 插件，其用途就是簡化建立 html 的過程。先回頭看看上一小節，很直覺的，我們會依據需求建立不同的頁面(.html)，因為在開發過程中很多時候前端只需要注重那些互動介面的邏輯，樣式，樣板，標籤結構 ，那我們的重點只有 client 端的 html, js, css 就不在話下了吧！再如果我們又以元件為思路中心來設計實踐的話，那麼 html 裡面大部分的東西都會往元件的 template 搬。依據 SPA 的思路，html 的責任就只是把我們的 bundle 載入並掛載 root component。 如果照著這樣的想法，不斷的新增 html 結果大部分的內容都是重複的那就不太靠譜啦。我們就需要一種簡化工作的方式。 這個套件如上面所說就是簡化建立載入 bundle 的 html的步驟，用在 webpack 打包的檔案包含每次編譯都會更新的 hash 時特方便。我們可以讓套件幫我們產生 html 或者搭配 loaders 與其他樣版引擎。 基本的用法第一種最簡單的用途就是為我們的 bundle 包上一層 html 12345plugins: [ new HtmlWebpackPlugin({ filename: 'i_love_this_file.html' })] 如果我們有多個 entry 進入點，那麼所有的 bundle 都會被加進這個自動產生的 HTML 中。如果我們透過 webpack 匯出了 css 資源檔(例如 extract-text-plugin) 那麼這些檔案也會透過 &lt;link&gt; 被加入 HTML 中。 html-webpack-plugin 的設定當然這個套件也有一些參數，讓我們可以透過設定提供其他的功能。 title: 設定該 html 的 &lt;title&gt; 標籤 filename: html 檔名，也當作路徑存取。預設是 index.html template: 樣板的路徑，也就是說我們可以先組織 HTML 在載入讓 html-webpack-plugin 幫我們注入(inject) bundle。此部分要注意相對路徑是從 server 程式檔案出發。 inject: 將所有的資源檔注入 template 或 templateContent，當值是 true, 'body' 的時候所有的 js 資源檔都會被注入 &lt;/body&gt; 之前，'head' 則是 &lt;head&gt; 之間，false 自然就是關閉 true: Boolean false: Boolean head: String body: String favicon: 替 HTML 加上 favicon 路徑 minify: 傳入 html-minifier 參數物件，壓縮輸出。 options: Object false: Boolean hash: true 時替 webpack 編譯的檔案或結果路徑結尾補上 hash，這麼做的用意是在開發時期當檔案有異動時可以避免瀏覽器快取 true: Boolean false: Boolean cache: 預設是 true 快取檔案，除非檔案有異動 true: Boolean false: Boolean showErrors: 預設 true 例外或錯誤資訊會寫入 html 頁面 true: Boolean false: Boolean chunks: 允許我們加入一些程式碼片段，例如單元測試 chunksSortMode: 控制 chunks 排序 none: String auto: String dependency: String {}: Function excludeChunks: 略過部分 chunk 程式碼片段 xhtml: 設定為 true 的話 link 標籤會是 self-closing ，預設是 false true: Boolean false: Boolean 腦力激盪 - 如果要多個頁面搭配各自的 bundle?webapck 難就難在其靈活之中伴隨著複雜，不同的思路有著不同的做法。這一小節目的是為了不讓我們對 webpack 使用上僵化而提出的一個小題目。 要達成這個需求，我們可以先使用 webpack.config 中 [name] 的功能拆分我們的 bundle 12345678910{ entry: { a: './path/src/a', b: './path/src/b', c: './path/src/c' }, output: { filename: '[name].bundle.js' }} 接著透過 html-webpack-plugin 的參數，把 inject: false 然後 template 在各自的 template 中使用 bundle。 html-webpack-template - 更牛的方式照著上面的方式你可能又跟我抱怨，那不是又要產一堆 HTML 了嗎? 對啊！原本這個架構就是針對 SPA 設計的嘛。不過透過這樣來來回回的思考動機與流程我相信對於您日後使用 webpack 與閱讀設定有很大的幫助。現在的問題是 - 你覺得產一大堆 HTML 不是很靠譜，於是我們就有了 html-webpack-template 的產生啦 這個東西大略的用法就是 123456789101112131415161718192021plugins: [ new HtmlWebpackPlugin({ title: 'Sample', filename: 'sample.html' }), new HtmlWebpackPlugin({ inject: false, // 必須 template: require('html-webpack-template'), // 必須 filename: 'sp.html', // 存取的路徑 // 只需要特定 bundle 可以這樣設定 chunks: ['vender'], title: 'OH My Gosh', // 可以參考 html-webpack-template 的參數設定 // 下面為提供 GA googleAnalytics: { trackingId: 'UA-XXXX-XX', pageViewOnLoad: true } })] html-webpack-plugin 事件特地介紹此套件的事件也是因為挺有可能會需要一些時間點對 html 動些手腳，有了事件的機制我們就可以讓其他套件修改產生的 html 非同步事件: html-webpack-plugin-before-html-generation html-webpack-plugin-before-html-processing html-webpack-plugin-after-html-processing html-webpack-plugin-after-emit 同步事件: html-webpack-plugin-alter-chunks 大略的用法就是在透過 hook event 綁定的事件做些處理 12345678compiler.plugin('compilation', function(compilation) { console.log('The compiler is starting a new compilation...'); compilation.plugin('html-webpack-plugin-before-html-processing', function(htmlPluginData, callback) { htmlPluginData.html += 'The magic footer'; callback(null, htmlPluginData); });}); webpack-hot-middlewarewebpack-hot-middleware 這個套件只能搭配 webpack-dev-middleware 使用，其實就是把熱替換的功能加到一般 server 應用。這個模組只專注在處理 webpack 和瀏覽器溝通的機制。這個中介軟體會去訂閱監聽開發伺服器，當更新或異動發生的時候它就透過 webpack 的 HMR API 來更新。實際上讓您的程式能無縫的使用熱替換已超過本文範圍，在這部分通常會靠其他模組來處理。 安裝完套件與在伺服器 app 中套用之外，要記得 webpack.config 的 plugin 也要加上 HotModuleReplacementPlugin 12345678plugins: [ // Webpack 1.0 new webpack.optimize.OccurenceOrderPlugin(), // Webpack 2.0 fixed this mispelling // new webpack.optimize.OccurrenceOrderPlugin(), new webpack.HotModuleReplacementPlugin(), new webpack.NoErrorsPlugin()] 簡短地介紹一下 OccurrenceOrderPlugin 部份，您應該知道 webapck 會給編譯好的程式碼片段一個 id 以用來辨別。透過上面的這個 plugin 可以讓 webpack 在 id 的分派上優化並保持一致性。 接著要在 entry point 加上 webpack-hot-middleware/client 這隻檔案會連到 server 目的是當 server 重新編譯好檔案時收到通知然後更新 client 的檔案。 如何撰寫 plugin為什麼要了解怎麼寫 plugin 呢? 因為某些 plugin 可以擴展支援其他 plugin 相互傳遞資料或需要客製後續任務，所以稍微明白 plugin 的寫法可以讓我們對於 plugin 的設定更加清楚。 plugin 的架構設計促使第三方開發者讓 webpack 核心發揮出無限的潛力。在不同建置階段執行 callback ，開發者可以自訂出特有的行為。當然建置 plugin 比起開發 loader 是較進階的議題，因為我們必須要理解 webpack 內部的一些 hook 事件 編譯器與編譯結果要開發 plugin 第一步就是先了解其中最重要的兩個角色 compiler 和 compilation 物件 compiler 編譯器物件代表一個完整設定的 webpack 環境。這個物件在 webpack 發動之後就會被建置，而且只會建置一次。然後它會配置所有可以操作的設定包含 loaders, plugins。當我們套用一個 plugin 這個 plugin 會收到 compiler 的參考透過存取這個參考 reference就可以取得 webpack 環境 compilation 編譯成果這個物件代表的是某個版本的編譯後的資源檔，在運行 webpack dev middleware 期間每當檔案發生異動就會產生一個新的 compilation 也就是產生新的編譯結果。這個編譯結果包含的訊息包含 module 模組的狀態，編譯後的資源檔，發生異動的檔案，被觀察的相依套件等。這個編譯結果物件也提供一些執行 callback 的機會讓我們可以在過程中客製一些自己想要的行為。 任何 webpack plugin 都必須依靠這兩者來完成，所以有需要對其原始碼有些大概的了解 Compiler Source Compilation Source 基本 plugin 架構本質上來說 plugin 只是一個物件實例具有 apply 方法，這個 apply 會在安裝時期被 webpack compiler 執行一次。透過這一次的執行呢我們就可以繫結許多事件，直接來看看程式碼您就明白了。 1234567891011121314151617181920function MyPlugin(options) { // 設定參數 this.options = options}MyPlugin.prototype.apply = function(compiler) { compiler.plugin('done', function() { // 當 plugin 安裝完成就會... console.log('Hello World!'); }) // 我們自然需要拿到編譯的結果 compiler.plugin(&quot;compilation&quot;, function(compilation) { console.log(compilation.assets) compilation.plugin(&quot;optimize&quot;, function() { console.log(&quot;Assets are being optimized.&quot;); }); });} OK! 我們現在並不是要開發套件所以點到這邊我想就足夠了，剩下的您可以自行參考相關文件。 text.forEach is not a function 詳細 plugin API extract-text-webpack-plugin顧名思義這個 plugin 的用途就是把 text 類型的結果匯出成一個檔案，先說這不是非常精確的描述，但概念來說 text 類型指的就是不會輸出成 module.exports 或 json 的資料。而像是 CSS 這類的資源檔 webpack 其實最終就是在 JS 中幫我們建個 style tag 的 dom 然後整包放進去。file-loader, raw-loader 等等這類內容大略就屬於 text 類型。查閱各種 loaders 回傳資料類型 於是乎以 entry point 為單位過程中解析的 text 內容就會被抽出來匯出成一個檔案。最常見的用法就是把 css 抽出來: 12345678910111213var ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;)module.exports = { module: { loaders: [ { test: /\\.css$/, loader: ExtractTextPlugin.extract(&quot;style&quot;, &quot;css&quot;) } ] }, plugins: [ // 注意: 這邊的副檔名如果亂下是會造成瀏覽器行為不符合預期的，例如不給副檔名那瀏覽器就會當作 binary 下載 new ExtractTextPlugin(&quot;styles.css&quot;) ]} 如果想要拆分多個檔案，那麼就先初始化 instance 12345678910111213141516171819let ExtractTextPlugin = require('extract-text-webpack-plugin');// multiple extract instanceslet cssExtractor = new ExtractTextPlugin('stylesheets/[name].css');let lessExtractor = new ExtractTextPlugin('stylesheets/[name].less');module.exports = { module: { loaders: [ {test: /\\.scss$/i, loader: cssExtractor.extract(['css','sass'])}, {test: /\\.less$/i, loader: lessExtractor.extract(['css','less'])}, ... ] }, plugins: [ cssExtractor, lessExtractor ]} HMR 熱替換Hot Module Replacement (HRM) 又稱熱替換，功能就是在程式運行中交換，移除，增加模組且不會使頁面重新載入。這跟我們伺服器的熱插拔差不多概念。 它是怎麼運作的?webpack 在 bundle 中即我們的 js 裡加入了一個小型的 HMR 執行環境，在編譯過程中這個 runtime 會在我們的 app 中運行。當建置完成時 webpack 也不會消失反而會持續存在，繼續監控原始碼檔案是否發生修改。一旦 webpack 發現程式有改變他就會去重新編譯那些有修改的模組，不全部重建。根據設定要嘛就是 webpack 把訊號丟給 HRM runtime 要嘛就是 HRM 自己更新異動資訊。不管哪種方式反正重點就是 HRM runtime 會取得修改的模組，接著就試著在運行的狀態下更新模組。首先會先檢查更新的模組是否能 self-accept。 關於 self-accept 先看看範例和原始碼，意思是要支援熱替換的模組或說編譯結果基本上是應該要實作 module.hot.accept 和遵循其他熱替換的規則。如果沒有辦法自己確認自己可以直接被更新，那就往上傳，通知那些 require 匯入使用自己的模組更新，就這樣層層往上。直到有人可以 accept 或到頂，不過一旦到根就表示熱替換失敗。 讀到這邊你可能通了，為什麼當我們要讓 React 支援 Hot Mode 的時候需要一個 react-hot-loader。以及因為要和 HRM 執行環境溝通的關係我們需要在 bundle 的 entry point 加上 webpack/hot/dev-server, webpack-hot-middleware/client 之類的東西。 從 App 的角度 當 App 程式開始執行(就是載入 bundle) HMR runtime 執行環境就會啟用，接下來程式就會要求 HMR runtime 幫我們檢查是否需要更新。HMR 會幫我們下載更新然後通知 App 程式有哪些更新可用。 從編譯器(webpack/compiler)的角度除了一般的資源檔像是圖片，css，編譯器還需要觸發更新事件讓程式碼可以完成新舊替換。這個”更新”包含兩個部分 更新的 Manifest 支援配置文件(json) 一或多個更新的chunks程式片段(js) 支援配置文件包含更新後編譯結果的 hash 和新的 chunks 程式碼片段的列表。而新的 chunks 則包含更新後模組的程式碼或 flag編譯器同時也會確保模組和片段 ID 是一致的，透過一個 records 的 json 檔案來儲存相關資訊。 從模組角度HMR 是選擇性的功能，所以只有在模組包含 HRM 程式碼才會被影響作用。也就是在模組中使用文件有提供的 API。一般來說模組的開發者 handler 會在模組相依的部分更新時被執行。當然也可以寫一個 handler 在這個模組更新時被呼叫。在大部分的情況並不需要為每一個模組都撰寫支援 HMR 的程式碼，當一個模組沒有遵循處理規則時就會往上層傳遞事件，意味著只有上方有一個 handler 可以處理就好，但不要讓這個冒泡事件一路冒到頂喔。 從 HMR runtime 角度模組系統的執行環境其實是額外加入的程式，用來追蹤模組之間的父子關係。 123if(module.hot) { ...} 從管理的角度，這個執行環境 runtime 支援 check 和 apply 兩個方法。check 的功能是發出 HTTP request 用來取得上面提到的 Manifest，當 request 失敗時就等於沒有任何更新。否則就會依照得到的更新列表去比對 chunks。對每個已載入的 chunk 都會有對應更新的程式碼要被下載。所有模組更新會被存在 runtime 中準備拿來更新。當執行環境切換成 ready 狀態就表示更新的程式碼都被下載完成了隨時可以套用。 接著 apply 方法會將所有已更新的模組的 flag 標記為 invalid 無效，然後無效的模組需要 update 的 handler 處理函式，這個 handler 會在模組中或者父節點上。只要沒有這個 handler 就會持續往上曾傳遞並標註為 invalid，一旦冒泡機制冒到頂端即 entry point 就表示熱替換失敗。 所有被標記為無效的模組都會透過 module.hot.dispose 卸載，然後更新 hash，再來所有 module.hot.accept 的 handlers 會被調用。執行環境切回 idle 狀態表示所有更新都完成了。 講這麼多其實簡單來說就是我們的模組要補一些 hot mode 的邏輯 123456789101112var app = require(&quot;./app&quot;);// 模擬每 5 秒更新一次setInterval(function() { console.log(app(new Date()));}, 5000);if(module.hot) { module.hot.accept(&quot;./app&quot;, function() { app = require(&quot;./app&quot;); });} 檔案的更新流程左邊表示初始化時編譯器產生的結構，右邊則是當模組 4 和 9 更新時的流程。方塊表示從 Entry 開始，webpack 幫我們編譯產生的部份從 Entry 然後轉換成 Chunk 0 - 4 資源參考 html-webpack-plugin webpack dev middleware 說明","link":"/2016/05/30/webpack-dev-middleware-in-express/"},{"title":"Vue 實作簡易驗證機制 App","text":"為了顯示出 Vue.js 強大的能力 ，本文將會逐步指導建置一個簡單的前端應用程式。搭配 Node 所建置的後端程式範例。前後端兩個程式是完全分離的，後端使用 RESTful API 的方式負責取得資料與驗證。本文旨在說明如何替 Vue.js 程式加上驗證機制，過程中我們會使用 vue-router, vue-resource 實作 Login 與 Signup 元件展示如何檢索和儲存使用者的 jwt token，最後執行驗證機制取得那些需要授權的資料。 安裝與設定首先從組織前端程式開始，讓我們先來建立專案： 123$ mkdir auth-front-app$ cd auth-front-app$ npm init --yes 安裝我們所需要的 npm 套件，我們會在這個專案使用 Babel, Webpack 負責建置工具的部份： 123$ npm i babel-core babel-loader babel-plugin-transform-runtime babel-preset-es2015 babel-runtime css-loader style-loader vue-hot-reload-api vue-html-loader vue-style-loader vue-loader webpack webpack-dev-server -D$ npm i bootstrap vue-resource vue-router vue -S package.json 如下： 1234567891011121314151617181920212223242526272829303132{ &quot;name&quot;: &quot;auth-front-app&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;keywords&quot;: [], &quot;license&quot;: &quot;MIT&quot;, &quot;devDependencies&quot;: { &quot;babel-core&quot;: &quot;^6.10.4&quot;, &quot;babel-loader&quot;: &quot;^6.2.4&quot;, &quot;babel-plugin-transform-runtime&quot;: &quot;^6.9.0&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.9.0&quot;, &quot;babel-runtime&quot;: &quot;^6.9.2&quot;, &quot;css-loader&quot;: &quot;^0.23.1&quot;, &quot;style-loader&quot;: &quot;^0.13.1&quot;, &quot;vue-hot-reload-api&quot;: &quot;^1.3.3&quot;, &quot;vue-html-loader&quot;: &quot;^1.2.3&quot;, &quot;vue-loader&quot;: &quot;^8.5.3&quot;, &quot;vue-style-loader&quot;: &quot;^1.0.0&quot;, &quot;webpack&quot;: &quot;^1.13.1&quot;, &quot;webpack-dev-server&quot;: &quot;^1.14.1&quot; }, &quot;dependencies&quot;: { &quot;bootstrap&quot;: &quot;^3.3.6&quot;, &quot;vue&quot;: &quot;^1.0.25&quot;, &quot;vue-resource&quot;: &quot;^0.8.0&quot;, &quot;vue-router&quot;: &quot;^0.7.13&quot; }} 安裝完套件之後就是專案目錄下新增 webpack.config.js 設定檔： 1234567891011121314151617181920212223242526272829var path = require('path')module.exports = { entry: ['./src/index.js', './src/auth/index.js'], output: { path: path.join(__dirname, 'dist'), filename: 'bundle.js' }, module: { loaders: [ { test: /\\.vue$/, loader: 'vue' }, { test: /\\.js$/, loader: 'babel', exclude: /node_modules/ } ] }, /** * option: 您可以選擇把下面這段設定置於 .babelrc */ babel: { presets: ['es2015'], plugins: ['transform-runtime'] }} 設定檔中首要的就是我們程式的進入點，我們設定了 src/index.js 和 src/auth/index.js 這兩支程式，最後會被輸出成 bundle.js。到這一步先別擔心我們還沒完成任何程式，習慣上小弟我會先構想整個專案架構，透過組織 webpack.config 可以讓我們先好好思考一下。 因為我們想使用 vue 元件 的方式組織程式碼。於是設定了負責處理 .vue 的部分，即 vue-loader 協助編譯。到此便是我們目前所需的設定，最後我們只要透過 webpack-dev-server --inline --hot 就可觀察開發的前端程式。 Module not found: Error: Cannot resolve 因為到目前為止我們只是預先規劃兩隻進入點的程式還沒實作，所以執行 webpack-dev-server 會產生錯誤。 設定後端程式因為本篇文章主要是要討論關於 Vue.js 處理驗證機制的作法，所以我們在後端部分採用 nodejs-jwt-authentication-sample。使用概略如下： 12345678910111213141516171819# 記得切換到另外的目錄$ git clone git@github.com:auth0-blog/nodejs-jwt-authentication-sample.git$ cd nodejs-jwt-authentication-sample$ npm install# 啟動後端程式$ PORT=3001 node server.js# 建立使用者 POST /users# 注意：username 和 password 必須替換$ curl -d &quot;username=[replace_me]&amp;password=[replace_me]&quot; http://localhost:3001/users# 建立成功應會回傳 { &quot;id_token&quot;: &quot;...&quot; }# 登入 POST /sessions/create$ curl -d &quot;username=[replace_me]&amp;password=[replace_me]&quot; http://localhost:3001/sessions/create# 登入成功應會回傳 { &quot;id_token&quot;: &quot;...&quot; }# 不需授權 API: http://localhost:3001/api/random-quote# 受保護 API: http://localhost:3001/api/protected/random-quote 注意這個後端範例的帳號資料會放在記憶體中，重啟就會消失。 配置 Vue 元件現在可以來替我們的應用程式建置元件。在專案配置一節我們安裝與使用了 vue-loader 然後提到它讓我們可以使用 .vue 的方式來撰寫元件。具體來說就是我們在一隻 [component_name].vue 的檔案中分別撰寫 &lt;template&gt;, &lt;script&gt;, &lt;style&gt; ，最終這隻檔案會被輸出成一個元件供我們組合或使用。 123# 在專案目錄下$ mkdir -p src/components$ touch src/components/Home.vue Home 元件主要透過 API 去得不須授權的資料並顯示 src/components/Home.vue 元件程式碼如下 123456789101112131415161718192021222324252627282930&lt;!-- src/components/Home.vue --&gt;&lt;template&gt; &lt;div class=&quot;col-sm-6 col-sm-offset-3&quot;&gt; &lt;h1&gt;取得不需授權的 Chunck Norris 名言&lt;/h1&gt; &lt;button class=&quot;btn btn-primary&quot; @click=&quot;getQuote&quot;&gt;取得名言&lt;/button&gt; &lt;div class=&quot;quote-area&quot; v-if=&quot;quote&quot;&gt; &lt;h2&gt;&lt;blockquote&gt;{{quote}}&lt;/blockquote&gt;&lt;/h2&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data () { return { quote: '' } }, methods: { getQuote () { this.$http.get('http://localhost:3001/api/random-quote') .then((res) =&gt; { this.quote = res.data }) .catch((err) =&gt; { console.log(err) }) } }}&lt;/script&gt; &lt;template&gt; 裡的就是我們要顯示的 HTML 標籤結構，裡面有一個按鈕用來呼叫 getQuote，還有一些看起來像 Angular 1.x 的特殊屬性，它們是 Vue 的 directive，像是 @click, v-if 這些都是，而 @click 又可以寫成 v-on:click 當點擊的時候會觸發我們綁定的事件(從 methods 來)，v-if 可以根據綁定的資料 quote 來決定 &lt;div class=&quot;quote-area&quot;&gt; 是否要輸出顯示。當然 Vue 也可以在樣板中使用 { {} } 的語法用來作資料綁定(從 data 來)。 &lt;script&gt; 的部分會匯出一個 JS 物件，接著會被 Vue 轉換為一個 Vue 元件。大體來說 data 可以提供我們作資料繫結，methods 可以協助我們綁定一些互動的事件。getQuote 中的 this.$http 則是從 vue-resource 中加入的功能。 目前為止程式仍無法運作，不過我們簡單的介紹了一個 .vue 元件長啥樣和一些語法的作用。詳細的用法還是需要花點時間閱讀手冊。 主程式 index.js 和 App.vueindex.js 是程式主要的進入點，我們會在這邊匯入元件，設定路由等等等。為了單純起見，整個程式所有需要的設定都會放在這隻檔案中。 新增 src/index.js 1234567891011121314151617181920212223242526272829303132333435363738394041import Vue from 'vue'import App from './components/App.vue'import Home from './components/Home.vue'import SecretQuote from './components/SecretQuote.vue'import Signup from './components/Signup.vue'import Login from './components/Login.vue'import VueRouter from 'vue-router'import VueResource from 'vue-resource'// 替 Vue 掛上 HTTP Request 的功能Vue.use(VueResource)// 替 Vue 掛上路由的功能Vue.use(VueRouter)// export 是為了讓其他分離的程式碼也能取得路由的物件實例export var router = new VueRouter()// 定義路由router.map({ '/home': { component: Home }, '/secretquote': { component: SecretQuote }, 'login': { component: Login }, 'signup': { component: Signup }})router.redirect({ '*': '/home'})auth.check()// 啟動路由並將 root component 掛載到 HTML 中 id=&quot;app&quot; 的 DOM 上router.start(App, '#app') 現在我們匯入了一些 Vue 元件大致上讓我們理解該怎麼使用元件與 vue-router，但注意到我們還未實作任何程式碼。 vue-router 和 vue-resource 需要透過 Vue.use() 將功能附加到 Vue 中。同時我們也定義了一些路由，理解 vue-router 中一個路由可以對應一個元件。 接著我們便可以開始完善這些元件。第一個是我們的根元件 App.vue 1234567891011121314151617181920212223&lt;!-- src/components/App.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;!-- 注意：少了最外層的 wrapper 會出現 Attribute &quot;id&quot; is ignored on component 警告 --&gt; &lt;nav class=&quot;navbar navbar-default&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li&gt;&lt;a v-link=&quot;'home'&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a v-link=&quot;'login'&quot;&gt;Login&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a v-link=&quot;'signup'&quot;&gt;Signup&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a v-link=&quot;'secretquote'&quot;&gt;Secret Quote&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a v-link=&quot;'login'&quot;&gt;Logout&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/nav&gt; &lt;div class=&quot;container&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 在 App.vue 元件中我們組織了最外層的結構，我們需要一個 navbar 來切換，而更換的元件會顯示在 &lt;router-view&gt;&lt;/router-view&gt; 位置。切換頁面的連結只要使用 v-link 屬性即可。最後我們需要一個 index.html 來載入 bundle.js 以及 app 的掛載點。 注意到 v-link 中的 &quot;'home'&quot;，v-link 有三種設定方式請參考說明文件 新增 index.html 1234567891011121314&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Authenticate Vue App&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;node_modules/bootstrap/dist/css/bootstrap.min.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 到這一步如果您很著急想看看到底實作了些什麼，您可以先把 webpack.config 中的 src/auth/index.js 移除並在 src/index.js 把還沒實作的元件註解。 執行 webpack-dev-server --inline --hot 應該可以看到如下圖 驗證機制為了讓使用者登入我們需要發送一個 HTTP 請求給後端程式驗證，然後儲存回傳的 jwt 到 localStorage。我們可以將這段邏輯放到 Login 元件裡，不過為了重複使用，我們會將這些驗證邏輯抽出來放到 src/auth/index.js 中。 新增 src/auth/index.js 撰寫程式碼如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 看到我們之前鋪的梗了吧，exprt router 就是這邊使用。import {router} from '../index'const API_URL = 'http://localhost:3001'export default { user: { authenticated: false }, login (context, creds, redirect) { var url = API_URL + '/sessions/create' context.$http.post(url, creds) .then((res) =&gt; { localStorage.setItem('id_token', res.data.id_token) this.user.authenticated = true console.log('Login successfully', res.data.id_token) if (redirect) { router.go(redirect) } }) .catch((err) =&gt; { console.log(err) context.error = err.data }) }, signup (context, creds, redirect) { var url = API_URL + '/users' context.$http.post(url, creds) .then((res) =&gt; { localStorage.setItem('id_token', res.data.id_token) this.user.authenticated = true if (redirect) { router.go(redirect) } }) .catch((err) =&gt; { console.log(err) context.error = err.data }) }, logout () { localStorage.removeItem('id_token') this.user.authenticated = false }, check () { /** * 這邊只是單純示範，您不該在驗證邏輯單純只判斷是否有 token */ var jwt = localStorage.getItem('id_token') if (jwt) { this.user.authenticated = true } else { this.user.authenticated = false } }, getAuthHeader () { return { 'Authorization': 'Bearer ' + localStorage.getItem('id_token') } }} 還記得我們在 src/index.js 中有匯出 export var router 所以這邊可以取得 router 的物件實例。這隻 src/auth/index.js 匯出一些 methods 協助我們執行登入，登出，驗證帳密，註冊的行為。登入只負責取回 jwt 然後儲存，如果帳密驗證失敗整個請求就會出現錯誤，自然就不會登入成功。最後我們透過這些方法和屬性來處理前端關於登入的相關邏輯，例如使用 user.authenticated 屬性來判斷是否登入。 實作 Login 元件Login 元件中我們需要兩個 &lt;input&gt; 來輸入帳密然後使用 auth 去驗證是否成功登入。 新增 src/components/Login.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!-- src/components/Login.vue --&gt;&lt;template&gt; &lt;div class=&quot;col-sm-4 col-sm-offset-4&quot;&gt; &lt;h2&gt;登入&lt;/h2&gt; &lt;p&gt; 登入帳號取得更棒的名言。 &lt;/p&gt; &lt;div class=&quot;alert alert-danger&quot; v-if=&quot;error&quot;&gt; {{error}} &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;帳號&quot; v-model=&quot;credentials.username&quot; &gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;密碼&quot; v-model=&quot;credentials.password&quot; &gt; &lt;/div&gt; &lt;button class=&quot;btn btn-primary&quot; @click=&quot;submit&quot;&gt;登入並存取&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import auth from '../auth'export default { data () { return { credentials: { username: '', password: '' }, error: '' } }, methods: { submit () { var credentials = { username: this.credentials.username, password: this.credentials.password } auth.login(this, credentials, 'secretquote') } }}&lt;/script&gt; HTTP 請求是透過 vue-reource 來完成的，由於我們把 auth 抽出去，所以在第一個參數部分，我們需要把 context 也就是該元件的物件實例(instance)傳過去，如此一來在發生錯誤的時候我們也才能夠把錯誤訊息傳回去。第二個參數是使用者登入所需的驗證資料，第三個參數則是完成登入後要切換的頁面路由。 緊接著 Signup 元件的部份跟 Login 幾乎一樣，只是使用的 auth 方法不同。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!-- src/components/Signup.vue --&gt;&lt;template&gt; &lt;div class=&quot;col-sm-4 col-sm-offset-4&quot;&gt; &lt;h2&gt;註冊&lt;/h2&gt; &lt;p&gt; 建立一組新帳號吧！ &lt;/p&gt; &lt;div class=&quot;alert alert-danger&quot; v-if=&quot;error&quot;&gt; {{error}} &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;帳號&quot; v-model=&quot;credentials.username&quot; &gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;密碼&quot; v-model=&quot;credentials.password&quot; &gt; &lt;/div&gt; &lt;button class=&quot;btn btn-primary&quot; @click=&quot;submit&quot;&gt;註冊並存取&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import auth from '../auth'export default { data () { return { credentials: { username: '', password: '' }, error: '' } }, methods: { submit () { var credentials = { username: this.credentials.username, password: this.credentials.password } auth.signup(this, credentials, 'secretquote') } }}&lt;/script&gt; 實作 SecretQuote 元件 - 取得受保護的資料使用者需要登入成功之後就才能存取 secret-quote 路由，SecretQuote 元件看起來跟 Home 很像，不過在呼叫 API 的過程需要使用 jwt token。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!-- src/components/SecretQuote.vue --&gt;&lt;template&gt; &lt;div class=&quot;col-sm-6 col-sm-offset-3&quot;&gt; &lt;h1&gt;取得需要授權的名言&lt;/h1&gt; &lt;button class=&quot;btn btn-warning&quot; @click=&quot;getQuote()&quot;&gt;取得名言&lt;/button&gt; &lt;div class=&quot;quote-area&quot; v-if=&quot;quote&quot;&gt; &lt;h2&gt;&lt;blockquote&gt;{{quote}}&lt;/blockquote&gt;&lt;/h2&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import auth from '../auth'export default { data () { return { quote: '' } }, methods: { getQuote () { this.$http.get('http://localhost:3001/api/protected/random-quote', null, { headers: auth.getAuthHeader() }) .then( (res) =&gt; { this.quote = res.data }) .catch((err) =&gt; { console.log(err) }) } }, route: { canActivate () { return auth.user.authenticated } }}&lt;/script&gt; 透過傳入 options 參數我們可以附加資料到請求的 header 中。而 jwt header 可以透過 auth.getAuthHeader 來取得。最關鍵的部分，因為我們不希望在使用者未登入時能夠存取該路由。所以在這一步我們就會透過 vue-router 的 canActivate hook 處理。 完成剩餘的部分最後針對不同狀態處理一些是否該顯示的地方完善我們的程式碼 App.vue 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!-- src/components/App.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;!-- 注意：少了最外層的 wrapper 會出現 Attribute &quot;id&quot; is ignored on component 警告 --&gt; &lt;nav class=&quot;navbar navbar-default&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li&gt;&lt;a v-link=&quot;'home'&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a v-link=&quot;'login'&quot; v-if=&quot;!user.authenticated&quot;&gt;Login&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a v-link=&quot;'signup'&quot; v-if=&quot;!user.authenticated&quot;&gt;Signup&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a v-link=&quot;'secretquote'&quot; v-if=&quot;user.authenticated&quot;&gt;Secret Quote&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a v-link=&quot;'login'&quot; v-if=&quot;user.authenticated&quot; @click=&quot;logout&quot;&gt;Logout&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/nav&gt; &lt;div class=&quot;container&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import auth from '../auth'export default { data () { return { user: auth.user } }, methods: { logout () { auth.logout() } }}&lt;/script&gt; 參考資源 Build an app with Vuejs","link":"/2016/06/18/build-app-with-vue/"},{"title":"深入 css z-index 屬性","text":"說來汗顏，一直以來對於 css 常常是不求勝解。直到自己需要打造自己的輪子才發現對 z-index 完全不熟悉。關於 z-index 的問題其實非常少人完全明白它到底是怎麼運作的。事實上這並不複雜，不過如果你不曾花些時間閱讀規範可能你不曾察覺一些重要的觀念。 問題在下面的 HTML 中我們有三個 &lt;div&gt; 元素，每一個元素包含著一個 &lt;span&gt;，我們給 &lt;span&gt; 設定背景色 - 分別是綠, 紅, 藍。每個 &lt;span&gt; 同時也設定 absolute 位置設在文件的左上角。約略的重疊在其他 &lt;span&gt; 這樣我們就可以觀察整個堆疊的行為。 第一個 &lt;span&gt; 的 z-index: 1，其他兩者不設。 下面是我們的程式碼： 123456div span class=&quot;red&quot; REDdiv span class=&quot;green&quot; GREENdiv span class=&quot;blue&quot; BLUE 1234567891011121314151617181920212223242526.red, .green, .blue { width: 100px; color: white; line-height: 100px; text-align: center; position: absolute;}.red { z-index: 1; background: red; top: 20px; left: 20px;}.green { background: green; top: 40px; left: 40px;}.blue { background: blue; top: 60px; left: 60px;} See the Pen ZWGvwV by andyyou (@andyyou) on CodePen. 這邊有個小小的挑戰: 試看看能不能把紅色區塊的 &lt;span&gt; 排到藍色和綠色 &lt;span&gt; 的後面，但要遵循下面的規則。 不能修改 HTML 結構 不能加入或修改任何元素的 z-index 不能加入或修改任何 position 屬性 目標要完成下面這樣，先不要偷看解答自己想一想。 See the Pen oxXEvx by andyyou (@andyyou) on CodePen. 解答這個解決方案是透過加入一個小於 1的 opacity 到紅色 &lt;span&gt; 的爸爸元素即 &lt;div&gt; 上面是透過加上 123div:first-child { opacity: .99;} 如果你現在跟我當初一樣驚訝，不相信為什麼加了 opacity: .99 可以改變元素的順序。希望剩下的文章可以幫助你更清楚這些機制。 呈現堆疊的順序z-index 看起來非常簡單，至少在我第一次看到這個屬性的時候，我只知道越大的 z-index 應該要被排在最前面(上面)，對吧？但事實上事情沒那麼單純。看起來很簡單以至於大部分的開發者都沒有花時間去理解它的規則。 在 HTML 中的任何元素可以被調整到其他元素的前面或後面，這也就是我們所知的堆疊順序(stacking order)。這樣順序的規則被很明確的定義在規範上，但如同我剛剛提到的，大多的開發者沒有認真的完全參透。 當我們沒有 z-index 和 position 屬性的時候，規則非常簡單，就是按照文件中 tag 撰寫的先後順序。好吧實際上還是有點複雜，請參考規範說明。不過呢，只要我們不使用負的 margin來覆蓋 inline 的元素，大致上我們不會遇到這些極端的情況。 當我們開始加入 position，任何被設定 position 的元素和它們的後代會呈現在其他沒有設定 position 的元素之前，這裡說的設定 position 指的是除了設為 static 以外得值例如: relative, absolute。 最後當我們也加入 z-index ，事情就變得更複雜了一點。很自然的我們會認為具備較大 z-index 的元素會排在前面，有 z-index 也會蓋在沒有的前面。但是實際上卻沒那麼簡單，首先是 z-index 只對那些有設定 position 的元素有效。如果你試著把 z-index 設在 static 的元素上，那麼什麼事都不會發生。第二點 z-index 會建立一個 stacking context ，此時就是進入重點的地方了。 Stacking Context當我們有一個 &lt;div id=&quot;parent&quot;&gt; 包著一群 &lt;div class=&quot;child&quot;&gt; 元素時，它們的堆疊順序通常會一起被移動(從父原則)，這整個群組的順序就是 stacking context，要完全理解 stacking context 我們就必須要參透 z-index 是怎麼排序 stacking order。 每一個 stacking context 有一個唯一的 HTML 元素當作其根元素，當一個新的 stacking context 或者我們翻作堆疊環境被建立在一個元素上時，這個堆疊環境就會控管它內部的子元素的順序 stacking order，意思是如果其中一個元素在這個堆疊環境中順序被排在最底下，那它就完全沒機會出現在另外一個元素排位較高的堆疊環境前面，就算他的 z-index 設成 9999999。 從另外一個角度來說，每一個被設定 position 的元素除了自己的 stacking order 另外如果內部還有子元素，就會有一個 stacking context 來管制底下的元素。 要建立一個堆疊環境 stacking context有下面三者方式，只要使用其一即可： 當元素是網頁文件的根元素通常就是 &lt;html&gt; 當元素被設定 position 除了 static 以外的值，然後 z-index 設定為除了 auto 以外的值 當元素設定了 opacity 且值小於 1 上面提到的三種方式中，前兩者大部分的開發者都知道，即使他們不懂原理但還是會使用。第三種方式除了 w3c 規範，大多開發者都不曾提到。 此外除了 opacity 另外一些新的屬性像是 transforms, filters, css-regions, paged media 等等都會產生 stacking context。還有當 css 屬性需要在超出螢幕的地方渲染，他也會產生一個 stacking context。 如何決定元素在堆疊環境中的位置實際上在 global stacking 決定整個頁面元素的排序包含 borders, background, 文字是極度複雜的而且已經超出這篇文章的範圍。不過針對大多數的應用，對於排序有些基本的認識有助於往後的開發工作，所以讓我們來一步步拆解說明 在單一堆疊環境 Stacking Context 中的順序在單一的堆疊環境從最下面(後)到上面(前)規則如下 執行堆疊的根元素。 有設定 position 且 z-index 為負數的元素和它們的子元素，-1 在 -2 前面。 沒有設定 position 的元素，一般元素。 有設定 position 且 z-index 為 auto，設定 opacity 小於 1 和其他 transforms 等屬性也在此列。 有設定 position 且 z-index 為正數。 都一樣的時候就比文件中程式碼出現的先後順序，後出現的蓋在上面。 注意：2 號情況在一個 stacking context 會被排在最下面(後面)，意思是他會躲在其他元素後面。也因此這讓元素藏在其父元素後面變成了可能。你可能會疑惑上面那句話，試想如下面這樣的結構 123div[z-index: 1, position: relative] /&lt;- 這邊建立了 stacking context div[class: 'parent'] div[z-index: -2, position: absolute] /&lt;- 這個元素跟 parent 在同一層 stacking context 所以就躲起來了 全域的堆疊排序 Global Stacking Order清楚的了解一個堆疊環境 stacking contetxt 是如何形成的以及掌握如何排序的原則後，我們不難理解一個元素在全域的堆疊環境下會如何呈現排序，就是把 &lt;html&gt; 作為我們最上層的 stacking context。接著原則就一樣。 避免搞死自己的關鍵點就是每當我們建立了一個新的堆疊環境我們要很清楚這是為了什麼。當你把 z-index 設得很大但卻沒有產生變化，往上層元素看看，可能就會發現已經有人具備了 stacking context 的條件了。 總結回到我們一開始的問題，這次我們就直接透過 html 結構來指出這些順序吧 123456789&lt;div&gt;&lt;!-- 1 --&gt; &lt;span class=&quot;red&quot;&gt;&lt;!-- 6 --&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;!-- 2 --&gt; &lt;span class=&quot;green&quot;&gt;&lt;!-- 4 --&gt;&lt;span&gt;&lt;/div&gt;&lt;div&gt;&lt;!-- 3 --&gt; &lt;span class=&quot;blue&quot;&gt;&lt;!-- 5 --&gt;&lt;/span&gt;&lt;/div&gt; 當我們在第一個 div 加上 opacity 後，由下至上的排序應該是 123456789&lt;div&gt;&lt;!-- 3 --&gt; &lt;span class=&quot;red&quot;&gt;&lt;!-- 3.1 --&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;!-- 1 --&gt; &lt;span class=&quot;green&quot;&gt;&lt;!-- 4 --&gt;&lt;span&gt;&lt;/div&gt;&lt;div&gt;&lt;!-- 2 --&gt; &lt;span class=&quot;blue&quot;&gt;&lt;!-- 5 --&gt;&lt;/span&gt;&lt;/div&gt; 本來是 6 的 span 因為上層的 div 也具備 stacking context 但是順序比下面 4, 5 的 span 小。自己又因為從父原則導致順序被往前推了。希望這篇文章能讓你對於 z-index 有能更加清楚。 資源 w3c 規範 詳細說明 - 中文 MDN stacking context 概覽 z-index No one told you about z-index","link":"/2016/03/03/z-index/"},{"title":"[譯] 美化無法載入的圖片 &lt;img&gt;","text":"當網頁中無法載入圖片(通常是圖片連結失效或錯誤)時，瀏覽器預設會幫我們顯示一個小小的圖示告知我們連結失效了。 這些預設圖片每一個瀏覽器都不太一樣，通常也不太好看。這篇文章主要介紹的內容就是我們可以透過 css 來美化這個預設行為。 關於 元素的兩件事為了了解如何美化壞掉的圖片，有兩個關於 &lt;img&gt; 的行為我們必須先瞭解。 能夠套用文字相關的樣式，這些樣式只會被套用在替代文字上。在圖片正常載入的情況下則沒有任何效果。 &lt;img&gt; 是一個replaced element，例如 &lt;video&gt;, &lt;object&gt; 等等，大略的意思就是這個元素呈現的外型尺寸是透過外部資源來決定的，像是圖片就是由實際圖片來決定，想知道更詳細的說明可以參考Sitepoint 提供了更好的說明。因為元素是透過外部資源來控制的，所以預設來說 :before 和 :after 這些偽元素(pseudo-elements) 應該是不能運作的，不過當圖片失效或是無法載入的時候這些偽元素就可以作用了。 因為上面這兩個原理所以我們能夠套用一些樣式只出現在 &lt;img&gt; 無法載入圖片的時候。 實作假設我們現在有一個圖片標籤 1&lt;img src=&quot;http://andyyou.github.io/broken.png&quot; alt=&quot;andyyou&quot;&gt; 提供有意義的資訊第一個重點就是我們需要設定 alt 為的就是在圖片失效的時候提供給使用者一些關於這張圖片的描述資訊。接著為了處理圖片失效的問題我們也需要提供一些資訊告訴使用者這張圖片壞了。另外就是可以透過 attr() 取得相關的資訊。 12345678910111213141516171819202122img { font-family: 'Helvetica'; font-weight: 300; line-height: 1.4em; text-align: center; width: 100%; height: auto; display: block; position: relative; &amp;:before { content: &quot;We are sorry, the image is broken :(&quot;; display: block; margin-bottom: 10px; } &amp;:after { content: &quot;(url: &quot; attr(src) &quot;)&quot;; display: block; font-size: 12px; }} 取代預設的替代文字透過偽元素我們可以取代預設的替代文字 alt text，原理就是把偽元素蓋在預設替代文字的上方。 12345678910111213141516img:after { content: &quot;\\f1c5&quot; &quot; &quot; attr(alt); font-size: 16px; font-family: FontAwesome; color: rgb(100, 100, 100); display: block; position: absolute; z-index: 2; top: 0; left: 0; width: 100%; height: 100%; background-color: #fff; /* 如果透明或不設定的話就露餡了 */} 其他樣式到了這邊其實我們知道有兩個偽元素可以操作，除了顯示資訊之外其實也可以用來單純作樣式的設計 1234567891011121314151617181920212223242526272829303132333435363738img { font-family: 'Helvetica'; font-weight: 300; line-height: 2em; text-align: center; width: 100%; height: auto; display: block; position: relative; min-height: 50px; &amp;:before { content: &quot; &quot;; display: block; position: absolute; top: -10px; left: 0; height: calc(100% + 10px); width: 100%; background-color: rgb(230, 230, 230); border: 1px dotted rgb(200, 200, 200); border-radius: 5px; } &amp;:after { content: &quot;\\f127&quot; &quot; Broken Image of &quot; attr(alt); display: block; font-size: 16px; font-style: normal; font-family: FontAwesome; color: rgb(100, 100, 100); position: absolute; top: 5px; left: 0; width: 100%; text-align: center; }} 瀏覽器支援很不幸的並不是所有瀏覽器都完整支援 alt text, :before, :after 套用樣式。所以在部分瀏覽器上這個作法可能不被支援。 來源 Styling broken images","link":"/2016/06/16/sytling-broken-images/"},{"title":"筆記 Javascript 的 constructors, prototypes, new 關鍵字","text":"您是否曾困惑關於 Javascript 中的 new 關鍵字呢？是否曾想理解關於 function 和 constructor 的不同是什麼？還有 prototype 到底是用來幹嘛的？ 這篇文章會試著讓您釐清這些東西。 網路上已經有許多討論關於 Javascript 非典型物件導向(pseudo-classical)的說明 - MDN。您可以閱讀一下釐清這些術語。 大多數 Javascript 的新進開發者不太想要使用 new 關鍵字，因為這會讓程式碼寫起來像是 Java 並且在使用上造成一點混亂。在這邊我並不想討戰也不會偏袒任何一種方式，我們只是要解釋它是如何運作的。我要說的只是這是個工作，如果在實務上能幫上忙就用吧！ constructor 是什麼？constructor 翻為建構子但為了讓您之後更好理解，這邊會直接使用 constructor。簡單說這和您之前學過的大部分物件導向語言不同，在 Javascript 中任何一個函式(function)都可以被當作 constructor。Javascript 並沒有明顯的區別兩者，也就是說 function 可以被當作 constructor 或者當作一般函式調用。 而 constructor 的用法就是 function 搭配 new 關鍵字： 12345var Vehicle = function Vehicle () {}var vehicle = new Vehicle() 這可能會讓許多慣於使用 C++ 或 Java 的人感到困惑。但其實，在某種程度上你可以把 function 看做是 class。 當 constructor 被調用時發生了什麼事？當 new Vehicle() 的時候，Javascript 做了 4 件事情 產生一個新的物件 將這個新物件的 constructor 屬性設為 Vehicle 這個 Function 物件 讓這個物件繼承 Vehicle.prototype (Function 物件) 在這個物件的 context 執行 Vehicle() 用個簡短的範例說明當我們在 Javascript 執行一個 foo() 時，一般來說它等於 window.foo()。這個 window 就是 context。上面的例子可以看成：Vehicle.call(新物件) 再看一次： 1. 產生一個新的物件這一步沒有任何特別的，就只是建立一個新物件 {} 2. 將這個新物件的 constructor 屬性設為 Vehicle 這個 Function 物件這步意味了 2 件事 12vehicle.constructor == Vehicle // truevehicle instanceof Vehicle // true 這個 constructor 並不是一般的屬性，當我們列舉所有屬性時並不會出現。另外，我們可以試著對它設值，不過只是在這個特殊屬性之上再加上一個普通的屬性 123456789vehicle // {}var Beer = function Beer() {}vehicle.constructor = Beervehicle // {constructor: function Beer()}vehicle.constructor == Beer // truevehicle instanceof Beer // falsevehicle instanceof Vehicle // true 可以想成這時有兩個 constructor 一個是我們加上的普通屬性，一個是底層屬性。底層內建的 constructor 我們是無法變更的。它是用來搭配 new 使用的。 3. 讓這個物件繼承 Vehicle.prototype (Function 物件的 prototype)到這一步事情變得有趣了 一個 function 本質上是一個特殊的物件，並且就像其他物件一樣。它也是有屬性的。而這個 Function 物件 預設會自動取得一個叫 prototype 的屬性，是一個空物件。這個物件會經過一些特別的處理。 當我們透過 constructor 的方式建立一個物件時，它會繼承這個 prototype 物件 的所有屬性。 讓我們來看一點程式碼理解一下 123Vehicle.prototype.wheel = 4var v = new Vehicle()v.wheel // 4 這個剛產生的 v 物件會從 Vehicle 的 prototype 中擷取 wheel。 看起來像是把屬性複製過去，但這個繼承的行為不只是單純的複製屬性到新物件上。這個物件代理了 prototype 所有的屬性。也就是說即使在建立之後，Vehicle Function 物件 的 prototype 加了新東西，這個物件還是能夠取得。 12345Vehicle.prototype.wheel = 6Vehicle.prototype.brand = 'BMW'v.wheel // 6v.brand // BMW 重點來了，我們還是可以單獨覆寫 instance 物件實例的屬性，這麼做並不會異動 prototype 的屬性 123v.wheel = 8v.wheel // 8(new Vehicle()).wheel // 6 當然我們也可以有 method 的使用方式。在屬性上的 function 一般稱為方法(method)。 12Vehicle.prototype.go = function go() {return 'run'}vehicle.go() // run 4. 在這個物件的 context 執行 Vehicle()最後，constructor 會自己呼叫自己。這個 function 裡面的 this 會指向我們剛剛建立的物件。 探討 this, context, scope 已經超出本文範圍，可以參考understanding scope and context in- javascript 所以我們可以這麼做 123456var Vehicle = function Vehicle(color) { this.constructor this.color = color}(new Vehicle('blue')).color // blue 備註：上面提到使用 new 關鍵字搭配 constructor 回傳一個新的物件，本質上是對的。但如果這個 constructor 回傳了一個其他物件那麼原本預計建構的物件會被拋棄，只回傳該內容。詳細的說明請參考javascript constructor value 小結這種方式讓我們可以實作類似 Class 的用法 12345678910// Classvar Vehicle = function Vehicle(color) { // Initialization this.color = color}// Instance MethodsVehicle.prototype.go = function () { return 'run'} 子類別這種非典型物件導向得設計，或稱 Prototype-based programming 並沒有標準的方式實作子類別。不過我們可以透過設定一個父類別的實例物件到 prototype 來達成這個功能。 也由於這種設計，所以不會有解構子 destructors 1234567891011var Car = function Car() {}Car.prototype = new Vehicle('blue')Car.prototype.honk = function honk() {return 'BEEEE!'}var car = new Car()car.honk() // 'BEEEE'car.go() // runcar.color // bluecar instanceof Car // true// 稍早我們把 Beer 設到 constructor 會是 falsecar instanceof Vehicle // true 還有一個問題，由於 Vehicle constructor 只有在設定 Car.prototype 時被呼叫一次。我們會在設定時給予 color 參數。於是我們就不能在初始化的階段給不同的物件不同的顏色。但這個問題有些 Javascript 框架已經實作它們的解決方案。 類似於 mixin 的作法有時您並不想使用類別的概念，我們只想要某個物件能夠取得另一個物件的屬性並能夠覆寫。 function 可以協助我們完成這個任務。通常這類 function 會被命名為 create 或 clone 1234567891011121314151617181920function create (parent) { var fn = function () {} fn.prototype = parent return new fn()}var company = {brand: 'Benz'}var car1 = create(company)var car2 = create(company)var car3 = create(company)car3.brand = 'Audi'car1.brand // Benzcar2.brand // Benzcar3.brand // Audicompany.brand = 'Toyota'car1.brand // Toyotacar2.brand // Toyotacar3.brand // Audi 總結關於 Javascript 的 prototype 相較於其他語言有點混亂難理解。即便讓語法看起來像是一般OOP但您還是需要掌握一些技巧並謹慎使用。 function 可當作 class 看待 在 Javascript 中任何一個函式(function)都可以被當作 constructor。Javascript 並沒有明顯的區別兩者，也就是說 function 可以被當作 constructor 或者當作一般函式調用。 class 所建立的 instance 屬性使用 prototype 加入繼承 constructor instance 沒有該屬性時會代理 prototype 的，但覆寫後就為自己個人的屬性 constructor instance 與 Function.prototype 是代理關係，也就是 prototype 異動時，物件的屬性會跟著更新(沒有覆寫的狀況下) 參考資源 javascript constructors prototypes and the new keyword Introduction to Object Oriented JavaScript understanding scope and context in javascrip javascript constructor return value","link":"/2016/09/22/js-contrstructors-prototypes-new/"},{"title":"Facebook Bot 開發小技巧","text":"流程 準備環境 使用 ngrok 取得 https 網址 建立與設定 Facebook App 與粉絲團 建立 webhook GET API 設定 Facebook App webhook 實作 webhook POST API 產生對話 準備由於 Facebook bot 在執行 API 溝通的時候需要使用 SSL 協定即網址要是 https，為了在本地端開發方便。因此我們需要使用 ngrok 來協助我們產生一個 https 的網址並傳回我們的機器。當然很多文章會介紹您使用 cloudflare 但這邊為了方便開發於是使用另外一種 ssh tunnel 的方式來解決 註冊並登入 ngrok 下載並安裝 ngrok 完成安裝 ngrok 憑證的流程 1234567# 安裝可以下載檔案並放置到 /usr/lcoal/bin 或者使用 brew$ brew cask install ngrok# 登入後會看到 ngrok 提供的驗證指令$ ngrok authtoken [your_token]# 開始使用$ ngrok http [port] 啟動之後畫面如下： 建立 Facebook App 與粉絲專頁 官方教學 建立好 App 與粉絲團之後接下來為了設定 webhook，網址的部分請給定 ngrok 的網址，例如https://[hash_code].ngrok.io/webhook。而 token 則是您自訂任意的字串，稍後需要在 API 中使用驗證。 因為設定 webhook 網址時，facebook 會發一個 request 給測試該網址是否正常運作，如果不正確的話，那就沒辦法進入下一階段了。所以我們需要先將 GET API 建立完成 123456app.get('/webhook/', function (req, res) { if (req.query['hub.verify_token'] === '&lt;YOUR CUSTOM TOKEN&gt;') { res.send(req.query['hub.challenge']); } res.send('Error, wrong validation token');}) 一旦設定了若要完全移除就是要讓 API 死掉 8H。 上敘動作完成之後，我們就完成前置作業了。接著下來就是實作與機器人對談的部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667var express = require('express')var bodyParser = require('body-parser')var request = require('request')var app = express()var token = '&lt;YOUR_PAGE_TOKEN&gt;'var facebookApi = 'https://graph.facebook.com/v2.6/me/messages'app.use(bodyParser.urlencoded({ extended: true}))app.use(bodyParser.json())app.get('/', function (req, res) { res.send('Hi, server')})app.get('/webhook/', function (req, res) { if (req.query['hub.verify_token'] === 'abcd') { res.send(req.query['hub.challenge']); } res.send('Error, wrong validation token');})app.post('/webhook/', function (req, res) { console.log(req.body.entry[0]) var messages = req.body.entry[0].messaging for (var i = 0; i &lt; messages.length; i++) { var event = messages[i] var sender = event.sender.id if (event.message &amp;&amp; event.message.text) { var text = event.message.text sendTextMessage(sender, text) } } res.sendStatus(200)})app.listen(8080, function () { console.log('Listen on port 8080')})/** * Functions */function sendTextMessage (sender, text) { messageData = { text: text } request({ url: facebookApi, qs: { access_token: token }, method: 'POST', json: { recipient: { id: sender }, message: messageData } }, function (err, res, body) { if (err) console.log('Error sending message: ', err) else if (res.body.error) console.log('Error: ', res.body.error) })} 到此我們就完成了一個簡單的 Facebook BOT 應用。","link":"/2016/08/26/facebook-bot/"},{"title":"npm 最佳實作的小技巧","text":"npm 最佳實作npm install 是我們最常在 npm 中用到的指令，但其實它還提供了更多的功能。在這篇文章中我們將會學到 npm 如何在開發過程中協助我們 - 從建立專案到部署應用程式。 0 了解您的 npm在進入更深的主題之前，讓我們先來看看一些可以協助我查閱 npm 版本的指令 npm versions要取得 npm 指令的版本我們可以執行下面的指令 1$ npm --version 要取得更詳細的訊息 12345678910111213141516171819$ npm version{ npm: '3.10.3', ares: '1.10.1-DEV', http_parser: '2.7.0', icu: '57.1', modules: '48', node: '6.6.0', openssl: '1.0.2h', uv: '1.9.1', v8: '5.1.281.83', zlib: '1.2.8'}$ npm show [library name] version # 顯示某 npm 線上最新版本$ nvm ls # 顯示本地端套件資訊$ nvm ls-remote # 顯示 node 可用版本$ npm ls -g # Locally global npm help跟大多數指令一樣，npm 也具備 help 功能。它會顯示相關指令的使用方式資訊，類似於 Linux 中的 man pages 1234567891011$ npm help testNAME npm-test - Test a packageSYNOPSIS npm test [-- &lt;args&gt;] aliases: t, tstDESCRIPTION This runs a package's &quot;test&quot; script, if one was provided. To run tests as a condition of installation, set the npat config to true. 1 使用 npm init 建立新專案當我們要開始一個新專案時，npm init 可以透過問答式的方式協助我們建立 package.json 當然如果我們想要全部使用預設值時可以使用 12$ npm init --yes$ npm init -y 有些預設值我們可以事先設定，像是專案作者這類資訊： 12$ npm config set init.author.name [YOUR NAME]$ npm config set init.author.email [YOUR EMAIL] 2 查詢 npm 套件找到正確的套件有時候也是一個挑戰 - 在 npm 上有成千上萬的套件模組供我們挑選。通常我們依據一些經驗又或者根據網路上文章或社群的推薦。另外我們也可以參考 npms.io 這個網站，上面提供了關於品質，解決 Issue 平均時間，是否通過測試，甚至還有該模組是否相依了一些過期的套件等等。 3 查閱 npm 套件相關資訊一旦我們選好了模組，舉例來說我們選了 request 這個套件。接著我們就需要查看相關文件，看看 Issue 是否會太多或有嚴重瑕疵。注意，當您使用了越多的套件就表示越高的風險。對於產品來說我們應該要很清楚相依套件的狀況。 這個時候就可以透過指令直接造訪官網 1$ npm home request 要檢查相關 Issues 或後續的發展計畫可以使用 12$ npm bugs request$ npm repo request # 套件 Git Repo 4 安裝與儲存設定當我們確認好要使用的套件之後，就需要將其安裝到我們的專案 12$ npm install request --save$ npm install request -S 預設 npm 會在版好的部分使用 ^ 意味著下次你使用 npm install 時會安裝該主版號下最新版的版本，也就是主版號不變。當然我們也可以改變設定 12$ npm config set save-prefix='~'$ npm config set save-exact true # 精準版號 詳細版號規則可以參考看懂 npm 語意化版本 5 鎖定相依套件上面提到我們可以指定精準版號，但即使我們採用這種方式，您應該意識到大部分 npm 模組的作者並不會這麼做，因為他們會希望自動更新相依的套件。 這種情形在上線的產品很容易變成問題，可能會造成本地的專案和線上產品使用了不同的版本。為了解決這個問題我們可以使用 npm shrinkwrap，它會產生一個 npm-shrinkwrap.json 檔案，這隻檔案不只會記錄我們專案相依模組的版本，還會連模組相依的版本都準確的記錄下來。如此一來下次使用 npm install 就能確保模組的部分完全一致。 6 檢查過期的相依模組為了找出那些需要更新的模組，npm 內建 npm outdated 指令 12$ npm outdated$ npm up [PACKAGE_NAME] -S # 更新 如果您想自動完成這個任務，您可以使用 Greenkeeper，一旦相依的模組有更新，它就會自動發送 pr 給您。 7 不要在產品中安裝 devDependencies1$ npm i --production 另外一個方式是指定環境變數 1$ NODE_ENV=production npm install 8 保護您的專案與 Tokens在 npm 登入帳號的狀況下，您的 npm token 會被放到 .npmrc。如果您發佈到 Github 的專案允許一些 . 開頭的隱藏擋格式那麼請注意關於 .npmrc 中的敏感的資訊不要一起發佈出去。 除了上述這一點，也要注意其他原始碼的部分是否包含一些敏感資訊。預設來說 npm 會遵循 .gitignore 的規則過濾掉一些檔案不發佈。然而當我們加入 .npmignore 時，就會以 .npmignore 為主，注意到兩隻檔案並不會彙整在一起。 9 開發模組當我們在本地端開發模組的時候，我們通常在發布之前會需要測試安裝它們，這時就會使用到 npm link。那麼這個 npm link 會做些什麼呢？它會建立一個軟連結，接著我們就可以在測試專案中使用 npm link package-name 12345# 建立測試模組連結/projects/request $ npm link# 安裝測試模組/projects/test-project $ npm link request 資源參考 nodejs at scale - npm best practices","link":"/2016/10/04/node-best-practice/"},{"title":"Node 筆記","text":"前言這篇文章試著要整理，翻譯Export This: Interface Design Patterns for Node.js Modules這篇非常值得一讀的文章。但因為這篇文章有些時日了，部分範例已經不符合現況。故這是一篇加上小弟收集彙整而成的更新翻譯。 旅程的開始當你在 Node 中載入一個模組，我們到底會取回什麼？當我們撰寫一個模組時我們又有哪些選擇可以用來設計程式的介面？在我第一次學習 Node 的時候，發現在 Node 中有太多的方式處理這個問題，由於 Javascript 本身非常彈性，加上在社群中的開發者們各自都有不同的實作風格，這讓當時的我感到有點挫折。 在原文作者的學習旅程中曾持續的觀察尋找好的方式以應用在其的工作上，在這篇文章中將會分享觀察到的 Node 模組設計方式。大略總結了 7 種設計模式(pattern) 匯出命名空間 Namespace 匯出函式 Function 匯出高階函式 High-Order Function 匯出建構子/構建函式 Constructor 匯出單一實例物件 Singleton 擴展全域物件 Extend Global Object 套用猴子補丁 Monkey Patch require, exports 和 module.exports首先我們需要先聊點基礎的知識 在 Node 官方文件中定義了匯入一個檔案就是匯入一個模組。 In Node.js, files and modules are in one-to-one correspondence. - Node 文件 每個模組內都有一個隱式(implicit)的 module 物件，這個物件身上有一個屬性 exports (即 module.exports)。當我們使用 require() 時它所傳回的，即是這個模組的 module.exports 所指向的東西。每個模組的 module.exports 預設都是一個空物件 {}，而每個模組內帶有一個 exports 捷徑變數，預設指向 module.exports。 在預設情況下，module.exports 是一個物件，而 exports 又指向該物件，所以在預設情況下，以下兩個操作視為等效： 123exports.foo = 'hello';// 等同於module.exports.foo = 'hello'; 如果，你重新指定了某東西給 module.exports，當然 module.exports 跟預設物件的關係就因此被打斷，而此時 exports 捷徑變數仍然是指向預設物件的。前面有提到，當我們使用 require() 時，模組是以 module.exports 所指向的東西而揭露給外部，因此模組的介面是由 module.exports 所決定，與 exports 捷徑變數無關。因此，一旦 module.exports 被指定新值後，使用捷徑變數 exports 所掛入預設物件的內容都將無法被揭露，因而可視為無效。 為了讓您更好理解關於 exports 與 module.exports 下面的範例提供了較詳細的說明 1234567891011121314var a = { id: 1 }var b = aconsole.log(a) // {id: 1}console.log(b) // {id: 1}// b 參考指向 a，意味著修改 b 的屬性 a 會跟著變動b.id = 2console.log(a) // {id: 2}console.log(b) // {id: 2}// 但如果將一個全新的物件賦予 b 那麼參考的關係將會中斷b = { id: 3 }console.log(a) // {id: 2}console.log(b) // {id: 3} 另外比較具體的範例 12345678910// 模組預設: module.exports = {}, 而 exports = module.exports, 等同於指向預設的空物件/* person.js */exports.name = function () { console.log('My name is andyyou.')}.../* main.js */var person = require('./person.js')person.name() 12345678910/* person.js */module.exports = 'Hey, andyyou' // module.exports 不再是預設物件exports.name = function () { // 透過 exports 捷徑掛進預設物件的內容, 將無法被揭露 console.log('My name is andyyou')}/* main.js */var person = require('./person.js')// exports 的屬性被忽略了person.name() // TypeError: Object Hey, andyyou has no method 'name' exports 只是指向 module.exports 的參考(Reference) module.exports 初始值為 {} 空物件，於是 exports 也會取得該空物件 require() 回傳的是 module.exports 而不是 exports 所以您可以使用 exports.property_name = something 而不會使用 exports = something 一旦使用 exports = something 參考關係便會停止，也就是 exports 的資料都會被忽略。 本質上我們可以理解為所有模組都隱含實作了下面這行程式碼 (實際上 module 與 exports 是由 node 模組系統傳入給我們的模組的) 1var exports = module.exports = {} 現在我們知道了，當我們要匯出一個 function 時我們得使用 module.exports。如果令捷徑 exports 變數指向該 function，僅僅是捷徑 exports 對 module.exports 的關係被打斷而已，真正揭露的還是 module.exports。 另外，我們在許多專案看到下面的這行程式碼 1exports = module.exports = something 這行程式碼作用就是確保 exports 在 module.exports 被我們覆寫之後，仍可以指向相同的參考。 接著我們就可以透過 module.exports 來定義並匯出一個 function 1234/* function.js */module.exports = function () { return { name: 'andyyou' }} 使用的方式則是 1var func = require('./function') 關於 require 一個很重要的行為就是它會快取(Cache) module.exports 的值，未來每一次 require 被調用時都會回傳相同的值。它會根據匯入檔案的絕對路徑來快取，所以當我們想要模組能夠回傳不同得值時，我們就需要匯出 function，如此一來每次執行函式時就會回傳一個新值。 下面在 Node REPL 中簡易的示範 123456789$ node&gt; f1 = require('/Users/andyyou/Projects/export_this/function')[Function]&gt; f2 = require('./function') // 相同路徑[Function]&gt; f1 === f2true&gt; f1() === f2()false 您可以觀察到 require 回傳了同樣的函式物件實例，但每一次調用函式回傳的物件是不同的。更詳細的介紹可以參考官方文件，值得一讀。 現在，我們可以開始探討介面的設計模式(pattern)了。 匯出命名空間一個簡單且常用的設計模式就是匯出一個包含數個屬性的物件，這些屬性具體的內容主要是函式，但並不限於函式。如此，我們就能夠透過匯入該模組來取得這個命名空間下一系列相關的功能。 當您匯入一個命名空間類型的模組時，我們通常會將模組指定到某一個變數，然後透過它的成員(物件屬性)來存取使用這些功能。甚至我們也可以將這些變數成員直接指定到區域變數。 1234567var fs = require('fs')var readFile = fs.readFilevar ReadStream = fs.ReadStreamreadFile('./file.txt', function (err, data) { console.log('readFile contents: %s', data)}) 這便是fs 核心模組的做法 1var fs = exports 首先用一個新的區域變數 fs，令其為捷徑 exports，因此預設情況下 fs 就指向了 module.exports 身上的預設物件。上面這一行我們可以說，只是將捷徑變數換個名稱成為 fs 如此而已。接下來，我們就可以使用新的捷徑 fs 了，例如: fs.Stats = binding.Stats。 123fs.readFile = function (path, options, callback_) { // ...} 其他東西也是一樣的作法，例如匯出建構子 1234567fs.ReadStream = ReadStreamfunction ReadStream(path, options) { // ...}ReadStream.prototype.open = function () { // ...} 當匯出命名空間時，您可以指定屬性到 exports ，就像 fs 的作法，又或者可以建立一個新的物件指派給 module.exports 12345678910/* exports 作法 */exports.verstion = '1.0'/* 或者 module.exports 作法 */module.exports = { version: '1.0', doYourTasks: function () { // ... }} 一個常見的作法就是透過一個根模組(root)來彙整並匯出其他模組，如此一來只需要一個 require 便可以使用所有的模組。原文作者在Good Eggs工作時，會將資料模型(Model)拆分成個別的模組，並使用匯出建構子的方式匯出(請參考下文介紹)，然後透過一個 index 檔案 來集合該目錄下所有的資料模型並一起匯出，如此一來在 models 命名空間下的所有資料模型都可以使用 123var models = require('./models')var User = models.Uservar Product = models.Product 在 ES2015 和 CoffeeScript 中我們甚至還可以使用解構指派來匯入我們需要的功能 12345/* CoffeeScript */{User, Product} = require './models'/* ES2015 */import {User, Product} from './models' 而剛剛提到的 index.js 大概就如下 12exports.User = require('./User')exports.Person = require('./person') 實際上這樣分開的寫法還有更精簡的寫法，我們可以透過一個小小的函式庫來匯入在同一階層中所有檔案並搭配 CamelCase 的命名規則匯出。於是在我們的 index.js 中看起來就會如下 1module.exports = require('../lib/require_siblings')(__filename) 匯出函式另外一個設計模式是匯出函式當作該模組的介面。常見的作法是匯出一個工廠函式(Factory function)，然後呼叫並回傳一個物件。在使用 Express.js 的時候便是這種作法 123456var express = require('express')var app = express() // 實際上 express() 傳回的 app 是一個 function，在 JS 中函式也是物件app.get('/hello', function (req, res, next) { res.send('Hi there! We are using Express v' + express.version)}) Express 匯出該函式，讓我們可以用來建立一個新的 express 應用程式。在使用這種模式時，通常我們會使用 factory function 搭配參數讓我們可以設定並回傳初始化後的物件。 想要匯出 function，我們就一定要使用 module.exports ，Express 便是這麼做 123456exports = module.exports = createApplication...function createApplication () { ...} 上面指派了 createApplication 函式到 module.exports 然後再指給 exports 確保參考一致。同時 Express 也使用下面這種方式將導出函式當作命名空間的作法使用。 1exports.version = '3.1.1' 這邊要大略解釋一下由於 Javascript 原生並沒有支援命名空間的機制，於是大部分在 JS 中提到的 namespace 指的就是透過物件封裝的方式來達到 namespace 的效果，也就是第一種設計模式。 注意！並沒有任何方式可以阻止我們將匯出的函式作為命名空間物件使用，我們可以用其來引用其他的 function，建構子，物件。 Express 3.3.2 / 2013-07-03 之後已經將 exports.version 移除了 另外在匯出函式的時候最好為其命名，如此一來當出錯的時候我們比較容易從錯誤堆疊資訊中找到問題點。 下面是兩個簡單的例子： 1234/* bomb1.js */module.exports = function () { throw new Error('boom')} 123module.exports = function bomb() { throw new Error('boom')} 123456789101112131415$ node&gt; bomb = require('./bomb1');[Function]&gt; bomb()Error: boom at module.exports (/Users/andyyou/Projects/export_this/bomb1.js:2:9) at repl:1:2 ...&gt; bomb = require('./bomb2');[Function: bomb]&gt; bomb()Error: boom at bomb (/Users/andyyou/Projects/export_this/bomb2.js:2:9) at repl:1:2 ... 匯出函式還有些比較特別的案例，值得用另外的名稱以區分它們的不同。 匯出高階函式一個高階函式或 functor 基本上就是一個函式可以接受一個或多個函式為其輸入或輸出。而這邊我們要談論的後者 - 一個函式回傳函式當我們想要模組能夠根據輸入控制回傳函式的行為時，匯出一個高階函式就是一種非常實用的設計模式。 補充：functor &amp; monad 舉例來說 Connect 就提供了許多可掛載的功能給網頁框架。這裡的 middleware 我們先理解成一個有三個參數 (req, res, next) 的 function。 Express 從 v4.x 版之後不再相依於 connect connect middleware 慣例就是匯出的 function 執行後，要回傳一個 middleware function。在處理 request 的過程中這個回傳的 middleware function 就可以接手使用剛剛提到的三個參數，用來在過程中做一些處理或設定。同時因為閉包的特性這些設定在整個中介軟體的處理流程中都是有效的。 舉例來說，compression 這個 middleware 就可以在處理 responsive 過程中協助壓縮 123456var connect = require('connect')var app = connect()// gzip outgoing responsesvar compression = require('compression')app.use(compression()) 而它的原始碼看起來就如下 123456789module.exports = compression...function compression (options) { ... return function compression (req, res, next) { ... next() }} 於是每一個 request 都會經過 compression middleware 處理，而代入的 options 也因為閉包的關係會被保留下來 這是一種極具彈性的模組作法，也可能在您的開發項目上幫上許多忙。 middleware 在這裡您可以大略想成串連執行一系列的 function，自然其 Function Signature 要一致 匯出建構子在一般物件導向語言中，constructor 建構子指的是協助我們從類別 Class建立一個該類別物件實例的一段程式碼。 123456789// C#class Car { // c# 建構子 // constructor 即 class 中用來初始化物件的 method。 public Car(name) { name = name; }}var car = new Car('BMW'); 由於在 ES2015 之前 Javascript 並不支援類別，某種程度上在 Javascript 之中我們可以把任何一個 function 當作類別，或者說一個 function 可以當作 function 執行或者搭配 new 關鍵字當作 constructor 來使用。如果想知道更詳細的介紹可以閱讀MDN 教學。 欲匯出建構子，我們需要透過構造函式來定義類別，然後透過 new 來建立物件實例。 12345678910function Person (name) { this.name = name}Person.prototype.greet = function () { return 'Hi, I am ' + this.name}var person = new Person('andyyou')console.log(person.greet()) // Hi, I am andyyou 在這種設計模式底下，我們通常會將每個檔案設計成一個類別，然後匯出建構子。這使得我們的專案架構更加清楚。 12var Person = require('./person')var person = new Person() 整個檔案看起來會如下 12345678910/* person.js */function Person(name) { this.name = name}Person.prototype.greet = function () { return 'Hi, I am ' + this.name}exports = module.exports = Person 匯出單一物件實例 Signleton當我們需要所有的模組使用者共享物件的狀態與行為時，就需要匯出單一物件實例。 Mongoose是一個 ODM(Object-Document Mapper)函式庫，讓我們可以使用程式中的 Model 物件去操作 MongoDB。 1234567891011var mongoose = require('mongoose')mongoose.connect('mongodb://localhost/test')var Cat = mongoose.model('Cat', {name: String})var kitty = new Cat({name: 'Zildjian'})kitty.save(function (err) { if (err) throw Error('save failed') console.log('meow')}) 那我們 require 取得的 mongoose 物件是什麼東西呢？事實上 mongoose 模組的內部是這麼處理的 12345function Mongoose() { ...}module.exports = exports = new Mongoose() 因為 require 的快取了 module.exports 的值，於是所有 reqire('mongoose') 將會回傳相同的物件實例，之後在整個應用程式之中使用的都會是同一個物件。 Mongoose 使用物件導向的設計模式來封裝，解耦(分離功能之間的相依性)，維護狀態使整體具備可讀性，同時透過匯出一個 Mongoose Class 的物件給使用者，讓我們可以簡單的存取使用。 如果我們有需要，它也可以建立其他的物件實例來作為命名空間使用。實際上 Mongoose 內部提供了存取建構子的方法 1Mongoose.prototype.Mongoose = Mongoose 因此我們可以這麼做 12345var mongoose = require('mongoose')var Mongoose = mongoose.Mongoosevar anotherMongoose = new Mongoose()anotherMongoose.connect('mongodb://localhost/test') 擴展全域物件一個被匯入的模組不只限於單純取得其匯出的資料。它也可以用來修改全域物件或回傳全域物件，自然也能定義新的全域物件。而在這邊的全域物件(Global objects)或稱為標準內建物件像是 Object, Function, Array 指的是在全域能存取到的物件們，而不是當 Javascript 開始執行時所產生代表 global scope 的 global object。 當我們需要擴增或修改全域物件預設行為時就需要使用這種設計模式。當然這樣的方式是有爭議，您必須謹慎使用，特別是在開放原始碼的專案上。 例如：Should.js是一個常被用在單元測試中用來判斷分析 值 是否正確的函式庫。 1234567require('should')var user = { name: 'andyyou'}user.name.should.equal('andyyou') 這樣您是否比較清楚了，should.js 增加了底層的 Object 的功能，加入了一個非列舉型的屬性 should ，讓我們可以用簡潔的語法來撰寫單元測試。 而在內部 should.js 做了這樣的事情 12345678910111213var should = function (obj) { return new Assertion(util.isWrapperType(obj) ? obj.valueOf(): obj)}...exports = module.exports = shouldObject.defineProperty(Object.prototype, 'should', { set: function(){}, get: function(){ return should(this); }, configurable: true}); 就算看到這邊您肯定跟我一樣有滿滿的疑惑，全域物件擴展定義跟 exports 有啥關聯呢？ 事實上 123456789101112131415161718/* whoami.js */exports = module.exports = { name: 'andyyou'}Object.defineProperty(Object.prototype, 'whoami', { set: function () {}, get: function () { return 'I am ' + this.name }})/* app.js */var whoami = require('whoami')console.log(whoami) // { name: 'andyyou' }var obj = { name: 'lena' }console.log(obj.whoami) // I am lena 現在我們明白了上面說的修改全域物件的意思了。should.js 匯出了一個 should 函式但是它主要的使用方式則是把 should 加到 Object 屬性上，透過物件本身來呼叫。 套用猴子補丁(Monkey Patch)在這邊所謂的猴子補丁特別指的是在執行時期動態修改一個類別、模組或物件(也稱 object augmentation)，通常會這麼做是希望補強某的第三方套件的 bug 或功能。 假設某個模組沒有提供您客製化功能的介面，而您又需要這個功能的時候，我們就會實作一個模組來補強既有的模組。這個設計模式有點類似擴展全域物件，但並非修改全域物件，而是依靠 Node 模組系統的快取機制，當其他程式碼匯入該模組時去補強該模組的實例物件。 預設來說 Mongoose 會使用小寫以及複數的慣例替資料模型命名。例如一個資料模型叫做 CreditCard 最終我們會得到 collection 的名稱是 creditcards 。假如我們希望可以換成 credit_cards 並且其他地方也遵循一樣的用法。 下面是我們試著使用猴子補丁的方式來替既有的模組增加功能 1234567891011121314151617181920212223242526var pluralize = require('pluralize') // 處理複數單字的函式庫var mongoose = require('mongoose')var Mongoose = mongoose.Mongoosemongoose.Promise = global.Promise // v4.1+ http://mongoosejs.com/docs/promises.htmlvar model = Mongoose.prototype.model// 補丁var fn = function(name, schema, collection, skipInit) { collection = collection || pluralize.plural(name.replace(/([a-z\\d])([A-Z])/g, '$1_$2').toLowerCase()) return model.call(this, name, schema, collection, skipInit)}Mongoose.prototype.model = fn/* 實際測試 */mongoose.connect('mongodb://localhost/test')var CreditCardSchema = new mongoose.Schema({number: String})var CreditCardModel = mongoose.model('CreditCard', CreditCardSchema);var card = new CreditCardModel({number: '5555444433332222'});card.save(function (err) { if (err) { console.log(err) } console.log('success')}) 您不該輕易使用上面這種方式補丁，這邊只是為了說明猴子補丁這種方式，mongoose 已經有提供官方的方式設定名稱 1var schema = new Schema({..}, { collection: 'your_collection_name' }) 當這個模組第一次被匯入的時候便會讓 mongoose 重新定義 Mongoose.prototype.model 並將其設回原本的 model 的實作。如此一來所有 Mongoose 的實例物件都具備新的行為了。注意到這邊並沒有修改 exports 所以當我們 require 的時候得到的是預設的物件 另外如果您想使用上面這種補丁的方式時，記得閱讀原始碼並注意是否產生衝突。 請善用匯出的功能Node模組系統提供了一個簡單的機制來封裝功能，使我們能夠建立了清楚的介面。希望掌握這七種設計模式提供不同的優缺點能對您有所幫助。 在這邊作者並沒有徹底的調查所有的方式，一定有其他選項可供選擇，這邊只有描述幾個最常見且不錯的方法。 小結 namespace: 匯出一個物件包含需要的功能 root module 的方式，使用一個根模組匯出其他模組 function: 直接將 module.exports 設為 function Function 物件也可以拿來當作命名空間使用 為其命名方便偵錯 exports = module.exports = something 的作法是為了確保參考(Reference)一致 high-order function: 可以透過代入參數控制並回傳 function 。 可協助實作 middleware 的設計模式 換句話說 middleware 即一系列相同 signature 的 function 串連。一個接一個執行 constructor: 匯出類別(function)，使用時再 new，具備 OOP 的優點 singleton: 匯出單一物件實例，重點在各個檔案可以共享物件狀態 global objects: 在全域物件作的修改也會一起被匯出 monkey patch: 執行時期，利用 Node 快取機制在 instance 加上補丁 筆記 一個 javascript 檔案可視為一個模組 解決特定問題或需求，功能完整由單一或多個模組組合而成的整體稱為套件(package) require 匯入的模組具有自己的 scope exports 只是 module.exports 的參考，exports 會記錄收集屬性如果 module.exports 沒有任何屬性就把其資料交給 module.exports ，但如果 module.exports 已經具備屬性的話，那麼exports 的所有資料都會被忽略。 就算 exports 置於後方仍會被忽略 Node 初始化的順序 Native Module -&gt; Module StartNodeInstance() -&gt; CreateEnvironment() -&gt; LoadEnvironment() -&gt; Cached Native Module 載入機制 檢查是否有快取 -&gt; 有; 直接回傳 this.exports -&gt; 沒有; new 一個模組物件 cache() compile() -&gt; NativeModule.wrap() 將原始碼包進 function 字串 -&gt; runInThisContext() 建立函式 return NativeModule.exports Node 的 require 會 cache ，也就是說：如果希望模組產生不同的 instance 時應使用 function 資源 官方 module 文件 理解 module exports Export This: Interface Design Patterns for Node.js Modules module.exports v.s exports 從 node.js 原始碼看 exports 與 module.exports Export This 中文","link":"/2016/09/19/node-note/"},{"title":"[譯] 學習 CSS clip-path 屬性","text":"整體來說網頁主要是由矩形所構成的，另一方面印刷品則具備相對多樣性。造成這樣差異的原因有很多，不過其中一個即是缺少合適的工具。這篇文章主要會介紹 clip-path 這個 css 的樣式規則可以讓我們遮掉元素的局部，就是不顯示出來。達成這項功能背後的原理就是我們可以透過它去定義可視區，類似於遮色片的概念。我們將從基礎開始然後涵蓋語法，進一步理解進階的概念。 基礎clip 意思是剪裁，意味著修剪某物的外型。在網頁設計的情況下，是讓我們可以去決定某個元素完全隱藏或局部隱藏。而在這篇文章中另外兩個相關的概念是 clipping path 和 clipping region。 clipping path 剪裁路徑意思就是我們使用它去修剪一個元素，透過路徑組成 clipping region 剪裁範圍。這個範圍或稱區域可以是簡單的形狀或複雜的多邊形。剪裁範圍就是透過一個封閉的剪裁路徑所組成的，這與您使用 Illustrator 的鋼筆工具繪製形狀的概念是一樣的。 任何在形狀範圍外的東西都會被瀏覽器裁掉。不只包含背景其他像是內容，borders，text-shadow 效果都會被裁掉。此外瀏覽器甚至不會處理範圍外的事件像是 hover, click 等。 即便我們設定的元素不再是矩形，但周圍的元素排列方式仍然維持原本矩形的佈局。為了達成周圍的元素跟著裁切的形狀，我們可以使用 shape-outside 屬性。 同時記住不要把舊的樣式 clip 和 clip-path 等搞混了。舊有的屬性只支援矩形的裁切。 使用目前這個樣式規則的語法如下： 1clip-path: &lt;clip-source&gt; | [ &lt;basic-shape&gt; || &lt;geometry-box&gt; ] | none 上面語法表示的是： clip-source 會是一個 URL 參考到一個 SVG &lt;clipPath&gt; 元素，這個元素可以是在檔案內部的或外連的。 basic-shape 基本形狀的 function ，您可以在 CSS Shapes 規範 中找到並使用。 geometry-box 可選的參數。搭配 basic-shape 函數，它的用途是設定整張畫布的基準點，定義裁切從哪範圍開始。如果我們自訂 geometry-box 那裁切路徑便會照著我們定義的形狀，包含任何圓角設定 border-radius 。這樣說有點模糊，稍後我們會詳細介紹。 現在，讓我們來思考下面這段 css 程式 123img { clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);} 這段設定將會裁切所有圖片為一個菱形。不過為什麼圖片會變成菱形呢？為什麼不是梯形或平行四邊形？您應該猜到了，這是因為形狀取決為我們定義的頂點。下面圖片說明了建立裁切形狀時使用的慣例 每個座標的第一個參數指定了該座標的 x 軸，第二個參數則是 y 軸。所有的點依照順時鐘的方向繪製。依照這個規則與上圖我想您應該理解了。 如果您正在使用 CodePen 測試這些語法，請注意上面的程式範例僅在 Chrome 並且需要使用 prefix 才能正常運行，您可以打開 Auto Prefix 功能。 CodePen 使用 geometry-box 裁切元素當我們要裁切 HTML 元素時，geometry-box 可以是下列值 margin-box, border-box, padding-box, content-box 1234.el { clip-path: polygon(10% 20%, 20% 30%, 50% 80%) margin-box; margin: 15px;} 上面的範例，margin-box 會決定我們得座標點從 margin 的範圍開始，而 (10%, 10%) 就是我們實際內容的左上角，因此 clip-path 也必須對應計算。 SVG 元素的狀況下，參數可能是 fill-box, stroke-box, view-box 。其中 view-box 會最接近整個 svg 的可視範圍。 clip-path 的使用方式關於這個屬性有很多有趣的使用方式。第一個就是它可以美化文字內容。您可以觀察一下下圖，我們透過背景色與裁切所營造出的感覺不再受限與單純的方形。 簡單說您可以簡單的使用背景色，漸層等等您已經熟悉的屬性然後搭配 clip-path ，例如上面粉紅色背景類似泡泡對話框的效果，從前我們可以要透過 border 組成三角形在透過 transform 和調整位置等屬性去完成，現在換成 clip-path 只需要一行，我們可以輕鬆完成任何不規則的形狀。 123.msg { clip-path: polygon(0% 0%, 100% 0%, 100% 75%, 75% 85%, 75% 100%, 50% 80%, 0% 75%);} 當然您可以用來裁切圖片使其變成各種不同的形狀，您的相片圖庫的頁面不再只能用矩形呈現。下面是一個範例建議您使用 Chrome 玩玩 CodePen 動畫這個屬性也能夠被用在動畫上。唯一要注意的是初始時和最後結果的座標數量要一致。 1234567891011@keyframes polygons { 25% { clip-path: polygon(20% 0%, 100% 38%, 70% 90%, 0% 100%); } 50% { clip-path: polygon(0 46%, 100% 15%, 55% 74%, 0 100%); } 70% { clip-path: polygon(100% 38%, 100% 38%, 66% 100%, 0 53%); }} 為了維持動畫的順暢，基本上座標數量最好保持一致，至於形狀的變化您可以透過重疊座標來實現。 奇技淫巧另外我們還可以透過 clip-path 來隱藏元素，不過這個效果類似於 visibility 和 opacity 該位置空間仍會被佔據。 123.hide { clip-path: polygon(0px 0px,0px 0px,0px 0px,0px 0px);} 關於瀏覽器支援度這個屬性暫時在 IE, Edge 是不能使用的，Firefox 也還沒完全支援只支援部份語法，在 v47 還得要套過 layout.css.clip-path-shapes.enabled 來開啟。Chrome 的話要加上 -webkit- prefix。 總結總結來說關於 clip-path 的重點大略為 設定的座標點(clip-path)需要能夠封閉，圍成一個形狀(clip-range)，這個形狀就是顯示的區域。 周圍的元素仍需要靠 shape-outside 來修正。 geometry-box 用來設定座標軸範圍，用在 HTML 和 SVG 參數是不同的。 動畫的部分座標點數量需維持一致。 目前大多數的瀏覽器支援度還不夠。 clippy 和 座標產生器可以協助我們取得座標。 原文參考 Introducing the CSS clip-path Property","link":"/2016/06/28/css-clip-path/"},{"title":"穠纖合度的整合 Rails、Webpack、Vuejs","text":"前言如果您曾經閱讀過小弟的vue + webpack 起手式一文，裡面我曾提到關於容易與傳統 MVC 框架(Rails, ASP.NET MVC)等結合。這篇文章主要就是用來介紹其作法與為什麼我會這麼說。 我先承認吧！我不總是需要使用 SPA 的架構 雖然它很好，但對於很多小型專案，或者我們應該說 UI/UX 設計本身非常單純的專案 - 殺雞焉用牛刀。所以這邊文章的作法針對的是那些專案不是使用 SPA 搭配 API 的架構的人，而是您覺得既有的 MVC 框架對於您的需求開發已經非常足夠且想保留大多數這些框架提供的功能（本文僅針對 Rails 介紹）。 網路上有非常多關於 Rails 與 Webpack 整合的方式，其實都非常不錯。而關於本文只是介紹其中一種小弟認為剛剛好的整合方式，其中許多觀念都不是新創的，都只是整理過去學習經驗而成。 需求先談談我們的需求與為什麼不使用 asset pipeline，其實簡單來說就是下面列表這些： 我們想使用 ES2015 等新支援的語法，需要 Babel。 許多套件在 bower 上面編譯後的版本並不完整、不支援、或者有其他問題導致我們需要使用 npm。 我們想透過模組來管理相依性的問題。 assets-org 和 gem 對於管理前端資源包來說並不是那麼優秀。 部署希望能夠盡可能單純一點。 準備大體來說這種整合的架構使用 npm (yarn 也可) 來管理前端的資源，gem 則只負責後端部分。 安裝 nodejs 與 npm 安裝 ruby 與 Rails 安裝 Postgre SQL(由於會示範部署至 Heroku 所以使用 Postgre SQL) 第一步 - 建立專案12345678910# 由於示範部署至 Heroku# 因此無法使用 sqlite3$ rails _5.0.0.1_ new [project_name] --database postgresql$ cd [project_name]$ bundle install$ rails db:create$ rails g controller pages index # 建立測試頁面$ rails server # 完成建立一個 Rails 專案# 開啟 http://localhost:3000/pages/index 導入 npm 123456789101112131415161718192021222324252627282930313233$ npm init --yes# 過程中，如果需要測試一下 webpack 指令則需要安裝全域$ npm i -g webpack webpack-dev-server# 安裝所需的前端函式庫$ npm i jquery@^2.1.4 -S$ npm i jquery-ujs@~1.1.0-1 -S$ npm i lodash@~3.0.0 -S$ npm i vue -S# 安裝開發環境所需的套件與函式庫$ npm i webpack \\ webpack-dev-server \\ webpack-manifest-plugin \\ extract-text-webpack-plugin -D$ npm i babel-core \\ babel-loader babel-runtime \\ babel-plugin-transform-runtime \\ babel-preset-es2015 -D # Babel 相關$ npm i coffee-loader coffee-script -D$ npm i css-loader \\ style-loader \\ node-sass \\ sass-loader -D$ npm i exports-loader -D # 匯出檔案$ npm i expose-loader -D # 將物件加到全域(Javascript)$ npm i file-loader url-loader -D$ npm i imports-loader -D # 使用的模組可相依於全域 為了方便您快速安裝下面提供 package.json 123456789101112131415161718192021222324252627282930313233343536373839404142&quot;dependencies&quot;: { &quot;jquery&quot;: &quot;^2.2.4&quot;, &quot;jquery-ujs&quot;: &quot;^1.1.0-1&quot;, &quot;lodash&quot;: &quot;^3.0.1&quot;, &quot;vue&quot;: &quot;^2.0.5&quot;},&quot;devDependencies&quot;: { &quot;babel-core&quot;: &quot;^6.18.2&quot;, &quot;babel-loader&quot;: &quot;^6.2.7&quot;, &quot;babel-plugin-transform-runtime&quot;: &quot;^6.15.0&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.18.0&quot;, &quot;babel-runtime&quot;: &quot;^6.18.0&quot;, &quot;coffee-loader&quot;: &quot;^0.7.2&quot;, &quot;coffee-script&quot;: &quot;^1.11.1&quot;, &quot;css-loader&quot;: &quot;^0.25.0&quot;, &quot;exports-loader&quot;: &quot;^0.6.3&quot;, &quot;expose-loader&quot;: &quot;^0.7.1&quot;, &quot;extract-text-webpack-plugin&quot;: &quot;^1.0.1&quot;, &quot;file-loader&quot;: &quot;^0.9.0&quot;, &quot;imports-loader&quot;: &quot;^0.6.5&quot;, &quot;node-sass&quot;: &quot;^3.11.2&quot;, &quot;sass-loader&quot;: &quot;^4.0.2&quot;, &quot;style-loader&quot;: &quot;^0.13.1&quot;, &quot;url-loader&quot;: &quot;^0.5.7&quot;, &quot;webpack&quot;: &quot;^1.13.3&quot;, &quot;webpack-dev-server&quot;: &quot;^1.16.2&quot;, &quot;webpack-manifest-plugin&quot;: &quot;^1.1.0&quot;},&quot;babel&quot;: { &quot;presets&quot;: [ &quot;es2015&quot; ], &quot;plugins&quot;: [ [ &quot;transform-runtime&quot;, { &quot;polyfill&quot;: false, &quot;regenerator&quot;: true } ] ]} 第二步 - 組織架構為了讓部署與後續設定單純一點，我們選擇將 javascript 和 css 的資源檔抽出原本的目錄，並同時也保留 Rails 預設的相關功能。大略的架構會如下，我們會將所有的前端資源放在 client 目錄底下，當然您要取名叫 webpack 或 frontend 也都是OK的。 12345678910111213141516171819.├── /app│ ├── /assets│ ├── /controllers│ ├── /views│ └── ...├── /bin├── /config├── /db├── /public├── ...├── /client│ ├── /fonts│ ├── /images│ ├── /javascripts│ ├── /stylesheets│ ├── development.config.js│ ├── production.config.js└── ... 除非您是指令控，不然您可以就使用編輯器建立相關檔案與目錄 12345678910111213$ mkdir -p client/javascripts$ mkdir client/fonts$ mkdir client/images$ mkdir client/stylesheets# 新增 Entry Point 檔案$ touch client/javascripts/application.js$ touch client/javascripts/home.coffee # 測試 coffee 使用$ touch client/fonts/.keep$ touch client/images/.keep$ touch client/stylesheets/home.scss$ touch client/development.config.js$ touch client/production.config.js 注意因為這個專案會有 Nodejs 混入，所以您應該要在 .gitignore 中增加相關的設定。 1234567891011121314# Nodenode_modulesjspm_packages.npm.eslintcachenpm-debug.log*pids*.pid*.seed*.pid.lock.nyc_output.grunt.lock-wscriptbuild/Release 簡易的驗證範例 javascripts/home.coffee 1console.log &quot;Hello, CoffeeScript!&quot; stylesheets/home.scss 1234/* 記得放一張圖片 */.home-banner { background-image: url('../images/banner.png');} javascripts/application.js 12import styles from '../stylesheets/home.scss'import Home from './home' 第三步 - 配置 webpackdevelopment.config.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475var path = require('path')var _ = require('lodash')var webpack = require('webpack')var assetsPath = path.join(__dirname, '..', 'public', 'assets')var ExtractTextPlugin = require('extract-text-webpack-plugin')var config = { context: path.join(__dirname, '..'), entry: { /* 定義進入點與其檔案名稱 */ application: [ path.join(__dirname, '/javascripts/application.js') ] }, output: { path: assetsPath, filename: '[name]-bundle.js', publicPath: '/assets/' }, resolve: { extensions: ['', '.js', '.coffee', '.json'] }, debug: true, displayErrorDetails: true, outputPathinfo: true, devtool: 'cheap-module-eval-source-map', module: { loaders: [ { test: require.resolve('jquery'), loader: 'expose?jQuery' }, { test: require.resolve('jquery'), loader: 'expose?$' }, { test: /\\.js$/, loader: 'babel', exclude: /node_modules/ }, { test: /\\.coffee$/, loader: 'coffee' }, { test: /\\.(woff|woff2|eot|ttf|otf)\\??.*$/, loader: 'url?limit=8192&amp;name=[name].[ext]' }, { test: /\\.(jpe?g|png|gif|svg)\\??.*$/, loader: 'url?limit=8192&amp;name=[name].[ext]' }, { test: /\\.css$/, loader: ExtractTextPlugin.extract('style', 'css') }, { test: /\\.scss$/, loader: ExtractTextPlugin.extract('style', 'css!sass') } ] }, plugins: [ new webpack.ProvidePlugin({ $: 'jquery', jQuery: 'jquery' }), new ExtractTextPlugin('[name]-bundle.css', { allChunks: true }) ]}module.exports = config production.config.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677var path = require('path')var _ = require('lodash')var webpack = require('webpack')var assetsPath = path.join(__dirname, '..', 'public', 'assets')var ExtractTextPlugin = require('extract-text-webpack-plugin')var ManifestPlugin = require('webpack-manifest-plugin')var config = { context: path.join(__dirname, '..'), entry: { application: path.join(__dirname, '/javascripts/application.js') }, output: { path: assetsPath, filename: '[name]-bundle-[chunkhash].js', publicPath: '/assets/' }, resolve: { extensions: ['', '.js', '.coffee', '.json'] }, debug: true, displayErrorDetails: true, outputPathinfo: true, devtool: 'cheap-module-eval-source-map', module: { loaders: [ { test: require.resolve('jquery'), loader: 'expose?jQuery' }, { test: require.resolve('jquery'), loader: 'expose?$' }, { test: /\\.js$/, loader: 'babel', exclude: /node_modules/ }, { test: /\\.coffee$/, loader: 'coffee' }, { test: /\\.(woff|woff2|eot|ttf|otf)\\??.*$/, loader: 'url?limit=8192&amp;name=[name]-[hash].[ext]' }, { test: /\\.(jpe?g|png|gif|svg)\\??.*$/, loader: 'url?limit=8192&amp;name=[name]-[hash].[ext]' }, { test: /\\.css$/, loader: ExtractTextPlugin.extract('style', 'css') }, { test: /\\.scss$/, loader: ExtractTextPlugin.extract('style', 'css!sass') } ] }, plugins: [ new webpack.ProvidePlugin({ $: 'jquery', jQuery: 'jquery' }), new ExtractTextPlugin('[name]-bundle-[chunkhash].css', { allChunks: true }), new ManifestPlugin({ fileName: 'client_manifest.json' }) ]}module.exports = config 完成之後執行，測試看看是否有地方錯誤。如果您對於 webpack 並不陌生可以閱讀設定檔理解一下。 12$ webpack --config client/development.config.js$ webpack --config client/production.config.js 查看 public/assets 目錄底下看看編譯的結果。 第四步 - 整合 Rails到此您應該已經理解，我們就是將前端的部份交給 webpack 處理，然後遵循 Rails 的架構將最終的資源檔編譯輸出到 public/assets 。 現在的問題是，我們該如何讀取編譯好的資源呢？ 由於我們希望能夠盡可能的遵循 Rails 的慣例，因此下一步我們在 app/views/layouts/application.html.erb 放入 12&lt;%= client_stylesheet_link_tag 'application' %&gt;&lt;%= client_javascript_include_tag 'application' %&gt; 上面是我們希望的作法（看起來就像是預設支援），所以接著下來我們需要做一些修改好讓 Rails 支援上面兩個 helpers。 首先因為 webpack 加上 hash 的編譯結果，Rails 並無法得知對應的檔案。於是我們需要在 production.config.js 使用 ManifestPlugin 匯出 manifest 讓 Rails 得知如何對應檔案。 config/application.rb 12345678910111213require_relative 'boot'require 'rails/all'Bundler.require(*Rails.groups)module RailsWepback class Application &lt; Rails::Application config.webpack = { asset_manifest: {} } endend 新增 config/initializers/webpack.rb 1234567asset_manifest = Rails.root.join('public', 'assets', 'client_manifest.json')if File.exist?(asset_manifest) Rails.configuration.webpack[:manifest] = JSON.parse( File.read(asset_manifest) ).with_indifferent_accessend 完成這些前置作業之後我們可以讀取到 manifest 了，但您知道的；原生的 Rails 並沒有剛剛那兩個 helpers ，我們需要在 app/helplers/application_helper.rb 加上 1234567891011121314151617181920212223242526272829def client_javascript_include_tag(name) filename = &quot;#{name}-bundle.js&quot; asset_url = Rails.application.config.asset_host src = &quot;#{asset_url}/assets/#{filename}&quot; if Rails.env.development? elsif Rails.configuration.webpack[:manifest] asset_name = Rails.configuration.webpack[:manifest][&quot;#{name}.js&quot;] if asset_name src = &quot;#{asset_url}/assets/#{asset_name}&quot; end end &quot;&lt;script src=\\&quot;#{src}\\&quot;&gt;&lt;/script&gt;&quot;.html_safeenddef client_stylesheet_link_tag(name) filename = &quot;#{name}-bundle.css&quot; asset_url = Rails.application.config.asset_host src = &quot;#{asset_url}/assets/#{filename}&quot; if Rails.env.development? elsif Rails.configuration.webpack[:manifest] asset_name = Rails.configuration.webpack[:manifest][&quot;#{name}.css&quot;] if asset_name src = &quot;#{asset_url}/assets/#{asset_name}&quot; end end &quot;&lt;link rel=\\&quot;stylesheet\\&quot; href=\\&quot;#{src}\\&quot;&gt;&quot;.html_safeend 這上面的 asset_host 是為了讓事情單純一點，我們選擇在 config/environments/development.rb 和 production.rb 加上 12# 路徑請依據實際的狀況調整config.action_controller.asset_host = '127.0.0.1:3000' 您可以採取任何您覺得更好的方式取得路徑。 完成第一階段到這一步，其實我們已經完成最上面我們列出的需求了。 先在 terminal 中執行 1$ webpack --config client/development.config.js --watch 開啟另一個 session 執行 1$ rails server 最後在 views/pages/index.html.erb 中的任一 tag 補上 class=&quot;home-banner&quot; 您就可以觀察到變化。webpack 在背後一直觀察 client 底下檔案的變化，Rails 的開發伺服器則負責原來的工作，載入那些編譯後的檔案。 只是這樣每一次要測試都要打兩條指令很麻煩。 優化開發指令 新增 npm scripts 再往下走之前，我們可以先把 webpack 的指令與其單配的參數先整理到 npm script 1234&quot;scripts&quot;: { &quot;build:dev&quot;: &quot;webpack --config=client/development.config.js --display-reasons --display-chunks --progress --color --watch&quot;, &quot;build&quot;: &quot;webpack --config=client/production.config.js -p&quot;} 接著為了讓我們往後只使用一道指令就能夠輕鬆寫意的開發。最簡單的方式就是使用 foreman 1$ gem install foreman 安裝完 foreman 之後我們需要設定 Procfile 讓其為我們同時啟動兩道指令。 新增 Procfile.dev Procfile support 類型程式預設使用 Procfile 為設定檔，如果直接使用該檔案可能會遇到問題，例如：當我們要使用 Heroku 的話，後續可能在部署的時候產生問題，主要是目前的設定僅限於開發階段使用，於是我們改使用其他的檔名 Procfile.dev。 在專案跟目錄下新增 Procfile.dev 12web: bundle exec rails server -p 3000webpack: npm run build:dev 使用 foreman 1$ foreman s -f Procfile.dev 啟動後您應該看到類似的訊息： 123456789101118:30:56 web.1 | started with pid 1669318:30:56 webpack.1 | started with pid 1669418:30:57 webpack.1 |18:30:57 webpack.1 | &gt; example@1.0.0 build:dev /Users/andyyou/Workspace/sandbox/rails_vuejs_integrate_1/example18:30:57 webpack.1 | &gt; webpack --config=client/development.config.js --display-reasons --display-chunks --progress --color --watch18:30:57 webpack.1 |Hash: 2fdcbe01c557b347442e18:31:00 web.1 | =&gt; Booting Puma18:31:00 webpack.1 | Version: webpack 1.13.318:31:00 web.1 | =&gt; Rails 5.0.0.1 application starting in development on http://localhost:300018:31:00 webpack.1 | Time: 2893ms 支援 Hot Reload基本上到了上一步就已經可以滿足大多數的開發情境，不過您可能也聽多了關於 Hot Replacement Mode (HRM) 的優點，如果我們也想支援呢？ 原理上很單純，我們只需要讓前端資源檔換成是由 webpack-dev-server 所提供即可。 新增 devserver.config.js 注意到基本上這邊只有加入 webpack/hot/dev-server 和 publicPath 不同的差異，可以有更精簡的方式，不過這邊為了讓之後維護比較明顯直覺一點所以將其獨立一個檔案： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677var path = require('path')var _ = require('lodash')var webpack = require('webpack')var assetsPath = path.join(__dirname, '..', 'public', 'assets')var ExtractTextPlugin = require('extract-text-webpack-plugin')var config = { context: path.join(__dirname, '..'), entry: { application: [ 'webpack/hot/dev-server', path.join(__dirname, '/javascripts/application.js') ] }, output: { path: assetsPath, filename: '[name]-bundle.js', publicPath: 'http://localhost:8080/assets/' /* publicPath: '/assets/' */ }, resolve: { extensions: ['', '.js', '.coffee', '.json'] }, debug: true, displayErrorDetails: true, outputPathinfo: true, devtool: 'cheap-module-eval-source-map', module: { loaders: [ { test: require.resolve('jquery'), loader: 'expose?jQuery' }, { test: require.resolve('jquery'), loader: 'expose?$' }, { test: /\\.js$/, loader: 'babel', exclude: /node_modules/ }, { test: /\\.coffee$/, loader: 'coffee' }, { test: /\\.(woff|woff2|eot|ttf|otf)\\??.*$/, loader: 'url?limit=8192&amp;name=[name].[ext]' }, { test: /\\.(jpe?g|png|gif|svg)\\??.*$/, loader: 'url?limit=8192&amp;name=[name].[ext]' }, { test: /\\.css$/, loader: ExtractTextPlugin.extract('style', 'css') }, { test: /\\.scss$/, loader: ExtractTextPlugin.extract('style', 'css!sass') } ] }, plugins: [ new webpack.ProvidePlugin({ $: 'jquery', jQuery: 'jquery' }), new ExtractTextPlugin('[name]-bundle.css', { allChunks: true }) ]}module.exports = config 增加 npm scripts 1&quot;dev&quot;: &quot;webpack-dev-server --config=client/devserver.config.js --inline --hot --no-info&quot; 更新 app/helpers/application.rb 因為目前有兩種開發模式，所以我們透過環境變數 HRM=true 來區分支不支援 HRM 模式。這邊遭遇的問題就單純是路徑不一樣，您絕對可自行調整優化，而這篇文章旨在記錄這個流程與概念。 123456789101112131415161718192021222324252627282930313233343536373839def client_javascript_include_tag(name) filename = &quot;#{name}-bundle.js&quot; asset_url = Rails.application.config.asset_host src = &quot;#{asset_url}/assets/#{filename}&quot; if Rails.env.development? if ENV[&quot;HRM&quot;] src = &quot;http://localhost:8080/assets/#{filename}&quot; else src = src end elsif Rails.configuration.webpack[:manifest] asset_name = Rails.configuration.webpack[:manifest][&quot;#{name}.js&quot;] if asset_name src = &quot;#{asset_url}/assets/#{asset_name}&quot; end end &quot;&lt;script src=\\&quot;#{src}\\&quot;&gt;&lt;/script&gt;&quot;.html_safeenddef client_stylesheet_link_tag(name) filename = &quot;#{name}-bundle.css&quot; asset_url = Rails.application.config.asset_host src = &quot;#{asset_url}/assets/#{filename}&quot; if Rails.env.development? if ENV[&quot;HRM&quot;] src = &quot;http://localhost:8080/assets/#{filename}&quot; else src = src end elsif Rails.configuration.webpack[:manifest] asset_name = Rails.configuration.webpack[:manifest][&quot;#{name}.css&quot;] if asset_name src = &quot;#{asset_url}/assets/#{asset_name}&quot; end end &quot;&lt;link rel=\\&quot;stylesheet\\&quot; href=\\&quot;#{src}\\&quot;&gt;&quot;.html_safeend Procfile.devserver 12web: bundle exec rails server -p 3000webpack: npm run dev 使用指令1234567# 平常開發模式$ foreman s -f Procfile.dev# 支援 Hot Reload$ HRM=true foreman start -f Procfile.devserver# Ctrl + C 中止 漸進式的 Vue.js 是 MVC 框架的好朋友在 Javascript 當道的今天我想您很容易找到很多關於 SPA 的主流作法。但這篇文章要說明的是把 JS 當作配角的作法。 首先我們需要更新設定檔，使其支援主角 Vue.js v2 1$ npm i vue-loader vue-hot-reload-api -D webpack 所有的 config loader 的部分補上： 1234{ test: /\\.vue$/, loader: 'vue'} 另外 resolve 的部分，因為我們需要 standalone 版本的功能所以需要下面設定： 123456789resolve: { extensions: ['', '.js', '.coffee', '.json'], /** * Vue v2.x 之後 NPM Package 預設只會匯出 runtime-only 版本，若要使用 standalone 功能則需下列設定 */ alias: { vue: 'vue/dist/vue.js' }} 首先新增元件 12$ mkdir client/javascripts/components$ touch client/javascripts/components/Car.vue Car.vue 範例程式如下 1234567891011121314151617181920212223242526272829&lt;script&gt;export default { data () { return { brand: 'BMW 3 Series', mileage: 0 } }, mounted () { this.handle = setInterval(() =&gt; { this.mileage++ }, 1000) }, destroyed () { clearInterval(this.handle) }}&lt;/script&gt;&lt;style lang=&quot;sass&quot; scoped&gt;$pink: pink;.brand { color: $pink; font-size: 1.4em;}&lt;/style&gt; 更新 application.js 12345678910111213141516import styles from '../stylesheets/home.scss'import Home from './home'import Vue from 'vue'import Car from './components/Car.vue'document.addEventListener('DOMContentLoaded', function () { new Vue({ el: '#app', data: { message: 'Hello, Rails with Vue.js' }, components: { car: Car } })}) app/views/pages/index.html.erb 123456789&lt;div id=&quot;app&quot; v-cloak&gt; &lt;h1 class=&quot;home-banner&quot;&gt;{{ message }}&lt;/h1&gt; &lt;car inline-template&gt; &lt;div&gt; I am &lt;span class=&quot;brand&quot;&gt;{{ brand }}&lt;/span&gt;! I runned {{ mileage }}. The important thing is the variable from controller#action wheel is &lt;%= @wheel %&gt; &lt;/div&gt; &lt;/car&gt;&lt;/div&gt; 如果您曾使用過 Vue.js 可能會覺得這樣好奇怪，為什麼 component 裡面沒有 &lt;template&gt; 。 主要因為 Vue 有支援 inline-template 這種作法，這讓我們還可以延續使用從 controller action 來的資料，像是您想繼續使用 Rails 的 i18n 機制。 當然有人可能會說 template 抽到 views 那怎麼重複使用元件，使用 Rails 的 partial 就好了。 重點是這裡不是試圖提出一種萬靈丹，而是提供另一種思路，該怎麼樣使用取決於您的需求。 另外您也可以繼續使用 slim 12345div id=&quot;app&quot; v-cloak=&quot;&quot; car inline-template=&quot;&quot; div | {{ message }} = @wheel 部署至 Heroku很高興您能看到這一步，這個過程其實挺累人的。最後當我們完成這一系列的修改，我們還是希望能夠部署到一些方便的服務上，這邊就舉 Heroku 來示範。 第一步我們需要先在 package.json 補上一些設定，好讓 Heroku 在安裝完 Node 環境之後可以幫我們執行 webpack 1234&quot;scripts&quot;: { ..., &quot;heroku-postbuild&quot;: &quot;npm run build&quot;} 部署 123456789$ heroku login$ heroku create --app [your_app_name]$ heroku buildpacks:clear$ heroku buildpacks:set heroku/nodejs$ heroku buildpacks:add heroku/ruby --index 2# 安裝 package.json devDependencies 的部分$ heroku config:set NPM_CONFIG_PRODUCTION=false$ git push heroku master 整體來說如果您有這些前端複雜的需求，使用 webpack 可能暫時是不錯的方式。當然如果您有更優秀的作法也歡迎您給小弟一些建議。","link":"/2016/11/07/integrate-rails-webpack-vue/"},{"title":"[譯] Yarn - Javascript 新一代套件管理","text":"本文轉譯並補充自 - Yarn: A new package manager for JavaScript。 在 Javascript 社群中，開發者們分享成千上萬的原始碼讓我們可以省去重造輪子的時間，不用重新打造函式庫，框架，元件等。而每段原始碼都有可能相依於其他原始碼片段，這些相依的程式碼通常會透過套件管理（package manager）來管理。其中在 Javascript 裡，最熱門的就屬 npm ，在上面有 5 百萬個開發者，套件庫提供了超過 300,000 模組，更驚人的是每個月有超過 5 億次的下載量。 Facebook 的團隊使用 npm 客戶端工具已經好幾年了，隨著原始碼大幅的成長，我們開始遭遇到一些問題包含了一致性，安全性，效能方面。在嘗試解決遇到的每一個問題之後，我們開始創造一套新的、更可靠的解決方案來協助我們管理相依性的問題。 這東西叫做 Yarn - 一個快速，可靠，更安全取代 npm 客戶端的工具。 我們很開心的發佈釋出 Yarn 為開放原始碼專案，並和 Exponent, Google, Tilde 協作。使用 Yarn ，開發者仍然存取 npm 套件庫 （npm registry），但可以更快速的安裝和管理套件，保持套件的一致性，可靠的離線環境的安全性。Yarn 讓開發者在使用這些分享的開源碼時可以自信的更新，替換，因此開發者們可以專注在他們的任務 - 開發產品和功能。 npm registry 收錄開發者提供模組的檔案庫與其對應資訊列表，翻譯為註冊表，但譯者認為套件庫較能表達其意義。 Facebook 管理 Javascript 模組的演化在使用套件管理之前，常見的狀況就是 Javascript 開發者直接透過 CDN 存取相依的片段原始碼。第一版的 npm 在 Nodejs 出現之後很快的就被開發出來，很快的它就成為世界上最熱門的套件管理工具。創造了數以千計的新開源專案以及比以往更多的開發者分享他們的成果。 Facebook 的許多專案像是 React，也相依於 npm 上面的程式碼。然而當我們內部成員增加的時候，當不同的成員與機器要安裝這些相依模組就開始面臨到一致性的問題，大量的時間花在處理安裝相依模組。同時由於 npm 會自動執行一些相依的程式碼而伴隨著安全性的議題。於是我們嘗試開發一個解決方案去處理這些問題。 嘗試擴展 npm 客戶端工具（npm client）起初，跟著官方的最佳實踐，我們只檢查 package.json 然後要求開發者手動執行 npm install。這對開發者來說運作還算良好，不過卻在我們持續整合環境（continuous integration environments）中出現問題，因為該環境處於沙箱模式，並且基於安全性的因素不與外部網路連接。 接著我們的解決方案則是檢查所有的 node_modules 然後存到檔案庫裡套件庫（registry）。雖然它能運作，但同時讓一些簡單的操作變得非常困難。舉例來說更新次版號的 babel 會產生高達 800,000 行的 commit 導致完整下載，執行 lint 規則檢查像是不符合規範的 utf8 字節序列，windows 行結尾，非 png 壓縮圖片，等等等這些任務變得很難完成。合併 node_modules 的修改很可能就耗掉開發者一整天。 我們的版本控制團隊也指出那些我們 check-in 的 node_modules 目錄包含了太大量的 metadata。例如：React Native 的 package.json 現在就有 68 個相依的模組，然後在執行 npm install 之後 node_modules 目錄包含了 121,358 個檔案。 我們做了最後的嘗試 - 補強 npm client，使其適用於 Facebook 的工程師。協助處理那些我們需要安裝的大量程式碼。我們決定 zip 打包整個 node_modules 目錄，然後上傳到內部的 CDN，之後開發者和持續整合環境都可以下載一樣的檔案。這讓我們可以從版本控制中移除數以千計的檔案，不過為了達到這個功能開發者提取和建置時需要內部的存取權限。 另外，我們在處理問題的時候也會需要使用 shrinkwrap 的功能，這讓我們可以鎖定特定相依套件的版本。預設 shrinkwrap 並不會產出，因此如果工程師忘記下指令的話那麼版本又會不一致，所以我們寫了一個工具用來驗證 shrinkwrap 的檔案內容是否符合 node_modules。 這些檔案是超大的 JSON blob 並且 keys 沒有排序，因此要修改它們勢必會產生大量的輸出，然後難以審核 commit。為了解決這個問題我們需要加入額外的 script 來排序它們。 最後，使用某些版本的 npm 更新單一的相依套件可能會連帶更新一些不相關的檔案。這將導致每一次更新比預期的更大，而且必須將其納入整個提交 node_modules 或更新到 CDN 的流程，這不是開發者樂於見到的狀況。 開發新的客戶端工具（client）比起持續補強 npm 客戶端工具，我們選擇嘗試更全面的看待這些問題。假如我們開發一個全新的客戶端工具能夠完全解決我們曾遭遇過的這些問題呢？倫敦辦公室的 Sebastian McKenzie 開始嘗試挑戰這個點子，這點子的潛力讓我們很興奮。 一開始，我們開始詢問業界的開發者們，發現他們都面臨一系列類似的問題，嘗試使用類似的解決方案，一次解決一個遭遇的問題。很明顯的社群正面臨通過合作來解決這一系列的問題，而我們可以開發出一個方案適用於任何人。得到 Exponent, Google, Tilde 工程師的協助，我們開發出了 Yarn 並在各個主流的 JS 框架中測試與驗證其效能，還包括了 Facebook 以外開發團隊的使用情境。今天(2016-10-11)我們很開心與社群分享這個成果。 Yarn 介紹Yarn 是一個新的套件管理工具，主要用來取代既有的工作流程中 npm client 或其他套件管理工具的部分（安裝、更新、移除套件等的指令集），同時兼容於現有的 npm registry。大部分的功能與操作與既有的流程相同並且更快速，安全，可靠。 任何套件管理工具的主要功能是安裝模組套件 - 一個特定用途的片段程式碼 – 從全球通用的套件庫（registry）中安裝到開發者本地的環境中。每一個套件可能會相依於其他套件。一個典型的專案可能具備數十，數百甚至上千個相依的模組。 這些相依的模組都有版號並且基於語意化版本規範（semver）安裝或更新。語意化版本規範了版號的意義與相關符號的規則，這些規則可以讓我們知道該版本是否相容於上個版本，是屬於加入新功能，或者只是修復 Bug，然後基於這些規則來確認是否能更新或該更新到什麼版號。 然而語意化版本規範（semver）需要仰賴套件開發者不犯任何錯誤 - 如果沒有鎖定相依套件的版本，新的 Bug 或錯誤的修改極有可能就被安裝了。 架構在 Node 的生態圈裡，相依的模組會被放在專案下的 node_modules 目錄。然而隨著合併重複模組的狀況，這個檔案結構可能不同於真實的目錄結構 譯者補充：npm 顯示的相依階層跟實際目錄結構不同。 npm 客戶端工具安裝相依模組到 node_modules 目錄並不會依據模組結構（不確定性）。意味著它只會依序安裝模組，而 node_modules 目錄中的結構每一個人可能是不一樣的。這些差異可能最造成『我可以跑啊』的狀況，通常需要很長的時間去找問題點。 Yarn 透過 lockfiles（yarn.lock） 鎖定機制和一套安裝邏輯解決了這些關於版本和不確定性的問題使其具備可靠性與確定性。這些 lockfiles 會鎖定安裝的相依模組為特定版本，確保安裝在每台機器上的 node_modules 結果是一致的。lockfile 使用精準的格式撰寫與排序的鍵 （keys）來確保修改動作最小化，同時在審核的時候比較單純。 整個安裝流程拆解為下面三個步驟： 辨識：Yarn 透過發送請求到套件庫（registry）開始解析相依的套件模組，然後層層遞迴的檢查每一個模組相依的東西。 擷取：下一步，Yarn 檢查全域快取的目錄（global cache directory）看看是否有需要的套件已經被下載了。如果沒有，Yarn 開始下載模組的壓縮包（tarball）並將其存放到全域快取的目錄下，所以這表示我們是可以離線工作的，同樣的模組不需要下載兩次。您也可以將相依的模組使用壓縮檔的形式加入版控來達到完全離線安裝。 連結：最後，Yarn 從全域快取（global cache）複製所需的檔案到本地的 node_modules 完成整個流程。 因為清楚的分拆這些步驟並確保一致的結果，Yarn 便有能力平行處理每個操作，讓整個安裝流程更快速。在某些 Facebook 專案 ，Yarn 簡化了整個安裝流程，從幾分鐘到只剩幾秒鐘。Yarn 也提供互斥的機制確保多個執行的指令不會互相干擾。 Yarn 會嚴格把關整個安裝流程，協助您掌控安裝流程。套件的檢核資訊會存放在 lockfiles（yarn.lock ）確保每一次安裝的都是一樣的套件模組。 功能除了確保安裝流程更迅速和可靠，Yarn 也支援其他功能讓我們更方便的管理相依套件，簡化工作流程。 與 npm 和 bower 相容，同時也支援不同的套件庫（registry） 嚴格限制安裝套件的 Licenses 和輸出相關訊息 提供 API 協助建置工具取得輸出一些工具的資訊（譯者註：此部分尚未完成，更多資訊參考此 Issue） 精簡有意義且美觀的指令輸出資訊 使用 Yarn 於正式環境在 Facebook 我們已經在正式產品中使用 Yarn，同時其運作非常良好。使得許多專案在管理相依套件上更加方便。我們讓工程師即便在每次的移動中都能夠快速的離線建置，加速整個工作流程。 您可以看到 Yarn 和 npm 安裝 React Native 的時間差距，具體資料您可以查閱這裡。 入門最快速的入手方式就是執行 1234$ npm install -g yarn$ yarn# 又或者參考官方文件：https://yarnpkg.com/en/docs/install yarn 就可以在工作流程中透過相同或相似的指令取代 npm 。 npm install -&gt; yarn 此指令不需任何參數，yarn 會讀取 package.json 然後從 npm registry 擷取套件並安裝到 node_modules。等同時使用 npm install。 npm install --save &lt;name&gt; -&gt; yarn add &lt;name&gt; 我們移除 npm 預設不紀錄模組並把 --save 拆開為參數的行為。執行 yarn add &lt;name&gt; 等於 npm install --save &lt;name&gt; 發展許多人和我們一起建造了 Yarn 來解決常見的問題，我們意識到 Yarn 需要成為一個社群專案讓更多人使用。Yarn 現在已經釋出可以在Github上找到，我們為 Node 社群貢獻最棒的東西就是：使用 Yarn，分享一些點子，撰寫文件，互相支援。我們相信 Yarn 有了一個好的開始，但有了您的幫助它會變得更好。 相關閱讀 取代 npm 的新利器 Yarn 利用 Yarn 安裝 Vue-cli","link":"/2016/10/12/new-package-manager-javascript-yarn/"},{"title":"Vue.js 由 1 到 2 的旅程 - (1)","text":"這系列文章會是記錄從 Vue 版一轉移到版二過程中差異點的筆記，希望以輕鬆短篇的方式撰寫。小弟認為如果您不是那種會乖乖的把文件完整娓娓讀一遍的人，有許多差異點可能就被您忽略了，當然就把它們忘了或從來沒理解過（從 Vue 2 入手的朋友們）也不會是什麼大問題，反正等到您遇到問題的時候肯定又會找到它。不過這系列跟希望紀錄的是思路的演進，像是為什麼不支援內建 filter 這類的議題，每一次改變總有它的道理我們不一定能參透但試著想想看並記錄下來希望下一次能成為更好的開發者。 廢話不多說就讓我們開始來說今天的故事： is 與 &lt; component &gt;事實上很多直上 vue-loader 的觀眾們可能會忽略 Vue 有一個 &lt; component &gt; 樣板標籤。怎麼使用呢？看看下面的範例程式碼，假如我們定義了一個元件： 12345678910111213141516Vue.component('engine', { template: ` &lt;div&gt; Engine: TSI &lt;/div&gt; `,})new Vue({ el: '#root', template: ` &lt;div&gt; &lt;component is=&quot;engine&quot;&gt;&lt;/component&gt; &lt;/div&gt; `}) 什麼用途呢？腦袋轉得快的朋友們馬上就意識到可以用來 binding 變數切換元件，官方文件當然也有說明。 12345678910111213141516171819202122232425Vue.component('iphone', { template: `&lt;div&gt;iphone&lt;/div&gt;`})Vue.component('s7', { template: `&lt;div&gt;Samsung S7&lt;/div&gt;`})new Vue({ el: '#app', template: ` &lt;div&gt; &lt;button type=&quot;button&quot; @click=&quot;change&quot;&gt;Change Phone&lt;/button&gt; &lt;component :is=&quot;mobile&quot;&gt;&lt;/component&gt; &lt;/div&gt; `, data: { mobile: 'iphone' }, methods: { change: function () { this.mobile = this.mobile === 'iphone' ? 's7' : 'iphone' } }}) keep-alive不管您是順著文件閱讀或是直覺地想問 切換過程中我可以保留該元件的狀態嗎？ 萬一我的元件很大可以快取嗎？，下一個解救我們的主角 - keep-alive 就會接續登場。 沒錯！它的用途就是將我們的物件實例暫存在記憶體，避免反覆重新渲染同時也保留了狀態。只不過他在版本ㄧ、二之間有點差異： 1234567&lt;!-- v 1.x --&gt;&lt;component :is=&quot;currentView&quot; keep-alive&gt;&lt;/component&gt;&lt;!-- v 2.x --&gt;&lt;keep-alive&gt; &lt;component :is=&quot;currentView&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt; 上面這兩小節純粹是為了鋪陳，沒什麼特別驚人之處，keep-alive 也只是順便帶上。接下來就是本日容易忽略的地方： 今日特餐 - activate（v1.x） v.s activated/deactivated（v2.x）先來聊聊在版本一時，官方文件 - Components 一章曾經探討到關於 activate 這個特殊的 hook。白話文來說這個事件在我們手動插入 Vue 物件實例時，例如：使用 new Vue() 的情況下是不會被觸發的。只有在使用 這樣的方式才會發動，第一次認識這傢伙是因為 vue-router v1。 另外這傢伙有一個特殊之處就是它具備一個 done 參數，須被執行元件才會正確地被掛載。 12345678910111213141516171819202122232425262728293031323334353637383940/** * Vue 1.x */Vue.component('transmission', { template: ` &lt;div&gt;{{name}}&lt;/div&gt; `, data: function () { return { name: 'DQ200' } }, activate: function (done) { console.log('transmission activate') done() }})Vue.component('engine', { template: ` &lt;div&gt;{{name}}&lt;/div&gt; `, data: function () { return { name: 'TSI' } }, activate: function (done) { console.log('engine activate') done() }})new Vue({ el: '#car', activate: function (done) { console.log('car activate') // missing: no trigger done() }}) jsfiddle 這也讓我們有機會在切換元件的過程中確定是不是該輸出該元件。可想而知這用在 router 上是多麽合適。 那麼在版本二之後呢？ 在 Vue 2.x 裡我們已經沒有這個 Hook 可以使用了，沒有取而代之。但是有相似的傢伙 - 是 activated 與 deactivated。且需要注意的是這兩個掛鉤只會在套用 keep-alive 時被觸發。注意過去式，這兩者和版本一的 activate 觸發的時間點是不同的。 123456789101112131415161718192021222324252627282930313233343536373839Vue.component('iphone', { template: `&lt;div&gt;iphone&lt;/div&gt;`, activated: function () { console.log('iphone activated') }, deactivated: function () { console.log('iphone deactivated') }})Vue.component('s7', { template: `&lt;div&gt;Samsung S7&lt;/div&gt;`, activated: function () { console.log('s7 activate') }, deactivated: function () { console.log('s7 deactivated') }})new Vue({ el: '#app', template: ` &lt;div&gt; &lt;button type=&quot;button&quot; @click=&quot;change&quot;&gt;Change Phone&lt;/button&gt; &lt;keep-alive&gt; &lt;component :is=&quot;mobile&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt; &lt;/div&gt; `, data: { mobile: 'iphone' }, methods: { change: function () { this.mobile = this.mobile === 'iphone' ? 's7' : 'iphone' } }}) jsfiddle","link":"/2016/12/05/vue-hook/"},{"title":"Heroku 運行類別、 Procfile、常用指令筆記","text":"Procfile 是一種定義指令是否可以在 Heroku dynos（一種輕量化的容器，可以執行特定用戶設定的指令）上執行的機制。它遵循著 Unix 的程序模型（process model）。這裡為了簡化概念，我們可以說 dyno 就是執行指令的一個個體。舉例來說一個 web dyno 就意味著執行一個 web server 的程式。希望這樣的說明可以理解這些特殊的名詞概念。 您可以使用 Procfile 來宣告多種程序的類型（執行的程式種類），更簡單的來說一個執行中的程式就稱為一個程序（process）。例如一個標準的 Rails 程式至少需要兩種程序類型一個是 rack 相容的網站服務程序（Webrick, Unicorn）和 worker 程序（Delayed Job, Resque）。套用上面白話的說法就是一個執行中的伺服器服務程式，和一個排程的執行程式。 Profile 命名與配置一個 Procfile 檔案名稱就是 Procfile，不應該是其他名稱也不需要副檔名。舉例來說 Procfile.txt 就是錯誤的，如果是 txt 檔案就應該只是一個文字檔。 再者這個檔案應該被存放在專案的根目錄底下，如果放到其他目錄則不產生任何作用。 程序類型（process types）一個 Procfile 可包含多個程序（process）的宣告，且每一行可以定義一個 process type 和指令。我們稱為程序類型（process type）其實就是一指定某一種 dyno 個體，隨後當這個 dyno 啟動後就會執行後面的指令。 好難懂！沒關係，舉例來說假設我們宣告了一個 web process type，意思就是靠設定後面的指令啟動該 dyno。這表示我們透過指令啟動一個 web server。直接看一下程式碼您比較清楚： 一個 Rails 的 process type 在 Procfile 中會如下設定 1web: bundle exec rails server -p $PORT 而一個 Clojure 程式的 web process type 大概會長得像下面這個： 1web: lein run -m demo.web $PORT 使用 Maven 產生的批次檔執行 Tomcat Java 的應用程式伺服器： 1web: sh target/bin/webapp 對於許多應用程式來說，這些預設的設定就足夠了。不過某些複雜並且帶有的特定執行環境需求的程式，您也許會需要自己設定相關的 process type。舉例來說，Rails 應用程式也提供額外的 process type 1worker: bundle exec rake jobs:work 定義程序類型（process type）程序類型是透過 Procfile 這個檔案來定義的，並且此檔需要放在專案的跟目錄下，而其中每一行定義一個 process type。其格式如下： 1&lt;process type&gt;: &lt;command&gt; process type - 英數字串，定義該程序類型例如：web, worker, urgentworker, clock 等。 command - 用來啟動該程序的指令，例如：rake jobs:work 其中 web process type 較為特殊，只有這種類型可以接收 Heroku 路由送來的 HTTP 傳輸資訊，其他類型可以隨意命名。 另外最一開始提到 dyno 與 process type 其實這兩者之間的關係： process type 是原型類似於 class 的概念，而 dyno 則是實際初始化後的執行個體。 本地端開發（Heroku Local）當我們在本地端開發和除錯的時候讓開發環境盡可能的與遠端環境相同是很重要的，這可以協助我們在部署之前找到問題。這時我們可以使用 Heroku Local 指令，在本地端模擬支援 Procfile 的機制。 這個時候只要先配置 Procfile 和 .env 環境並數的檔案並執行 heroku local 並可在開啟本地端模式。 Heroku Local 是一系列指令工具協助我們執行支援 Procfile 的應用程式。預設就會跟著 Heroku CLI 一起被安裝。同時它會從 .env 檔案讀取環境變數，該指令集使用 node-foreman 來完成這個任務。 啟動1234567$ heroku local$ heroku local:start # 上面是縮寫$ heroku local web # 啟動指定特定 process type，Ctrl + C 關閉$ heroku local -f Procfile.test # 指定其他 Procfile$ heroku local -e .env.test # 指定其他環境變數檔案$ heroku local -p 7000 # 指定 port，預設使用 5000 port$ heroku local -r # 當程序死掉時自動重啟 .env 的設定格式 12S3_KEY=mykeyS3_SECRET=mysecret 注意 .env 應該要加到 .gitignore 複製 Heroku config 環境變數到 .env1$ heroku config:get CONFIG-VAR-NAME -s &gt;&gt; .env 部署到 HerokuProcfile 並不是部署應用程式必須的東西，Heroku 會自動偵測使用的程式語言然後替它們建立對應的 web 程序類型。當然這邊推薦替您的程式建立一個明確的 Procfile。 另外，使用 heroku ps 可以提供我們明確正在執行的 dyno 數量與其狀態資訊。 123heroku ps=== web (Free): bin/rails server -p $PORT -e $RAILS_ENV (1)web.1: idle 2016/10/31 12:32:49 +0800 (~ 4h ago) heroku logs 可以彙整顯示關於所有 dyno 的 log。 操作（擴展） process typeHeroku 正常情況下會自動執行一個 web dyno ，並且其他的 process type 預設並不會自動執行。例如我們要啟動一個 worker 我們就需要自己執行（注意：Procfile 沒有註明的情況下） 1$ heroku ps:scale worker=1 當然在隨著服務成長我們可能會需要增加 dyno 的規格 1234567$ heroku ps:resize worker=standard-2x# web=2 意味著水平擴展增加為 2 個叢集節點，standard-2x 為垂直擴展增加單節點的效能$ heroku ps:scale web=2:standard-2x# 單純水平擴展$ heroku ps:scale web=4 worker=2 使用 ps 可以確認看看 process type 是否運行。 123456heroku ps=== web: `bundle exec rails server -p $PORT`web.1: up for 2m=== worker: `env QUEUE=* bundle exec rake resque:work`worker.1: up for 5s 由於預設 heroku logs 會把所有 process type 的日誌訊息都混在一起，有時候我們僅需要針對某一類型查看資訊 1$ heroku logs --ps worker Heroku 指令彙整1234567891011121314151617181920$ heroku login # 登入$ heroku version # 查看版本$ heroku keys:add # 上傳金鑰$ heroku create --app [app_name] # 建立 app$ heroku open # 開啟網址$ heroku rename # 重新命名 app 與對應網址$ heroku ps:scale worker=2 # 啟動 worker dyno$ heroku ps:stop worker # 停止所有 worker dynos$ heroku ps:stop worker.2 # 停止指定的 worker dyno$ heroku ps:restart # 重啟所有 dynos$ heroku dyno:type web=3 # 設定指定 dyno 規格$ heroku dyno:type standard-1x # 全部服務都設定為 standard-1x$ heroku ps # 查看運行狀態$ heroku logs --ps worker # 針對特定 dyno 列出 log$ heroku pg:reset DATABASE # 清空資料庫# Rails v5.x$ heroku run rails console # 運行在遠端主機的 rails console$ heroku run rails db:migrate$ heroku run rails assets:precompile 資源 官方 dynos 管理教學文件","link":"/2016/10/31/process-types-and-profile/"},{"title":"2017 歲末年終工具大掃除","text":"很快地又到了年末大掃除了時候，今年增加的工具軟體並不多反而捨去了不少工具。剩下的這些便是展望 2017 年與 2016 整年度下來持續使用的工具。 OSX 一般軟體 Bartender 2 - OSX Menu bar icon 整合 Alfred 3 - 快速搜尋啟動 AppCleaner - 軟體移除 Divvy - 視窗佈局快速切換 Dropbox - 雲端硬碟 Google Drive FileZilla Transmit Firefox Awesome Screenshot Google translator JSONView OneTab SQLite Manager Zoom Chrome Bitly feedly Google Translate Momentum OneTab Pocket Postman Rails Panel Open SEO Stats Wappalyzer Vue.js Devtools Growl - 通知管理 Kindle - 下載特定免費書籍 Microsoft Office VMWare Fusion - 虛擬作業系統 Memory Cleaner 2 Quip Spark - Email 工具 Spotify - 串流音樂 uTorrent - BT MPlayerX Monosnap - 截圖簡易編輯 ember - 擷取畫面與管理 The Unarchiver - 壓縮 ScreenFlow - 錄螢幕 CloudApp - 拖拉上傳空間 管理/服務 Be Focused - 蕃茄鐘 Wunderlist - 待辦清單 asana - 團隊任務管理 Trello - 看板 Desktime - 追蹤工作時間 開發工具 Fira Code Light - 開發慣用字體 iTerm2 - 終端機軟體 Dash - 開發 API 文件快速查閱 Atom - 開發編輯器 UI Theme One Dark Syntax Theme Solarized Dark Plugins atom-beautify atom-ternjs color-picker emmet file-icons git-log vim-mode vim-surround CLI homebrew homebrew-services git nvm + node rvm + ruby tree elasticsearch mongodb mysql postgresql Docker Powerline Fonts MacVim ngrok - ssh tunneling Postico - PostgreSQL Client 軟體 Robomongo - MongoDB Client 軟體 Sequel Pro - MySQL Client 軟體 devdocs - API 文件會整 Website Grader - 網頁測試分析工具 norse - DDOS 地圖 fabric kit - 追蹤 Crash 等工具 regexr - Regex 測試 caniuse - 瀏覽器支援測試 Paw - API Tool Client 軟體 設計軟體 Pencil - 單機 wireframe Sketch - 繪圖設計工具 XMind Adobe Photoshop - 繪圖設計工具 Adobe Illustrator - 向量圖工具 0to255 - 色票 Sip - Color Picker siteinspire - 靈感 deviantart - 靈感 dribbble - 設計靈感 brandcolors - 各大品牌 color palettes Rulers - 測量 px PhotoBulk 社群 Gitter Line KakaoTalk Hangout Zoom.us Skype Skype Meetings App WeChat 網路服務 intercom - User feedback gitlab gogs imgur - 圖片分享 statcounter - 趨勢分析 ifttt - 服務串連工具 codepen - 線上 HTML, CSS, JS tailorbrands - 快速 logo 產生 mailgun - 寄信服務 urban - 新世代英文單字查詢 calendly - 協同日曆 quizlet - 語言學習, 背單字 Bussiness Canvas Github dictionary engoo Heroku AWS 2017 開發 Framework &amp; Standard Vue.js Weex Ruby on Rails 5.x 設計原則 Ant Design Atom 偏好設定Use Preview Tabs說明點擊檔案一下為預覽檔案，兩下才開啟分頁 設定 開啟 Preferences 選取 Packages 搜尋 tabs 點 Settings 勾選 Use Preview Tabs 關閉自動補齊加入 Buffers說明自動補齊會把之前打過的字加入，很惱人。 設定 開啟 Preferences 選取 Packages 搜尋 autocomplete-plus 點 Settings 關閉 Include Completions From All Buffers","link":"/2016/12/17/2017-osx-tools/"},{"title":"關於 Javascript {} + {}","text":"這篇文章源自 What is {} + {} in JavaScript? 其實早在 2012 年就問世了。時至 2016 年末純粹是在聊天時重提這個問題，但由於年紀大了記憶力不佳，竟然記錯了，所以才會有這一篇重新紀錄的筆記。 源頭是當時由 Gary Bernhardt 在閃電秀中指出 Javascript 的詭異行為 - Wat 在開始之前我們先補充一下關於 Javascript 型別的整理 基礎型別（Primitive Type） string number boolean nudefined null symbol（ECMAScript 6） 物件型別（Object Type） object Function Array Date 其他 關於 Javascript 的加法其實是很簡單的：原則上您只能夠將數字（Number）或字串（String）相加。於是其他的東西相加的時候將會被轉型成數字或者字串。為了理解轉換的機制我們需要先釐清一些事情，我們得引用 ECMA-262 5.1 版規範的 9.1 章節或新版 ECMA-262 7 的 7.1.1 的說明 讓我們來複習一下，在 Javascript 中關於型別的大分類 - 有兩種類型的值： primitive 原生 object 物件 就像上面列出來的除了 undefined, null, boolean, number, string, symbol 之外的東西都是物件，當然陣列和函式都是物件的一種。 轉換加法運算子整體來說會執行三種類型的轉換，結果就是它會將值轉成原生型別 primitive 中的 Number 或 String 1.1 使用 ToPrimitive() 將值先轉換成為原生型別在內部 ToPrimitive() 的使用調用格式為 ToPrimitive(input, PreferredType?)第二個為可選參數 PreferredType 值可以是 Number, String，這只是一個轉型偏好的註記，最終的結果可以是任一原生型別。假設 PreferredType 是 Number 那麼執行轉換的步驟如下 如果輸入是原生型別，直接回傳 否則調用 obj.valueOf() 如果值是原生型別就回傳 還不是原生型別的話則調用 obj.toString() 結果如果是原生型別就回傳 否則拋出例外 如果 PreferredType 是 String 則 2, 3 步驟交換。如果沒有 PreferredType 則 Date 預設為 String，其他型別則預設是 Number。 1.2 使用 ToNumber() 轉換為數字下列說明 ToNumber() 是如何轉換原始型別為數字 undefined -&gt; NaN null -&gt; +0 boolean true -&gt; 1 false -&gt; +0 number -&gt; 不轉換 string -&gt; 將字串轉換成數字，不過這其中有些小細節下面整理給您，結果與 Number(input) 是一樣的 +’23.1’ = 23.1 +’2e1’ = 20 +’25px’ = NaN +’p23’ = NaN +’010’ = 10 +’0xf’ = 15 +[1] = 1 +[1, 2] = NaN 過程是這樣的：一個物件 obj 透過呼叫 ToPrimitive(obj, Number) 轉換成原始型別，接著在使用 ToNumber() 取得最後的結果 1.3 使用 ToString() 轉換為字串下面說明 ToString() 如何轉換原生型別為字串 undefined -&gt; ‘undefined’ null -&gt; ‘null’ boolean true -&gt; ‘true’ false -&gt; ‘false’ number -&gt; ‘1.234’ string -&gt; 不轉換 一個物件 obj 透過調用 ToPrimitive(obj, String) 轉換為原始型別，然後 ToString() 取得最後結果 1.4 實作下面這個物件可以讓我們觀察轉換的過程 12345678910111213var obj = { valueOf: function () { console.log('valueOf') return {} }, toString: function () { console.log('toString') return {} }}Number(obj)+obj // 等價 123&gt; valueOf&gt; toString&gt; TypeError: can't convert obj to number 當 Number() 作為 function 使用時內部會執行轉換 ToNumber() 的流程，根據上面的實作可以看出就如我們上面所敘述的規則流程一樣。整個過程即先依據 PreferredType 轉換為原始型別，這裡要注意並不是最終結果，再來依據需要看是否要再將原生型別轉成數字或字串。 加法舉例下面的例子 1val1 + val2 要解析上面這個 expression 德遵循 ECMA-262 5.1 規範的 11.6.1 章節或新版 ECAM-262 7 版的 12.8.3 說明的步驟： (1). 轉換兩邊的運算元為原生型別 Primitive 12prim1 = ToPrimitive(val1)prim2 = ToPrimitive(val2) 由於 PreferredType 被省略了，因此物件除了 Date 是代入 String 外，其他的是 Number。 (2). 兩數相加的情況下，如果 prim1 或 prim2 只有要一個是 String 那麼兩者都會被轉成字串，最終結果就是串接字串。 (3). 否則，兩者都會被轉成數字並加總。 到這一步可能造成困惑的地方： 12+[] // Number('') = 0[] + [] // '' + '' = '' 2.1 如同預期的結果當您執行下面的範例，兩個陣列相加 12&gt; [] + []'' 第一步使用 valueOf() 轉換兩個陣列 [] ，其會回傳陣列本身，因為還不是 Primitive 所以繼續使用 toString() 結果回傳一個空字串。兩個空字串相加還是空字串。在只有單一 +[] 的狀況下 Javascript 會幫我們轉成數字 ToNumber()，一元運算子和二元的行為有些差異。 第二個例子我們相加陣列和物件 12&gt; [] + {}'[object Object]' 空物件跟陣列一樣 valueOf() 還是物件，然後 toString() 物件會轉換成 [object Object] 相加就是上面的結果。 1235 + new Number(7) // 126 + { valueOf: function () { return 2} } // 8'abc' + { toString: function () { return 'def'} } // 'abcdef' 2.2 非預期的詭異結果到這一步我們覺得已經掌握了 Javascript，但 Javascript 可怕的地方就是總是可以給您驚喜驚嚇。當我們試著將兩個物件實字 {} 相加時 12&gt; {} + {}NaN 啥米鬼！？ 造成這個問題的原因是 Javascript 把第一個 {} 當作是 code block 並忽略它。這個結果等於 Javascript 只作 +{} 的運算。上面有提過在 + 加號當作一元運算子的時候會嘗試把值轉成數字，下面就是等價執行過程： 123456+{}Number({})Number({}.valueOf()) // 依然不是 Primitive 所以要繼續轉型Number({}.toString())Number('[object Object]')NaN 那為什麼第一個 {} 會被解析成程式片段而不是一個物件實字呢？因為 Javascript 將其解析為一個 statement 。因此如果要處理這個問題我們可以透過 () 強迫 JS 將其視為 expression 1234({} + {})// [object Object][object Object]'var o = {} + {}o // '[object Object][object Object]' 其他還有一些技巧，如果您想知道更多細節請參考重讀 Axel 的 Javascript 中的 Expression vs Statement 一文 經過了上面的解釋，我想您就不會很驚訝下面這段程式的結果了 12&gt; {} + []0 123456+[]Number([])Number([].valueOf()) // 依然不是 Primitive 所以要繼續轉型Number([].toString())Number('')0 有趣的是 Node.js 的 REPL 解析輸入的方式和 Firefox, Chrome 等瀏覽器不同，它會將下面的輸入解析成 expression 1234&gt; {} + {}'[object Object][object Object]'&gt; {} + []'[object Object]' 這個結果就好像把 input 放到 console.log() 的參數內一樣。 總結在大多數的情況下，並不難理解 Javascript 加號的運作，您只能相加數字或字串。物件會被轉換成數字或字串。當然會造成混亂的還有一元運算與二元運算之間的行為差異這點值得注意一下，然後遵循上面談論的規則，相信您應該就能參透 Javascript 一些奇怪的行為。另外如果您想要合併陣列那您需要使用 Array.concat([3, 4]) 12&gt; [1, 2].concat([3, 4])[1, 2, 3, 4] 如果是合併物件在快到 2017 的今天，您可以使用 Object.assign 或者其他函式庫例如 Underscore 等 1234567var o1 = { a: 1, b: 2}var o2 = { c: 3, d: 4}Object.assign(o1, o2)o1/** {a: 1, b: 2, c: 3, d: 4} */ 參考 Fake operator overloading in Javascript Javascript values: not everything is an object object plus object","link":"/2016/12/26/javascript-wat/"},{"title":"理解 DOM 座標","text":"座標系統在瀏覽器中有兩種座標系統 &amp; 滑鼠座標： 1. 相對於 document - 座標 (0, 0) 在整個頁面的最左上角。 2. 相對於 window - 座標 (0, 0) 在可視區 Viewport 的最左上角。 3. 滑鼠座標 - 通常透過事件取得。 當頁面還沒捲動時 window 和 document 的原點 (0, 0) 與其他座標是相同的。 開始捲動後，document 的座標等於 window（viewport） 的座標加上 scroll 的位置，大部分的情況下我們會使用 document 座標系統，因為它即便 scroll 了，還是會保持一致。 元素座標與 offsetParent一個元素的座標位於該元素的左上角，不幸的是沒有屬性可以直接取得元素對應 document 的座標。不過可以透過計算 offsetTop/offsetLeft 和 offsetParent 來取得。 offsetParent 為元素的一個唯讀屬性，其值為上層最接近的有設定 position 的容器元素。更精確的說是 position 不為 static 的元素。當沒有任何 positioned 的元素時最接近的 table cell 或根元素為 offsetParent。HTML 兼容模式 body 為 offsetParent。display: none 時 offsetParent 為 null。 一個簡單的計算方式就是遍歷所有 offsetParent 計算 offsetTop/offsetLeft。簡單說就是不斷累加自己在父元素（positioned）的座標/距離，最終到達 document 則完成計算。 1234567891011121314function getOffset (el) { var top = 0, left = 0 while (el) { top += parentInt(el.offsetTop) left += parentInt(el.offsetLeft) el = el.offsetParent } return { top: top, left: left }} 這種方式有 2 個缺點： 不同瀏覽器行為可能不同。因為 border 和 scroll 是否加入計算造成差異。 慢！因為要遍歷所有 offsetParent。 正確的方式 el.getBoundingClientRect()這個方法時 w3c 標準，並且幾乎所有新版的瀏覽器都支援。它會回傳封閉該元素的一個矩形(CSS border-boxes)，而這個矩形會透過物件的形式包含 top, left, right, bottom 等資料傳回。 再次強調 - 不幸的是沒有屬性可以直接取得元素對應 document 的座標。這個 getBoundingClientRect() 取得的資訊是相對於 window 不是 document。 根據 CSS 規範，任何內容都會被放置在 CSS Box 中。像是 div 這類的 Box 又稱 block box，這類的 Box 原本就是一個矩形。如果元素是 inline 的話會牽扯到 inline box，line box，containing box，contain area。就會有多個的矩形來組織。又稱 anonymous block box 使用 getBoundingClientRect() 1234567891011121314151617181920212223function getOffset (el) { // (1) var box = el.getBoundingClientRect() var body = document.body var docEl = document.documentElement // (2) var scrollTop = window.pageYOffset || docEl.scrollTop || body.scrollTop var scrollLeft = window.pageXOffset || docEl.scrollLeft || body.scrollLeft // (3) var clientTop = docEl.clientTop || body.clientTop || 0 var clientLeft = docEl.clientLeft || body.clientLeft || 0 // (4) var top = box.top + scrollTop - clientTop var left = box.top + scrollLeft - clientLeft return { top: Math.round(top), left: Math.round(left) }} 取得矩形與元素等相關座標資訊 計算 page scroll。所有瀏覽器器除了 IE &lt; 9 外都支援 pageXOffset/pageYOffset。在 IE 當宣告了 DTD i.e DOCYPTE 則 scroll 位置可以透過 documentElement（）取得，否則就從 body 取。 在 IE &lt; 8 document 或 body 會具有特殊的偏移，所以我們需要取得偏移並扣掉。但要注意的是 clientTop/clientLeft 同時也表示 border 寬，一般來說我們不會替 document 或 body 設定 border，在這種情況下 IE 的document.documentElement.clientTop 不是 0 而是 2px。因此我們要減掉。 加入捲動的距離，然後扣掉位移即是該元素相對於 document 的座標。 針對 Firefox 我們需要而外使用四捨五入 Math.round() scrollTop取得已經捲動多少距離 document.body.scrollTop（Undefined DTD，兼容所有瀏覽器） document.documentElement.scrollTop（DTD， Chrome, Safari 為 0） window.pageYOffset（FF，Chrome，IE9+，Opera） window.scrollY（不推薦使用） DTDDTD（Document Type Definition）文件類型定義，定義 XML 的元素，結構，屬性。使用 DTD 可以讓不同的使用者在交換資料時明白其資料格式的標準，而程式可以使用 DTD 來驗證 XML 是否正確。 在 HTML 中 document.compatMode 可以得知是否宣告了 DTD，值為 BackCompat 為未宣告，CSS1Compat 為宣告 DTD。 MouseEvent 座標 screenX/Y - 相對於螢幕左上角的座標 pageX/Y - 相對於頁面左上角的座標（IE9 不支援）包含 scroll clientX/Y - 相對於瀏覽器左上角的座標，不含 scroll layerX/Y - 首先當元素的 position 不是 static 我們稱為定位元素（positioned）。觸發事件的元素相對於父容器定位元素或根元素的座標，Chrome 從 border 開始計算，Firefox 則從 padding 邊界，計算過程包含 scroll。 offsetX/Y - 滑鼠點擊點相對於目標元素 padding 邊界的座標，點擊到 border 區域時會是負值。 movementX/Y - 上個 mousemove 座標與當前的 mousemove 座標移動距離。currentEvent.screenX - previousEvent.screenX window 尺寸 window.innerWidth window.innerHeight window.outerWidth window.outerHeight window.pageYOffset window.pageXOffset window.scrollX window.scrollY window.screenX window.screenY DOM 尺寸 clientWidth / clientHeight scrollWidth / scrollHeight offsetWidth / offsetHeight scrollTop / scrollLeft offsetTop / offsetLeft clientTop / clientLeft offsetParent getBoundingClientRect() video.videoWidth video.videoHeight 小結client 前綴的概略為相對於瀏覽器 viewport 或指內部 padding area。offset 前綴的概略為相對於父定位元素。scroll 前綴的概略為相對於完整頁面。screen 相對於螢幕。 資源 Javascript coordinates","link":"/2017/01/31/understand-coordinate-of-dom/"},{"title":"撰寫高效能的 Javascript 小技巧","text":"這篇文章將會介紹簡單的技巧來優化我們的程式碼讓 Javascript 編譯的過程更具效率，最終我們的程式碼可以執行的更加快速。特別是當您在遊戲類型的專案上發現掉禎或記憶體回收機制(garbage collector)遇到大量資料無法被回收的情況。這些技巧可以協助我們增加程式碼的效能。 單態(Monomorphism)當我們定義一個函式搭配兩個參數的時候，如果函數的參數型別，數量，傳回的型別改變編譯器會遵循我們的指令，但效能便會開始下降。因為一般程式會預期一個單態的資料結構且相同的參數。 123456789function example(a, b) { console.log(++a, ++b)}example() // 糟糕example(1) // 還是糟糕example(&quot;1&quot;, 2) // 很糟糕example(1, 2) // 良好 展開(Unfolding)編譯器可以在編譯時期解析變數的值並且在最好的情況下可以將其展開，盡可能在程式實際執行前解析出其資料。常數和變數只要是不需要等到執行時期才能夠計算的值都會被展開。 1234567891011121314151617181920const a = 42; // 能夠被簡單的展開const b = 1337 * 2; // 表達式也能夠被計算const c = a + b; // 可以被解析計算const d = Math.random() * c; // 只有 c 可以被展開，Math.random() 要等到執行時期才能得到值const e = &quot;Hello &quot; + &quot;Medium&quot;; // 字串格式也是可以被展開的// 展開之前a;b;c;d;e;// 展開之後// 在編譯時期就可以得到下面的結果4226742716Math.random() * 2716&quot;Hello Medium&quot; 內嵌(Inlining)JIT 編譯器可以知道我們程式碼哪些段落特別常被執行。透過拆分 function 為更小的片段程式碼，就可以在編譯時期將其內嵌並追蹤特別常被使用的 function 同時提升效能。 12345678910111213141516171819202122232425// Likely gets inlined 可能被內嵌的條件// [✓] Single return statement 回傳單一語句// [✓] Always returns 總是回傳// [✓] Monomorphic return type 回傳單態型別// [✓] Likely monomorphic parameters 可能是單態的參數// [✓] Single body statement 單一語句// [✓] Isn't wrapped inside another function 內部沒有其他 function// 等等function isNumeric(n) { return ( n &gt;= 48 &amp;&amp; n &lt;= 57 );};let cc = &quot;8&quot;.charCodeAt(0); // 56// before inlining 內嵌之前if (isNumeric(cc)) {}// after inlining 內嵌之後if (cc &gt;= 48 &amp;&amp; cc &lt;= 57) {} 宣告避免宣告函式/閉包和物件在經常被調用的任務中。物件會被堆進 heap 這會影響記憶體回收造成回收上的困擾。 123456789101112131415161718192021// 糟糕function a () { // 請避免在 function 裡面宣告 function // 如此在每一次被調用時都在配置一次 let doSomething = function () { return (1) } return (doSomething())}// 較好的作法let doSomething = function () { return (1)}function b() { return (doSomething());} 引數(Arguments)調用函式是很耗費效能的。盡可能減少直接使用 arguments 並且不要在函式內部修改它們 12345678910function mul(a, b) { return (arguments[0] * arguments[1]); // 非常慢 return (a * b); // 良好};function test(a, b) { a = 5; // 糟糕, 不要直接修改引數 let tmp = a; // 良好 tmp *= 2;}; 資料型別(Data Types)盡可能使用 Number 和 Boolean 他們相對於其他資料型別快非常多。 12345678910111213141516171819202122232425const ROBOT = 0;const HUMAN = 1;const SPIDER = 2;let E_TYPE = { Robot: ROBOT, Human: HUMAN, Spider: SPIDER};// 糟糕// 在常被使用的函式或程式碼中避免直接使用字串來判斷if (entity.type === &quot;Robot&quot;) {}// 良好if (entity.type === E_TYPE.Robot) {}// 完美if (entity.type === ROBOT) {} 嚴格與轉換型別運算子(Strict and abstract operators)盡量使用 === 而不是 == 由於嚴格比對模式下編譯器不需要執行額外的轉換因此效能會比較好。 致命傷下列功能盡可能避免使用會造成嚴重的效能問題 eval with try/catch 物件物件實例通常會分享一個隱藏且相同的類別，注意在替物件實例加上新的屬性時會建立一個新的隱藏類別，這件事對編譯器來說挺複雜的。 123456789101112131415161718// 隱藏的類別 'hc_0'class Vector { constructor(x, y) { // 編譯器預期屬性成員在這邊被宣告了 this.x = x; this.y = y; }};// 兩個 vector 物件共用隱藏類別 'hc_0'let vec1 = new Vector(0, 0);let vec2 = new Vector(2, 2);// 糟糕, vec2 現在產生了新的隱藏類別 'hc_1'vec2.z = 0;// 良好, 編譯器已知的屬性vec2.x = 1; 迴圈盡量使用單一型別的陣列。減少使用 for .. in 來遍歷物件，效能很差。 在迴圈中 continue 和 break 效能比 if 條件式要快。盡可能讓迴圈要處理的資料在外頭。另外使用 ++i 而不是 i++ 這可以得到一點點的效能提升。 123456789101112131415161718192021let badarray = [1, true, 0]; // 糟糕, 盡量不要混合型別let array = [1, 0, 1]; // 良好// 糟糕for (let key in array) {};// 較好的作法let i = 0;for (; i &lt; array.length; ++i) { key = array[i];};// 良好let i = 0;let key = null;let length = array.length;for (; i &lt; length; ++i) { key = array[i];}; 參考資料 Writing efficient JavaScript","link":"/2016/12/19/write-efficient-javascript/"},{"title":"設定 Heroku 使用 Cloudflare HTTPS","text":"設定 Heroku 使用 Cloudflare HTTPS Heroku 是一個 SaaS 雲端平台，支援多種程式語言應用程式可快速部署。使用者不需要擔心底層的機器與設定，只需要專注在應用程式。 這篇文章將說明：如何設定 Cloudflare 使用自有的網域搭配 Heroku 讓我們的傳輸使用 HTTPS。針對這個需求我們假設您已經在 Cloudflare 有一組設定好的網域，同時有一個正在運行的 Heroku app。 加入自訂網域到 Heroku app 登入 Heroku 選擇該 App 切換到設定頁面。 捲至下方 Domains 輸入您的網域，儲存。 如果您是透過 Heroku CLI 管理那麼則使用 1234$ heroku domain:add [domain]# 例如$ heroku domain:add andyyou.io$ heroku domain:add www.andyyou.io 設定 Cloudflare DNSHeroku 的應用程式伺服器使用了多組的 IP，所以使用 A record 對應單一 IP 可能影響您的應用程式。因此我們將使用 CANME Flattening 的功能來動態解析對根網址的請求。 簡單說 CNAME Flattening 就是把 CNAME 設定的值 動態解析成 IP。在下面情況，這個技術非常有用；舉例來說我們使用了 Heroku 這類的雲端服務，通常這些服務會給我們一組 subdomain，在不用 SSL 的情況下到也沒有差，不過一但要使用 SSL 憑證和 CNAME 值所設定的域名就會對不上。另外一個常見的案例就是想把 root domain 直接對應到服務，不過一般來說 root domain 只能設 A Record。 root domain 使用 CNAME Flattening 登入 Cloudflare 然後切換到 DNS 介面。 加入新的 CNAME 讓 root domain 根網域對應到 Heroku APP URL（例如：cf-app-test.herokuapp.com）。到了這一步 CNAME Flattening 會自動生效，將根網域對應到 Heroku 的伺服器。 子網域 使用 CNAME Flattening如果您的網站有其他子網域也要為其加入 CNAME。注意，CNAME Flattening 預設只提供根網域，當您需要支援整個 Zone 時請連絡支援團隊，在 Support 介面下開票。 確認網域路由是使用 Cloudflare12345678910$ curl -I martijn.cfHTTP/1.1 200 OKDate: Wed, 24 Jun 2015 02:46:16 GMTContent-Type: text/html; charset=utf-8Connection: keep-aliveSet-Cookie: __cfduid=d981b13a67668bc3dba1f4cf901450cf21435113976; expires=Thu, 23-Jun-16 02:46:16 GMT; path=/; domain=.martijn.cf; HttpOnlyX-Frame-Options: SAMEORIGINVia: 1.1 vegurServer: cloudflare-nginxCF-RAY: 1fb519efe503119b-SJC 您可以透過 __cfuid cookie 或 CF-Ray 來判斷是否已經由 Cloudflare 來代理。假設兩個值都存在則表是已經由 Cloudflare 代理了。 設定網域的 SSLCloudflare 為付費方案提供 SANs 通用型憑證，免費方案則是 SNI 通用型憑證。利用 Cloudflare 設定 SSL 非常簡單。只要到 Cloudflare 的 Crypto 介面設定即可。同時 Cloudflare 提供不同的選項設定。 SSLCloudflare 提供了三種不同的 SSL 選項如下圖 預設 Heroku 提供通用 SSL 憑證，只適用 *.herokuapp.com 範圍下。 這表示在不要求 SAN 為完整網域名稱的情況下可以使用 Full SSL 。 如果要使用嚴格模式 Full(Strict) 我們就需要在 Heroku 上掛上自己的憑證，詳細的安裝說明可參考官方文件。 強迫全部傳輸使用 HTTPS要強迫全部傳輸使用 HTTPS 我們可以透過 Page Rules 的功能來完成。 進入 Page rules 頁面加入新的規則： 再此透過 cURL 來檢查 12345678910111213141516171819$ curl -I -L martijn.cfHTTP/1.1 301 Moved PermanentlyDate: Wed, 24 Jun 2015 04:06:00 GMTConnection: keep-aliveSet-Cookie: __cfduid=d37122464f26484c74e2359938310ac611435118760; expires=Thu, 23-Jun-16 04:06:00 GMT; path=/; domain=.martijn.cf; HttpOnlyLocation: https://martijn.cf/Server: cloudflare-nginxCF-RAY: 1fb58ebf219111b9-SJCHTTP/1.1 200 OKServer: cloudflare-nginxDate: Wed, 24 Jun 2015 04:06:01 GMTContent-Type: text/html; charset=utf-8Connection: keep-aliveSet-Cookie: __cfduid=dacb13cbfbc6415248b68d3c51e03a8001435118761; expires=Thu, 23-Jun-16 04:06:01 GMT; path=/; domain=.martijn.cf; HttpOnlyX-Frame-Options: SAMEORIGINVia: 1.1 vegurCF-RAY: 1fb58ec130851213-SJC 如果 SSL 沒運作那麼我們會看到 525 或 526 的錯誤。 資源 Configure Cloudflare and Heroku over HTTPS Rage4、CloudXNS、Route53 和 CloudFlare 解析","link":"/2017/02/14/cloudflare-heroku-setup/"},{"title":"Vue.js 由 1 到 2 的旅程 - (2)","text":"第二集，我們要聊的是一個很瑣碎的點也許會造成您困惑，在精神不濟的情況下建議略過本文。如果您跟我一樣閱讀的是英文版的文件加上英文又不是很牛，那麼我想這個點可能會造成您的困惑。如果您也曾對 string templates 和 non-string templates 兩個詞有疑惑的話就讓我們繼續看下去… 在開始之前我們要先介紹的是 Vue 的 templates 提供了兩種實作方式。什麼意思，就是我們可以透過 Vue 的 template 屬性（options）或者 DOM templates 的方式來撰寫樣板。看看下面兩種範例 No 1 template 屬性12345// template 屬性new Vue({ el: '...', template: `&lt;div&gt;1&lt;/div&gt;`}) No 2 DOM templates不同的 HTML 與 Javascript 檔案： 1234&lt;div id=&quot;app&quot;&gt; &lt;!-- 標籤結構寫在 HTML 中的 --&gt; &lt;p&gt;{{ message }}&lt;/p&gt;&lt;/div&gt; 123456new Vue({ el: '#app', data: { message: 'Hello, Vue.js' }}) 小結一下就是 template 可以寫在 Javascript 又或者寫在 HTML 裡面。 疑惑的產生當我們開始閱讀 Vue 2 官方文件時，會發現在第一版時並沒有 Template Syntax 一章。原因是在該章節的一開始便開宗明義的提到： Under the hood, Vue compiles the templates into Virtual DOM render functions. 這個點算是第二版一個極大的變化。所以我們理解 Vue 會將 template 屬性 或者 DOM Templates 即標籤結構寫在 HTML 裡面的作法編譯成 render function。 接著 Template Syntax 一節提到 Vue is not a string-based templating engine 所以 Vue 並不是 string-based 的樣板引擎會編譯成 render function 我們懂了。但是 Components 一章竟然出現 It should be noted that these limitations do not apply if you are using string templates from one of the following sources &lt;script type=&quot;text/x-template&quot;&gt; JavaScript inline template strings .vue components 奇怪？前面不是說 Vue 不是 string-based template 嗎？現在提出 string templates 還附上三種類型。雖然英文字不一樣不過換成中文來說到底是什麼意思啊？不都是字串類型的樣板嗎？ 加上 Components camelCase-vs-kebab-case 提到關於屬性（attributes）的命名方式在 string templates 與 non-string templates 有所差異。non-string templates 的 props 一定要用 kebab-case 的命名方式，而 string templates 則不受限制。心中出現滿滿的 WHY 我們想知道 template 屬性、DOM templates、string-based template、string templates、non-string templates 這些詞之間的關係到底是什麼？ 問答上面的說明肯定搞的您很混亂，沒關係讓我們先整理出問題。我們要問的是： 1. string-based templating engine 與 string-templates 的意義分別是啥？Vue 文件一開始提到 Vue 並不是 string-based templating engine 意味著並不是組出字串後完全交給瀏覽器，而是會將這些 template 轉成 render function 的機制。 而 string templates 指的是在 Javascript 中寫入字串格式的 templates，即上面提到的三種形式： &lt;script type=&quot;text/x-template&quot;&gt; JavaScript inline template strings .vue components 才屬於 string templates，雖然看起來不太一樣但它們都是屬於 Javascript 的範疇。 2. 文件中的 string templates 與 non-string templates 具體是指？所謂的 string templates 概略來說是指在 Javascript 以字串形式出現的 templates。所以其他不在 Javascript 裡面的樣板都是 non-string templates 最一開始提到的 DOM templates 也屬於這個分類，換句話說其他在 HTML 寫的也就是 DOM templates 屬於 non-string templates。我們只要以檔案類型來區分便可。 造成困惑的地方 - 一開始說 Vue 不是 string-based 但後來又出現 string templates 這兩者指的是不同東西。一個是編好完整字串交給瀏覽器的作法，一個是指在 Javascript 字串形式的 templates。 驗證 template 屬性屬於 string templates 即使屬性使用 camelProp 也沒問題 1234567891011121314151617181920Vue.component('row', { props: [ 'camelProp' ], template: ` &lt;div class=&quot;row&quot;&gt; Row: {{ camelProp }} &lt;/div&gt; `})new Vue({ el: '#root', template: ` &lt;row :camelProp=&quot;message&quot;&gt;&lt;/row&gt; `, data: { message: 'Hello, Vue' }}) 使用 inline-template 來觀察差異 範例1 string templates 範例2 non-string templates tag 的屬性若不是使用 kebab-case 則無法取得屬性 3. DOM templates 的方式也會編譯為 render function 嗎？如果會編譯成 render function 那為什麼 DOM templates 就不行？Vue 會將所有 template 都編譯成 render function 所以 DOM templates 也會編譯成 render function。其中差異在於取得的資料的時間點由於 Vue can only retrieve the template content after the browser has parsed and normalized it 在瀏覽器解析之後 camelCase 的屬性會全部轉成小寫而無法分辨與切割屬性名稱（myProp -&gt; myprop）。也就造成和 props 定義的名稱不同。因此 DOM templates 無法支援 camelCase 的屬性名稱。 補充在使用 DOM templates 時需注意：由於瀏覽器限制某些標籤存在的位置例如 &lt;option&gt; 只能在 &lt;select&gt; 裡面，&lt;table&gt; 裡面要放 &lt;tr&gt;, &lt;td&gt; 等等。當不合法的時候這些標籤會被移出該標籤內 12345&lt;table&gt; &lt;tr&gt; &lt;h3&gt;Column&lt;/h3&gt; &lt;/tr&gt;&lt;/table&gt; h3 會被移出 table 外層導致顯示錯誤，此時可以使用 is 屬性處理，或者就用 string templates 就正常了，為了避免問題產生還是遵循 HTML 規則較為單純。 沒有使用 is 不合法的元素被移出了 table 示意圖 總結又來了，如果您一開始就直上 vue-loader 相信這些問題壓根都不會遇到。原因是你全部的 template 都屬於 string templates。相較之下如果您使用了像是小弟之前撰寫的穠纖合度的整合 Rails、Webpack、Vuejs一文，那麼裡面使用的 inline-template 搭配 DOM template（為了取得 Rails View 來的資料）那麼上面提到的一些限制可能就是您會遇到的問題了。","link":"/2016/12/16/vue-migration-2/"},{"title":"[譯 + 補充] Webpack 2 學習筆記","text":"在今時今日，webpack 已經成為前端開發非常重要的工具之一。本質上它是一個 Javascript 模組封裝工具，但透過 loaders 和 plugins 它也可以轉換封裝其他前端的資源檔像是 HTML，CSS，甚至是圖片等，讓我們能夠控制程式發出 HTTP 請求的數量（編譯結果的檔案數量）。我們可以使用偏好的方式去撰寫這些資源檔像是 Jade, Sass, ES6 等等。同時也讓我們能夠輕易的使用來自 npm 的套件。 這篇文章目標讀者是那些剛接觸 webpack 的新手。內容將會包含設定，模組的使用，loaders，plugins，code splitting（分拆程式碼），熱替換（Hot module replacement）。 每過一陣子，重新學習 webpack 就會有些新的發現 - 廢話。 為了完成文章中的練習您需要些前置作業：安裝 Nodejs（作者使用 v6.9.2），如果您還麼安裝那麼這邊有篇完整使用 nvm 安裝的教學。 設定讓我們開始來使用 npm 初始化專案與安裝 webpack。 12345678$ mkdir webpack-demo$ cd webpack-demo$ npm init -y$ npm i webpack@2 -D$ npm view webpack version# 2.2.1$ mkdir src$ touch index.html src/app.js webpack.config.js 上面這些檔案的概略說明： index.html - 首頁，載入使用編譯好的 Javascript 檔案。 src/ 目錄 - 許多開發者會把 Source Code 的目錄命名為 src 但這並不強迫。 webpack.config.js - 設定 webpack 行為的設定檔，這邊我們可以先概略了解一下 webpack 的行為可以靠設定檔或者指令的參數調整，而 webpack.config.js 是預設的設定檔名稱。 src/app.js - 這是我們程式的 Entry point。 接著編輯我們剛產出的這些檔案 index.html 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Hello webpack 2&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script src=&quot;dist/bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; src/app.js 12const root = document.querySelector('#root')root.innerHTML = `&lt;p&gt;Hello webpack 2&lt;/p&gt;` webpack.config.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455const path = require('path')const config = { /** * webpack 執行環境，即 webpack 載入檔案時相對路徑的根目錄環境 * 預設（沒有設定時）為執行指令（webpack）所在的那個目錄 * * 【其他】 * 假設自己新增一個 build/build.js 檔案，使用載入 webpack 的作法 * * 例如範例：https://github.com/andyyou/webpack-context-prove/blob/master/build/build.js#L14 * * 在不同目錄執行： * &gt; node build/build.js (in root/ folder) * &gt; node build.js (in build/ folder) * 預設 context 會分別為 root/ 和 root/build/ */ context: path.join(__dirname, 'src'), /** * Entry point * 因為設定了 context 所以不需要加上 src/ 了 */ entry: './app.js', /** * 輸出路徑與檔名 */ output: { path: path.join(__dirname, 'dist'), filename: 'bundle.js' }, /** * loaders 對應使用規則 */ module: { rules: [ { test: /\\.js$/, exclude: /node_modules/, use: [ { /* webpack 2.x 移除了省略 -loader 的寫法 */ loader: 'babel-loader', options: { presets: [ /* Loose mode and No native modules(Tree Shaking) */ ['es2015', { modules: false, loose: false }] ] } } ] } ] }}module.exports = config 上面這些是常見的基本設定，它告訴 webpack 如何編譯我們的原始碼，進入點是 src/app.js 輸出的檔案則放在 dist/bundle.js。所有的 .js 檔案都會使用 Bable 從 ES2015 被編譯成 ES5。 Babel 從 6.13.0 之後提供額外的參數 loose 和 modulesloose: 提供 loose 編譯模式，該模式啟動下 Babel 會盡可能產生較精簡的 ES5 程式碼，預設 false 會盡可能產出接近 ES2015 規範的程式碼。modules: 轉換 ES2015 module 的語法（import）為其它類型，預設為 true 轉換為 commonjs。 為了要能夠執行我們需要安裝 babel-core，babel-loader 和 babel-preset-es2015。上面還有一個值得注意的地方就是 {modules: false} 關閉這個設定是為了提供 Tree Shaking 的特性 - 移除沒有使用到的 exports 來縮小編譯的檔案大小。 1$ npm i babel-core babel-loader babel-preset-es2015 -D 最後我們在 package.json 補上 scripts 的部分。 1234&quot;scripts&quot;: { &quot;start&quot;: &quot;webpack --watch&quot;, &quot;build&quot;: &quot;webpack -p&quot;} 到這步我們就可以使用 npm start 來執行 webpack，加入參數 –watch 會讓 webpack 進入監視模式，當發現檔案有異動時就會立即重新編譯我們的原始碼。在 console 畫面會輸出類似下面的訊息來告知我們 bundle 已經被建立了。同時有個小小的重點那就是我們可已觀察編譯後的檔案大小。 12345678Webpack is watching the files…Hash: f4fadf78c49f43d8a078Version: webpack 2.2.1Time: 1342ms Asset Size Chunks Chunk Namesbundle.js 2.6 kB 0 [emitted] main [0] ./app.js 87 bytes {0} [built] 在專案目錄下執行 open index.html 可以觀察截至目前為止的結果。 開啟 dist/bundle.js 看看 webpack 編譯的結果，上半部是 webpack 處理模組載入的程式碼，最下面則是我們的模組。到這您可能不覺得有什麼特別的，不過一旦我們開始使用 ES2015 來開發並將程式模組化，那麼 webpack 就可以替我們處理後續的工作讓我們的原始碼編譯成可以在瀏覽器執行的版本。 接著，我們可以透過 Ctrl + C 來停止 webpack，換成執行 npm run build 可以編譯產品模式的 bundle（壓縮）。您可以注意到檔案大小從 2.6kB 變成 587 bytes，再次觀察 dist/bundle.js 會發現程式碼已經被 Uglify 了。 至此我們初始化了專案並對 webpack 設定有了基本的了解。 模組webpack 本身知道該如何處理載入各種格式的 Javascript 模組，比較值得注意的有兩個： ES2015 import CommonJS require() 我們使用 lodash 來試驗看看 1$ npm i lodash -S src/app.js 123456789101112131415161718import {groupBy} from 'lodash/collection'const people = [{ manager: 'Jen', name: 'Bob'}, { manager: 'Jen', name: 'Sue'}, { manager: 'Bob', name: 'Shirley'}, { manager: 'Bob', name: 'Terrence'}]const managerGroups = groupBy(people, 'manager')const root = document.querySelector('#root')root.innerHTML = `&lt;pre&gt;${JSON.stringify(managerGroups, null, 2)}&lt;/pre&gt;` 執行 npm start 然後在瀏覽器重新載入 index.html 應該要看到我們透過 lodash 區分群組的結果。接著讓我們把 people 的資料搬移到 src/people.js src/people.js 12345678910111213141516const people = [{ manager: 'Jen', name: 'Bob'}, { manager: 'Jen', name: 'Sue'}, { manager: 'Bob', name: 'Shirley'}, { manager: 'Bob', name: 'Terrence'}]export default people 在 src/app.js 使用 import 載入 people.js 123456import {groupBy} from 'lodash/collection'import people from './people'const managerGroups = groupBy(people, 'manager')const root = document.querySelector('#root')root.innerHTML = `&lt;pre&gt;${JSON.stringify(managerGroups, null, 2)}&lt;/pre&gt;` 注意：不使用相對路徑的例如 lodash/collection 模組將會從 /node_modules 載入，我們自定義的模組通常使用相對路徑。 匯入模組時的 path 分成 函式庫 node_modules 相對路徑 絕對路徑 函式庫：什麼都不加，單純 library name 相對路徑：./ 開頭 絕對路徑：/ 開頭 第二小節我們示範了模組的使用，也就是我們可以把程式模組化再使用 webpack 來處理匯入使用的部分。 Loaders上面我們已經使用了 babel-loader，它是眾多 loader 中的一個，功能就是把 ES2015 轉成 ES5。而 loaders 的功用就是告訴 webpack 該如何處理匯入的檔案，通常是 Javascript 但 webpack 不限於處理 Javascript，其他資源檔像是 Sass，圖片等也都可以處理，只要提供對應的 loader。同時 loader 也可以串連使用，概念上類似於 Linux 中的 pipe，A Loader 處理完之後把結果交給 B Loader 繼續轉換，以此類推。最好的示範範例就是匯入 Sass 的流程，下面就讓我們來看看。 Sass我們的目標是要把 Sass 編譯封裝到我們的 bundle 中（Javascript）。這個轉換過程需要一些 loaders 和函式庫： 1$ npm i css-loader style-loader sass-loader node-sass -D 為處理 .scss 類型的檔案加入新的編譯規則 12345678910111213141516171819module: { rules: [ // {...}, { test: /\\.scss$/, /** * use 屬性是用來套用，串接多個 loaders。 * v2 為了相容的因素保留 loaders 屬性，loaders 為 use 的別名， * 盡可能的使用 use 代替 loaders */ use: [ 'style-loader', 'css-loader', 'sass-loader' ] } // {...} ]} 每當我們修改了 webpack.config.js 我們就必須重啓。 Ctrl + C -&gt; npm start 設定 loaders 的陣列實際上會反過來逐一執行： sass-loader - 編譯 Sass 成為 CSS css-loader - 解析 CSS 轉換成 Javascript 同時解析相依的資源 style-loader - 輸出 CSS 到 document 的 &lt;style&gt; 元素內 我們可以想成像下面這樣調用 function 1styleLoader(cssLoader(sassLoader('source'))) 讓我們來加入 Sass src/style.scss 123456$bg-color: #2B3A43;pre { padding: 15px; background: $bg-color; color: #DEDEDE;} 現在我們可以在 app.js 匯入 scss 了。 1import './style.scss' 重載 index.html 我們應該可以看到樣式已經套用了。 CSS in JS上一步我們完成了從 JS 中把 Sass 當作一個模組載入。 打開 dist/bundle.js 搜尋 pre {，我們看到 Sass 已經被編譯為字串並存為一個模組。當我們匯入該模組時 style-loader 會把該字串嵌入 &lt;style&gt; 標籤中。 為什麼我們要這麼作呢？ 這邊我們不想探討太多這個議題，不過的確有些理由讓我們這麼作： 回想我們在使用 jQuery 套件或 Javascript 元件時，假如這些元件包含些資源檔像是 HTML，CSS，圖片，SVG 等等，通常這時候我們就需要把這檔案搬到對應的目錄下，又或者我們有潔癖希望圖檔等放在我們定義的目錄下，這時我們就需要去修改路徑。當全部都封裝在 Javascript 時我們在組織時就方便很多。 方便移除不需要的程式碼 - 當 Javascript 元件不在被使用時， CSS 等資源檔內容也會一併被移除。 CSS Module - 隨著 CSS 樣式越來越多，命名常常容易衝突，透過 CSS Module 的方式可以對特定元件或模組套用其專用（local）的樣式，只有該模組可以套用樣式，這樣一來也相對容易維護。 減少 HTTP request 的數量。 圖片最後我們要在介紹一個常遇到的需求 - 圖片。我們將要使用 url-loader 來處理圖片的載入。在標準的 HTML 文件中圖片需要透過 &lt;img&gt; 標籤或 CSS 的 background-image 來載入。使用 webpack 我們可以優化圖片並根據檔案大小分別處理。像是把比較小的圖片轉成 base64 字串存在 Javascript 中。這麼作瀏覽器可以預先載入，而且不會發出額外的 HTTP 請求。 1npm i file-loader url-loader -D 當然我們記住了，每當我們需要一個 loader 來幫我們處理某類型的檔案時，我們除了安裝該 loader 外，還需要設定 rules。 1234567891011121314rules: [ // ... { test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, use: [ { loader: 'url-loader', options: { limit: 10000 /* 小於 10kB 的圖片轉成 base64 */ } } ] }] 讓我們下載張圖片並將其放在 src/ 1$ curl http://i.imgur.com/5Hk42Ct.png --output src/code.png 接著在 app.js 中使用下面範例載入 src/app.js 123456import imageURL from './code.png'const img = document.createElement('img')img.src = imageURLimg.style = 'background: #2B3A4F; padding: 15px;'img.width = 32document.body.appendChild(img) 檢查 HTML 該圖片元素，我們看到會如下圖片的來源被轉換成 base64 了。 1&lt;img src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSU...&quot; style=&quot;background: rgb(43, 58, 79) none repeat scroll 0% 0%; padding: 15px;&quot; width=&quot;32&quot;&gt; 不只是在 Javascript 載入的圖片，我們之前提到 css-loader 同時也會解析相依的資源，但是要處理圖片 css-loader 也是需要 url-loader 來幫忙。我們可以從 css-loader 的文件 options 一節得知。 src/style.scss 123pre { background: $bg-color url('code.png') no-repeat center center;} 也會被編譯成 123pre { background: $bg-color url('data:image/png;base64,iVBORw0KG...') no-repeat center center;} 從模組到靜態資源現在您應該明白 loaders 是如何協助我們編譯各式各樣的檔案，這也是 webpack 2 官方文件首頁 出現圖片所要表達的。 透過 Javascript 的 Entry point 進入點，webpack 就會明白我們需要那些模組以及各種類型的檔案該如何處理。 心法：組織好專案架構後，安裝 webpack，設定的基礎是 entry，output 以及想編譯哪些類型的檔案，對應安裝相關 loaders 接著設定 rules。 Plugins開始講 plugins 之前，其實我們已經看過一個 webpack 內建的 plugin。它就是當我們執行 webpack -p 時使用的 UglifyJsPlugin。 簡單說，loaders 的任務是針對單一檔案協助轉換，而 plugins 的任務則針對轉換後的程式碼片段作處理。 通用程式碼commons-chunk-plugin 是另一個內建的核心套件，可以將多個 Entry point 中共用模組的部分抽出來獨立成一個模組。到這邊我們都只有單一個 Entry point 然後只輸出一個 bundle。在實務上您可能會需要多個進入點來切割 bundle，例如：我們自己開發的部分歸納在 app.js，其他外部的函式庫歸納在 vendor.js。 又或者假設我們的網站有兩個功能上需要切割的部分 - 一般使用者 app.js 和管理者 admin.js。這麼一來我們就可以像下面這樣處理： 12345678910111213141516171819202122232425const path = require('path')const webpack = require('webpack')const extractCommons = new webpack.optimize.CommonsChunkPlugin({ name: 'commons', filename: 'commons.js'})const config = { context: path.join(__dirname, 'src'), entry: { app: './app.js', admin: './admin.js' }, output: { path: path.join(__dirname, 'dist'), filename: '[name].bundle.js' }, // ... plugins: [ extractCommons ]}module.exports = config 注意到 output.filename 部分我們在前面加上了 [name]，同時 entry 也從字串換成物件格式，物件 key 的名稱會對應到 [name]，也就是照上面的設定會產生 app.bundle.js 和 admin.bundle.js 兩隻檔案。 而 commons-chunk-plugin 則會把這兩個 entry point 中共用的模組抽出來產生第三隻檔案 commons.js。 我們先來看看範例： src/app.js 12345678import './style.scss'import {groupBy} from 'lodash/collection'import people from './people'const managerGroups = groupBy(people, 'manager')const root = document.querySelector('#root')root.innerHTML = `&lt;pre&gt;${JSON.stringify(managerGroups, null, 2)}&lt;/pre&gt;` src/admin.js 123import people from './people'const root = document.querySelector('#root')root.innerHTML = `&lt;p&gt;There are ${people.length} people.&lt;/p&gt;` 再次執行 npm start 就會看到 webpack 產生了 3 隻檔案 app.bundle.js 包含了 style 和 lodash/collection admin.bundle.js 沒有其他額外的模組 commons.js 包含 people 模組 然後調整 HTML 的部分： index.html 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Hello webpack 2&lt;/title&gt; &lt;style&gt; html, body { padding: 0; margin: 0; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script src=&quot;dist/commons.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;dist/app.bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; admin.html 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Hello webpack 2 - Admin&lt;/title&gt; &lt;style&gt; html, body { padding: 0; margin: 0; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script src=&quot;dist/commons.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;dist/admin.bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 當我們分別造訪兩個頁面的時候，commons.js 也可以因為前一次被 cache 了而加快了網頁載入的速度。 輸出 CSS 檔案前面我們把 CSS 也當作模組匯入並打包進 Javascript，但實務上我們想要讓瀏覽器非同步載入和平行處理 CSS 所以我們需要輸出獨立的 CSS 檔案。 這時我們就要另外一個非常熱門的 plugin - extract-text-webpack-plugin 它可以將模組匯出成檔案。 下面我們將改寫 .scss rule 的部分，將編譯好的 CSS 匯出成檔案，而不是放在 Javascript。 123456# extract-text-webpack-plugin 2 正處於 rc 階段# 我們可以透過下面的指令查看所有的版本$ npm show extract-text-webpack-plugin versions# 安裝$ npm i extract-text-webpack-plugin@2.0.0-rc.3 -D 接著修改 webpack.config.js 12345678910111213141516171819202122232425262728293031323334353637383940414243const path = require('path')const webpack = require('webpack')const extractCommons = new webpack.optimize.CommonsChunkPlugin({ name: 'commons', filename: 'commons.js'})const ExtractTextPlugin = require('extract-text-webpack-plugin')const extractCSS = new ExtractTextPlugin('[name].bundle.css')const config = { context: path.join(__dirname, 'src'), entry: { app: './app.js', admin: './admin.js' }, output: { path: path.join(__dirname, 'dist'), filename: '[name].bundle.js' }, module: { rules: [ // ... { test: /\\.scss$/, loader: extractCSS.extract(['css-loader', 'sass-loader']) /* use: [ 'style-loader', 'css-loader', 'sass-loader' ] */ } ] }, plugins: [ extractCommons, extractCSS ]}module.exports = config 重啓 webpack 您應該可以看到 webpack 匯出了 app.bundle.css，於是我們就可以在 HTML 中補上連結。每一個 entry 內匯入的 Sass 都會被抽出來成一隻獨立的檔案。由於 admin 沒有匯入 Sass 所以沒有輸出。 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Hello webpack 2&lt;/title&gt; &lt;style&gt; html, body { padding: 0; margin: 0; } &lt;/style&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;dist/app.bundle.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script src=&quot;dist/commons.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;dist/app.bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 分拆原始碼我們已經看了一些分拆程式碼的方式： 手動建立多個 Entry point 使用 commons-chunk-plugin 分拆出共用模組的部分 使用 extract-text-webpack-plugin 另外一個分拆的方式是使用 System.import 或 require.ensure。透過調用這些方法設定，我們可以劃分程式碼讓它們在需要的時候才在執行時期（runtime）載入，而不是一口氣全部載入。這樣能夠有效的改善載入所造成的效能問題。System.import 使用 module 名稱作為參數，接著回傳一個 Promise。require.ensure 則是傳入相依套件的列表， callback，和一個可選的參數來設定該程式片段的名稱。 System.import 是 ES2015 模組載入的 API 如果您的程式中某部分具有大量相依函式庫，且程式的其他地方不需要。這種情況正好就適合將其拆分出來。看看下面的範例，我們的 dashboard.js 需要 d3，但可以見得的其它地方不需要 d3。 1$ npm i d3 -S src/dashboard.js 1234567import * as d3 from 'd3'console.log('Loaded', d3)export const draw = () =&gt; { console.log('Draw!')} 接著在 app.js 的最下方我們模擬晚一點載入（需要的時候才載入） 1234567891011function gotoDashboard () { System.import('./dashboard') .then(function (dashboard) { dashboard.draw() }) .catch(function (err) { console.log('Chunk loading failed') })}setTimeout(gotoDashboard, 5000) 因為我們使用的是 System.import('./dashboard') 這樣的相對路徑，在線上的情況下會變成 http://example.com/dashboard.js 這樣的路徑是錯誤的。所以需要加上 output.publicPath 的設定，這樣才會是 http://example.com/dist/dashboard.js。 12345output: { path: path.join(__dirname, 'dist'), publicPath: '/dist/', filename: '[name].bundle.js'} 重啓 webpack 會發現 console 有一個奇怪的 0.bundle.js 123456789Hash: e96d4e3ab03b79a320aaVersion: webpack 2.2.1Time: 4030ms Asset Size Chunks Chunk Names 0.bundle.js 452 kB 0 [emitted] [big] app.bundle.js 184 kB 1 [emitted] appadmin.bundle.js 461 bytes 2 [emitted] admin commons.js 5.91 kB 3 [emitted] commons app.bundle.css 1.31 kB 1 [emitted] app webpack 用了較為突出的顏色顯示 [big] 讓我們去注意它。 這個 0.bundle.js 將會在需要的時候發出 JSONP 的請求，這個時候如果我們繼續直接讀取檔案的方式是拿不到資料的。暫時我們可以在專案目錄下使用 python 提供的簡易伺服器（因為 Linux，OSX 內建都有 python 我們不需要在作其他安裝）。 1$ python -m SimpleHTTPServer 瀏覽 http://localhost:8000，5 秒後我們應該可以看到一個 GET 請求 /dist/0.bundle.js 同時 console 顯示 Loaded 載入完成。 Webpack Dev ServerLive reload 的出現，大大的改善了我們的開發體驗也替開發者們節省了許多的時間。簡單的說就是當檔案發生變動時瀏覽器會自動重新載入頁面。只需要安裝並使用 webpack-dev-server 這個開發伺服器我們就可以輕鬆取得這個功能。 1$ npm i webpack-dev-server@2 -D 接著我們需要修改 package.json scripts start 的部分： 1234&quot;scripts&quot;: { &quot;start&quot;: &quot;webpack-dev-server --inline&quot;, &quot;build&quot;: &quot;webpack -p&quot;}, 執行 npm start 就可以透過 http://localhost:8080 來瀏覽網頁。 現在，只要我們修改 src 目錄下的檔案，例如：people.js 或 style.scss 就可以看到瀏覽器馬上更新結果。 熱替換（Hot Module Replacement）如果您對於 Live reload 印象深刻的話，那麼 HMR 可能將令你感到驚訝。 假如您已經在開發 SPA （Signle Page Application），您應該已經遭遇過了這種惱人的情況 - 在你的開發過程常常因為要測試某元件而反覆操作一些流程。什麼意思？假如我們正在開發付款流程的頁面，分別有 4 個步驟，我們的元件在第 3 步，於是每當我們一修改，所有狀態因為重載的關係回到預設，然後我們就只好反覆執行步驟 1， 2。 Hot Module Replacement 就是為了拯救我們脫離這個迴圈而出現了。 我們理想的開發流程應該是：每當我們修改我們的模組，然後應該只要編譯該模組，在不刷新瀏覽器，不影響其他模組的情況下把新的程式碼換上去，當我們需要 reset 狀態時在重載頁面。大致上這就是 HMR 的功能。 我們只需要加入一個參數 --hot 就可以啟用這個功能： 1234&quot;scripts&quot;: { &quot;start&quot;: &quot;webpack-dev-server --inline --hot&quot;, &quot;build&quot;: &quot;webpack -p&quot;} 為了讓我們的模組也支援 HMR 我們需要在 app.js 的最上面補上下面這段程式碼，好讓 webpack 知道我們模組的邊界以及更新底下相依的元件。 123if (module.hot) { module.hot.accept()} 注意：webpack-dev-server --hot 會把 module.hot 設為 true 而且只有在開發模式才支援。在 production 模式下 module.hot 會是 false，相關的程式碼不會出現在 bundle 中。 加入 NamedModulesPlugin 到 webpack.config.js 的 plugins 陣列，如此一來我們在瀏覽器的 console 就可以看出是哪個檔案更新。 1234plugins: [ // ... new webpack.NamedModulesPlugin()] 最後，我們加入 &lt;input&gt; 到 HTML ，重新執行 npm start 並在頁面的輸入框輸入一些字，編輯 people.js 中的人名，存檔。我們可以觀察到 HMR 的行為，的確不是整個頁面刷新。 Hot Reloading CSS修改 style.scss 中 &lt;pre&gt; 的背景色，我們注意到 HMR 並沒有對應更新 123pre { background: red;} 當我們使用 style-loader 時 HMR 是會更新的，我們不需要作其他設定。不過因為我們使用了 extract-text-webpack-plugin 把 CSS 獨立出去成為檔案，所以也就不支援 HMR。 HTTP/2使用 webpack 這類的封裝工具一個主要的好處就是可以控制最終資源檔被請求的數量。在過去幾年這是最佳的實作方式，不過 HTTP/2 的出現，整合成單檔的方式不再是唯一，分散成許多小檔案在 HTTP/2 中是相對好的作法。 不過 webpack 的作者 Tobias Koppers 寫了篇文章闡述即使在 HTTP/2 的情況下，封裝工具仍有其重要性。連結 資源 A Beginner’s Guide to Webpack 2 and Module Bundling Migrating from v1 to v2","link":"/2017/02/17/webpack-2-beginner-guide/"},{"title":"[譯] 理解 SVG 座標系統與 Transformations - 1","text":"SVG 元素並不像其他 HTML 元素受到 CSS 盒模型的管轄。乍看之下元素的定位、變形、移動、旋轉等形變的行為並不是那麼直覺好控制。然而只要我們理解關於 SVG 的座標系與圖案變形(transformation)是如何運作，控制 SVG 就會變得非常容易。 在這篇文章我們要討論 SVG 中最重要的 1 個觀念和 2 個屬性 ，它們控制了 SVG 座標系統：viewport、viewBox、preserveAspectRatio。 我們將探討 SVG 的座標系統和 Transformations ，這系列文章將會包含下列 3 篇 [譯] 理解 SVG 座標系統與 Transformation - 1 viewport、viewBox、和 preserveAspectRatio [譯] 理解 SVG 座標系統與 Transformation - 2 transform 屬性 [譯] 理解 SVG 座標系統與 Transformation - 3 建立 viewport 為了感受以及將要探討的概念，這裡提供了一個可互動的範例，讓我們概略理解一下關於 viewBox 和 preserveAspectRatio 這兩個屬性 範例 先不需要花太多時間研究上面這個範例，待我們說明之後您可以使用這個互動的範例去驗證自己是否理解了 SVG 的一些行為。 SVG canvas第一個我們要先介紹的是 SVG canvas - 指的是一個空間或區域，SVG 會在這一層畫下圖案、內容的地方(SVG 作畫區域/畫布)。概念上 SVG canvas 這張畫布的 xy 軸都是無限長的。因此 SVG 可以是任何尺寸。然而螢幕本身並不是無限長，於是 SVG 的渲染輸出是必須對應有限尺寸的 viewport（可視區域）就是該如何計算畫在螢幕上。SVG 的內容只要超過 viewport 的邊界就會被裁切，並且被隱藏起來。到這我們明白了在 SVG 中有一層畫布，圖案具體是跟這一層有相對關係，然後有一層可視區域 viewport 的概念，讓我們接著介紹。 Viewportviewport 或稱可視區指的是 SVG 的顯示範圍，我們可以把 viewport 想成是電腦中的視窗，改變這個視窗的尺寸會影響我們看到的內容，通過視窗我們可能看到的是整個內容或者只有局部。更具體的比喻 - SVG 的 viewport 類似於瀏覽器視窗，我們透過視窗看到裡面的內容。網頁內容的寬是可以比視窗寬的，一般情形下網頁內容的高的確會超過視窗的高，但我們一次只能從視窗中看到局部的內容。這就是 viewport 的概念。 透過 svg 標籤上的 width 和 height 屬性我們可以設定 viewport 的尺寸，同時指的是 svg 元素的尺寸，也是 canvas 的尺寸。 1234&lt;!-- viewport 會是 800px * 600px --&gt;&lt;svg width=&quot;800&quot; height=&quot;600&quot;&gt; &lt;!-- SVG 內容 即 SVG canvas --&gt;&lt;/svg&gt; 在 3D 的世界中世界座標系(World Coordinate Syste)定義了一個空間的絕對位置，然後我們可以有多個用戶座標系(User coordinate system) - 取決於要從哪個點開始，往那個方向看去的相對座標。我們可以在世界座標系中任意動態的定義另一個用戶座標系。這段概略的介紹是要讓我們對於用戶座標系這個生硬的詞有個簡單的概念。 在 SVG 中，值不一定要具有單位。沒有單位的值，就會在用戶空間 (User space)/用戶座標系中使用用戶單位，如果值使用了用戶單位，那這個值預設就會使用 px 為其單位。這表示上面的範例將會渲染一個 800px * 600px 的 viewport。當然，您也可以使用其他單位。SVG 支援的單位包含 em、ex、px、pt、pc、cm、mm、in 和百分比。 回到上面寬高的設定，這意味著一但最外層 SVG 的寬高被設定了，瀏覽器就會初始化 viewport 座標系統 和 用戶座標系統。 初始化座標系統初始化的 viewport 座標系 建立 viewport 上，這個座標系從 viewport 的最左上角為 (0, 0) 開始計算。 X 軸的右側為正向，Y 軸的下方為正向。我們可以理解成 svg 元素的左上那個點就是 (0, 0)。同時在初始化時 viewport 中的一個單位等同於 1px，這個座標系統跟 HTML 和 CSS 盒模型的座標系統很類似。 初始化的 用戶座標系統 則建立在 SVG canvas 上，這個座標系一開始會和 viewport 座標系相同。原點都是在 viewport 的左上角。如果使用 viewBox 屬性的話這個用戶座標系統就會被調整修改，也就是不再跟 viewport 座標系統一致即實際的單位大小和原點可能不同。我們會在後續討論關於修改的部分。 現在，我們先不設定 viewBox ，讓 SVG canvas 的用戶座標和 viewport 座標相同。 在下面的圖片中，灰色的尺規標的是 viewport 座標 ，青藍色的則是用戶座標（viewBox）。因為它們目前是一樣的所以兩個尺規會重疊。 總結上面的說明就是兩個座標系統分別屬於在 viewport 和 SVG canvas。 圖片上的鸚鵡顯示寬為 200，高為 300 在這邊單位是 px，這隻鸚鵡依據初始化的座標被畫在 SVG canvas 層。而 viewport 就像瀏覽器視窗一樣，它就是我們渲染到瀏覽器上最終具體尺寸的依據。 viewBox到這邊我們先把它們整理一下 畫布(SVG canvas) 使用的是用戶座標，也是用來畫圖的座標，viewport 的是另一個座標系通常只用來作最後渲染的參考換算。viewBox 可以調整用戶座標，所以我偏好直接把 viewBox 直接當作是最終使用的座標系，畢竟最終呈現就是用它。這個座標系統或者我們說這個空間是可以大或小於 viewport，要完成顯示於 viewport 或局部顯示取決於我們的需求。 用戶座標系統 其實就是 viewBox 參數產生的座標系，目前跟 viewport 座標一致。因為我們現在沒有設定，所以 2 個座標預設是一樣的，這就是為什麼目前畫上去的物件看起來像是依據 viewport 座標定義一樣，但實際上依據的是用戶座標系。 一般的流程是：我們透過 &lt;svg&gt; 的 width, height 定義 viewport 座標，一但 viewport 座標系統初始化，瀏覽器預設會建立一個用戶座標系統其所有定義跟 viewport 座標一樣。 後續我們可以使用 viewBox 調整用戶座標系統，如果用戶座標系統的寬高比和 viewport 一致，就會自動擴展以填滿 viewport 的空間。不過，如果您的用戶座標系統和 viewport 比例不同，我們可能就需要使用 preserveAspectRatio 屬性來調整在 viewport 中顯示的方式，我們可以設定其在 viewport 的位置(垂直置中或水平置中等等)。在下一節我們會透過大量的範例來說明。現在我們將固定 viewBox 的比例跟 viewport 一樣，所以 preserveAspectRatio 在此沒有作用。 白話小結：在 svg 的世界裡，底下有一張不限寬高的畫布(canvas)，預設用 px 當單位，我們把圖畫在這裡。接著上面有一層視窗層(viewport)，概念像透過瀏覽器視窗看網頁一樣就是那個可視區域。初始化後兩個東西的寬高一樣，通常圖案也是根據此時的座標和單位配置，但後續 canvas 可以使用 viewBox 調整，概念上有點像 Sketch Slice 或 Illustrator 切片定義的那個範圍。在 canvas 上切個範圍，接著它會盡可能的塞滿 viewport，於是 canvas 上圖案的單位產生變化，我們還可以用 preserveAspectRatio 來設定塞滿的規則像是對齊等等。 viewBox 語法關於 viewBox 屬性需要 4 個參數分別為 &lt;min-x&gt;, &lt;min-y&gt;, width, height 1&lt;svg viewBox=&quot;&lt;min-x&gt; &lt;min-y&gt; width height&quot;&gt;&lt;/svg&gt; &lt;min-x&gt; 和 &lt;min-y&gt; 的值決定 viewBox 的左上座標，width 和 height 則決定 viewBox 的寬高。注意 viewBox 的寬高並不需要跟 svg 的寬高一致，並且負值是不合規範的。只要寬或高其一設為 0 時則停止渲染該元素。 注意 viewport 的寬是可以透過 CSS 修改的，高不行。例如：設定 width: 100% 會使 SVG viewport 填滿 doucment 的寬。接著無論 viewBox 的值是什麼都會對應填滿 viewport 並轉換計算出對應的單位值。 1234&lt;!-- 在這個例子 viewBox 等於 viewport，但它們可以通過設定而不同 --&gt;&lt;svg width=&quot;800&quot; height=&quot;600&quot; viewbox=&quot;0 0 800 600&quot;&gt; &lt;!-- 內容 --&gt;&lt;/svg&gt; 如果您曾經閱讀 viewBox 的規範，您也許看過規範說您可以使用 viewBox 屬性來使 SVG 產生形變，例如：放大或位移。沒錯，後續我們甚至會用其特性裁切 SVG。 要理解 viewBox 和 viewport 之間的差異最好的方式便是直接觀察視覺化的結果，如果上面的說明已經讓您混亂，那就讓我們來看看一些範例，透過系列範例希望能讓您掌握 viewport 和 viewBox。讓我們先從簡單的開始，所以一開始我們讓 viewBox 和 viewport 的比例是一樣的，還有現階段我們先不探討 preserveAspectRatio 避免混亂。 與 viewport 寬高比相同的 viewBox範例中的 viewBox 寬高是 viewport 的一半，並且這次我們不改變 viewBox 的原點，&lt;min-x&gt; 和 &lt;min-y&gt; 都設為 0。 12&lt;svg width=&quot;800&quot; height=&quot;600&quot; viewBox=&quot;0 0 400 300&quot;&gt;&lt;/svg&gt; 所以 viewBox=&quot;0 0 400 300&quot; 做了什麼？ 先在 SVG canvas 中從 (0, 0) 到 (400, 300) 畫一個特殊的區塊 接著，依據此區塊裁切 SVG 將該區塊放大到塞滿整個 viewport 對應用戶座標與 viewport 座標轉換單位，在這個範例下，一個用戶單位具體的大小會等於 2 倍的 viewport 單位 下圖說明了將上面 viewBox 的屬性加到 &lt;svg&gt; 時的狀況。灰色代表 viewport 座標，青藍色表示 viewBox 座標即用戶座標系統。 任何您畫在 SVG canvas 上的東西都會跟這個新產生的用戶座標有對應的關係，或者說坐落在這個座標系統上。 視覺化 SVG canvas 搭配 viewBox 的行為類似於 Google Map。你可以縮放特定區域，當放大時只有在 viewport 範圍的東西可以被呈現，雖然我們知道剩下的東西都還在地圖上，但它們不會顯示因為超出 viewport 邊界的內容會被裁切掉。所以具體來說裁切的動作是 viewport 執行的，viewBox 只是畫好區塊。 現在讓我們修改 &lt;min-x&gt; 和 &lt;min-y&gt; 的值。值可以是任何數字，但這邊我們將兩個值設成 100。寬高維持一樣的比例。 123&lt;svg width=&quot;800&quot; height=&quot;600&quot; viewbox=&quot;100 100 200 150&quot;&gt; &lt;!-- 內容 --&gt;&lt;/svg&gt; 套用 viewBox=&quot;100 100 200 150&quot; 的效果同樣會像上一個範例一樣產生裁切的效果。 同樣的，用戶座標會對應 viewport 座標。即 200 的用戶單位會對應 800 的 viewport 座標單位，等於實際長度是 4 倍的 viewport 單位。這個結果就像是 zoom-in 的效果。 同時注意到在這個時候，設定的 &lt;min-x&gt; 和 &lt;min-y&gt; 也對圖片產生了形變的效果，更具體的說就是 SVG canvas 被位移了 100 個單位 transform=&quot;translate(-100, -100)&quot;。 的確如同 SVG 規範所說的 viewBox 屬性的效果是自動計算變形矩陣並對應到特定的空間，通常這個空間是 viewport。 這行為看似很複雜，但就如同我們之前說的，就是先裁切圖片，然後塞滿 viewport。接著規範加上了註解：在某些情況下瀏覽器處理 SVG 的部分(User Agent)除了要提供 scale 縮放的資訊外還得提供 translate 位移的資訊。當 viewBox 的 &lt;min-x&gt; 和 &lt;min-y&gt; 不是 0 的時候最外層的 svg 元素就會需要 translate 的相關資訊，簡單說就是為了要填滿 viewport 而移動了畫布。 為了示範圖形的位移(translate transformation)，讓我們套用負值 -100 到 &lt;min-x&gt; 和 &lt;min-y&gt;。從左上角 (-100, -100) 裁切之後把該區塊填滿 viewport 的行為，其效果具體看起來是像是 transform=&quot;translate(100, 100)&quot;。 意味著圖片在裁切和放大之後會往右下搬。讓我們來看看下面的範例： 123&lt;svg width=&quot;800&quot; height=&quot;600&quot; viewbox=&quot;-100 -100 400 300&quot;&gt; &lt;!-- 內容 --&gt;&lt;/svg&gt; 套用上面 viewBox 屬性的結果會如下圖 注意！不同於 transform 屬性，這種由 viewBox 造成自動添加的 transformation (變形，位移效果)並不會影響設定 viewBox 元素本身的 x, y, width, height 屬性。因此在上面這個範例中的 svg 元素仍然保有原本的 width, height, viewBox。width 和 height 表示的是 viewBox 變更用戶座標前的值，然後看看灰色的尺規(表示 viewport 座標系統)在 viewBox 屬性產生效果之後 svg 仍然維持原本的屬性值。 其他方面則跟 transform 屬性一樣，它會建立一個新的座標系給其他子元素使用。您可以觀察到上面的範例用戶座標是新的，跟原本初始化時跟 viewport 座標相同的那個已經不一樣了。並且在 &lt;svg&gt; 下的元素都依據這個新的座標系重新定位，改變尺寸。 最後一個關於 viewBox 的範例類似於上一個，不過這次我們不是要裁切，而是要擴展，來看看在 viewport 下圖片會有什麼變化。我們將 viewBox 的寬高設的大於 viewport 的寬高，但我們仍保持一樣的比例。後續我們在討論關於不同比例的部分。 下面的範例我們讓 viewBox 設為 viewport 的 1.5 倍。 123&lt;svg width=&quot;800&quot; height=&quot;600&quot; viewBox=&quot;0 0 1200 900&quot;&gt; &lt;!-- 內容 --&gt;&lt;/svg&gt; 其結果就是現在用戶座標擴大到 1200x900。然後一樣對應 viewport 的座標系轉換具體渲染輸出的單位，也就是填滿 viewport 這個行為。所以現在每一個用戶座標 x 軸的單位需要乘上 viewport.width / viewBox.width 來轉換，用戶座標 y 軸的單位也是要乘上 viewport.height / viewBox.height 轉換。在這種情況下 viewBox 上每一個 x 座標的單位會等於 viewport 單位乘上 0.66 換算，以此類推 y 軸單位。 當然最好的理解方式就是直接看圖。viewBox 會先被擴大，再填滿 viewport，最終的結果就如下圖。因為圖是基於新的用戶座標畫在 SVG canvas 上而不是 viewport 座標，從新座標系每個單位變成 0.66 倍，我們可以預見圖會變小。 截止目前為止，所有的範例都跟 viewport 的寬高維持一樣的比例。那如果 viewBox 的寬高和 viewport 的不一樣時會如何？ 假定 viewBox 的寬高為 1000x500，如此 viewBox 的比例就不再跟 viewport 一樣了。看看下面的範例 用戶座標和圖都要被放置在 viewport 中，也因此預設行為如下： 整個 viewBox 即 viewBox 切出來的區域要盡可能的執行填滿 viewport 的動作 viewBox 的寬高比會被保留，所以 viewBox 不會擴展完整覆蓋 viewport 在 viewport 區塊中，viewBox 會被水平、垂直置中 上面描述的是預設行為。那是什麼控制這個行為呢？如果我們想要改變 viewBox 在 viewport 中的位置那該怎麼做？這兩個問題就是 preserveAspectRatio 存在的意義。 preserveAspectRatio 屬性preserveAspectRatio 屬性的目的是為了在縮放時強制固定圖片的比例。 假設我們定義了一個和 viewport 座標不同寬高比的用戶座標系，接著瀏覽器會將 viewBox 填滿 viewport。但因為比例不同的關係，所以導致圖片在 viewBox 展延時變形了。照上面 1000x500 的設定圖片如果不設定比例將會變成下圖這樣： 當 viewBox 使用 0 0 200 300 時扭曲變形也是顯而易見的，使用 200x300 是因為這樣 viewBox 會剛好涵蓋整隻鸚鵡，然後 viewBox 會展延填滿 viewport，我們就觀察到圖片產出變形了 preserveAspectRatio 屬性讓我們可以強統鎖定 viewBox 和圖案的比例來進行縮放，並且可以設定 viewBox 在 viewport 中的位置，這是因為固定比例縮放有以導致 viewBox 不會跟 viewport 完全吻合，預設(在不提供任何設定時)會將 viewBox 保持比例縮放，並水平與垂直置中於 viewport 中。 preserveAspectRatio 語法關於 preserveAspectRatio 語法如下： 1preserveAspectRatio = defer? &lt;align&gt; &lt;meetOrSlice&gt;? preserveAspectRatio 可用在任何會建立 viewport 的元素上(下一篇我們會深入討論)。除了 &lt;image&gt; 外，對於支援此屬性的元素，preserveAspectRatio 只在元素設定 viewBox 時產生作用。 defer 是選擇性的參數，通常只有當我們要套用 preserveAspectRatio 到 &lt;image&gt; 上會使用，套用到其他元素時此屬性會被忽略。由於 &lt;image&gt; 已經超過本文要討論的範圍，所以這邊我們會略過 defer。 align 參數本身除了如同字面的意義對齊之外還可以用來設定是否固定比例，當 viewBox 和其元素的比例和 viewport 不同時產生效果。 如果 align 設為 none 1preserveAspectRatio=&quot;none&quot; 圖片將會填滿 viewport 不管 viewBox 的比例，也就是上面變形的 2 個例子。 除了 none 外其他的設定值將會固定 viewBox 的比例，然後依照設定在 viewport 中對齊。 最後的參數 meetOrSlice 也是選填的，預設為 meet。這個參數設定了 viewBox 是否要完整呈現於 viewport 中。align 和 meetOrSlice 兩個參數一起使用的寫法如下，中間需要插入一個空白： preserveAspectRatio=&quot;xMinYMin slice&quot; 一開始看到這些設定值也許會覺得很怪，不過我們大致上可以把 meetOrSlice 想成是 CSS 中 background-size 的 contain 和 cover，meet 的行為很像 contain ，而 slice 則像 cover 。下面我們先來討論關於 meetOrSlice 的參數 meet (預設值)儘可能的讓圖片填滿 viewport 同時遵循下列規則 固定 viewBox 比例 整個 viewBox 需完整呈現在 viewport 中，原理概略為取得寬高的比例 viewport.width / viewBox.width 和 viewport.height / viewBox.height。小的一邊儘可能填滿 viewport 對應的邊。 在這種情況下，因為比例不符合 viewport，viewport 的邊界會大於 viewBox 即 viewBox 繪製的區域小於 viewport 的區域。這就是 meet 參數的作用 viewBox 會完整呈現於 viewport 中。 meet 類似於 background-size: contain 。背景圖會儘可能的放大同時固定比例，最後確保整張圖可以被完整呈現在背景容器裡。當圖片與元素容器比例不同時，圖片就無法完整覆蓋元素。 slice縮放並固定圖片比例讓 viewBox 覆蓋整個 viewport。viewBox 會被縮放到剛剛好可以覆蓋 viewport，通常會有一邊超出 viewport，超出的部分就會被 viewport 裁掉。這個參數的行為類似於 background-size: cover，在背景圖的情況，圖片保持寬高比，然後縮放到寬高可以完全覆蓋元素的背景定位區的最小尺寸。 所以 meetOrSlice 可以用來設定 viewBox 是否要完全呈現在 viewport 中或者是盡可能縮放覆蓋整個 viewport。 舉例來說：如果我們同樣使用 200x300 的 viewBox align 都維持置中，meet 和 slice 的效果會分別如下： align 的參數有 9 + 1 種，除了 none 其他的值都會啟用固定比例和設定對齊的方式。align 的行為類似於 background-position 使用百分比的用法。例如 background-position: 50% 50%; 就是把圖片 X 座標 50% 的位置對齊元素 X 座標 50% 的位置。把 viewBox 想成是一張背景圖，不過和 background-position 不同是我們不是使用百分比來取座標點而是直接指定 viewBox 和 viewport 對齊的 xy 軸。 為了理解 align 我們要先介紹軸的部分。 記得 viewBox 的 &lt;min-x&gt; 和 &lt;min-y&gt;？我們要使用的就是 viewBox 的 min-x 軸和 min-y 軸，另外 max-x 和 max-y分別是透過 &lt;min-x&gt; + width 和 &lt;min-y&gt; + height 計算而得的。最後還有 mid-x mid-y 計算方式即 &lt;min-x&gt; + (width/2) 和 &lt;min-y&gt; + (height/2)。 上面的說明越看越亂？好吧讓我們透過下圖，看看這些軸各自在哪。在圖片中 &lt;min-x&gt; 和 &lt;min-y&gt; 預設是 0 因為 viewBox=“0 0 300 300” 灰色的虛線是 viewport 的 mid-x 和 mid-y 軸。我們將要設定一些值來讓 viewBox 對齊 viewport 的軸。 接著我們來一一看看所有設定值： none不執行固定比例縮放。換句話說就是 viewBox 直接填滿 viewport 不管 viewBox 的比例，圖片可能因此變形。 注意：align 設為 none 時 meetOrSlice 直接無效 xMinYMin 固定比例縮放 viewBox 的 min-x 和 viewport x 的最小值對齊 viewBox 的 min-y 和 viewport y 軸的最小值對齊 行為類似於 background-position: 0% 0%; xMinYMid 固定比例縮放 viewBox 的 min-x 和 viewport x 的最小值對齊 viewBox y 軸的中間點和 viewport y 軸的中間點對齊 行為類似於 background-position: 0% 50%; xMinYMax 固定比例縮放 viewBox 的 min-x 和 viewport x 軸的最小值對齊 viewBox 的 min-y + height 和 viewport y 軸的最大值對齊 行為類似於 background-position: 0 100%; xMidYMin 固定比例縮放 viewBox x 軸的中間點和 viewport x 軸的中間點對齊 viewBox 的 min-y 和 viewport y 軸的最小值對齊 行為類似於 background-position: 50% 0%; xMidYMid 固定比例縮放 viewBox x 軸的中間點和 viewport x 軸的中間點對齊 viewBox y 軸的中間點和 viewport y 軸的中間點對齊 行為類似於 background-position: 50% 50%; xMidYMax 固定比例縮放 viewBox x 軸的中間點和 viewport x 軸的中間點對齊 viewBox 的 min-y + height 和 viewport y 軸的最大值對齊 行為類似於 background-position: 50% 100%; xMaxYMin 固定比例縮放 viewBox 的 min-x + width 和 viewport x 軸的最大值對齊 viewBox 的 min-y 和 viewport y 軸的最小值對齊 行為類似於 background-position: 100% 0%; xMaxYMid 固定比例縮放 viewBox 的 min-x + width 和 viewport x 軸的最大值對齊 viewBox y 軸的中間點和 viewport y 軸的中間點對齊 行為類似於 background-position: 100% 50%; xMaxYMax 固定比例縮放 viewBox 的 min-x + width 和 viewport x 軸的最大值對齊 viewBox 的 min-y + height 和 viewport y 軸的最大值對齊 行為類似於 background-position: 100% 100%; 所以使用 preserveAspectRatio 的 align 和 meetOrSlice 我們就可以設定 viewBox 縮放與定位的行為。我們可以選擇是要全部顯示或只顯示局部。 有時結果會取決於 viewBox 的尺寸，有些設定雖然不同但結果會一樣。例如：之前的 viewBox=&quot;0 0 200 300&quot; 在 meetOrSlice 為 meet 的情況下，align 就算不同也會達成一樣的結果 但如果我們把 meetOrSlice 換成 slice 那麽結果就完全不同了。因為 slice 設定下 viewBox 展延覆蓋 viewport 的行為 - x 軸的 200 單位被換算並覆蓋了 viewport 的 800 單位，同時為了固定比例 viewBox 的 y 軸勢必會大於 viewport 的 y 軸而造成被 viewport 裁切。觀察下圖 下面我們不再示範更多例子，而是回到一開始那個互動的範例讓您親自調整 viewBox 和 preserveAspectRatio 的參數去驗證觀察。 不過在我們繼續往下走之前，我想提醒一下關於 mid-x mid-y max-x max-y 的值是會隨著 min-x 和 min-y 而改變的。 viewBox 並不會真的裁切隱藏畫在 SVG canvas 上的圖，當比例不同時 viewBox 所定義的矩形區塊會作為縮放(單位實際值轉換)和對齊的依據。 下圖是 viewBox=&quot;100 0 200 300&quot; 的效果，meetOrSlice 維持預設 meet 觀察 mid-x 和 max-x 是如何變化，是否跟您所預期的效果一致。 互動範例要理解 viewport、viewBox 和 preserveAspectRatio 之間的關係最好的方式就是直接看視覺化的結果。為了這個目的文章提供了這個簡單的互動範例，您可以透過修改參數的值直接觀察結果。 查閱範例 希望您能從這篇文章更加理解 SVG 中 viewport、viewBox 和 preserveAspectRatio 的概念。如果您想要更深入的理解關於 SVG 座標系統，例如巢狀座標，如何在 SVG 中建立新的座標系與變形的議題，您可以繼續閱讀後續的系列文章。 資源參考 原文 MDN SVG w3c 理解SVG viewport,viewBox,preserveAspectRatio缩放 簡體中譯","link":"/2017/03/17/svg-coordinate-1/"},{"title":"DOM 基礎複習筆記","text":"DOMDOM = Document Object Model。DOM 詮釋了 HTML，XML，SVG 上元件的組成建構，操作，是一套程式介面。所有的 DOM 都提供了 API 可以對其操作。實務上指的就是 HTML Tag，文件樹的結構化表示法。 例如：我們使用 HTML 標籤來撰寫，然後瀏覽器會把這些 HTML 轉成 DOM Object 讓我們可以操作。 DOM Node（DOM Object） v.s DOM ElementNode 節點通常是對 DOM 結構中任何類型物件的泛稱。Node 可以是任何一種內建的 DOM 元素（Element）e.g. document，document.body。也可以指特定 HTML tag e.g.&lt;input&gt;，&lt;p&gt;。Node 即任何一種 DOM Object。 元素 Element 指的是特定類型的 Node（DOM Object）。 更精確的說：Node 的實踐是為了建構樹狀結構，它會具有 firstChild lastChild childNodes 等方法。有些 Node 同時也是 Element。因為 Element 繼承 Node。 1234567891011&gt; document instanceof Nodetrue&gt; document instanceof Elementfalse&gt; document.firstChild instanceof Nodetrue&gt; document.firstChild instanceof Elementtrue Bubbling v.s. CapturingDOM Element 可以嵌套在其他 DOM Element 之中，而且即便我們點擊的是子元素（嵌套在內部），父元素也會觸發自己對應的處理程序 Handler（Event）。 造成這個結果的原因就是 Event bubbling。 舉例來說下面的 div 的處理程序 i.e. 觸發的事件，就算我們點擊的是子元素 em 或 code 也會被執行。 123&lt;div onclick=&quot;alert('div handler')&quot;&gt; &lt;em&gt;Click here to triggers on nested &lt;code&gt;em&lt;/code&gt;, not on &lt;code&gt;div&lt;/code&gt;&lt;/em&gt;&lt;/div&gt; 這就是因為 Event bubbles 即事件上升傳遞 Bubbling 上升傳遞所謂 Bubbling 的原則或說執行流程就是：當最底層（最內部）的元素觸發事件之後，接著會照著順序往上層／父／容器元素觸發對應事件。 舉例來說，下面有三層的 div 結構 123456&lt;div class=&quot;d1&quot;&gt;&lt;!— 最外層 —&gt; &lt;div class=&quot;d2&quot;&gt; &lt;div class=&quot;d3&quot;&gt;&lt;!— 最內層 —&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; Bubbling 或稱上升傳遞機制，例如 click 事件，當我們點擊 d3 時： 首先確保最內部的 div d3 (同時也稱作 target)的 onclick 先被觸發執行。 接著觸發 div d2 的 onclick 最後 div d3 的 onclick 這樣的行為稱為 Bubbling Order 也有人直翻冒泡。因為事件觸發由最內部往上層就像水中的氣泡一樣。 01 this 和 event.target當我們觸發最內部元素的事件時，這個最內部的元素又稱為 target 或觸發起始元素。在 IE 有個 srcElement 屬性可以取得，其他遵循 w3c 規範的瀏覽器則使用 event.target。 在 Javascript 中 this 簡單來說就是指向調用 function 的物件（可以理解為其別名） 所以在這個 Bubbling 的流程下 this 和 target 分別為： event.target/srcElement - 維持同樣的元素 this - 綁定該事件的元素，會指向現在正處理該事件的事件監聽器所註冊的 DOM 物件。 注意：target 在整個過程中是不變的，this 則會變動。 在 w3c 兼容的瀏覽器中 this 也等於 event.currentTarget。至於 IE 中的 attachEvent 方法則不會傳遞 this 和 currentTarget。 停止 Bubbling因為冒泡的機制，當某個事件被觸發後就會一路往上傳直到 &lt;html&gt; 才會停止。但很多時候這會造成不預期的結果。因此我們需要停止傳遞的方法。 w3c 兼容瀏覽器：event.stopPropagation() IE &lt; 9 : event.cancelBubble = true 假如同一個事件綁定多個處理函式，其中一個函式停止了傳遞，其他綁定的函式仍然會執行。另外綁定多個函式瀏覽器並不能確保其執行的順序。 Capturing 由上至下傳遞在所有瀏覽器，除了 IE &lt; 9。事件在處理執行時都有兩個階段。 根據 w3c de 規範觸發流程會先由上至下稱為 Capturing，接著由下至上稱為 Bubbling。 預設，所有 Capturing 階段的事件處理函式會被忽略。除非我們使用 addEventListener 最後的參數為 true，那麼就只會執行 Capturing 階段的事件，Bubbling 階段的觸發就會被忽略。 在實務上 Capturing 很少被使用。不過有些事件不會冒泡傳遞，例如：onfocus/onblur 總結 事件觸發的順序是先 Capturing 階段至最內部的元素，接著 Bubbling。除了 IE&lt;9 只有 Bubbling 除非 addEventListener 最後的參數使用 true 否則 Capturing 階段的觸發都會被忽略。 可以使用 event.stopPropagation() 或 event.cancelBubble = true 來停止傳遞觸發。","link":"/2017/02/11/dom-review/"},{"title":"[譯] 理解 SVG 座標系統與 Transformation - 3 建立 viewpor","text":"在 SVG 繪製的任何一個時間點，我們都可以透過內嵌 &lt;svg&gt; 或者使用像是 &lt;symbol&gt; 這類的元素來建立新的 viewport 和用戶座標。本篇文章我們將要探討該怎麼作？以及如何利用這種方式協助我們控制 SVG 元素使其更具彈性。 本篇是探討 SVG 座標系與變形系列文章的第三篇也是最後一篇，在第一篇我們討論了 SVG 座標系的基本觀念即 viewport viewBox preserveAspectRatio 這三個東西。第二篇主要討論了關於變形的用法和座標系之間關係的觀念。系列文章的連結條例於下： [譯] 理解 SVG 座標系統與 Transformation - 1 viewport、viewBox、和 preserveAspectRatio [譯] 理解 SVG 座標系統與 Transformation - 2 transform 屬性 [譯] 理解 SVG 座標系統與 Transformation - 3 建立 viewport 在這篇文章中，我假設您至少已經讀完第一篇文章，並且能夠掌握 SVG viewport 的觀念和 viewBox preserveAspectRatio 兩個屬性。本篇文章不需要具備第二篇討論的觀念，您可以略過無妨。 嵌入 &lt;svg&gt;在第一篇文章中我們聊到了關於 &lt;svg&gt; 可以為我們的 SVG canvas 即繪圖的那一層建立一個 viewport 的觀念，就像視窗與網頁內容之間的關係。而這邊要說的就是在 SVG 繪製的任一時間點，其中繪製的意義講的更具體一點就是我們加上的 SVG 元素的任意時間點，我們還可以在建立新的 viewport。作法就是在 &lt;svg&gt; 內部加上另一個 &lt;svg&gt; 就可以建立新的 viewport。在我們建立新的 viewport 同時我們也建立了一個新的 viewport 座標系和新的用戶座標系。 舉例來說，假設我們的 &lt;svg&gt; 如下 123456&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;&gt; &lt;!-- 圖案 --&gt; &lt;svg&gt; &lt;!-- 其他在嵌入 svg 內部的圖案 --&gt; &lt;/svg&gt;&lt;/svg&gt; 第一件要注意的是內部的 &lt;svg&gt; 元素不需要設定命名空間 xmlns，因為它會和外層的 &lt;svg&gt; 使用同樣的命名空間。當然如果我們使用的是 HTML 5 那麽外層的 &lt;svg&gt; 也不需要加上命名空間。 XML 命名空間用來解決 tag 名稱衝突的問題，例如在 HTML 5 以前我們使用 XHTML 應加上 &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;。 我們可以用 SVG 元素來將一些元素圈在一個群組，然後集體操作它們。我們知道如果只是要群組的功能我們可以使用 &lt;g&gt; ，例如要移動元素，我們可以在 &lt;g&gt; 套用 transform 效果來達成位移效果，底下所有的元素都會受到影響。這邊要使用 &lt;svg&gt; 肯定是因為它具備其他功能。舉例來說直接設定 x 和 y 座標在大部分情況下比起使用 transform 要方便多了。還有，&lt;svg&gt; 可以設定寬高，而 &lt;g&gt; 不行。我們並沒有要讓 &lt;svg&gt; 取代 &lt;g&gt; 的意思，兩者在用途上有些差異，我們並不是都需要 &lt;svg&gt; 的功能，因為它會建立另外的 viewport 座標和用戶座標，有些時候這並不是我們要的。 透過在 &lt;svg&gt; 上設定寬高（這邊指的是內嵌的 &lt;svg&gt;），我們可以限制內容呈現的邊界，如同第一篇說的我們使用 SVG 的 width 和 height 會定義出視窗的範圍，超出範圍的內容都會被裁切掉。另外，這邊要在加上兩個屬性 x 和 y。 如果不設定 x 和 y 預設是 0，不設定 width，height 的話預設是最外層 SVG 的 100%。看看這個範例稍微體會一下上面提到的裁切效果。 此外，當我們改變這個 &lt;svg&gt; 的用戶座標系時，該 &lt;svg&gt; 內的內容都會受到影響。 &lt;svg&gt; 內的元素如果使用百分比值會根據父層的 &lt;svg&gt; 來計算，而不是最外層的 &lt;svg&gt;。在內層 &lt;svg&gt; 元素上如果使用百分比值則是依據外層的 &lt;svg&gt; 來計算。下面範例的結果裡面的 &lt;svg&gt; 會是 400 單位，而內部 &lt;svg&gt; 裡的方形會是 200 單位。 12345&lt;svg width=&quot;800&quot; height=&quot;600&quot;&gt; &lt;svg width=&quot;50%&quot;&gt; &lt;rect width=&quot;50%&quot;&gt;&lt;/rect&gt; &lt;/svg&gt;&lt;/svg&gt; 假定這個範例被放在一個 HTML 文件中，例如最外層的 &lt;svg&gt; 被設為 100%，讓它隨著瀏覽器視窗自動縮放。於是裡面的 &lt;svg&gt; 就會動態的跟著外層的寬高變動縮放。 最外層的 &lt;svg&gt; 元素可以使用 CSS 設定背景色和邊框和一般 HTML 元素很接近，但內部的 &lt;svg&gt; 則無法。範例。另外內嵌 SVG 使用的單位會根據外層設定的結果，這點需要特別注意。修改這個範例內部 &lt;svg&gt; 的 width，height，viewBox 觀察一下。 善用內嵌 SVG 可以增加操作 SVG 元素的靈活性。是什麼靈活性呢？假設我們在最外層 &lt;svg&gt; 的寬設成 100%，讓我們的 SVG 可以隨著容器（或瀏覽器視窗）縮放，到這一步就可以像網頁那樣使 SVG 也具備自適應的效果。如果我們有其他需求我們可以接著透過 viewBox 和 preserveAspectRatio 讓內容依照我們想要的方式在自適應的 viewport （最外層的 &lt;svg&gt;）中呈現。原作者在 CSSConf 中的 slide有介紹過關於 Responsive SVG 的作法。您可以在查閱。 然而，當我們像上面那樣在 SVG 實作自適應的效果時，整個畫布裡的元素都會同時產生對應的變化。有時，我們並不想要這樣，我們可能只想要某個元素彈性變動，其他元素固定位置/尺寸。這個時候內嵌 &lt;svg&gt; 就能派上用場。 一個 SVG 元素能夠擁有自己的座標系，自己的 viewBox 和 preserveAspectRatio 屬性，我們可以依照需求定義其位置，尺寸，顯示的範圍。 所以為了讓一個元素保留更多彈性，我們可以將它用 &lt;svg&gt; 包起來，如果給 SVG 百分比的寬那麽元素就會依照最外層 &lt;svg&gt; 的寬來調整，想要填滿容器的話可以加上 preserveAspectRatio=&quot;none&quot;。注意，SVG 沒有限制嵌入的階層，這邊為了讓介紹單純一點，文章只使用一層。 為了展嵌入 SVG 如何發揮作用，下面讓我們來看個範例 範例假設我們有下面一張 SVG 這張自適應的 SVG 當我們改變視窗的大小，整張 SVG 就會根據需要產生改變。下面的截圖顯示了當頁面變窄時的情形，圖片變小了。注意到 SVG 的內容如何變形，它仍然維持原來的座標與比例等等，只是座標系依據 viewport 使單位產生變化。 ！ 使用內嵌 SVG 我們可以改變這點，我們可以替 SVG 中的元素設定在 viewport 中的位置，也就是當最外層 SVG viewport 尺寸改變時，每個元素各自有自己對應變形的方式。 注意在這邊您需要熟悉 SVG viewport，viewBox，preserveAspectRatio 的使用方式。 下面我們要建立的效果是：當視窗改變尺寸時，蛋的上半部會往上移動，後續躲在後層的小雞就會出現。如下圖 為了完成這個效果，蛋上半部的部分必須要使用 &lt;svg&gt; 來和其他元素分開，我們給這個 &lt;svg&gt; 設定 ID 為 upper-shell。 然後，我們要讓新的 svg#upper-shell 和最外層的 &lt;svg&gt; 有一樣的寬高，這我們可以透過在 &lt;svg&gt; 上設定 width=100% height=100% 或者全部都不設定保持預設值 100% 都能完成。 假如內嵌的 svg 沒用設定寬高，其會自動展延填滿外層的 svg 即寬高為 100% 然後最後，為了讓上半部蛋殼升起，我們將要使用 preserveAspectRatio 來使 viewBox 移動到 viewport 的上方 - xMinYMin。 12345678910111213141516&lt;svg version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;&gt; &lt;!-- ... --&gt; &lt;svg viewBox=&quot;0 0 315 385&quot; preserveAspectRatio=&quot;xMidYMid meet&quot;&gt; &lt;!-- the chicken illustration --&gt; &lt;g id=&quot;chicken&quot;&gt; &lt;!-- ... --&gt; &lt;/g&gt; &lt;!-- path forming the lower shell --&gt; &lt;path id=&quot;lower-shell&quot; fill=&quot;url(#gradient)&quot; stroke=&quot;#000000&quot; stroke-width=&quot;1.5003&quot; d=&quot;...&quot;/&gt; &lt;/svg&gt; &lt;svg id=&quot;upper-shell&quot; viewBox=&quot;0 0 315 385&quot; preserveAspectRatio=&quot;xMidYMin meet&quot;&gt; &lt;!-- path forming the upper shell --&gt; &lt;path id=&quot;the-upper-shell&quot; fill=&quot;url(#gradient)&quot; stroke=&quot;#000000&quot; stroke-width=&quot;1.5003&quot; d=&quot;...&quot;/&gt; &lt;/svg&gt;&lt;/svg&gt; 這裡為了示意觀念，把上面程式嗎一些跟圖有關的部分移除了 在這，注意到 svg#upper-shell 的 viewBox 值和最外層的 svg 是一樣的（上面程式已經被我們移除）。這麼做的原因是在視窗較大時我們希望圖案跟原來一樣。 所以，事情是這樣的；一開始我們的 SVG 是一顆有裂痕的蛋，圖層下方還有一隻小雞被蛋殼蓋住。然後我們利用內嵌 svg 的方式 - 建立另一個圖層把蛋殼的上半部移到這一層。這個內嵌的 svg 和外面其他的 svg 寬高和 viewBox 設定都一樣（蛋殼下半部 + 小雞）。最後上半部蛋殼 svg 的 viewBox 設定往上對齊 xMin 軸。當最外層的 svg 縮小時， viewport 隨著 width height 產生變化，此時 viewBox 定義的區塊比例和 viewport 不同了，上半部蛋殼就會往上移動。我們來看看圖片。 譯者註：原文 outer svg 並非最外層的 svg 在對照範例時可能會造成誤會，如果 viewBox 的比例和最外層一樣的話，將不會有效果。因為外層的用戶座標將會和內嵌的 svg 一樣，比例一樣的狀況下 preserveAspectRatio 不會有效果。 ！ 一但視窗尺寸縮小，SVG 變得瘦長，上半部蛋殼 svg 的 viewBox 就會因為 preserveAspectRatio=&quot;xMidYMin meet&quot; 往上對齊 灰色的部分顯示出內嵌 svg 的 viewport。淺紫色的部分顯示出上半蛋殼的內嵌 svg viewBox，因為 preserveAspectRatio=&quot;xMidYMin&quot; 所以對齊上方。 點擊連結查看實際的範例 內嵌 svg 或者我們說增加 svg 圖層可以讓我們設定不同的對齊裁切方式。換句話說等於是多了一層 viewport，多一次機會設定 preserveAspectRatio。如此一來我們就可以設計變化自適應效果。 如果我們想要整隻小雞顯示，我們可以單獨再把下半部的蛋殼獨立一層 svg，只是這次要換成 preserveAspectRatio=&quot;xMidYMax meet&quot; 123456789101112131415161718&lt;svg version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;&gt; &lt;svg id=&quot;chick&quot; viewBox=&quot;0 0 315 385&quot; preserveAspectRatio=&quot;xMidYMid meet&quot;&gt; &lt;!-- the chicken illustration --&gt; &lt;g id=&quot;chick&quot;&gt; &lt;!-- ... --&gt; &lt;/g&gt; &lt;/svg&gt; &lt;svg id=&quot;upper-shell&quot; viewBox=&quot;0 0 315 385&quot; preserveAspectRatio=&quot;xMidYMid meet&quot;&gt; &lt;!-- path forming the upper shell --&gt; &lt;path id=&quot;the-upper-shell&quot; fill=&quot;url(#gradient)&quot; stroke=&quot;#000000&quot; stroke-width=&quot;1.5003&quot; d=&quot;...&quot;/&gt; &lt;/svg&gt; &lt;svg id=&quot;lower-shell&quot; viewBox=&quot;0 0 315 385&quot; preserveAspectRatio=&quot;xMidYMax meet&quot;&gt; &lt;!-- path forming the lower shell --&gt; &lt;path id=&quot;the-lower-shell&quot; fill=&quot;url(#gradient)&quot; stroke=&quot;#000000&quot; stroke-width=&quot;1.5003&quot; d=&quot;...&quot;/&gt; &lt;/svg&gt;&lt;/svg&gt; 每個內嵌的 svg viewport 都跟最外層的 svg 一樣，意味著 width 和 height 都是 100%。所以基本上我們得到了 3 個 viewport 座標系的副本。每一層各自負責內部的元素。3 個 viewBox 定義一樣，只有 preserveAspectRatio 不同。 ！ 我們可以把之前那個線上的範例，使用 inspect 把 viewBox 都移除觀察原始的樣子，搭配第一篇學習到的觀念驗證一下。在這邊呢，3 個 svg 寬高都是 100% 也就是 viewport 跟最外層一致，viewBox 則是剛剛好圈出圖案的部分，最後我們使用 preserveAspectRatio 來調整 viewBox。 當然，在這個範例效果是讓小雞躲在蛋殼後面，隨著視窗縮小讓小雞出現。您也可以設計一些不一樣的效果。例如我們先在小一點的視窗下建立圖案，當視窗變大時才讓某些圖案顯示出來。 我們可以發揮更多的創意，根據不同的視窗大小顯示/隱藏元素，加上 media query 把新元素放到特定位置等等。唯一的限制就是您的想像力。 同時也注意到嵌入的 svg 寬高並不一定要跟外層的 svg 一樣。您完全可以自己設定寬高來決定顯示的範圍一切取決於我們想要的效果。 使用嵌入 svg 使元素自動調整尺寸（Fluid)除了在固定比例的情況下調整位置外，我們也能夠使用嵌入 svg 的方式讓特定元素自動調整尺寸或稱為流動式的元素。要完成這個效果我們只要內嵌的 svg 不要保持元素的比例即可。 舉例來說，如果我們只想要 SVG 中的某個元素可以自動調整尺寸，我們可以使用 svg 將它包起來，然後在 svg 設定 preserveAspectRatio=&quot;none&quot;，如此一來 svg 內部的元素就會自動填滿容器的寬，其他元素則保持一樣的行為。 12345678910&lt;svg&gt; &lt;!-- ... --&gt; &lt;svg viewBox=&quot;..&quot; preserveAspectRatio=&quot;none&quot;&gt; &lt;!-- this content will be fluid --&gt; &lt;/svg&gt; &lt;svg viewBox=&quot;..&quot; preserveAspectRatio=&quot;..&quot;&gt; &lt;!-- content positioned somewhere in the viewport --&gt; &lt;/svg&gt; &lt;!-- ... --&gt;&lt;/svg&gt; Jake Archibald 使用用內嵌 svg 的方式建立過一個簡單的範例。該範例是一個簡單的操作介面，裡面包含了幾個固定比例的元素分別被放在 svg 的四周，然後中間的部分則會跟著 svg 的寬調整尺寸。範例在此。您可以使用瀏覽器的開發者工具觀察席下這個範例的原始碼，看看裡面 viewBox 和 svg 的設定。 其他建立 viewport 的方式svg 元素並不是唯一可以在 SVG 中建立 viewport 的元素。下面的段落我們將要大略來來看看其他可以建立 viewport 的元素。 使用 &lt;use&gt; 和 &lt;symbol&gt; 建立 viewportsymbol 元素可以是用定義圖形樣板的，有點類似在 OOP 中 class 的感覺。既然有 class 那麼就會有負責實例化的 new。在 SVG 中 use 就類似 new 的功能。 每當我們使用 use 實例化 symbol 的時候好會建立一個新的 viewport。 透過 use 的 xlink:href 指定 symbol 就可以將實例化： 1234567&lt;svg&gt; &lt;symbol id=&quot;my-symbol&quot; viewBox=&quot;0 0 300 200&quot;&gt; &lt;!-- contents of the symbol --&gt; &lt;!-- this content is only rendered when `use`d --&gt; &lt;/symbol&gt; &lt;use xlink:href=&quot;#my-symbol&quot; x=&quot;?&quot; y=&quot;?&quot; width=&quot;?&quot; height=&quot;?&quot;&gt;&lt;/svg&gt; 上面程式碼的問號表示這幾個屬性可以設定或不設，如果沒設定預設是 0。 這裡我們觀察到當使用 use 搭配 symbol 時，我們用瀏覽器的開發者工具並不會看到 use 標籤中有 symbol 的內容。原因是因為 use 的內容被渲染在 shadow tree，您可以開啟檢視 shadow DOM 的功能就可以看到了。 使用 symbol 時，它的內容會被完整複製到 shadow tree 中，唯一的例外是 symbol 本身會被 svg 替換。這個產生的 svg 永遠都會有明確的寬高屬性。假如 use 中有設定 width 或 height 那麼這些屬性會被轉移到產生的 svg 上。如果沒有設定寬高，那麼 svg 的寬高會是 100%。 當 use 參考引用 symbol 時，symbol 的內容會完整的複製並在 shadow tree 中生成，symbol 則會換成 svg。 因為麼們在 DOM 中使用 svg，然後這個 svg 實際上是透過 use 被包在另一個 svg 中的，這種情況跟的嵌入 svg 並沒有什麼不同 - 嵌入的 svg 一樣會建立新的 viewport。 不過有一點要注意的地方是 viewBox 屬性要設在 &lt;symbol&gt; 元素上。 &lt;symbol&gt; 可以使用 viewBox 和 preserveAspectRatio 屬性，但 width 和 height 是下在 &lt;use&gt; 上。更多關於 svg 的元素與用法可以參考 理解 SVG 的建構，群組，引用功能 - ，，，。 所以現在我們有了新的 viewport ，這個 viewport 的座標和定位可以用 &lt;use&gt; 的 x，y，width，height 設定。viewBox，preserveAspectRatio 則設在 &lt;symbol&gt; 上。 Dirk Weber 也曾使用 symbol 搭配嵌入 svg 的方式寫過一個模仿 CSS border 行為的範例 引用 &lt;image&gt; 建立新的 viewportimage 元素的用途是將一個完整的檔案渲染到目前用戶座標系中給定的一個矩形中。一個 &lt;image&gt; 可以代表一個圖檔像是 png ， jpeg 或 MIME 類型為 image/svg+xml 的檔案。 當 image 元素引用的是一個 SVG 檔案時會因為檔案中的 svg 元素而建立一個暫時的 viewport。 1&lt;image xlink:href=&quot;graphic.svg&quot; x=&quot;?&quot; y=&quot;?&quot; width=&quot;?&quot; height=&quot;?&quot; preserveAspectRatio=&quot;?&quot; /&gt; &lt;image&gt; 元素也具有許多屬性可以使用，其中跟本文介紹有關的就是 x，y，width，height 和 preserveAspectRatio。 一般來說，SVG 檔案都有一個 &lt;svg&gt; 根節點；這個元素可能有設定寬高，座標，viewBox 或 preserveAspectRatio。 當 image 參考 SVG 圖檔時根 &lt;svg&gt; 上的 x，y，width，height 會被忽略。除非我們在 image 上使用 preserveAspectRatio 搭配 defer。 SVG 2 preserveAspectRatio 移除支援 defer 總結來說 SVG 檔案的根 元素 x，y，width，height，preserveAspectRatio 會由 image 上的屬性來設定。 範例 至於 viewBox 一樣維持從檔案的設定來，如果檔案沒有 viewBox 則會參考使用 image 的 width，height。觀察這個範例（viewBox=&quot;0 0 image-width image-height&quot;）。同時在沒有 viewBox 時，preserveAspectRatio 會被忽略。此時如果要對齊位置的效果只能用 image 的 x y。 假如我們有一個 &lt;image&gt; 引用 png 或 jpeg 然後 preserveAspectRatio=&quot;xMinYMin meet&quot;，這時圖片的比例會固定並確保圖片儘可能完整的填滿 viewport。這個 viewport 是靠 &lt;image&gt; 的 x，y，width，height 來定義的。如果 preserveAspectRatio=&quot;none&quot; 那麽圖片就會變形並完整填滿整個 viewport。 使用 &lt;iframe&gt; 建立 viewport使用 iframe 引用 SVG 檔案類似於使用 image，一樣可以使用 x，y，width，height 和 preserveAspectRatio。使用方式可以參考範例。 使用 &lt;foreignObject&gt; 建立 viewportforeignObject 元素可以建立新的 viewport 並在裡面渲染元素。foreignObject 主要是讓我們可以在 SVG 中加入非 SVG 的內容。通常 foreignObject 的內容會使用不同的命名空間。例如我們可以放入 HTML 到 SVG 裡。 同樣的 foreignObject 也可以使用 x，y，width，height。關於更詳細的資訊您可以參考下列連結 MDN 總結使用我們上面介紹的方式建立新的 viewport 和座標系主要是讓我們可以獨立控制 SVG 中的某個區塊，提供不同的設定。這篇文章的核心是讓我們了解關於嵌入 svg 如何提供更彈性的方式去協助我們創造更有意思的 SVG ，就如同上面提到的自適應 SVG ，自動調整尺寸，模仿 CSS border 等等。我們也可以應用在專案之中，甚至想出更多點子。 到此結束了理解 SVG 座標系統與 Transformation 系列文章，希望您能在這有些收穫。 重點 內嵌 svg 的 width, height, viewBox 等等的單位會依據外層 svg。 參考資源 Understanding SVG Coordinate Systems and Transformations (Part 3) — Establishing New Viewports 理解SVG坐标系统和变换： 建立新视窗 - 簡體中文 SVG 優化工具 SVG 優化工具 - svgo","link":"/2017/04/02/svg-coordinate-3/"},{"title":"使用 Passport 實作 Nodejs 應用程式驗證機制","text":"為應用程式實作穩固的驗證機制一直以來都是令人害怕的工作，當然在 Nodejs 的世界中也不例外。 在這篇文章，我們將要從零開始開發一個 Nodejs 的應用程式搭配一套熱門的驗證 Middleware - passport。passport 本身單純只關注驗證相關的部分，在官方文件中它這麼描述：這是一套簡單，可無縫整合於 Node 的 Middlewre。理解它本質是 Middleware 有助於後續的應用。 透過 Middleware 的機制，passport 將驗證所需的工作抽離以達到關注點分離的特點。同時這讓 passport 可以簡單的設定任何基於 express 的應用程式，就像我們設定其他 express middleware 一樣，例如 logging，body-parser，cookie-parser 等等。 這裡我們假設您對於 Nodejs 和 express 有些基本的認識，我們將專注在驗證機制的部分。 驗證機制/策略 (Authentication Strategies)passport 提供了 300 多種驗證機制讓我們選擇。我們可以使用本地端或遠端的資料庫來驗證用戶身分又或者使用 OAuth 來完成單一登入 (SSO) 的功能例如 Facebook，Twitter，Google 等等。我們可以從驗證機制列表中選擇 passport 有支援的 Node 模組。 小結來說：passport 是一個 Middleware，負責處理身分驗證，其將 驗證邏輯 抽離並稱其為 驗證策略 Stratety 例如：使用本地端的資料庫驗證是一種策略，Facebook 登入也是一種，我們可以依據需求使用。 先別擔心，我們只需要安裝我們需要的東西即可。每個驗證策略模組都是獨立的，當我們安裝 passport 時，預設不會幫我們安裝任何一種。 在這篇文章我們將會使用最常見的方式 - 本地端驗證策略搭配我們存在本地端 MongoDB 資料庫的帳號。為了要使用本地端驗證機制，我們需要安裝 passport-local。 OK，到這邊我們理解了， passport 需要搭配不同的驗證策略，這裡我們使用 passport-local。 在開始之前，我們還需要一個 express 應用程式。讓我們打開終端機，建立一個 express 應用程式。這個應用程式會有包含登入，註冊，首頁的功能。注意，我們將要使用 express 4 來實作。 設定應用程式如果您還沒安裝 express 產生器請先跟著官方文件安裝。然後我們執行下面的指令建立專案。 1$ express express-mongodb-passport 為了讓事情單純，不被混淆。我們要移除一些預設 generator 產生的但我們不需要的東西 - 刪除 routes/users.js 和 app.js 中有使用 routes/users.js 部分的程式碼。 安裝 passport 和相關模組在終端機上，切換到我們的專案目錄下安裝 passport，passport-local 和預設的模組。 12$ npm i$ npm i passport passport-local -S 因為我們要把使用者帳號等資訊存在 MongoDB 中。為了方便，這邊我們會使用 mongoose 這個 ODM 函式庫來協助我們操作 MongoDB。 一樣讓我們來安裝。 1$ npm i mongoose -S 現在，我們已經安裝好相依的函式庫了，讓我們執行 npm start 來看看程式是否可以正常運作。 1$ npm start 啟動 Server 之後我們用瀏覽器查看 http://localhost:3000 應該要能看到 express 預設的首頁。 雖然畫面上除了簡單的文字，什麼都沒有。沒關係！我們會接著完成 註冊，登入並使用 passport 驗證已註冊的使用者。 建立 mongoose 資料模型因為我們要使用 mongoose 來將使用者帳號資料等存在 MongoDB，要使用 ODM 第一步我們需要先定義資料模型。 在專案目錄下建立 models/user.js。 12345678910var mongoose = require('mongoose');var Schema = mongoose.Schema;var UserSchema = new Schema({ username: String, password: String, firstname: String, lastname: String});module.exports = mongoose.model('User', UserSchema); 基本上我們建立的這個 mongoose 資料模型是讓我們簡化 CRUD 的操作，參考文件中的範例程式碼就能明白為什麼我們需要這麼做。 設定 MongoDB如果您本機還沒安裝 MongoDB 請先遵循官方文件進行安裝。又或者可以使用雲端服務 MongoLab。 在我們安裝完成 MongoDB 並啟動之後我們就可以使用 mongodb://localhost:27017 來連線。如果您是使用雲端服務您應該會取得一個連線字串像是 mongodb://&lt;dbuser&gt;:&lt;dbpassword&gt;@&lt;service.url.com&gt;:27017/&lt;dbName&gt;。這個連線字串會決定我們操作的資料庫。 通常在專案中我們會將資料庫設定的部分獨立出來。在這裡我們建立一個 db.js 來負責資料庫相關的部分。 123module.exports = { connection: 'mongodb://&lt;dbuser&gt;:&lt;dbpassword&gt;@&lt;service.url.com&gt;:27017/&lt;dbName&gt;'} 如果您跟我一樣是使用本機的 MongoDB ，請記得啟動您的 MongoDB 並且設定如下 資料庫名稱即 &lt;dbName&gt; 的部分可以自行修改。 123module.exports = { connection: 'mongodb://localhost:27017/express-mongodb-passport-development'} 現在，我們已經完成前置作業，讓我們在 app.js 載人並使用 mongoose 12345var mongoose = require('mongoose');var config = require('./db');mongoose.connect(config.connection);// 在需要操作 db 的地方記得載入 Model 設定 passportpassport 本身只提供驗證機制，其他過程中如果需要功能像是 session 則是交給其他 Middleware。這邊我們則使用 express-session 來處理。 1$ npm i express-session -S 安裝完之後我們開始在 app.js 中設定 passport 1234567891011var passport = require('passport');var LocalStrategy = require('passport-local').Strategyvar session = require('express-session');app.use(session({ secret: 'your secret key', resave: false, saveUninitialized: false}));app.use(passport.initialize())app.use(passport.session()) 加上 session 的設定是因為我們希望用戶登入後的相關資料可以透過 session 被保留且一致，所以我們才安裝了 express-session 來幫我們處理這部分。LocalStrategy 並不強制使用 session，我們也可以透過參數來關閉，但如果沒有使用 session 每一次登入後資料不會自動保留需要自己處理。 概念：passport 可以 use 多個策略，接著只要在對應的路由使用 passport.authenticate('&lt;strategy-name&gt;') 即可。 序列化與反序列化 User 物件序列化指的是一個轉換資料格式的過程。為了支援登入的 session，passport 需要把從 session 取得的資料轉換成帳號資料即 User 的物件實例。因此後續的 request 請求將不會重複包含使用者的認證資訊。為了完成這個功能，passport 提供了兩個方法 serializeUser 和 deserializeUser。 123456789passport.serializeUser(function (user, done) { done(null, user._id);});passport.deserializeUser(function (id, done) { User.findById(id, function (err, user) { done(err, user); });}); 看完上面的程式碼，您應該理解了；passport 只把 user._id 存在 session，取回時在反序列化從資料庫找回 User 物件。 使用 passport 驗證機制登入機制現在，我們終於要為登入和註冊行為定義 passport 的驗證機制。在這個範例中每個驗證策略或者說驗證邏輯比較通順，它們都是一個 passport 的 Local Authentication Strategy 物件，並可以使用 passport.use() 來套用。這裡我們要在加上一個函式庫 connect-flash 來協助我們處理呈現動作結果的資訊。 1234567891011121314151617181920212223var User = require('./models/user.js);passport.use('login', new LocalStrategy({ passReqToCallback: true }, function (req, username, password, done) { User.findOne({ username: username }, function (err, user) { if (err) { return done(err) } if (!user) { return done(null, false, req.flash('info', 'User not found.')) } if (!isValidPassword(user, password)) { return done(null, false, req.flash('info', 'Invalid password')) } return done(null, user) }) })); passport.use() 的第一個參數是驗證機制的名稱，稍後這可以用來識別到底是哪一套機制。第二個參數是我們想建立的策略類型，這邊我們使用 LocalStrategy。值得注意的是預設 LocalStrategy 會在 Middleware 傳遞的過程中查找 req.body 和 req.query 的 username 和 password 來取得用戶認證的資訊，但我們也可以使用其他參數名稱。 其中 passReqToCallback 參數設定讓我們可以在後續 callback 中存取 req 物件。如果沒有的話，那麼預設 callback 參數會如下： 注意 * 註解 123456789new LocalStrategy({ // 使用其他參數名稱取得用戶認證的資訊 usernameField: 'email', passwordField: 'passwd', // 關閉 session session: false},function(username, password, done) { // * 沒有 passReqToCallback 的話，第一個參數就不是 req}) 詳細 passport-local 的參數與用法請參考說明 取得用戶帳密之後就是驗證的邏輯我們會在 callback 參數中處理這件事。下一步，我們將使用 mongoose 取得帳號資訊來驗證帳號是否正確。而在 LocalStrategy 的 callback 中最後一個參數 done 就是我們用來告訴 passport 模組登入結果的方法，假如登入失敗那麼第一個參數需要傳入錯誤訊息，第二個參數則是 false。登入成功的話，第一個參數則傳入 null，第二個則是任何為 真 的值，這個值會被加到 req 物件上以便我們後續使用。 接著，基於存放在 MongoDB 用戶資料的安全性考量，我們應該在儲存之前先將密碼加密。要完成這個需求我們需要使用加解密的函式庫。本文使用 bcrypt-nodejs，如果您有習慣的函式庫也可以使用。 1$ npm i bcrypt-nodejs -S 123var isValidPassword = function (user, password) { return bcrypt.compareSync(password, user.password)} 讓我們先來看看目前完成的 app.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100var express = require('express');var path = require('path');var favicon = require('serve-favicon');var logger = require('morgan');var cookieParser = require('cookie-parser');var bodyParser = require('body-parser');var mongoose = require('mongoose');var passport = require('passport');var LocalStrategy = require('passport-local').Strategy;var session = require('express-session');var flash = require('connect-flash');var bcrypt = require('bcrypt-nodejs');// DBvar config = require('./db');mongoose.connect(config.connection);passport.serializeUser(function (user, done) { done(null, user._id);});passport.deserializeUser(function (id, done) { User.findById(id, function (err, user) { done(err, user); });});passport.use('login', new LocalStrategy({ passReqToCallback: true }, function (req, username, password, done) { User.findOne({ username: username }, function (err, user) { if (err) { return done(err) } if (!user) { return done(null, false, req.flash('info', 'User not found.')) } var isValidPassword = function (user, password) { return bcrypt.compareSync(password, user.password) } if (!isValidPassword(user, password)) { return done(null, false, req.flash('info', 'Invalid password')) } return done(null, user) }) }));var index = require('./routes/index');var app = express();// view engine setupapp.set('views', path.join(__dirname, 'views'));app.set('view engine', 'jade');// uncomment after placing your favicon in /public//app.use(favicon(path.join(__dirname, 'public', 'favicon.ico')));app.use(logger('dev'));app.use(bodyParser.json());app.use(bodyParser.urlencoded({ extended: false }));app.use(cookieParser());app.use(express.static(path.join(__dirname, 'public')));app.use(session({ secret: 'your secret key', resave: false, saveUninitialized: false}));app.use(passport.initialize());app.use(passport.session());app.use(flash());app.use('/', index);// catch 404 and forward to error handlerapp.use(function(req, res, next) { var err = new Error('Not Found'); err.status = 404; next(err);});// error handlerapp.use(function(err, req, res, next) { // set locals, only providing error in development res.locals.message = err.message; res.locals.error = req.app.get('env') === 'development' ? err : {}; // render the error page res.status(err.status || 500); res.render('error');});module.exports = app; 註冊機制我們定義好登入部分的機制了，接著我們要定義下一個機制來處理新的使用者註冊帳號的部分 123456789101112131415161718192021222324252627282930313233passport.use('signup', new LocalStrategy({ passReqToCallback: true}, function (req, username, password, done) { var findOrCreateUser = function () { User.findOne({ username: username }, function (err, user) { if (err) { return done(err); } if (user) { return done(null, false, req.flash('info', 'User already exists')); } else { var newUser = new User(); newUser.username = username; newUser.password = bcrypt.hashSync(password, bcrypt.genSaltSync(10), null); newUser.email = req.params.email; newUser.firstname = req.params.firstname; newUser.lastname = req.params.lastname; newUser.save(function (err, user) { if (err) { throw err; } return done(null, user); }); } }); }; process.nextTick(findOrCreateUser)})); 再一次我們使用 mongoose 來查詢看看是否有使用者已經註冊了一樣的 username 。如果沒有那麼我們就建立新的帳號，否則就返回一個錯誤訊息。 建立路由讓我們先來看看這個程式的流程圖 完成登入和註冊的邏輯定義之後，我們要來撰寫路由。預設 express generator 將路由抽離成一個個模組，我們已經刪除了 routes/users.js。為了讓 routes/idnex.js 裡的路由能夠使用剛剛上面定義在 app.js 的 passport 物件，我們將改寫一下 routes/index.js 如下 1234567891011121314151617181920212223242526var express = require('express');var router = express.Router();module.exports = function (passport) { router.get('/', function (req, res, next) { res.render('index', { message: req.flash('info') }); }) router.post('/signin', passport.authenticate('login', { successRedirect: '/home', failureRedirect: '/', failureFlash: true })); router.get('/signup', function (req, res, next) { res.render('signup', { message: req.flash('info') }); }); router.post('/signup', passport.authenticate('signup', { successRedirect: '/home', failureRedirect: '/signup', failureFlash: true })); return router;} 上面程式碼中最重要的部分就是：當 HTTP 發出 POST 的請求給 login 和 signup 時分別使用 passport.authenticate() 搭配對應的機制(login，signup)來處理。 注意到路由並不需要強制跟驗證機制模組的名稱一樣。 假如您還需要在驗證過程中加入其他處理，則可使用下面這種寫法 1234567891011121314151617181920router.post('/signin', function (req, res, next) { passport.authenticate('login', function (err, user, info) { if (err) { // handle youself } if (!user) { // handle youself } req.login(user, function (err) { if (err) { return next(err) } req.flash('info', 'Sign in successfully') return res.redirect('/') }) })(req, res, next)}) 樣板接著我們需要調整 views 的部分，我們總共需要註冊 signup，登入 index，後續需要登入驗證的頁面 home，以及調整我們的 layout。 layout.jade index.jade 登入頁 signup.jade 註冊頁 home.jade layout.jade1234567891011doctype htmlhtml head title= title link(rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/css/bootstrap.min.css&quot; integrity=&quot;sha384-rwoIResjU2yc3z8GV/NPeZWAv56rSmLldC3R/AZzGRnGxQQKnKkoFVhFQhNUwEyJ&quot; crossorigin=&quot;anonymous&quot;) script(src=&quot;https://code.jquery.com/jquery-3.1.1.slim.min.js&quot; integrity=&quot;sha384-A7FZj7v+d/sdmMqp/nOQwliLvUsJfDHW+k9Omg/a/EheAdgtzNs3hpfag6Ed950n&quot; crossorigin=&quot;anonymous&quot;) script(src=&quot;https://cdnjs.cloudflare.com/ajax/libs/tether/1.4.0/js/tether.min.js&quot; integrity=&quot;sha384-DztdAPBWPRXSA/3eYEEUWrWCy7G5KFbe8fFjk5JAIxUYHKkDx6Qin1DkWx51bBrb&quot; crossorigin=&quot;anonymous&quot;) script(src=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/js/bootstrap.min.js&quot; integrity=&quot;sha384-vBWWzlZJ8ea9aCX4pEW3rVHjgjt7zpkNpZk+02D9phzyeVkE+jo0ieGizqPLForn&quot; crossorigin=&quot;anonymous&quot;) link(rel='stylesheet', href='/stylesheets/style.css') body block content index.jade12345678910111213141516extends layoutblock content div(class=&quot;container&quot;) div(class=&quot;col-md-4 offset-md-4&quot;) h1(class=&quot;text-center login-title&quot;) Sign In div(class=&quot;card&quot;) div(class=&quot;card-blcok&quot;) form(action=&quot;/signin&quot; method=&quot;post&quot;) input(type=&quot;text&quot; name=&quot;username&quot; class=&quot;form-control&quot; placeholder=&quot;Email&quot; required=&quot;true&quot; autofocus) input(type=&quot;password&quot; name=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot; required=&quot;true&quot;) button(class=&quot;btn btn-primary btn-block&quot; type=&quot;submit&quot;) Sign In span(class=&quot;clearfix&quot;) if message.length div(id=&quot;message&quot;) div(class=&quot;alert alert-danger text-center&quot;) #{message} signup.jade12345678910111213141516extends layoutblock content div(class=&quot;container&quot;) div(class=&quot;col-md-4 offset-md-4&quot;) h1(class=&quot;text-center login-title&quot;) Sign Up div(class=&quot;card&quot;) div(class=&quot;card-blcok&quot;) form(action=&quot;/signup&quot; method=&quot;post&quot;) input(type=&quot;text&quot; name=&quot;username&quot; class=&quot;form-control&quot; placeholder=&quot;Email&quot; required=&quot;true&quot; autofocus) input(type=&quot;password&quot; name=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot; required=&quot;true&quot;) button(class=&quot;btn btn-primary btn-block&quot; type=&quot;submit&quot;) Sign In span(class=&quot;clearfix&quot;) if message.length div(id=&quot;message&quot;) div(class=&quot;alert alert-danger text-center&quot;) #{message} home.jade1234567extends layoutblock content div(class=&quot;container&quot;) div(class=&quot;row&quot;) div(class=&quot;col-12&quot;) p(class=&quot;alert alert-primary&quot;) This is page will protected by passport. 基於商標因素 jade 樣板引擎已改名為 pug，雖然目前仍然支援但官方已警告 deprecated 建議更換為 pug。 登出passport 作爲一個 Middleware 它是具備加入屬性和方法到 req 和 res 物件的能力的。為了方便使用，它加了 req.logout() 這個方法讓我們可以將使用者存在 session 的資料作廢。 1234router.get('/signout', function () { req.logout() res.redirect('/')}) 驗證存取權限passport 也賦予我們控制存取權限的能力，用來保護不能匿名存取的路由。從這個例子來說就是；當使用者沒有登入的情況下是無法存取 http://localhost:3000/home 我們會將他們導向登入或其他公開的頁面。 12345678910function authenticated (req, res, next) { if (req.isAuthenticated()) { return next() } res.redirect('/)}router.get('/home', authenticated, function (req, res, next) { res.render('home', { user: req.user })}) 結論歸納來說，passport 這個 Middleware 會在整個 request 的過程中幫我們處理驗證流程，透過使用 策略 決定是否登入成功。在本例子中後續 Middleware 的 req 物件中我們就可以取得 req.isAuthenticated() 和 req.user。由於驗證是否登入可能會有很多路由需要使用，故上面我們將這部分抽成一個 Middleware function 方便後續使用。 另外關於 Node.js 世界的驗證套件 ， passport 並不是這個領域唯一的函式庫，還有像是 everyauth 等的函式庫。不過在社群支援度，模組化等部分的確相對優秀，這也是為什麼我們選擇 passport。 關於詳細的比較您可以參考everyauth vs passport。 參考資源 Authenticating Node.js Applications With Passport Node.js 身份認證：Passport 入門","link":"/2017/04/11/express-passport/"},{"title":"Heroku 優化 Node 應用程式 - 併發","text":"Node 對於擴展到不同規格的主機環境上其能力有限。首先是它是單執行緒，所以預設它不會自動使用額外的 CPU 核心。再者由於它基於 v8 引擎所以有記憶體上的限制概略是 1.5GB，所以也無法自動使用額外的記憶體。 因此 Nodejs 的應用程式需要多個進程來最大化可用的資源。這個過程我們稱為叢集，我們可以透過使用 Nodejs Cluster API 來完成這個功能。我們可以直接在程式中使用 API 又或者使用基於這些 API 抽象化的函式庫。這裡我們將使用 throng。 使用叢集的方式，應用程式可以善加利用各種 dyno 的資源使效能得到提升。Heroku 的 Nodejs buildpack 也提供一些環境變數來協助我們。 讓應用程式支援併發我們建議所有的應用程式支援叢集。即使您不認為到您的程式需要執行超過一個進程，讓您的程式提供更大的彈性和控制權以利未來作調整。您可以參考下面的範例。 首先，我們需要知道我們有多少我們的 dyno 有多少 process 可以使用 1var WORKERS = process.env.WEB_CONCURRENCY || 1 如果您想理解關於 process 和 thred 的關係可以參考进程与线程的一个简单解释。 12# 補充：查詢 Heroku dyno 的 CPU 資訊$ heroku run grep -c processor /proc/cpuinfo 接著，我們定義一個 start function 這將是我們每個 process 開始執行時的進入點。 123function start () {} 最後我們使用 throng 來使我們的程式支援叢集。我們設定 throng 的 lifetime 參數為 Infinity。假如一個 worker 死掉了它會自己再爬起來。這意味著我們永遠有 WORKERS 在執行。 1234throng({ workers: WORKERS, lifetime: Infinty}, start) 補充 - 使用 pm2 支援 Cluster如果您已經完成了您的程式，或者說您想讓支援叢集的方式再彈性一點，我們可以使用 pm2。 調整 package.json以 Express 為例： 1234&quot;scripts&quot;: { &quot;preinstall&quot;: &quot;npm i -g pm2 &amp;&amp; pm2 install pm2-logrotate&quot;, &quot;start&quot;: &quot;pm2 start --attach -i 0 ./bin/www &amp;&amp; pm2 logs all&quot;} 驗證啟用叢集1234567891011121314$ heroku ps:execInitializing feature... doneAdding the Heroku Exec buildpack to xeatsRun the following commands to redeploy your app, then Heroku Exec will be ready to use: git commit -m &quot;Heroku Exec initialization&quot; --allow-empty git push heroku master$ git commit -m &quot;Heroku Exec initialization&quot; --allow-empty$ git push heroku master$ pm2 ls# 如果要驗證平常是只啟用一個 Ap 可以把 `-i 0` 參數移除 Heroku exec 範例 - 完整示範 Express 支援叢集12345678910111213141516171819$ express demo$ cd demo$ npm i# 編輯 package.json$ git init$ git add .$ git ci -m 'Initial commit'$ heroku login$ heroku create$ git push heroku master$ heroku ps:exec$ pm2 ls$ grep -c processor /proc/cpuinfo # cpu 資訊# 壓力測試(osx)$ brew install siege$ siege -c100 -t1M &lt;your_url&gt; 參考資源 Heroku 官方優化文件 pm2 Heroku exec Introducing Exec (beta) - Connect to a dyno via SSH 更多 pm2 設定 pm2 設定檔方式","link":"/2017/05/25/optimizing-node-concurrency/"},{"title":"RabbitMQ 學習筆記 - 安裝、入門、Work Queues","text":"本篇是關於 RabbitMQ 的入門學習筆記，內容從安裝到學習使用 Work Queue 的方式。能夠引導您快速入門。大部分的資料來自於官方的學習文件佐以實作時相關問題的資料補充。 OS X 使用 Homebrew 安裝 RabbitMQ在開始安裝之前請先確保您的 brew 是最新版本： 1$ brew update 接著安裝 RabbitMQ 1$ brew install rabbitmq 執行 RabbitMQ ServerRabbitMQ server 的執行與操作指令會被安裝在 /usr/local/sbin。這個路徑並不會自動被加到我們電腦的 PATH 所以我們需要在 .bash_profile 或 .profile 加入 PATH=$PATH:/usr/local/sbin。 啟動 server 的指令為 rabbitmq-server。所有指令只需要使用者帳號的權限，不需執行 sudo。 如果您有使用 brew services 的話可以直接執行 brew services start rabbitmq。 預設使用者仲介（Broker）預設會建立一個 guest 使用者，密碼是 guest。沒有設定的客戶端一般會直接使用這組帳密。這組帳密只有當 Broker 在本機時可以使用，所以我們在從其他主機連線之前我們需要做些設定。所謂的 Broker 就是幫我們傳遞訊息的角色。 可以在存取設定文件查詢到相關的資訊，如建立帳號，刪除 guest，甚至讓遠端可以存取 guest。 OSX 設定系統限制RabbitMQ 安裝程式預設的工作負載也許需要調整系統限制和核心參數，使其可以處理大量的併發連線和佇列（Queue)。最主要需要調整的設定就是開檔的最大數量，也就是 ulimit -n。大部分的作業系統預設值都不夠訊息仲介（Message Broker）使用，在一些 Linux 系統預設是 1024。我們建議對於線上服務來說最少 file descriptors 是 65536 給 rabbitmq 使用，4096 應該可以滿足大部分開發時期使用。 通常有兩個地方限制關於開檔數：系統核心允許的最大開檔限制（kern.maxfilesperproc）和每個使用者的限制（ulimit -n），前者的設定會高於後者，也就是說 kern.maxfilesperproc 在有設定的情況下 ulimit 不可以超過它。 調整每個使用者限制的部分有幾個方式： 在開啟 RabbitMQ 之前執行 ulimit -Sn 4096 （後續更新為該值，重開機或開新 shell 會回到預設） 修改 rabbitmq-env.conf 使其在 server 開啟之前執行 ulimit 透過 launchctl limit /etc/launchd.conf 調整最大開檔數量 注意：修改的設定不會影響已經執行的程式，調整 launchctl limit 需重開機。 更多關於使用 sysctl 設定 kern.maxfilesperproc 請參考 Apple 官方文件 sysctl(8)。 macOS Sierra 不作任何設定下預設 ulimit file descriptors 上限可調至 10240(unlimited) 使用者執行 rabbitmq-server 會使用 ulimit 的設定，但注意：如果您使用 brew services 則會採用 launchctl limit 即系統的設定。如果加入 limit.maxfiles.plist 調整系統限制，ulimit 最高不可超過該設定。為了讓後續開發時直接使用 brew services 我們建議直接調整 launchctl limit。另外在設定 soft limit 和 hard limit 時，如果 hard limit 小於 soft limit 那麼 launchctl limit 預設會變成 maxfiles 256 unlimited。 macOS Sierra 調整 launchctl limit新增 /Library/LaunchDaemons/limit.maxfiles.plist，並重新開機。 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt; &lt;dict&gt; &lt;key&gt;Label&lt;/key&gt; &lt;string&gt;limit.maxfiles&lt;/string&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;launchctl&lt;/string&gt; &lt;string&gt;limit&lt;/string&gt; &lt;string&gt;maxfiles&lt;/string&gt; &lt;string&gt;65636&lt;/string&gt; &lt;string&gt;65636&lt;/string&gt; &lt;/array&gt; &lt;key&gt;RunAtLoad&lt;/key&gt; &lt;true/&gt; &lt;key&gt;ServiceIPC&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt;&lt;/plist&gt; 查詢限制我們一樣有許多方式來驗證 RabbitMQ 當前的限制是否如我們所設定。最簡單的方式就是透過RabbitMQ management UI。 12$ rabbitmq-plugins enable rabbitmq_management# 瀏覽 http://localhost:15672 再來就是使用指令的方式 1$ rabbitmqctl status 兩者的資訊會是一致的。對於 macOS 的使用者則可以使用下列指令觀察使用者的限制。 1$ launchctl limit 處理 node with name rabbit already running1234567$ rabbitmqctl stop# OR$ ps aux | grep epmd$ ps aux | grep erl$ kill -9 [pid] 入門這一系列筆記主要是閱讀官方文件的記錄，內容涵蓋如何使用 RabbitMQ 建立基本的訊息，上面我們已經完成安裝了，接著我們就會使用 Javascript 系列來實作。官方教學完整的提供各種語言的教學，如果您需要其他的語言請參考官方文件。 RabbitMQ 是個訊息仲介（Message Broker）上面第一次提到時，您恐怕是一頭霧水。簡單說就是它協助我們傳遞交換訊息。您可以把它想成是郵局，當我們把信件丟到郵筒時，我們幾乎可以確定郵差先生最終一定會幫我們把信件送給收件者。以這個比喻來說 RabbitMQ 就是郵筒、郵局、郵差的集合體。 唯一的差別是 RabbitMQ 不會真的寄出紙本，它使用二進制的文件類型來傳遞資料（Binary blobs）我們稱為 - Message。 當然 RabbitMQ 也有些術語是我們在使用之前最好先了解的。 Producing 就是傳送訊息。一個發送訊息的程式也被稱為 producer queue 佇列在 RabbitMQ 裡其實就是郵筒的意思。雖然訊息在 RabbitMQ 和我們的應用程式之間傳遞但它們只會被存放在 queue。queue 本身只會被主機的記憶體和硬碟所限制，本質上就是一個很大的訊息緩衝區。可以有很多個 producer 發送，但它們都會傳到同一個 queue 並且可以有多個 consumer 可以從 queue 取得資料。 Consuming 概略來說就是接收的意思。consumer 大致上說來就是一個等待接收訊息的程式。 現在我們介紹了產生者（producer）、接收者（consumer）、和仲介（broker）。它們並不需要存在同一台主機上，確實在大多的程式中也不是都放在一個機器上。 Hello, World使用 amqp.node在這個段落我們將會用 javascript 撰寫兩隻很簡單的程式；producer 用來傳送訊息，consumer 用來接收訊息。這裡我們會略過一些 amqp.node API 的細節，專注在最基礎的地方 - 傳遞與接收 Hello World 訊息。 下圖的 p 代表我們的 producer 而 c 則是 consumer。中間的方塊則是我們的 queue 一個訊息的緩衝區，RabbitMQ 會為我們的 consumer 維護這些資料。 amqp.node 函式庫RabbitMQ 支援多種協定。本教學使用 AMQP 0-9-1，這是一個通用的訊息傳遞協定。同時 RabbitMQ 也支援了許多不同語言的 client 函式庫。這裡的 amqp.node client 就是 Nodejs。首先，我們使用 npm 來安裝 1$ npm install amqplib 安裝完成之後，我們可以來開始寫些程式 傳送 現在我們有個傳送者叫 send.js ，訊息的接收者為 receive.js。傳送者的任務就是連線到 RabbitMQ 然後送出訊息。在 send.js 中，第一步我們需要載入 amqp 函式庫 1const amqp = require('amqplib/callback_api) 接著連線到 RabbitMQ 的伺服器 1amqp.connect('amqp://localhost', function (err, conn) {}) 然後建立頻道，大部分 API 會在頻道內完成其任務。 12345amqp.connect('amqp://localhost', function (err, conn) { conn.createChannel(function (err, ch) { })}) 為了傳送訊息，我們需要建立一個 queue 然後把資料傳到 queue 裡面。 123456789amqp.connect('amqp://localhost', function (err, conn) { conn.createChannel(function (err, ch) { var q = 'hello' ch.assertQueue(q, {durable: false}) ch.sendToQueue(q, new Buffer('Hello, World!')) console.log('Sent Hello, World!') })}) 宣告 queue 的動作是冪等的，意思是只會在當 queue 不存在時才會建立，不然就使用同一個。最後，我們需要關閉連線： 1234setTimeout(function () { conn.close() process.exit(0)}, 500) 傳送失敗如果您是第一次使用 RabbitMQ 而且上面的範例您沒有看到 Sent... 訊息，可能的原因包含沒有足夠的硬碟空間給 broker，預設 RabbitMQ broker 需要 200 MB 的空間。檢查 broker 的 log 檔案，OSX 的話預設在 /usr/local/var/log/rabbitmq。我們可以先搜尋 rabbitmq-server 的目錄尋找 rabbit-defaults 來查看預設的設定。 12345$ which rabbitmq-server# /usr/local/sbin$ cat /usr/local/sbin/rabbitmq-defaults# 預設 logs : /usr/local/var/log/rabbitmq# 預設設定檔 : /usr/local/etc/rabbitmq 要減少關於硬碟限制的資訊請參考官方文件，相關設定檔的位置則參考。 接收訊息我們完成了我們的傳送程式。而我們的接收者則需要從 RabbitMQ 把訊息取出。不像發送者那麼只是單純發送一道訊息。接收程式需要持續的監聽是否有訊息。 第一步跟發送程式一樣我們需要載入函式庫 1let amqp = require('amqplib/callback_api') 一樣需要建立連線和頻道，然後宣告 queue ，我們會從這個 queue 中取出訊息。 123456amqp.connect('amqp://localhost', function (err, conn) { conn.createChannel(function (err, ch) { let q = 'hello' ch.assertQueue(q, {durable: false}) })}) 注意到我們也同樣在這邊建立了 queue。因為我們可能在發動傳送訊息程式之前就啟動接收訊息程式，於是我們需要確保 queue 在我們嘗試取資料前就存在。接著我們繼續來探討如何讓伺服器從 queue 派送訊息給我們。由於推送訊息的行為是非同步的，我們需要提供一個 callback ，當 RabbitMQ 推送訊息的時候我們就可以執行。這就是 Channel.consume 作的事情。 1234console.log(&quot;Wating for message in %s. To exit press CTRL+C&quot;, q)ch.consume(q, function (msg) { console.log(&quot;Received %s&quot;, msg.content.toString())}, {noAck: true}) 小結現在我們可以執行兩個 scripts 了，在終端機裡我們先執行 send.js 接著執行 receive.js。接收程式會列出收到的訊息。 很多時候我們可能想知道 RabbitMQ 裡面有些什麼 queue 和訊息 1$ rabbitmqctl list_queues 工作佇列（Work Queues）在上面的教學中我們撰寫了兩隻程式利用具名佇列（named queue）發送與接收訊息。在這個段落我們將要建立 Work Queue 常用來派發耗時的任務到多個程序去處理。 Work Queues （Task Queues）的核心想法是為了要避免耗時的任務直接接在我們的操作流程上導致我們需要等待其完成才能到下一步。取而代之的是我們把這個耗時的任務加到排程之中讓它可以在稍後完成。我們需要將任務封裝當成一個訊息，然後把它送到 queue。接著工作程序會在背後慢慢的取出任務完成。當我們執行多個工作程序時，它們會一起消化 queues 裡面的任務。這樣的概念在網路應用程式中特別實用。 準備在第一部分的教學中我們送了 Hello, World! 的訊息。現在我們將要傳送代表複雜任務的字串。這個教學中，我們並沒有事務上常見的例子像是修改圖片尺寸或是產生 pdf，所以讓我們使用 setTimeout 假裝這個任務非常耗費效能與時間，將字串中的點 . 模擬為複製度，每一個點假裝需要一秒工作時間。例如：Hello... 會需要 3 秒。 接下來讓我們來稍微修改之前的 send.js 範例，為了讓我們使用指令發送任意的訊息，這隻程式會把我們的任務加到 work queue 中，現在我們就叫它 new_task.js 12345let q = 'task_queue'let msg = process.argv.slice(2).join(' ') || 'Hello World!'ch.assertQueue(q, {durable: true})ch.sendToQueue(q, new Buffer(msg), {persistent: true})console.log('Sent %s', msg) 舊版的 receive.js 也需要稍微修改。我們需要模擬耗時任務的部分。它的任務是從 queue 取出訊息然後執行任務，我們命名該檔案為 worker.js。 1234567ch.consume(q, function (msg) { var secs = msg.content.toString().split('.').length - 1 console.log('Received %s', msg.content.toString()) setTimeout(function () { console.log('Task Done') }, secs * 1000)}, noAck: true) 循環制派發的任務使用 Task Queue 的好處之一就是可以輕鬆的擴展平行的工作程序。假設我們累積了大量的任務需要執行，我們可以增加工作程序 workers 來協助我們。首先，我們試試同時運行 2 個 worker.js 它們兩者都會取得 queue 的訊息，但具體是如何呢？ 現在我們有 3 個 console，兩個執行 worker.js 這兩個 console 讓我們先分別稱為 C1, C2。在剩下的 console 我們要用來傳送任務 12345$ node ./new_task.js First maessage.$ node ./new_task.js Second message..$ node ./new_task.js Third message...$ node ./new_task.js Fourth message....$ node ./new_task.js Fifth message..... 接著我們來看看我們的 workers（C1，C2） 123456789## C1$ node worker.js# Wating for message in task_queue. To exit press CTRL+C# Received First maessage.# First maessage. Task Done# Received Third message...# Received Fifth message.....# Third message... Task Done# Fifth message..... Task Done 1234567## C2$ node worker.js# Wating for message in task_queue. To exit press CTRL+C# Received Second message..# Received Fourth message....# Second message.. Task Done# Fourth message.... Task Done 預設，RabbitMQ 會把訊息依序傳給下一個接收者，每個接收者會平均收到差不多訊息。這種發送訊息的方式稱為循環制。 確認訊息執行任務可能會需要一點時間。您可能會想知道假如接收程式收到訊息並開始一個耗時的任務但最後並未完成會如何？依據我們現在的程式碼，一旦 RabbitMQ 派發了訊息，它就會立即把訊息從記憶體移除。這個情況下如果我們停止了工作程序（Worker) 我們將會遺失正在處理的訊息。 但我們並不希望在工作程序發生異常或停止時遺失任何訊息，我們希望該任務可以派發給其他工作程序。為了確保訊息不會遺失 RabbitMQ 支援了確認訊息的機制 - 一個 ack(nowledgement) 確認通知需要從接收程式這邊送回 RabbitMQ 告訴 RabbitMQ 該訊息已被接受和處理完成了，接著 RabbitMQ 才會釋放和刪除該訊息。一旦接收程式因為任何原因中斷例如：RabbitMQ 頻道關閉，連線中斷，TCP 連線失敗等等導致沒有回傳 ack，RabbitMQ 就知道該訊息還沒處理完成，就會把它再放回 queue 裡面，假如當下還有其他工作程序在運行，那 RabbitMQ 會立刻將這個訊息派給其他人，透過這個機制我們可以確保訊息不會遺失。 RabbitMQ 不存在逾時的狀況，即使處理需要非常長的時間，假如接收程式異常或斷線， RabbitMQ 會重新發送訊息。在上面的範例中訊息確認通知是被關閉的，現在我們要使用 {noAck: false}（您也可以移除參數）和 ch.ack(msg) 在適當時機發送通知。{noAck: &lt;Boolean&gt;} 設定算是一個保護機制的參數，不設定時我們可以隨時使用 ch.ack 一旦我們設定為 {noAck: true} 如果又呼叫 ch.ack 則會產生例外。 123456789ch.consume(q, function (msg) { let secs = msg.content.toString().split('.').length - 1 console.log('Received %s', msg.content.toString()) setTimeout(function () { console.log('%s Done', msg.content.toString()) ch.ack(msg) }, secs * 1000)}, {noAck: false}) 使用這段程式碼我們可以確保即使訊息在處理階段我們用 CTRL+C 中斷工作程序，訊息也不遺失。 忘記發送確認通知忘記 ack 是個很常見的錯誤，但後果卻很嚴重。當目前處理的工作程序斷線時，該訊息會再次被派發，這可能導致我們重複執行任務，且當我們無法釋放 unacked 的訊息時，RabbitMQ 將會使用越來越多的記憶體。為了 debug 這類問題，您可以使用 rabbitmqctl 指令來列出 messages_unacknowledged。 1$ rabbitmqctl list_queues name messages_ready messages_unacknowledged 訊息的持久性我們已經學會如何確保當工作程序（接收程式)異常時訊息依然存在的處理機制，但這些任務訊息在 RabbitMQ Server 停止的時候依然會消失。當 RabbitMQ 停止或異常崩潰時會失去我們傳入的 queue 和訊息，除非我們告訴 RabbitMQ 要保留這些資訊。兩件事可以確保我們的訊息不會遺失，我們需要註記 queue 和 message 為持久性的（Durable)。 第一步，我們可以通過宣告參數告訴 RabbitMQ 不要弄丟我們的 queue。 1ch.assertQueue('hello', {durable: true}) 雖然這個設定是正確的，但現在無法作用，因為我們之前已經定義了一個 queue 叫 hello ，且其沒有開啟 durable 特性。RabbitMQ 不允許我們建立相同名稱的 queue 卻使用不同的設定。最簡單的解決辦法就是換個名稱。 1ch.assertQueue('task_queue', {durable: true}) 注意要修改這個參數，發送程式和接收程式都必須要修改。到這邊我們確保了 task_queue 這個 queue 不會因為 server 停止或重啟而消失，現在我們要來處理訊息的部分，透過在 Channel.sendToQueue 加入 persistent 參數可讓訊息持續存在。 關於訊息的持久性讓訊息具備持久特性並不能完全保證訊息不會遺失，雖然我們已經告訴 RabbitMQ 要將訊息存在硬碟上，但仍可能在非常短的時間之間遺失訊息，即 RabbitMQ 已接收訊息但還沒寫入硬碟，RabbitMQ 並非對所有訊息的操作都使用 fsync （確保所有對文件的修改都同步到硬碟上）- 它可能只是先被存在暫存區並不是寫入硬碟。也就是說訊息的持久性並不能給我們完全保證，但這對與簡單的佇列任務需求已經足夠了，如果您需要更加完整的確認機制可以使用發佈/傳送確認機制 均等派發您可能已經注意到派發的機制並不是完全如我們所預期的，舉例來說有兩個 workder，奇數訊息任務比較吃效能，偶數訊息比較輕鬆，其中一個 worker 會一直在忙碌狀態，另一個幾乎沒有任何工作。其實，RabbitMQ 並不知道哪個 worker 的任務比較吃重，只是平均的分配任務。 會這樣是因為 RabbitMQ 只是發送訊息到 queue，它沒有為了接收方去判斷 unacknowledged message 未處理訊息的數量，就只是盲目的派發訊息。 為了克服這個問題我們可以使用 prefetch 方法並賦值為 1。這會告訴 RabbitMQ 一次不要給某個 worker 超過 1 個訊息，換句話說就是在 worker 處理完任務之前不要再送新任務給它。於是 RabbitMQ 就會把任務派發給其他 worker。 1ch.prefetch(1) 關於 queue 的容量如果所有的工作程序（workers）都在忙碌，則訊息會被放在 queue 直到 queue 被塞滿。我們可以增加更多 workers 或提供其他解決方式。 小結最後我們這一節的範例程式如下 123456789101112131415161718// new_task.jsconst amqp = require('amqplib/callback_api)amqp.connect('amqp://localhost', function (err, conn) { conn.createChannel(function (err, ch) { let q = 'task_queue' let msg = process.argv.slice(2).join(' ') || 'Hello World!' ch.assertQueue(q, {durable: true}) ch.sendToQueue(q, new Buffer(msg), { persistent: true }) console.log('Sent %s', msg) setTimeout(function () { conn.close() process.exit(0) }, 500) })}) 123456789101112131415161718192021// worker.jsconst amqp = require('amqplib/callback_api')amqp.connect('amqp://localhost', function (err, conn) { conn.createChannel(function (err, ch) { let q = 'task_queue' ch.assertQueue(q, {durable: true}) ch.prefetch(1) console.log('Waiting for messages in %s. To exit press CTRL+C', q) ch.consume(q, function (msg) { let secs = msg.content.toString().split('.').length - 1 console.log('Received %s', msg.content.toString()) setTimeout(function () { console.log('%s Done', msg.content.toString()) ch.ack(msg) }, secs * 1000) }, {noAck: false}) })}) durable 參數是訊息被存放在硬碟，即使 RabbitMQ 重啟資料也不會遺失。 訊息確認 ack 的部分確保 worker 正確處理完資料。 prefetch 讓工作程序可以平均分配任務。 這幾個機制讓我們可以確保任務佇列裡的任務被完成。如果您還想知道更多關於 Channel 的方法和訊息的屬性可以參考amqplib 文件。 參考 各版本 OSX 調整 kern.maxfilesperproc Open File limit RabbitMQ 官方","link":"/2017/06/08/rabbitmq-notes/"},{"title":"電子發票系統安裝","text":"前言 支援電子發票，營業人必須使用 Turnkey Client 連線工具 來執行發票開立、發票作廢、發票註銷、折讓開立、折讓作廢等（傳送/接收發票資料檔案）。 本篇為 Turnkey Client on Ubuntu 的安裝筆記。 使用環境需求系統 Window 或 Linux RAM 2GG+ HD 80G+ CPU 2+ core Linux Ubuntu 10.4+/Redhat ES 5.4 (須含 xwindow) Windows WinXP/Win7/Win2003 Server+ 資料庫 PostgreSQL 8.0+ Oracle 10+ MySQL 5 MS SQL Server 2003+ JDK僅支援 JSK 1.6.x 系統安裝安裝 Ubuntu 16.0.4 Server選擇系統語系，使用英文即可。 開始安裝 選擇時區，如果有使用排程要特別注意 設定鍵盤排列類型 是否偵測鍵盤排列類型 輸入主機名稱 輸入使用者名稱/帳號 設定密碼 是否要加密使用者目錄: No 硬碟格式化 詢問是否有Proxy設定。可以直接按 Enter 跳過 是否自動更新 為了能夠遠端連線，選擇安裝了 OpenSSH Server 是否要建立開機選單。如果電腦中擁有雙重系統，就要注意一下，因為建立後有可能導致無法進入原本已安裝好的系統。如果 Ubuntu 是電腦中唯一的系統，那就一定要選擇Yes。這樣Ubuntu Server才打的開。 VNC 與 XWindowVNC(Virtual Network Computing) 為一種連線方式，讓我們可以使用 GUI 圖形化介面操作遠端伺服器。VNC 可以讓我們管理遠端主機的檔案，軟體，設定等等。由於 turnky 軟體需要 xwindow 介面，因此為了遠端管理我們需要安裝 VNC 與 XWindow。 安裝桌面環境和 VNC Server大部分的 Linux Server 預設並不會安裝圖形化介面，所以第一步我們需要安裝桌面環境。這裡我們使用輕量化的 xwindow - XFCE4 搭配 TightVNC 12$ sudo apt-get update$ sudo apt-get install xfce4 xfce4-goodies tightvncserver 接著使用 vncserver 指令完成 VNC Server 初始化設定 1$ vncserver 設定完存取密碼之後會詢問是否需要建立 view-only 密碼。注意如果要設定密碼和上一組存取密碼不可相同。 如果設定錯誤可使用下列指令修改密碼 1$ vncpasswd 設定 VNC Server接下來，我們得告訴 VNC Server 在啟動時該執行那些指令，這些指令會存放在家目錄下 ~/.vnc/xstartup 的設定檔。在我們第一次執行 vncserver 時就被建立了，但我們需要為 Xfce 做些調整。 VNC 第一次設定時預設會使用 5901 port。在 VNC 中則代表 :1，例如 :2 :3 分別為 5902，5903 簡單說 :X = 5900+X。因為我們需要修改設定所以第一步我們要先停止 VNC 12$ vncserver -kill :1# Killing Xtightvnc process ID 17648 在開始設定之前，我們先備份一份設定檔 1$ mv ~/.vnc/xstartup ~/.vnc/xstartup.bak 設定檔 123#!/bin/bashxrdb $HOME/.Xresourcesstartxfce4 &amp; 第一行 xrdb $HOME/.Xresources 告訴 VNC 的 GUI framework 讀取 Server 使用者的 .Xresources 檔案。這個檔案可以讓使用者調整特定圖形化介面，終端機顏色，字體，等等設定。第二行單純告訴 server 執行 Xfce。 同時為了確保 VNC Server 可以使用這個檔案我們需要修改檔案權限 1$ sudo chmod +x ~/.vnc/xstartup 重啓 VNC Server 1$ vncserver 指令整理 123456789101112# 啟動$ vncserver# 停止$ vncserver -kill :1 # 停止 5901 port$ vncserver -kill :2 # 停止 5902 port# 修改密碼$ vncpasswd# 設定檔# ~/.vnc/ 測試 VNC 遠端連線首先，為了連線安全與方便性我們可以在本地端建立 SSH 轉發連線，就是將 localhost 與遠端 IP 資訊繫結起來。 1$ ssh -L 5901:127.0.0.1:5901 -N -f -l turnkey &lt;server_ip&gt; 之後就可以使用 localhost:5901 來連線。 OSX VNC Client VNC Viewer Browser, Failure to Execute123456789$ sudo apt-get install netsurf-gtk# Application -&gt; Settings -&gt; Preferred Application -&gt; Web Browser -&gt; netsurf# OR 安裝 Firefox$ sudo add-apt-repository ppa:ubuntu-mozilla-daily/ppa$ sudo apt-get update$ sudo apt-get upgrade$ sudo apt-get install firefox 建立 VNC Service File下一步我們要設定 VNC Server 為系統服務。如此一來就可以像其他服務一樣使用 service 指令來啟動、停止、重啓。 建立 /etc/systemd/system/vncserver@.service 注意 User PIDFile 的部分要換成您的 username。 1$ sudo vi /etc/systemd/system/vncserver@.service 設定檔內容如下 12345678910111213141516[Unit]Description=Start TightVNC server at startupAfter=syslog.target network.target[Service]Type=forkingUser=turnkeyPAMName=loginPIDFile=/home/turnkey/.vnc/%H:%i.pidExecStartPre=-/usr/bin/vncserver -kill :%i &gt; /dev/null 2&gt;&amp;1ExecStart=/usr/bin/vncserver -depth 24 -geometry 1280x800 :%iExecStop=/usr/bin/vncserver -kill :%i[Install]WantedBy=multi-user.target 1234567891011# 重載新 Unit 設定檔$ sudo systemctl daemon-reload# 啟用 Unit$ sudo systemctl enable vncserver@1.service# 啟動$ sudo systemctl start vncserver@1# 狀態$ sudo systemctl status vncserver@1 安裝 JDK1234567891011121314151617181920212223# 下載 jdk6# http://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase6-419409.html# 由於 Orcale 下載連結需要登入，可以使用 sftp 或 scp$ scp ./jdk-6u45-linux-x64.bin turnkey@&lt;ip&gt;:/home/&lt;your_username&gt;$ chmod u+x jdk-6u45-linux-x64.bin$ ./jdk-6u45-linux-x64.bin$ sudo mv jdk1.6.0_45 /opt$ sudo update-alternatives --install /usr/bin/java java /opt/jdk1.6.0_45/bin/java 1$ sudo update-alternatives --install /usr/bin/javac javac /opt/jdk1.6.0_45/bin/javac 1$ sudo update-alternatives --install /usr/bin/jar jar /opt/jdk1.6.0_45/bin/jar 1# 其他備註 - 安裝 jdk8$ sudo add-apt-repository ppa:webupd8team/java$ sudo apt-get update$ sudo apt-get install oracle-java8-installer# 選擇 java 版本$ sudo update-alternatives --config java# 確認版本$ java -version$ javac -version 安裝 PostgreSQL1$ sudo apt-get install postgresql postgresql-contrib 預設，PostgreSQL 使用角色的概念來進行驗證與授權。某種程度上類似於 Unix-Style 的帳號，但 PostgreSQL 沒有區分群組和使用者，而是使用角色的方式。 預設安裝之後 Postgre 使用 ident 的驗證方式，意味著只要符合條件 Linux／Unix 系統的帳號都可以存取。例如一個 Postgre 的角色和 Linux/Unix 的 username 一樣就可使用該角色的權限登入。 切換 postgres 帳號預設安裝流程中幫我們建立了一個使用者帳號 postgres，這個帳號就可以存取預設 Postgre 的角色。為了使用該角色，現在我們需要切換換系統帳號。 123$ sudo -i -u postgres# -i 登入# -u 指定帳號 接著，使用 psql 存取 Postgre 1$ psql 123456789101112131415161718# 登入$ $ psql -h localhost -U andyyou database_name# 確認當前使用者psql=# select current_user;# 離開psql=# \\q# 幫助 - 指令介面下psql=# psql --help# 幫助 - 已經登入 postgres 之後psql=# \\?psql=# \\help# 直接使用帳號執行 psql$ sudo -u postgres psql psql 入門 建立角色要建立角色需要帳號有權限，目前我們只能使用 postgres。我們可以使用 createuser 指令 搭配 --interactive 來建立新角色和資料庫使用者。 如果已經切換帳號 sudo -i -u postgres 123456789101112# 建立包含密碼的角色（Turnkey 強制需要密碼）$ createuser --interactive --pwprompt# &gt; psql# 列出角色psql=# \\du# 列出使用者psql=# SELECT * FROM &quot;pg_user&quot;;# 列出資料庫psql=# \\l# 顯示連線資訊psql=# \\conninfo 如果沒有切換則 1$ sudo -u postgres createuser --interactive --pwprompt 接著指令會提供一系列選擇，依據需求來建立帳號和角色。 建立新資料庫除了預設建立的資料庫 postgres 外，另一個預設行為就是 PostgresSQL 在登入時預設存取跟帳號同名的資料庫。 假如我們剛剛建立了一個角色叫作 turnkey 預設登入時會存取名為 turnkey 的資料庫。我們可以使用 createdb 來建立資料庫，如果後面沒有加入名稱預設會使用帳號名稱。 1$ sudo -u postregres createdb einvTurnkey 使用新帳號與角色基於 ident 驗證機制，我們必須要有一個 Linux 的系統帳號來存取角色和資料庫。假如我們沒有符合的 user 可以使用 adduser 來建立。 123$ sudo adduser andyyou$ sudo -i -u andyyou$ psql 如果需要連線到不同的資料庫 1$ psql -d postgres 一旦登入成功，我們可以使用下面指令來確認登入資訊 12# port 資訊也在上面psql=# \\conninfo PostgreSQL 安裝流程 for Turnkeypostgresql 分別有使用者和角色，使用 createuser 可以一起建立，使用 createdb 可建立資料庫。因為 ident 驗證的關係所以我們需要一組系統帳號。 12345678910111213141516# Turnkey 安裝流程# 1. 建立 turnkey role$ createuser --interactive --pwprompt# 2. 如果沒有系統帳號$ sudo adduser turnkey# 3. 切換帳號$ sudo -i -u turnkey# 4. 建立資料庫$ createdb einvTurnkey# 設定 /etc/postgresql/&lt;version&gt;/main/postgresql.conf# 設定 /etc/postgresql/&lt;version&gt;/main/pg_hba.conf# 5. 重啓服務$ sudo /etc/init.d/postgresql reload# 6. 稍後匯入 .sql$ psql -f PostgreSQL.sql 中文字 issue1234567891011121314151617181920# 檢視是否支援語系$ locale -a # 如果不支援$ sudo dpkg-reconfigure locales# 更新$ sudo apt-get dist-upgrade# 安裝字體$ sudo apt-get install xfonts-intl-chinese$ sudo apt-get install fonts-arphic-bkai00mp fonts-arphic-bsmi00lp# （可選）安裝 Google 字體# 確認系統安裝 fontconfig 套件$ sudo dpkg -l | grep fontconfig# 沒有的話則安裝$ sudo apt-get install fontconfig $ mkdir ~/.fonts $ cd ~/.fonts$ wget https://github.com/google/fonts/archive/master.zip$ unzip master.zip $ fc-cache -fv 安裝 Turnkey1234567891011121314151617181920212223242526# 下載並解壓縮$ sudo apt-get install unzip$ wget http://117.56.24.205/EINVTurnkey1.4.8-linux.zip$ unzip EINVTurnkey1.4.8-linux.zip$ cd ~/EINVTurnkey1.4.8-linux/# 1. 匯入 sql (本文使用關聯式資料庫)$ psql -f DBSchema/PostgreSQL/PostgreSQL.sql# 注意下列指令須在 xwindow 下執行# 備註：Application -&gt; settings -&gt; window manager -&gt; keyboard -&gt; Super + Tab Clean -&gt; Fix tab issue# 2. 設定 Turnkey$ cd linux$ chmod +x runFirst.sct einvTurnkey.sct$ ./runFirst.sct$ ./einvTurnkey.sct# 預設密碼：ADMIN# 注意：這些 scripts 包含相對路徑，所以不可使用 profile。# runFirst.sct： 執行環境設定# einvTurnkey.sct: 執行 Turnkey# runUpgrade.sct: 執行更新程式# setenv: 設定環境變數# StartBatchEINVTurnkey.sct: 啟動 Turnkey 背景執行功能# StopBatchEINVTurnkey.sct: 關閉 Turnkey 背景執行功能 到這邊我們已經完成 Turnkey 的安裝，但還沒完成設定。 軟體憑證 PFX說明：使用 Turnkey 需要使用憑證認證，硬體（卡片）或軟體憑證 PFX。 官方文件 官方網站 流程 至PFX 網頁產生csr 憑證申請 GTestCA 測試憑證申請(工商測試憑證 - 公司及分公司) 經濟部工商憑證管理中心 正式憑證請參考官方文件 測試憑證申請步驟連線至PFX 網頁 產生 csr 備份到 txt 連線至GTestCA 測試憑證申請 - 我要申請非 IC 卡類測試憑證，新版網站與官方的文件圖片不同。 可以使用 工商測試憑證 - 公司及分公司 或 一站式專屬測試，但要注意 CA金鑰與簽章演算法 不可以選新的。 如果憑證無法使用則匯出 base64 格式 貼上 base64 的編碼之後產生憑證。 備份金鑰 上傳憑證至主機12$ sftp turnkey@&lt;ip&gt;$ put &lt;pfx&gt; Turnkey 設定最後開啟 turnkey 將 系統管理 與 檔案接收 逐步設定。 參考 電子發票介紹 財政部電子發票整合服務平台 二代電子發票平台 VNC 安裝教學 Ubuntu 安裝 JDK Ubuntu 安裝 PostgreSQL Ubuntu JDK 1.6 Debian 支援中文 Ubuntu 安裝 Google 字體 jdk 6 安裝","link":"/2017/06/27/e-invoce-setup/"},{"title":"[譯] 理解 SVG 座標系統與 Transformation - 2 transform 屬性","text":"SVG 的元素可以執行縮放、移動、傾斜、旋轉等形變效果就像 HTML 元素可以用 CSS transform 一樣。然而當變形的任務牽扯到座標時，勢必也會影響結果。在這篇文章我們要討論的是 SVG 的 transform 屬性與 CSS 屬性，內容涵蓋如何操作 SVG 變形以及座標系轉換過程您應該知道的事。 這是系列文章的第二篇，我們將開始探討 SVG 座標系與變形之間的關係。在第一篇時我們介紹了關於 SVG 座標系的基礎概念，更具體的說就是 viewBox， preserveAspectRatio 屬性和 viewport 的概念。 [譯] 理解 SVG 座標系統與 Transformation - 1 viewport、viewBox、和 preserveAspectRatio [譯] 理解 SVG 座標系統與 Transformation - 2 transform 屬性 [譯] 理解 SVG 座標系統與 Transformation - 3 建立 viewport 這裡我假設您已經閱讀並理解第一篇的部分，如果您還沒參透那麼這邊建議您先讀完第一篇。 trasfrom 屬性transform 屬性可以設定一或多個關於元素變形的參數。它會將參數放到一個 &lt;transform-list&gt; 列表並將這些變形效果按照順序套用。各個的變形效果參數使用空白字元或逗號(,)分開。舉例來說要使一個元素變形的程式碼看起來如下： 1transform=&quot;translate(20, 20) rotate(20)&quot; SVG 可以在 transform 中使用的變形包含：旋轉、縮放、位移、傾斜變形。使用方式類似於 CSS transform 但是它們的參數有些差異。 下面我們就來逐一介紹這些參數，更細的說來這些參數屬於一種函數，因為它們各自還需要各自的參數 Matrix使用 matrix() 您可以套用一到多種的變形效果到元素上，該函式的語法如下 1martix(&lt;a&gt; &lt;b&gt; &lt;c&gt; &lt;d&gt; &lt;e&gt;) 上面是 matrix 的使用格式，它需要 6 個參數是依據矩陣來計算變形結果。對於不擅長數學的人來說，可能也沒辦法使用這個函數。不過您可以參考W3C 的說明或著這篇不錯的文章。在多數情況下這個函數很少被直接使用，因為牽扯到複雜的數學計算，所以在這邊我們會直接跳過這個函數，有興趣的讀者可以參考上面的連結。 位移要移動 SVG 的元素，我們可以使用 translate() 函數。語法如下 1translate(&lt;tx&gt; [&lt;ty&gt;]) 關於 translate() 函數它需要 1 到 2 個參數，分別設定水平 X 軸和垂直 Y 軸的偏移值。tx 為設定 X 軸偏移，ty 則是 Y 軸偏移。ty 是選擇性的參數，如果被忽略，其預設值為 0。tx 和 ty 之間可以用空白字元或 , 隔開。不需要設定任何單位，它們會跟著目前用戶座標系的單位。 下面範例會往右移動元素 100 個用戶單位，往下 300 個單位 1&lt;circle cx=&quot;0&quot; cy=&quot;0&quot; r=&quot;100&quot; transform=&quot;translate(100, 300)&quot;&gt; 範例 縮放我們也可以改變 SVG 元素的大小，這時就要使用 scale() 函數 1scale(&lt;sx&gt; [&lt;sy&gt;]) scale() 函數需要 1 到 2 個參數，分別設定水平和垂直的縮放的倍率。sx 為 x 軸的倍率用來放大或縮小 x 軸的單位。sy 則是 y 軸的縮放倍率。sy 同樣是選擇性的參數，如果忽略預設會等於 sx 的值。一樣兩個參數可以用 空白字元 或 , 隔開，也一樣不需要單位。 1&lt;rect width=&quot;150&quot; height=&quot;100&quot; transform=&quot;scale(2)&quot; x=&quot;0&quot; y=&quot;0&quot;&gt; 下面的例子會水平擴展 2 倍的寬，縮小高為原本的一半。 1&lt;rect width=&quot;150&quot; height=&quot;100&quot; transform=&quot;scale(2 0.5)&quot; x=&quot;0&quot; y=&quot;0&quot;&gt; 小數的 0 可以省略，空白字元或逗點可以擇一使用，上面的例子也可以寫成 scale(2, .5)。這裡有個重點需要注意當 SVG 元素被縮放時，當前的座標也會被縮放，結果就是元素的位置可能會偏移。不過現在先別擔心我們後續會討論到細節的部分。 傾斜SVG 元素也可以被傾斜/扭曲(Skew)變形。我們可以透過 skewX 和 skewY 來完成這個效果。 123skewX(&lt;skew-angle&gt;)skewY(&lt;skew-angle&gt;) skewX 函數會隨著 x 軸傾斜變形，skewY 則是跟著 y 軸變形。您可以先試試下面的範例來理解這個效果 範例 skew 角度不需要設定單位，預設是角度。 注意到傾斜的時候元素可能會被改變定位，在範例中試試 skewX(0) 和 skewX(60) 可以觀察到結果。一樣我們先別擔心這個問題，待會會說明。 旋轉使用 rotate() 可以旋轉 SVG 元素 1rotate(&lt;rotate-angle&gt; [&lt;cx&gt; &lt;cy&gt;]) rotate() 函數基於一個中心點和旋轉的度數來產生旋轉效果。跟 CSS 不同的是：這邊不能設定單位，預設就是使用角度，不是徑度(弧度)。 選擇性參數 cx，cy 可設定旋轉的中心點，同樣不設定單位。如果 cx 和 cy 沒有設定時預設的旋轉的中心是目前用戶座標的原點。 設定旋轉中心點的語法就像 CSS 中 transform: rotate() 搭配 transform-origin 的簡寫。因為預設旋轉的中心點是 svg 用戶座標的左上角，所以跟您預想的旋轉效果可能不同。此時我們可以設定一個新的中心點。如果您知道該元素在 SVG 的座標，您就可以輕易的把元素的中心設為旋轉的中心點。 下面範例示範旋轉一個元素群組 &lt;g&gt; 並指定旋轉中心點為用戶座標系中的 (50, 50) 123&lt;g id=&quot;parrot&quot; transform=&quot;rotate(45 50 50)&quot; x=&quot;0&quot; y=&quot;0&quot;&gt; &lt;!-- 鸚鵡圖案 --&gt;&lt;/g&gt; 然而如果您想要依據元素中心點來旋轉元素，您可能想要像 50% 50% 這樣的用法，不幸的是 svg 的 rotate() 沒有這個功能。您需要使用絕對位置， 不過我們可以透過搭配 CSS 的 transform-origin 和 transform 來完成您想要的效果。本篇後續我們會更詳細的探討這個問題。 座標系的轉換現在我們已經介紹了 SVG 所以的變形函數，我們將深入探討關於套用變形效果至 SVG 元素時️視覺效果呈現的部分。這是控制 SVG 變形中最重要的部分。以及我們稱其為座標系轉換，而不只是元素變形。 在規範中，transform 屬性被定義為可以建立新用戶座標系的兩個屬性之一，viewBox 是另一個。但具體來說這個定義到底在說什麼？ 使用 transform 屬性的元素會建立一個新的用戶座標即目前使用的座標系。 這個行為很像在 HTML 元素中套用 CSS 變形的屬性 - 即元素的座標系統改變了(影響子元素)，通常在執行一系列變形效果時尤其明顯。儘管很多地方 SVG 變形機制和 HTML 類似，但還是有些不同的地方。 最主要的差異就是座標系。HTML 元素的座標系會建立在元素自己身上。在 SVG 中，元素的座標一開始用的是當前的用戶座標，或稱用戶空間。 當您在 SVG 元素套用 transform 屬性時，元素會取得一個用戶座標副本來使用。我們可以想成為這個變形的元素建立了一個新的圖層，這個新圖層複製了一份自己的座標系(從 viewBox 複製)。接著元素的座標系會根據 transform 屬性的設定轉換，這個結果就會造成元素變形。 為了理解 SVG 變形是如何套用運作，讓我們試著從視覺化的範例來理解。下圖是我們要用來操作的 SVG 鸚鵡和小狗的圖片各自使用 &lt;g&gt; 群組起來，我們將試著對它們套用變形的效果 12345678&lt;svg width=&quot;800&quot; height=&quot;600&quot; viewBox=&quot;0 0 800 600&quot;&gt; &lt;g id=&quot;parrot&quot;&gt; &lt;!-- 鸚鵡圖案 --&gt; &lt;/g&gt; &lt;g id=&quot;dog&quot;&gt; &lt;!-- 小狗圖案 --&gt; &lt;/g&gt;&lt;/svg&gt; 灰色的座標時 viewBox 初始化時建立的，為了單純起見我們先不改變初始化的座標，即 viewBox 和 viewport 相同尺寸。 當我們套用 transform 屬性到 SVG 元素時，會取得一個用戶座標副本來使用。 現在我們已經建立了 canvas 並初始化了用戶座標，接著我們要來讓元素變形。一開始讓我們來移動鸚鵡向右 150 個單位，向下 200 個單位。這隻鸚鵡我們是透過 path 和基礎形狀畫出來的並用 &lt;g&gt; 包起來讓它成為一個物件。後續我們可以對 g 套用 transform 它就會將效果套用到 g 底下所以的形狀，於是鸚鵡就會像是單一物件一樣移動。 123456&lt;svg width=&quot;800&quot; height=&quot;800&quot; viewBox=&quot;0 0 800 600&quot;&gt; &lt;g id=&quot;parrot&quot; transform=&quot;translate(150 200)&quot;&gt; &lt;!-- 鸚鵡圖案 --&gt; &lt;/g&gt; &lt;!-- ... --&gt;&lt;/svg&gt; 下圖就是位移的結果，半透明的圖案是鸚鵡一開始的位置。 關於 SVG 偏移的變形效果看起來非常簡單直覺，跟 CSS 的用法一樣。不過上面我們提到 transform 屬性套用到元素時會建立一個新的座標系。下圖表示建立在圖案上的用戶座標副本，現在鸚鵡的座標被移動了 值得注意的是新的用戶座標是建立在元素上的，它是初始化時的用戶座標的副本(複製一份用戶座標)，裡面也保留了元素原本的座標。這意味著雖然我們說副本座標建立在元素上，但它並非依據元素的邊界或尺寸來建立，換句話說，元素本身不會限制座標的大小。這就是 SVG 座標系和 HTML 最大的差異。 新的用戶座標建立在形變的元素上，但不會被限制在元素的邊界或尺寸之下。 如果我們移動右下角的小狗效果會更明顯，假設我們移動小狗向右下各 50 個單位。下圖為套用的效果。我們注意到新的座標並不是依據小狗圖案本身的邊界，位移也不是從小狗圖案的左上角開始。從下圖我們理解到位移是先複製一份畫布的座標，新增了一個圖層然後依據副本的座標來變形。 現在讓我們來試試其他的效果，讓我們來將鸚鵡放大 2 倍 123456&lt;svg width=&quot;800&quot; height=&quot;800&quot; viewBox=&quot;0 0 800 600&quot;&gt; &lt;g id=&quot;parrot&quot; transform=&quot;scale(2)&quot;&gt; &lt;!-- 鸚鵡圖案 --&gt; &lt;/g&gt; &lt;!-- ... --&gt;&lt;/svg&gt; SVG 放大的效果和 HTML 放大的效果有些不同，我們注意到放大的 SVG 元素的位置和 viewport 1:1 時不一樣了。下圖顯示出不止圖案被變大連位置座標也被放大了 我們稍早提到這是因為座標系變形，座標系的單位也被放大了。也就是原本的 x, y 在和 viewport 對應轉換後也變大 2 倍了。而這隻鸚鵡會被畫在新的座標系上，所以在這個範例中的效果類似於 viewBox=&quot;0 0 400 300&quot; 像是對畫布 zoom in。 如果我們來看看視覺化的結果，就會像下圖 這隻鸚鵡的新座標系被放大了，注意到鸚鵡在這個新座標中位置並沒有改變，座標不變只是因為單位變大了所以渲染到 viewport 時看起來像是位移了。 讓我們試試使用不同的比例縮放鸚鵡的寬高，假如我們使用 transform=&quot;scale(2 0.5)&quot; 那等於讓寬變為 2 倍，高只剩一半，這個效果類似於 viewBox=&quot;0 0 400 1200&quot; 注意到鸚鵡在的紅色的新座標中位置和原來灰色座標 - x 和 y 是一樣的。 也因此在 SVG 傾斜扭曲元素也會造成元素被移動的效果，因為目前的用戶座標被扭曲了。例如我們套用 skewX 效果到小狗的 x 軸上 123456&lt;svg width=&quot;800&quot; height=&quot;600&quot; viewBox=&quot;0 0 800 600&quot;&gt; &lt;!-- ... --&gt; &lt;g id=&quot;dog&quot; transform=&quot;skewX(25)&quot;&gt; &lt;!-- 小狗圖案 --&gt; &lt;/g&gt;&lt;/svg&gt; 下圖是套用傾斜效果到小狗圖案的結果 因為座標系被扭曲了所以小狗的位置和原來不同了，但在新座標的位置不變。 接著我們來看看使用 skewY() 的效果 最後我們來試著旋轉鸚鵡。預設的旋轉中心點是目前用戶座標的左上角。新的用戶座標會建立在旋轉的元素上。下面的範例我們要旋轉鸚鵡 45 度。正值會順時針旋轉。 123456&lt;svg width=&quot;800&quot; height=&quot;600&quot; viewBox=&quot;0 0 800 600&quot;&gt; &lt;g id=&quot;parrot&quot; transform=&quot;rotate(45)&quot;&gt; &lt;!-- 鸚鵡圖案 --&gt; &lt;/g&gt; &lt;!-- ... --&gt;&lt;/svg&gt; 您可能會想要讓元素依照圖案的中心點旋轉，而不是座標系的原點。使用 rotate() 時我們可以設定旋轉的中心點。假設我們想要在這個範例根據鸚鵡的中心來旋轉鸚鵡。依照鸚鵡的寬高和位置，我們可以知道它的中心點大約在 (150, 170) 123456&lt;svg width=&quot;800&quot; height=&quot;600&quot; viewBox=&quot;0 0 800 600&quot;&gt; &lt;g id=&quot;parrot&quot; transform=&quot;rotate(45 150 170)&quot;&gt; &lt;!-- 鸚鵡圖案 --&gt; &lt;/g&gt; &lt;!-- ... --&gt;&lt;/svg&gt; 我們說所謂的變形效果是套用在座標系上，因此元素最終也會受到影響而變形。那麼究竟要如何改變座標系的原點 (0, 0) 呢？ 當我們改變中心點或旋轉時，座標系會被移動，然後旋轉設定的角度，最後在依據設定的中心點位移回去。舉例來說： 1&lt;g id=&quot;parrot&quot; transform=&quot;rotate(45 150 170)&quot;&gt; 瀏覽器會執行下面一系列的操作 1&lt;g id=&quot;parrot&quot; transform=&quot;translate(150 170) rotate(45) translate(-150 -170)&quot;&gt; 目前的用戶座標(副本)會被位移到我們設定的中心點，然後旋轉設定的角度，最後透過位移負值 在我們繼續探討關於巢狀與連續套用變形效果之前，我想請大家注意關於所謂的目前的用戶座標，它是各自被建立在變形元素上的，每個變形元素的座標是各自獨立的，不會��影響。下圖顯示了小狗和鸚鵡的座標系。 另外要注意的是每一個元素的用戶座標仍然存在於 canvas (svg viewBox 屬性) 所建立的主用戶座標系中。任何 viewBox 產生的效果會影響 canvas 中的元素，無論元素本身是否有自己的座標系。 舉例來說，下圖我們把 viewBox 屬性從 viewBox=&quot;0 0 800 600&quot; 換成 viewBox=&quot;0 0 600 450&quot;。於是整個 canvas 不只會被放大，還會保留每個元素各自套用的變形效果。 巢狀(Nested)與鏈接組合變形很多時候我們會需要套用多個效果到元素上。這種套用多個變形效果我們可以當成是在組合變形效果。原文為 chaining transformations 也可稱作鏈接變形。當我們要組合效果的時候，最重要的是要清楚，其行為會跟 HTML 元素變形一樣，每一個效果是會堆疊的，意味著每一個效果會套用在上一個效果處理後的座標系上。 例如：我們要旋轉一個元素後位移，此時位移會根據新的座標系並不是一開始沒有旋轉的那個。 下面的範例我們先套用了旋轉的效果然後向右位移 200 個單位 transform=&quot;rotate(45 150 170) translate(200)&quot; 這種組合效果的座標行為一旦牽扯到縮放可能又更不直覺，讓我們直接看看另一個範例 1234567891011&lt;svg width=&quot;600&quot; height=&quot;300&quot;&gt; &lt;rect id=&quot;a&quot; x=&quot;20&quot; y=&quot;20&quot; width=&quot;10&quot; height=&quot;100&quot; fill=&quot;red&quot; transform=&quot;translate(10 10)&quot; &gt;&lt;/rect&gt; &lt;rect id=&quot;b&quot; x=&quot;20&quot; y=&quot;20&quot; width=&quot;10&quot; height=&quot;100&quot; fill=&quot;pink&quot; transform=&quot;translate(10 10) scale(2)&quot; &gt;&lt;/rect&gt; &lt;rect id=&quot;a&quot; x=&quot;20&quot; y=&quot;20&quot; width=&quot;10&quot; height=&quot;100&quot; fill=&quot;blue&quot; transform=&quot;translate(10 10) scale(2) translate(-10 -10)&quot; &gt;&lt;/rect&gt;&lt;/svg&gt; 根據我們要的效果來鏈接變形效果的函數，堆疊的最後座標(位置)和變形就是我們的結果。永遠記住座標的變化，尤其是那些造成單位發生改變的效果。例如一個座標 (10, 10) 經過 scale(2) 後，因為其新的用戶座標單位被變大了，座標依然是 (10, 10) 只是最後要渲染到 viewport 時因為元素的用戶單位是 viewport 單位的 2 倍才會被畫在 viewport (20, 20) 的地方。 另外當我們傾斜元素時，座標系統將不再是 90 度角而是根據傾斜後的座標系統來計算。 巢狀變形或稱嵌套變形(Nestd transformations)指的是當一個變形元素的子元素也具有變形效果。這種變形會堆疊父元素和自己的效果。 所以實際上巢狀變形跟組合變形是很類似的，唯一的差異是巢狀變形不是套用一系列的變形效果到元素上，它是直接取得父層的最終效果，接著補上自己的變形效果。 這在處理某 A 元素已和 B 元素有對應關係時尤其實用。什麼意思，假如我們想要實作小狗搖尾巴的動畫，這個尾巴會是小狗元素裡面的子元素，即在小狗的群組裡。 1234567891011121314&lt;svg width=&quot;800&quot; height=&quot;800&quot; viewBox=&quot;0 0 800 600&quot;&gt; &lt;!-- ... --&gt; &lt;g id=&quot;dog&quot; transform=&quot;translate(..)&quot;&gt; &lt;g id=&quot;head&quot;&gt; &lt;!-- 頭 --&gt; &lt;/g&gt; &lt;g id=&quot;body&quot; transform=&quot;rotate(.. .. ..)&quot;&gt; &lt;path id=&quot;tail&quot; d=&quot;...&quot; transform=&quot;rotate(..)&quot;&gt; &lt;/path&gt; &lt;g id=&quot;legs&quot;&gt; &lt;/g&gt; &lt;/g&gt; &lt;/g&gt;&lt;/svg&gt; 如果我們已經移動了小狗，又將身體旋轉了幾度。我們的搖尾巴動畫就必須繼承已產生的效果。當我們旋轉了尾巴的部分時，我們就繼承了其父層 #body 已轉換的座標系。同樣的 #body 也會繼承 #dog 的效果。結果跟上面提到的組合效果是不是很類似。 使用 CSS 屬性使 SVG 變形由於 CSS 3 變形規範整合了 SVG Transforms，CSS 2D Transforms，和 CSS 3D Transforms 的規範。並且將一些功能引入 SVG 例如 transform-origin 和 3D 的部分。也就是我們可以用 transform attribute (在 SVG 標籤上) 和 transform property (CSS 樣式) 這兩種方式來讓 SVG 元素變形。但要注意的是兩者的參數設定是不同的。 後續我們稱 transfrom attribute 是指 SVG 元素上的屬性，transform property 則是 CSS 的用法。 由於 CSS Transforms 規範中定義 CSS 的 transform 屬性也可以被套用在 SVG 元素上。但 transform 屬性的效果函數必須要遵循 CSS 的語法，函數的參數必須要使用逗號 , 分開，不可以使用空白字元來區隔參數。但在設定字串中加入空白是沒問題的，只是沒有區隔參數的作用。然後 rotate() 函數沒有 cx cy 的用法，要設定旋轉中心點則使用 transform-origin 屬性，預設是 50% 50% 0 即該元素的中心點。另外 CSS 屬性是允許使用單位的，以角度來說我們也可以使用弧度(徑度)，座標部分可以使用 px，em 等等。 兩者用法的差異是這邊需要注意的。 下面的範例是我們使用 CSS 來旋轉 SVG 元素 1234#parrot { transform-origin: 50% 50%; transform: rotate(45deg);} 同時 SVG 元素也可以透過 CSS 3D Transforms 達成 3D 的效果。不過，仍然要注意用戶座標的影響和 HTML 座標系之間是不同的，試著使用下面 3D 旋轉的程式碼我們可以看出它並不是以元素的中心點旋轉的。 123#svg-el { transform: perspective(800px) rotate3d(0, 0, 1, 45deg);} 利用 CSS 變形效果套用在 SVG 元素上大致上跟套在 HTML 元素上一樣，只要注意座標系的觀念即可，因此在這篇文章我們將跳過 CSS 的部分。在撰寫本篇文章的同時還是有些瀏覽器支援的功能並不完整，因此我強烈建議您實作看看到底瀏覽器支援的程度到哪來決定是否要在您的專案中使用該屬性。 動畫SVG 變形也可以拿來作動畫，就像 CSS 變形效果一樣。我們使用 CSS transform 屬性來使 SVG 產生變形，當然也可以使用 CSS 動畫和轉場效果套在 SVG 元素上。 SVG 的 transform attribute 可以透過 SVG &lt;animateTransfrom&gt; 元素來產生動畫。&lt;animateTransform&gt; 元素是三種可以讓 SVG 產生動畫的元素之一。詳細 &lt;animateTransform&gt; 的用法已超出本文範疇。我們概略看看範例即可。 範例 進階 - 底層的原理 - 矩陣對於那些想更加深入理解變形的人，這一小段落為您起個頭。詳細的解釋與算法您可以閱讀Transform Matrix這篇文章。這裡只是單純的歸納出 - 最終畫在 viewport 上的圖形都會依據 transform 所產生的 CTM (Current Transform Matrix) 來畫出變形的結果。每每套用一個效果等於是 當前矩陣 * 變形矩陣。 不管是 viewBox 造成的效果或是 transform 就是不斷的相乘得到最終的 CTM。您可以使用 document.querySelector('el').getCTM() 來觀察。 最後學習 SVG 一開始可能會因為對座標系的轉換不是很清楚而感到非常困惑，尤其是您具備 CSS 的知識，自然會希望 SVG 元素和 HTML 元素的變形行為一致。然而一但我們掌握了 SVG 轉換的機制我們就能夠輕易的控制 SVG。 最後一篇我們將更深入的探討巢狀 SVG 與如何建立新的 viewport 與 viewbox 的部分。 資源 SVG Matrix","link":"/2017/04/02/svg-coordinate-2/"},{"title":"Promise 學習筆記","text":"這篇文章主要是為了複習與更加深入掌握 Javascript Promise 而產生的筆記。在直接閱讀關於 Promise A+ 或原理說明之前先通過比喻的方式理解可以更加深記憶。如果您對於 Promise 還是有點似懂非懂，不妨可以看看。 理解 PromisePromise 簡單來說： 想像一下你是個孩子，你媽承諾(Promise)你下個禮拜會送你一隻新手機。 現在你並不知道下個禮拜你會不會拿到手機。你媽可能真的買了新手機給你，或者因為你惹她不開心而取消了這個承諾。 這就是一個 Promise，一個 Promise 有三種狀態： pending 未發生、等待的狀態。到下週前，你還不知道這件事會怎樣。 resolved 完成/履行承諾。你媽真的買了手機給你。 rejected 拒絕承諾。沒收到手機，因為你惹她不開心而取消了這個承諾。 總結來說狀態有 等待、成功、失敗，使用情境就是我們當前還不知道結果，需要等待結果發生才繼續後續的處理。 建立一個 Promise看完上面的比喻讓我們對應到 Javascript。 123456789101112131415var isMomHappy = falsevar willIGetNewPhone = new Promise(function (resolve, reject) { if (isMomHappy) { var phone = { brand: 'Samsung', color: 'black', type: 's8' } resolve(phone) } else { var reason = new Error('Mom is unhappy') reject(reason) }}) 上面這段程式碼應該已經充分解釋概略的觀念。 第一行我們使用一個 Boolean isMomHappy 定義媽媽是否開心。 我們宣告一個 Promise willIGetNewPhone。這個 Promise 可能是被履行(resolved)又或者拒絕(rejected)。 Promise 標準的語法可以參考 MDN 1new Promise(function (resolve, reject) {}) 我們需要記得的是如果一個 Promise 執行成功要在內部 function 呼叫 resolve(成功結果)，如果結果是失敗則呼叫 reject(失敗結果)。在我們的範例中如果媽媽開心，我們將得到手機因此我們執行 reslove(phone)，如果媽媽不高興則執行 reject(reason)。 一個 Promise 物件表達的是一件非同步的操作最終的結果，可以是成功或失敗。 使用 Promise到這一步我們已經有了一個 Promise，讓我們接著來使用它。 12345678910var askMom = function () { willIGetNewPhone .then(function (fulfilled) { console.log(fulfilled) }) .catch(function (error) { console.log(error.message) })}askMom() 首先我們有個 function 叫 askMom 在這個 function 中，我們將利用 Promise willIGetNewPhone。 我們希望一旦等待的結果發生時可以採取對應的動作，我們可以使用 .then 或 .catch 來執行對應的行為。 在這個範例中，我們在 .then 中使用 function (fulfilled){}，而這個 fulfilled 就是從 Promise 的 resolve(成功結果) 傳來的結果，範例中這個結果就是 phone 物件。 在 .catch 中我們使用了 function (error) {}。而這個 error 就是從 Promise 的 reject(失敗結果) 傳來的即 reason。 範例 鏈式調用 PromisePromise 是可串連的。 假如你承諾您的朋友，如果你拿到新手機會借他們看看。這又是另一個 Promise。讓我們繼續來撰寫這個範例： 1234567var showOff = function (phone) { return new Promise(function (resolve, reject) { var message = 'Hey friend, I have a new ' + phone.color + ' ' + phone.brand + ' phone' + phone.type resolve(message) })} 在這個範例，您可能發現到我們根本沒有呼叫 reject，這是可選的，我們可以省略不調用。 另外，我們可以透過使用 Promise.resolve 簡化這個範例。 12345var showOff = function (phone) { var message = 'Hey friend, I have a new ' + phone.color + ' ' + phone.brand + ' phone ' + phone.type return Promise.resolve(message)} 接著讓我們來看看如何串連 Promise。在 willIGetNewPhone 這個 Promise 之後接續 showOff Promise。 1234567891011var askMom = function () { willIGetNewPhone .then(showOff) .then(function (fulfilled) { console.log(fulfilled) // 'Hey friend, I have a new black Samsung phone s8' }) .catch(function (error) { console.log(error.message) })} 這就是 Promise 串連的方式。 非同步Promise 是非同步的，讓我們在呼叫 Promise 的前後加上 console.log 1234567891011121314var askMom = function () { console.log('before asking Mom') willIGetNewPhone .then(showOff) .then(function (fulfilled) { console.log(fulfilled) }) .catch(function (error) { console.log(error.message) }) console.log('after asking Mom')} 關於上面這段程式碼，您認為 log 的順序會如何？大概我們會猜 1231. before asking Mom2. Hey friend, I have a new black Samsung phone s83. after asking Mom 然而真正的順序是 1231. before asking Mom2. after asking Mom3. Hey friend, I have a new black Samsung phone s8 為什麼？因爲時間是不等人的 XD。這也是我們在寫 JS 的時候非常常見得情況。 想像您還是那個孩子，在你媽決定買手機給你之前難道你就一直待在那等結果嘛！？你應該是跑去玩了吧！這就是我們說的非同步，程式碼不會卡在那等待結果。如果需要等待結果才能繼續處理的部分，我們就把它方到 then 裡面。 ES5， ES6/ES2015，ES7/Next 的 PromiseES5目前主流瀏覽器使用的 JS 版本。上面的範例如果想在全部的瀏覽器運行我們需要加入 Promise 函式庫 - Bluebird。這是因為 ES5 內建不支援 Promise，當然時至今日已經有許多瀏覽器陸續支援了。 ES6/ES2015Nodejs v6+ 開始原生支援 Promise，此外還有 arrow function、const 和 let 讓我們來看看 ES6 的程式碼 1234567891011121314151617181920212223242526272829const isMomHappy = trueconst willIGetNewPhone = new Promise((resolve, reject) =&gt; { if (isMomHappy) { const phone = { brand: 'Samsung', color: 'black', type: 's8' } resolve(phone) } else { const reason = new Error('Mom is not happy) reject(reason) }})const showOff = function (phone) { const message = 'Hey friend, I have a new ' + phone.color + ' ' + phone.brand + ' phone ' + phone.type return Promise.resolve(message)}const askMom = function () { willIGetNewPhone .then(showOff) .then(fulfilled =&gt; console.log(fulfilled)) .catch(error =&gt; console.log(error.message))}askMom() 看到所有的 var 被換成 const 然後 function 換成 (resolve, reject) =&gt; 關於更深入的介紹可以參考 JavaScript ES6 Variable Declarations with let and const An introduction to Javascript ES6 arrow functions ES7到了 ES7 更引進 async await 讓處理非同步的語法更加簡潔與具備可讀性。 1234567891011121314151617181920212223242526272829303132333435363738const isMomHappy = trueconst willIGetNewPhone = new Promise((resolve, reject) =&gt; { if (isMomHappy) { const phone = { brand: 'Samsung', color: 'black', type: 's8' } resolve(phone) } else { const reason = new Error('Mom is not happy') reject(reason) }})async function showOff(phone) { return Promise((resolve, reject) =&gt; { const message = 'Hey friend, I have a new ' + phone.color + ' ' + phone.brand + ' phone ' + phone.type return resolve(message) })}async function askMom () { try { console.log('before asking Mom') let phone = await willIGetNewPhone let message = await showOff(phone) console.log(message) console.log('after asking mom') } catch (error) { console.log(error.message) }}(async () =&gt; { await askMom()})() 當我們要在一個 function 中回傳 Promise 時，我們需要在該 function 前加上 async 當我們使用一個 Promise 或者 function 回傳 Promise （async）時需要使用 await 例如 let phone = await willIGetNewPhone 或 let message = await showOff(phone) 使用 try {} catch (error) {} 來攔截例外，即 Promise reject 時。 為何及何時使用 Promise在我們概略的介紹之後您肯定有些疑問，首先是為什麼我們需要 Promise？以及在沒有 Promise 之前的世界又是怎麼樣。在回答這些問題之前讓我先談談一些基礎的東西 Function 與 Async Function讓我們先來看看範例：使用函式來加總兩個數字 1234567// 普通的函式加總兩數function add (num1, num2) { return num1 + num2}const result = add(1, 2)// result 為 3 1234// 呼叫遠端函式加總兩數const result = getAddResultFromServer('http://example.com?num1=1&amp;num2=2')// result 會是 undefined 如果我們在本地端加總兩數，基本上我們會立刻得到其值，然而如果是透過遠端執行（呼叫 API)則需要等待其回應，不會立刻得到值。或者這麼說，我們其實不知道 server 需要多久時間，甚至是否正常運作等等，這種情況下我們又不希望介面操作卡在這邊等待。於是像調用 API，下載檔案，讀檔等這些會需要花點時間的操作，在 JS 中通常都是使用非同步的機制來處理。 在 Promise 出現之前： 難道我們一定要用 Promise 來處理非同步嗎？不是，在 Promise 出現之前我們已經有個方式處理 - Callback。所謂的 Callback 就是一個 function ，當我們調用非同步的 function 時，我們把它當作參數一起傳出去，當非同步的處理完成後，會把結果丟進這個 function 繼續處理。讓我們來看看範例： 12345678910function addAsync (num1, num2, callback) { return $.getJSON('http://example.com', { num1: num1, num2: num2 }, callback)}addAsync(1, 2, success =&gt; { const result = success // 取得結果為 3}) 目前這個範例看起來還OK啊，為什麼我們需要 Promise？ 假如我們需要連續處理多個非同步的行為？現在假如我們不是只有相加兩數，我們想要相加 3 次，如下這個情況 123456789101112let resultA, resultB, resultCfunction add (num1, num2) { return num1 + num2}resultA = add(1,2)resultB = add(resultA, 3)resultC = add(resultB, 4)console.log('total', resultC)console.log(resultA, resultB, resultC) 如果是上面這個情況使用 callback 呢？ 1234567891011121314151617181920212223let resutlA, resultB, resultCfunction addAsync (num1, num2, callback) { return $.getJSON('http://example.com', { num1: num1, num2: num2 }, callback)}addAsync(1, 2, function (success) { resultA = success addAsync(resultA, 3, function (success) { resultB = success addAsync(resultB, 4, function (success) { resultC = success console.log('total', resultC) console.log(resultA, resultB, resultC) }) })}) 這樣不斷內嵌的語法看起來就不是這麼友善了，在實務上我們非常容易遇到這個情形，例如：需要先使用 API 取得帳號資料，接著該帳戶的訂單，再取出某筆訂單的詳細資料。像上面這樣的程式碼通常人們稱為 callback hell 因為我們需要不斷的內嵌 callback，想像一下如果我們需要 10 層 callback 那會怎樣！ 逃離回呼地獄（Callback Hall）在大部分的程式語言中您比較少機會遇到這樣的問題，主要是因為它們以同步的機制為主，但在大量使用非同步的 JS 中我們就需要解決這個問題了。於是 Promise 就是為了解決這個問題而產生的。讓我們再來看看 Promise 的版本。 123456789101112131415161718192021222324252627let resultA, resultB, resultCfunction addAsync (num1, num2) { // fetch API 會回傳一個 Promise return fetch(`http://example.com?num1=${num1}&amp;num2=${num2}`) .then(x =&gt; x.json())}addAsync(1, 2) .then(success =&gt; { resultA = success return resultA }) .then(success =&gt; addAsync(success, 3)) .then(success =&gt; { resultB = success return resultB }) .then(success =&gt; addAsync(success, 4)) .then(success =&gt; { resultC = success return resultC }) .then(success =&gt; { console.log('total', success) console.log(resultA, resultB, resultC) }) 透過 Promise 我們使用 .then 把 callback hall 不斷內嵌的語法給攤平了。 後起之秀 - Observables在我們決定使用 Promise 之前，其實還有一個也是用來處理上面這些問題的新方法 Observables。 Observable 是 lazy event stream 可以觸發 0 到 多個事件，這些事件也不見得需要完成。 相比，Observable 和 Promise 相比，主要的差異為： Observable 是可以被取消的。 Observable 在需要時才會執行。 下面是使用 RxJS 的範例 12345678910111213141516171819let Observable = Rx.Observablelet resultA, resultB, resultCfunction addAsync (num1, num2) { const promise = fetch(`http://example.com?num1=${num1}&amp;num2=${num2}`) .then(x =&gt; x.json()) return Observable.fromPromise(promise)}addAsync(1, 2) .do(x =&gt; resultA = x) .flatMap(x =&gt; addAsync(x, 3)) .do(x =&gt; resultB = x) .flatMap(x =&gt; addAsync(x, 4)) .do(x =&gt; resultC = x) .subscribe(x =&gt; { console.log('total', x) conosle.log(resultA, resultB, resultC) }) Observable.fromPromise 會將 Promise 轉換成 observable stream。 .do 和 .flatMap 是 Observable 的運算子。 所謂的需要時才執行（lazy）意思是當我們呼叫 .subscribe 時才會開始執行。 Observable 可以將一些複雜的處理流程變的容易。舉例來說我們可以只用一行程式碼去 delay 延遲相加函式 3 秒 123addAsync(1, 2) .delay(3000) .do(x =&gt; resultA = x)","link":"/2017/06/27/js-promise/"},{"title":"[譯] 使用 stream 的方式處理 JSON 傳輸","text":"網頁應用程式在處理大量資料時一直都不是一件簡單的事。當需要接受大量資料時不只速度會變慢，且容易出錯，逾時等等。因此這是使用者體驗設計上的一個挑戰。傳送大量資料同樣的也不容易，特別是在傳送前處理某些複雜的資料成為我們需要的資料時。 在這篇文章，我們將要來看看如何面對這些挑戰 困難點緩慢與高度依賴伺服器回應當我們需要在伺服器端處理大量的 HTML 來回應使用者的請求時，速度理所當然就會變慢。更糟糕的是所謂的變慢，具體來說是指使用者的感覺。當使用者點擊連結或發出請求後如果不能很即時的看到畫面，他們就會感到不開心。 提升伺服器回應的速度一直都是提升效能的目的，一旦回應需要執行一個非常慢的操作時，這件事就會變的棘手。如果回應的資料不只很大，還牽扯到需要使用其他第三方服務或 API 可想而知這個回應會需要更多的處理時間。 AJAX 請求大量資料會很緩慢並容易出錯關於伺服器回應緩慢的問題也說明了為什麼 AJAX 在 Web 開發中如此重要，因為我們就不需要等待伺服器幫我們編譯完整的頁面，而是把所需的資料直接傳回即可。一旦取得資料我們就在客戶端渲染，這可以省下不少時間。 然而將資料操作整個轉移到前端不見得是最快的作法。有可能變慢的原因來自大部分的個人電腦並沒有比伺服器的規格來的高，同時網路品質也比較慢。使用者依然要等待所有資料下載完畢才能開始後續的處理，任何網路的問題都會造成資料不完全導致頁面無法正常呈現。 複數 AJAX 請求增加程式複雜度一個相對不錯的方式；就是我們可以將取回一整包大量資料的 AJAX 請求打散成許多較小的請求，然後各自處理在頁面上對應的部分。這種方式一般來說可以有效改善使用者體驗，因為使用者可以儘快的看到部分資料而不是等待整個頁面一起出現。同時程式在網絡不佳的情況下也可用性也增加許多，已經完成下載的部分就可以運作，部分下載失敗的資料則不影響已經下載好的部分。 但很多時候處理多個請求也不見得都是那麼簡單，我們客戶端程式的邏輯會因此變的複雜許多。 模擬問題與實作我們將要透過實作一個 Web 應用程式，使用它渲染顯示一張貓在陽光下的 8-bit 圖來示範如何解決這個難題。這張圖片的構成資訊會包含在 JSON 裡。裡面包含多個物件的陣列，每個物件有 x, y, color 屬性。而網頁頁面上將會是一個大的 div （一個 grid）包含許多小 div （row &amp; cell）大概可以將其看成一張方眼紙。我們希望一個格子對應一個點即使用物件中的 x, y, color，來完成這張圖。 限制這裡為了模擬更多造成問題的原因，我們加入了些條件限制： 多個資料來源首先是關於貓的部分，每個點的資料會存放在我們伺服器上的 JSON 檔案。然後關於太陽圖案的部分則是存在 Github 的 JSON 檔案。 回應大量資料我們的 JSON 將會不合理的包含大量資料，這主要是為了凸顯我們要處理的問題。事實上貓圖案部分的 JSON 額外包含 100 個不需要的屬性，讓這個檔案變得較大，大約是 500k。如果這樣您還是覺得很正常，沒關係我們太陽的部分將包含 600 個不需要的屬性，整個檔案大約會來到 1 mb。 不好的連線品質我們同時希望使用者可以在網絡不好的狀況下使用我們的程式。 解決方案我們的客戶端將會發出一個請求給伺服器。客戶端會有個事件處理程序，它會知道每當收到一個點的資料時該如何處理。接著，我們的伺服器端會使用串流的方式回應 JSON ，如此一來我們就不需要等到所有資料都取得才開始處理。 最終我們將通過一個串流資料的方式取得所有圖案所需的資料。伺服器端將各自從兩個串流的資料來源取得資料並合併。這麼做是因為我們要模擬許多現實的情況，即資料來源一個較快（從硬碟讀取），另一個較慢（從網絡讀取）。 工具Oboe.js, 接收並處理串流類型的 JSONoboe 讓我們在 JSON 整個完成傳輸之前便可以開始解析使用。一旦符合 pattern 格式的資料被解析完成就執行對應的動作。 1234567const source = 'url or readable stream'const pattern = 'string representing a node in the tree'oboe(source) .node(pattern, function (data) { // handle data }) Highland.js - 處理串流資料的函式庫一直以來我總是覺得自己實作串流機制的方式非常麻煩，而且容易不知道它們該怎麼和既有的工作流程整合。Highland.js 是一個函式庫，它使得串流資料變得容易被管理和操作。 123let data = ['one', 'two', 'three']highland(data) .pipe(anotherStream) 接收串流的回應我們將從客戶端開始作回來。首先是我們的回應是一個大量資料的 JSON，但我們不想等它們全部載完才開始動作。 第一步是使用 Oboe 來發起請求，Oboe 會在發出請求後開始解析回應。 1oboe('http://localhost:3000/data') 接著，我們要註冊兩個事件監聽用來處理回應。第一個會尋找 JSON 中具備 3 個屬性（x, y, color）的物件。在這個範例我們只會搜尋 pixels 陣列，接著我們就可以將資料更新到對應的元素上。 12345.node('{x y color}', function (point) { let grid = document.querySelector('.grid) let cell = getCell(grid, point.x, point.y) cell.classList.add(point.color)}) 第二個監聽事件只會在整個回應都被解析完成時觸發一次 1234.done(function () { let el = document.querySelector('#status') el.textContent = 'All data loaded'}) 看看下面的範例會更有感覺： 範例 傳送串流類型的回應能夠處理串流的資料來源之後當然下一步，我們的應用程式將需要一個路由用來提供資料給客戶端。首先我們需要一個回應的樣板，讓我們可以組織 metadata 或其他屬性。重要的是後續當我們取得 pixels 陣列時可以知道該怎麼和這個字串化的物件合併。您可以把這個過程想成我們在使用像 ejs, pug 這類樣板引擎一樣。我們在需要後續填上資料的地方先留下一個佔位符 不懂這邊在說什麼，先耐著性子讀下去… 12345678910111213router.get('/data', function (req, res) { let response = { exif: { software: '', dateTime: '', dataTimeOriginal: '' }, pixif: { pixels: [&quot;#{pixels}&quot;] }, end: 'test' }}) res 物件是 express 傳到客戶端一個 WriteableStream，這意味著我們可以接續處理（pipe） ReadableStream 然後送到客戶端。然而它只能夠接收字串所以我們要將物件轉換成字串，這也是上面需要樣板機制來處理的原因。 1let json = JSON.stringify(response) 在轉換成字串後，我們將要切割 response ，我們就可以將 #{pixles} 前後的部分拆出來。 1let parts = json.split('&quot;#{pixels}&quot;') 現在我們可以將除了 pixels 之外的部分建立一個新的 highland stream。 1234highland({ parts[0], // before placeholder parts[1] // after placeholder}) 接著我麼可以在串流上使用 invoke 來讓串流的每個元素執行 split 並使用參數 ''，這表示我們串流中的內容會被切成一個個字元。 1.invoke('split', ['']) 然後我們要告訴 highland 我們想要依序讀取每個元素。如此一來 highland 就會先讀取 before 的部分直到完成才接著讀取 after 的部分。這點非常重要，因為我們需要的是一個符合規範的 JSON 不然的話我們取得的只是一堆亂碼。 1.sequence() 最後我們可以開始傳送串流。 1.pipe(res) 到這邊我們有了基本的概念，也知道 highland 可以協助我們處理串流的部分，甚至直接幫我們處理 express 回應的部分 12345678910111213141516171819202122router.get('/data', function (req, res, next) { var response = { exif: { software: 'http://make8bitart.com', dateTime: '2015-11-07T15:35:13.415Z', dateTimeOriginal: '2015-11-07T00:24:05.776Z' }, pixif: { pixels: [&quot;#{pixels}&quot;] }, end: 'test' } var json = JSON.stringify(response) var parts = json.split('&quot;#{pixels}&quot;') highland([ parts[0], parts[1] ]) .invoke('split', ['']) .sequence() .pipe(res)}) 在回應中加入資料這時我們的客戶端已經可以接收串流的回應了，我們可以繼續處理加上其他資料到這個回應中。現階段我們單純加入一些靜態的資料來驗證行為如同我們所想的。 123456789101112let points = [ { x: 1, y: 2, color: 'orange' }, { x: 2, y: 2, color: 'orange' }] 我們可以為這個陣列建立一個串流 1let pointsStream = highland(points) 剛剛提到 express 只能接收字串串流，所以這邊我們也要轉成字串，我們可以使用 map 來完成這個需求 1.map(point =&gt; JSON.stringify(point)) 這個剛建立的陣列串流會被塞進 &quot;#{points}&quot; 佔位符的位置，即放在陣列裡面。由於最終我們需要的是一個符合規範的 JSON 因此在這個串流的每個元素之間我們還缺少一個逗號。要完成這個需求我們可以通過下面的方法告訴串流物件幫我們在每個元素之間加上逗號。 1.intersperse(',') 現在我們可以將這個陣列的 stream 組進剛剛的 before 和 after 中間完成一個完整的串流 12345678highland([ parts[0], pointStream, parts[1]]).invoke('split', ['']).sequence().pipe(res) 從其他模組取得資料我們可以透過將資料拆離成模組簡化路由的程式 12let points = require('../data/points')let pointStream = points.getStream() 也就是說不管模組做什麼只要最後傳回一個 stream 給我們就好，其他組合的部分就如同上面說明。 從檔案取得貓圖案部分的資料現在讓我們來使用真的資料而不是我們模擬的假資料。首先我們需要從檔案讀取關於貓圖案的資料，將其一併從模組傳回。 1234function getDataStream () { let catPath = path.resolve(__dirname, './cat-points.json') let catSource = fs.createReadStream(catPath)} 關於檔案的內容將會是字串的串流，而我們最後需要的是物件的串流 1let catStream = getPointStream(catSource) 要完成這一步我們需要再次利用 Oboe。這麼做我們將可以在讀取檔案時，每當一個點完成讀取就執行對應的操作而不需要等到整個檔案載人完成。我們也會需要用到 highland 來建立 stream。這次我們使用 highland 並傳入一個 function 。該 function 有一個參數 push 。在 function 內我們會調用 push 傳入錯誤或 null 為第一個參數，第二個參數則是我們的資料。 1234567891011function getPointStream (sourceStream) { return highland(function (push) { oboe(sourceStream) .node('{x y color}', function (point) { push(null, point) }) .done(function () { push(null, highland.nil) }) })} 從網路讀取太陽圖案的資料最後一個難題則是將太陽圖案的點加到我們的回應。幸運的是前面我們已經完成了類似的任務。在 getDataStream 我們將類似處理貓圖案的部分加入其他點，只不過來源不同。這裡我們會使用 request 函式庫來取得在 Github 上面的檔案。這一步會是比較慢的操作。 幸運的是 request 會回傳一個可讀的 stream 我們可以將其傳入 getPointStream，Oboe 將會將其處理為跟 fs.getReadStream 一樣的結果。 12345function getDataStream () { let sunUrl = 'https://raw.githubusercontent.com/JuanCaicedo/better-json-through-streams/master/data/sun-points.json' let sunSource = request(sunUrl) let sunStream = getPointStream(sunSource)} 現在我們有兩個 stream 了，catStream 和 sunStream 我們想要將它們合併傳回。我們可以使用 highland 來處理這兩個 stream，使用 merge 來合併成一個 stream。 1234return highland([ catStream, sunStream]).merge() 總結設計應用程式搭配串流作為主要的資料傳輸手段是非常強大的。它讓我們可以更有彈性的處理資料傳輸的部分。 參考 Node.js Streams 完整範例 原文 - Better JSON through streams","link":"/2017/05/22/better-json-through-stream/"},{"title":"使用 Rails Webpacker 安裝 Foundation 6","text":"動機由於 foundation-rails 6.4.1 版本有個 Issue 目前還沒合併。加上 Rails 已經支援了 webpack 2.x。這篇文章純粹紀錄另外一種做法。 準備開始使用之前需要確保 ruby，node，yarn 已經安裝完成。 安裝流程12345678# 建立專案$ rails new &lt;project_name&gt; --webpack# 安裝 Foundation 相關套件$ yarn add jquery foundation-sites motion-ui# 安裝 script-loader （匯出至全域）$ yarn add script-loader 設定 script-loader新增 config/webpack/loaders/global.js 12345module.exports = { test: /^(jquery|foundation-sites)$/, exclude: /node_modules/, loader: 'script-loader'} 新增 config/webpack/app-config.js 擴充 webpack 設定 12345678910111213const webpack = require('webpack')module.exports = { shared: { plugins: [ new webpack.ProvidePlugin({ $: 'jquery', jQuery: 'jquery', &quot;window.jQuery&quot;: 'jquery' }) ] }} 修改 config/webpack/shared.js 1234567891011121314151617181920const webpack = require('webpack')const { basename, dirname, join, relative, resolve } = require('path')// &lt;略&gt;const appConfig = require('./app-config')module.exports = { // &lt;略&gt; plugins: appConfig.shared.plugins.concat([ new webpack.EnvironmentPlugin(JSON.parse(JSON.stringify(env))), new ExtractTextPlugin(env.NODE_ENV === 'production' ? '[name]-[hash].css' : '[name].css'), new ManifestPlugin({ publicPath: output.publicPath, writeToFileEmit: true }) ]), // &lt;略&gt;} 設定 Foundation 模組新增 app/javascript/packs/vendor.js 1import 'foundation' 新增 app/javascript/foundation 目錄。 新增 app/javascript/foundation/index.js 新增 app/javascript/foundation/application.scss 新增 app/javascript/foundation/_settings.scss 123456789// app/javascript/foundation/index.jsimport 'jquery'import 'foundation-sites'import './application.scss'$(document).ready(function () { $(document).foundation()}) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// app/javascript/foundation/application.scss@charset 'utf-8';@import 'settings';@import '~foundation-sites/scss/foundation';@import '~motion-ui/src/motion-ui';@include foundation-global-styles;@include foundation-grid;// @include foundation-flex-grid;@include foundation-xy-grid-classes;@include foundation-typography;@include foundation-button;@include foundation-forms;// @include foundation-range-input;@include foundation-accordion;@include foundation-accordion-menu;@include foundation-badge;@include foundation-breadcrumbs;@include foundation-button-group;@include foundation-callout;@include foundation-card;@include foundation-close-button;@include foundation-menu;@include foundation-menu-icon;@include foundation-drilldown-menu;@include foundation-dropdown;@include foundation-dropdown-menu;@include foundation-responsive-embed;@include foundation-label;@include foundation-media-object;@include foundation-off-canvas;@include foundation-orbit;@include foundation-pagination;@include foundation-progress-bar;// @include foundation-progress-element;// @include foundation-progress-element;// @include foundation-meter-element;@include foundation-slider;@include foundation-sticky;@include foundation-reveal;@include foundation-switch;@include foundation-table;@include foundation-tabs;@include foundation-thumbnail;@include foundation-title-bar;@include foundation-tooltip;@include foundation-top-bar;@include foundation-visibility-classes;@include foundation-float-classes;@include foundation-flex-classes;// @include foundation-prototype-classes;@include motion-ui-transitions;@include motion-ui-animations; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863// app/javascript/foundation/_settings.scss// Foundation for Sites Settings// -----------------------------//// Table of Contents://// 1. Global// 2. Breakpoints// 3. The Grid// 4. Base Typography// 5. Typography Helpers// 6. Abide// 7. Accordion// 8. Accordion Menu// 9. Badge// 10. Breadcrumbs// 11. Button// 12. Button Group// 13. Callout// 14. Card// 15. Close Button// 16. Drilldown// 17. Dropdown// 18. Dropdown Menu// 19. Flexbox Utilities// 20. Forms// 21. Label// 22. Media Object// 23. Menu// 24. Meter// 25. Off-canvas// 26. Orbit// 27. Pagination// 28. Progress Bar// 29. Prototype Arrow// 30. Prototype Border-Box// 31. Prototype Border-None// 32. Prototype Bordered// 33. Prototype Display// 34. Prototype Font-Styling// 35. Prototype List-Style-Type// 36. Prototype Overflow// 37. Prototype Position// 38. Prototype Rounded// 39. Prototype Separator// 40. Prototype Shadow// 41. Prototype Sizing// 42. Prototype Spacing// 43. Prototype Text-Decoration// 44. Prototype Text-Transformation// 45. Prototype Text-Utilities// 46. Responsive Embed// 47. Reveal// 48. Slider// 49. Switch// 50. Table// 51. Tabs// 52. Thumbnail// 53. Title Bar// 54. Tooltip// 55. Top Bar// 56. Xy Grid@import '~foundation-sites/scss/util/util';// 1. Global// ---------$global-font-size: 100%;$global-width: rem-calc(1200);$global-lineheight: 1.5;$foundation-palette: ( primary: #1779ba, secondary: #767676, tertiary: #ff00ff, success: #3adb76, warning: #ffae00, alert: #cc4b37,);$light-gray: #e6e6e6;$medium-gray: #cacaca;$dark-gray: #8a8a8a;$black: #0a0a0a;$white: #fefefe;$body-background: $white;$body-font-color: $black;$body-font-family: 'Helvetica Neue', Helvetica, Roboto, Arial, sans-serif;$body-antialiased: true;$global-margin: 1rem;$global-padding: 1rem;$global-position: 1rem;$global-weight-normal: normal;$global-weight-bold: bold;$global-radius: 0;$global-menu-padding: 0.7rem 1rem;$global-menu-nested-margin: 1rem;$global-text-direction: ltr;$global-flexbox: true;$global-prototype-breakpoints: false;$global-color-pick-contrast-tolerance: 0;$print-transparent-backgrounds: true;@include add-foundation-colors;// 2. Breakpoints// --------------$breakpoints: ( small: 0, medium: 640px, large: 1024px, xlarge: 1200px, xxlarge: 1440px,);$print-breakpoint: large;$breakpoint-classes: (small medium large);// 3. The Grid// -----------$grid-row-width: $global-width;$grid-column-count: 12;$grid-column-gutter: ( small: 20px, medium: 30px,);$grid-column-align-edge: true;$grid-column-alias: 'columns';$block-grid-max: 8;// 4. Base Typography// ------------------$header-font-family: $body-font-family;$header-font-weight: $global-weight-normal;$header-font-style: normal;$font-family-monospace: Consolas, 'Liberation Mono', Courier, monospace;$header-color: inherit;$header-lineheight: 1.4;$header-margin-bottom: 0.5rem;$header-styles: ( small: ( 'h1': ('font-size': 24), 'h2': ('font-size': 20), 'h3': ('font-size': 19), 'h4': ('font-size': 18), 'h5': ('font-size': 17), 'h6': ('font-size': 16), ), medium: ( 'h1': ('font-size': 48), 'h2': ('font-size': 40), 'h3': ('font-size': 31), 'h4': ('font-size': 25), 'h5': ('font-size': 20), 'h6': ('font-size': 16), ),);$header-text-rendering: optimizeLegibility;$small-font-size: 80%;$header-small-font-color: $medium-gray;$paragraph-lineheight: 1.6;$paragraph-margin-bottom: 1rem;$paragraph-text-rendering: optimizeLegibility;$code-color: $black;$code-font-family: $font-family-monospace;$code-font-weight: $global-weight-normal;$code-background: $light-gray;$code-border: 1px solid $medium-gray;$code-padding: rem-calc(2 5 1);$anchor-color: $primary-color;$anchor-color-hover: scale-color($anchor-color, $lightness: -14%);$anchor-text-decoration: none;$anchor-text-decoration-hover: none;$hr-width: $global-width;$hr-border: 1px solid $medium-gray;$hr-margin: rem-calc(20) auto;$list-lineheight: $paragraph-lineheight;$list-margin-bottom: $paragraph-margin-bottom;$list-style-type: disc;$list-style-position: outside;$list-side-margin: 1.25rem;$list-nested-side-margin: 1.25rem;$defnlist-margin-bottom: 1rem;$defnlist-term-weight: $global-weight-bold;$defnlist-term-margin-bottom: 0.3rem;$blockquote-color: $dark-gray;$blockquote-padding: rem-calc(9 20 0 19);$blockquote-border: 1px solid $medium-gray;$cite-font-size: rem-calc(13);$cite-color: $dark-gray;$cite-pseudo-content: '\\2014 \\0020';$keystroke-font: $font-family-monospace;$keystroke-color: $black;$keystroke-background: $light-gray;$keystroke-padding: rem-calc(2 4 0);$keystroke-radius: $global-radius;$abbr-underline: 1px dotted $black;// 5. Typography Helpers// ---------------------$lead-font-size: $global-font-size * 1.25;$lead-lineheight: 1.6;$subheader-lineheight: 1.4;$subheader-color: $dark-gray;$subheader-font-weight: $global-weight-normal;$subheader-margin-top: 0.2rem;$subheader-margin-bottom: 0.5rem;$stat-font-size: 2.5rem;// 6. Abide// --------$abide-inputs: true;$abide-labels: true;$input-background-invalid: get-color(alert);$form-label-color-invalid: get-color(alert);$input-error-color: get-color(alert);$input-error-font-size: rem-calc(12);$input-error-font-weight: $global-weight-bold;// 7. Accordion// ------------$accordion-background: $white;$accordion-plusminus: true;$accordion-title-font-size: rem-calc(12);$accordion-item-color: $primary-color;$accordion-item-background-hover: $light-gray;$accordion-item-padding: 1.25rem 1rem;$accordion-content-background: $white;$accordion-content-border: 1px solid $light-gray;$accordion-content-color: $body-font-color;$accordion-content-padding: 1rem;// 8. Accordion Menu// -----------------$accordionmenu-padding: $global-menu-padding;$accordionmenu-nested-margin: $global-menu-nested-margin;$accordionmenu-submenu-padding: $accordionmenu-padding;$accordionmenu-arrows: true;$accordionmenu-arrow-color: $primary-color;$accordionmenu-item-background: null;$accordionmenu-border: null;$accordionmenu-submenu-toggle-background: null;$accordion-submenu-toggle-border: $accordionmenu-border;$accordionmenu-submenu-toggle-width: 40px;$accordionmenu-submenu-toggle-height: $accordionmenu-submenu-toggle-width;$accordionmenu-arrow-size: 6px;// 9. Badge// --------$badge-background: $primary-color;$badge-color: $white;$badge-color-alt: $black;$badge-palette: $foundation-palette;$badge-padding: 0.3em;$badge-minwidth: 2.1em;$badge-font-size: 0.6rem;// 10. Breadcrumbs// ---------------$breadcrumbs-margin: 0 0 $global-margin 0;$breadcrumbs-item-font-size: rem-calc(11);$breadcrumbs-item-color: $primary-color;$breadcrumbs-item-color-current: $black;$breadcrumbs-item-color-disabled: $medium-gray;$breadcrumbs-item-margin: 0.75rem;$breadcrumbs-item-uppercase: true;$breadcrumbs-item-separator: true;$breadcrumbs-item-separator-item: '/';$breadcrumbs-item-separator-item-rtl: '\\\\';$breadcrumbs-item-separator-color: $medium-gray;// 11. Button// ----------$button-font-family: inherit;$button-padding: 0.85em 1em;$button-margin: 0 0 $global-margin 0;$button-fill: solid;$button-background: $primary-color;$button-background-hover: scale-color($button-background, $lightness: -15%);$button-color: $white;$button-color-alt: $black;$button-radius: $global-radius;$button-hollow-border-width: 1px;$button-sizes: ( tiny: 0.6rem, small: 0.75rem, default: 0.9rem, large: 1.25rem,);$button-palette: $foundation-palette;$button-opacity-disabled: 0.25;$button-background-hover-lightness: -20%;$button-hollow-hover-lightness: -50%;$button-transition: background-color 0.25s ease-out, color 0.25s ease-out;// 12. Button Group// ----------------$buttongroup-margin: 1rem;$buttongroup-spacing: 1px;$buttongroup-child-selector: '.button';$buttongroup-expand-max: 6;$buttongroup-radius-on-each: true;// 13. Callout// -----------$callout-background: $white;$callout-background-fade: 85%;$callout-border: 1px solid rgba($black, 0.25);$callout-margin: 0 0 1rem 0;$callout-padding: 1rem;$callout-font-color: $body-font-color;$callout-font-color-alt: $body-background;$callout-radius: $global-radius;$callout-link-tint: 30%;// 14. Card// --------$card-background: $white;$card-font-color: $body-font-color;$card-divider-background: $light-gray;$card-border: 1px solid $light-gray;$card-shadow: none;$card-border-radius: $global-radius;$card-padding: $global-padding;$card-margin-bottom: $global-margin;// 15. Close Button// ----------------$closebutton-position: right top;$closebutton-offset-horizontal: ( small: 0.66rem, medium: 1rem,);$closebutton-offset-vertical: ( small: 0.33em, medium: 0.5rem,);$closebutton-size: ( small: 1.5em, medium: 2em,);$closebutton-lineheight: 1;$closebutton-color: $dark-gray;$closebutton-color-hover: $black;// 16. Drilldown// -------------$drilldown-transition: transform 0.15s linear;$drilldown-arrows: true;$drilldown-padding: $global-menu-padding;$drilldown-nested-margin: 0;$drilldown-background: $white;$drilldown-submenu-padding: $drilldown-padding;$drilldown-submenu-background: $white;$drilldown-arrow-color: $primary-color;$drilldown-arrow-size: 6px;// 17. Dropdown// ------------$dropdown-padding: 1rem;$dropdown-background: $body-background;$dropdown-border: 1px solid $medium-gray;$dropdown-font-size: 1rem;$dropdown-width: 300px;$dropdown-radius: $global-radius;$dropdown-sizes: ( tiny: 100px, small: 200px, large: 400px,);// 18. Dropdown Menu// -----------------$dropdownmenu-arrows: true;$dropdownmenu-arrow-color: $anchor-color;$dropdownmenu-arrow-size: 6px;$dropdownmenu-arrow-padding: 1.5rem;$dropdownmenu-min-width: 200px;$dropdownmenu-background: $white;$dropdownmenu-submenu-background: $dropdownmenu-background;$dropdownmenu-padding: $global-menu-padding;$dropdownmenu-nested-margin: 0;$dropdownmenu-submenu-padding: $dropdownmenu-padding;$dropdownmenu-border: 1px solid $medium-gray;$dropdown-menu-item-color-active: get-color(primary);$dropdown-menu-item-background-active: transparent;// 19. Flexbox Utilities// ---------------------$flex-source-ordering-count: 6;$flexbox-responsive-breakpoints: true;// 20. Forms// ---------$fieldset-border: 1px solid $medium-gray;$fieldset-padding: rem-calc(20);$fieldset-margin: rem-calc(18 0);$legend-padding: rem-calc(0 3);$form-spacing: rem-calc(16);$helptext-color: $black;$helptext-font-size: rem-calc(13);$helptext-font-style: italic;$input-prefix-color: $black;$input-prefix-background: $light-gray;$input-prefix-border: 1px solid $medium-gray;$input-prefix-padding: 1rem;$form-label-color: $black;$form-label-font-size: rem-calc(14);$form-label-font-weight: $global-weight-normal;$form-label-line-height: 1.8;$select-background: $white;$select-triangle-color: $dark-gray;$select-radius: $global-radius;$input-color: $black;$input-placeholder-color: $medium-gray;$input-font-family: inherit;$input-font-size: rem-calc(16);$input-font-weight: $global-weight-normal;$input-line-height: $global-lineheight;$input-background: $white;$input-background-focus: $white;$input-background-disabled: $light-gray;$input-border: 1px solid $medium-gray;$input-border-focus: 1px solid $dark-gray;$input-padding: $form-spacing / 2;$input-shadow: inset 0 1px 2px rgba($black, 0.1);$input-shadow-focus: 0 0 5px $medium-gray;$input-cursor-disabled: not-allowed;$input-transition: box-shadow 0.5s, border-color 0.25s ease-in-out;$input-number-spinners: true;$input-radius: $global-radius;$form-button-radius: $global-radius;// 21. Label// ---------$label-background: $primary-color;$label-color: $white;$label-color-alt: $black;$label-palette: $foundation-palette;$label-font-size: 0.8rem;$label-padding: 0.33333rem 0.5rem;$label-radius: $global-radius;// 22. Media Object// ----------------$mediaobject-margin-bottom: $global-margin;$mediaobject-section-padding: $global-padding;$mediaobject-image-width-stacked: 100%;// 23. Menu// --------$menu-margin: 0;$menu-nested-margin: $global-menu-nested-margin;$menu-items-padding: $global-menu-padding;$menu-simple-margin: 1rem;$menu-item-color-active: $white;$menu-item-background-active: get-color(primary);$menu-icon-spacing: 0.25rem;$menu-item-background-hover: $light-gray;$menu-state-back-compat: true;$menu-centered-back-compat: true;// 24. Meter// ---------$meter-height: 1rem;$meter-radius: $global-radius;$meter-background: $medium-gray;$meter-fill-good: $success-color;$meter-fill-medium: $warning-color;$meter-fill-bad: $alert-color;// 25. Off-canvas// --------------$offcanvas-size: 250px;$offcanvas-vertical-size: 250px;$offcanvas-background: $light-gray;$offcanvas-shadow: 0 0 10px rgba($black, 0.7);$offcanvas-inner-shadow-size: 20px;$offcanvas-inner-shadow-color: rgba($black, 0.25);$offcanvas-overlay-zindex: 11;$offcanvas-push-zindex: 12;$offcanvas-overlap-zindex: 13;$offcanvas-reveal-zindex: 12;$offcanvas-transition-length: 0.5s;$offcanvas-transition-timing: ease;$offcanvas-fixed-reveal: true;$offcanvas-exit-background: rgba($white, 0.25);$maincontent-class: 'off-canvas-content';// 26. Orbit// ---------$orbit-bullet-background: $medium-gray;$orbit-bullet-background-active: $dark-gray;$orbit-bullet-diameter: 1.2rem;$orbit-bullet-margin: 0.1rem;$orbit-bullet-margin-top: 0.8rem;$orbit-bullet-margin-bottom: 0.8rem;$orbit-caption-background: rgba($black, 0.5);$orbit-caption-padding: 1rem;$orbit-control-background-hover: rgba($black, 0.5);$orbit-control-padding: 1rem;$orbit-control-zindex: 10;// 27. Pagination// --------------$pagination-font-size: rem-calc(14);$pagination-margin-bottom: $global-margin;$pagination-item-color: $black;$pagination-item-padding: rem-calc(3 10);$pagination-item-spacing: rem-calc(1);$pagination-radius: $global-radius;$pagination-item-background-hover: $light-gray;$pagination-item-background-current: $primary-color;$pagination-item-color-current: $white;$pagination-item-color-disabled: $medium-gray;$pagination-ellipsis-color: $black;$pagination-mobile-items: false;$pagination-mobile-current-item: false;$pagination-arrows: true;// 28. Progress Bar// ----------------$progress-height: 1rem;$progress-background: $medium-gray;$progress-margin-bottom: $global-margin;$progress-meter-background: $primary-color;$progress-radius: $global-radius;// 29. Prototype Arrow// -------------------$prototype-arrow-directions: ( down, up, right, left);$prototype-arrow-size: 0.4375rem;$prototype-arrow-color: $black;// 30. Prototype Border-Box// ------------------------$prototype-border-box-breakpoints: $global-prototype-breakpoints;// 31. Prototype Border-None// -------------------------$prototype-border-none-breakpoints: $global-prototype-breakpoints;// 32. Prototype Bordered// ----------------------$prototype-bordered-breakpoints: $global-prototype-breakpoints;$prototype-border-width: rem-calc(1);$prototype-border-type: solid;$prototype-border-color: $medium-gray;// 33. Prototype Display// ---------------------$prototype-display-breakpoints: $global-prototype-breakpoints;$prototype-display: ( inline, inline-block, block, table, table-cell);// 34. Prototype Font-Styling// --------------------------$prototype-font-breakpoints: $global-prototype-breakpoints;$prototype-wide-letter-spacing: rem-calc(4);$prototype-font-normal: $global-weight-normal;$prototype-font-bold: $global-weight-bold;// 35. Prototype List-Style-Type// -----------------------------$prototype-list-breakpoints: $global-prototype-breakpoints;$prototype-style-type-unordered: ( disc, circle, square);$prototype-style-type-ordered: ( decimal, lower-alpha, lower-latin, lower-roman, upper-alpha, upper-latin, upper-roman);// 36. Prototype Overflow// ----------------------$prototype-overflow-breakpoints: $global-prototype-breakpoints;$prototype-overflow: ( visible, hidden, scroll);// 37. Prototype Position// ----------------------$prototype-position-breakpoints: $global-prototype-breakpoints;$prototype-position: ( static, relative, absolute, fixed);$prototype-position-z-index: 975;// 38. Prototype Rounded// ---------------------$prototype-rounded-breakpoints: $global-prototype-breakpoints;$prototype-border-radius: rem-calc(3);// 39. Prototype Separator// -----------------------$prototype-separator-breakpoints: $global-prototype-breakpoints;$prototype-separator-align: center;$prototype-separator-height: rem-calc(2);$prototype-separator-width: 3rem;$prototype-separator-background: $primary-color;$prototype-separator-margin-top: $global-margin;// 40. Prototype Shadow// --------------------$prototype-shadow-breakpoints: $global-prototype-breakpoints;$prototype-box-shadow: 0 2px 5px 0 rgba(0,0,0,.16), 0 2px 10px 0 rgba(0,0,0,.12);// 41. Prototype Sizing// --------------------$prototype-sizing-breakpoints: $global-prototype-breakpoints;$prototype-sizing: ( width, height);$prototype-sizes: ( 25: 25%, 50: 50%, 75: 75%, 100: 100%);// 42. Prototype Spacing// ---------------------$prototype-spacing-breakpoints: $global-prototype-breakpoints;$prototype-spacers-count: 3;// 43. Prototype Text-Decoration// -----------------------------$prototype-decoration-breakpoints: $global-prototype-breakpoints;$prototype-text-decoration: ( overline, underline, line-through,);// 44. Prototype Text-Transformation// ---------------------------------$prototype-transformation-breakpoints: $global-prototype-breakpoints;$prototype-text-transformation: ( lowercase, uppercase, capitalize);// 45. Prototype Text-Utilities// ----------------------------$prototype-utilities-breakpoints: $global-prototype-breakpoints;$prototype-text-overflow: ellipsis;// 46. Responsive Embed// --------------------$responsive-embed-margin-bottom: rem-calc(16);$responsive-embed-ratios: ( default: 4 by 3, widescreen: 16 by 9,);// 47. Reveal// ----------$reveal-background: $white;$reveal-width: 600px;$reveal-max-width: $global-width;$reveal-padding: $global-padding;$reveal-border: 1px solid $medium-gray;$reveal-radius: $global-radius;$reveal-zindex: 1005;$reveal-overlay-background: rgba($black, 0.45);// 48. Slider// ----------$slider-width-vertical: 0.5rem;$slider-transition: all 0.2s ease-in-out;$slider-height: 0.5rem;$slider-background: $light-gray;$slider-fill-background: $medium-gray;$slider-handle-height: 1.4rem;$slider-handle-width: 1.4rem;$slider-handle-background: $primary-color;$slider-opacity-disabled: 0.25;$slider-radius: $global-radius;// 49. Switch// ----------$switch-background: $medium-gray;$switch-background-active: $primary-color;$switch-height: 2rem;$switch-height-tiny: 1.5rem;$switch-height-small: 1.75rem;$switch-height-large: 2.5rem;$switch-radius: $global-radius;$switch-margin: $global-margin;$switch-paddle-background: $white;$switch-paddle-offset: 0.25rem;$switch-paddle-radius: $global-radius;$switch-paddle-transition: all 0.25s ease-out;// 50. Table// ---------$table-background: $white;$table-color-scale: 5%;$table-border: 1px solid smart-scale($table-background, $table-color-scale);$table-padding: rem-calc(8 10 10);$table-hover-scale: 2%;$table-row-hover: darken($table-background, $table-hover-scale);$table-row-stripe-hover: darken($table-background, $table-color-scale + $table-hover-scale);$table-is-striped: true;$table-striped-background: smart-scale($table-background, $table-color-scale);$table-stripe: even;$table-head-background: smart-scale($table-background, $table-color-scale / 2);$table-head-row-hover: darken($table-head-background, $table-hover-scale);$table-foot-background: smart-scale($table-background, $table-color-scale);$table-foot-row-hover: darken($table-foot-background, $table-hover-scale);$table-head-font-color: $body-font-color;$table-foot-font-color: $body-font-color;$show-header-for-stacked: false;$table-stack-breakpoint: medium;// 51. Tabs// --------$tab-margin: 0;$tab-background: $white;$tab-color: $primary-color;$tab-background-active: $light-gray;$tab-active-color: $primary-color;$tab-item-font-size: rem-calc(12);$tab-item-background-hover: $white;$tab-item-padding: 1.25rem 1.5rem;$tab-expand-max: 6;$tab-content-background: $white;$tab-content-border: $light-gray;$tab-content-color: $body-font-color;$tab-content-padding: 1rem;// 52. Thumbnail// -------------$thumbnail-border: solid 4px $white;$thumbnail-margin-bottom: $global-margin;$thumbnail-shadow: 0 0 0 1px rgba($black, 0.2);$thumbnail-shadow-hover: 0 0 6px 1px rgba($primary-color, 0.5);$thumbnail-transition: box-shadow 200ms ease-out;$thumbnail-radius: $global-radius;// 53. Title Bar// -------------$titlebar-background: $black;$titlebar-color: $white;$titlebar-padding: 0.5rem;$titlebar-text-font-weight: bold;$titlebar-icon-color: $white;$titlebar-icon-color-hover: $medium-gray;$titlebar-icon-spacing: 0.25rem;// 54. Tooltip// -----------$has-tip-cursor: help;$has-tip-font-weight: $global-weight-bold;$has-tip-border-bottom: dotted 1px $dark-gray;$tooltip-background-color: $black;$tooltip-color: $white;$tooltip-padding: 0.75rem;$tooltip-max-width: 10rem;$tooltip-font-size: $small-font-size;$tooltip-pip-width: 0.75rem;$tooltip-pip-height: $tooltip-pip-width * 0.866;$tooltip-radius: $global-radius;// 55. Top Bar// -----------$topbar-padding: 0.5rem;$topbar-background: $light-gray;$topbar-submenu-background: $topbar-background;$topbar-title-spacing: 0.5rem 1rem 0.5rem 0;$topbar-input-width: 200px;$topbar-unstack-breakpoint: medium;// 56. Xy Grid// -----------$xy-grid: true;$grid-container: $global-width;$grid-columns: 12;$grid-margin-gutters: ( small: 20px, medium: 30px);$grid-padding-gutters: $grid-margin-gutters;$block-grid-max: 8; 測試1$ rails g controller pages index 開啟 app/views/layouts/application.html.erb 於 &lt;head&gt; 加入 12&lt;%= stylesheet_pack_tag 'vendor' %&gt;&lt;%= javascript_pack_tag 'vendor' %&gt; 開啟 app/views/pages/index.html.erb 加入 123456789101112131415161718192021222324252627&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;columns&quot;&gt; &lt;ul class=&quot;accordion&quot; data-accordion&gt; &lt;li class=&quot;accordion-item is-active&quot; data-accordion-item&gt; &lt;a href=&quot;#&quot; class=&quot;accordion-title&quot;&gt;Accordion 1&lt;/a&gt; &lt;div class=&quot;accordion-content&quot; data-tab-content &gt; &lt;p&gt;Panel 1. Lorem ipsum dolor&lt;/p&gt; &lt;a href=&quot;#&quot;&gt;Nowhere to Go&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class=&quot;accordion-item&quot; data-accordion-item&gt; &lt;a href=&quot;#&quot; class=&quot;accordion-title&quot;&gt;Accordion 2&lt;/a&gt; &lt;div class=&quot;accordion-content&quot; data-tab-content&gt; &lt;textarea&gt;&lt;/textarea&gt; &lt;button class=&quot;button&quot;&gt;I do nothing!&lt;/button&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class=&quot;accordion-item&quot; data-accordion-item&gt; &lt;a href=&quot;#&quot; class=&quot;accordion-title&quot;&gt;Accordion 3&lt;/a&gt; &lt;div class=&quot;accordion-content&quot; data-tab-content&gt; Type your name! &lt;input type=&quot;text&quot;&gt;&lt;/input&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 執行開發伺服器，開啟兩個 terminal 分別執行 12$ bin/webpack-dev-server$ rails server 瀏覽 http://localhost:3000，完成測試。 結論此方法善用了 webpacker 提供的功能也讓我們可以設定 scss 檔案。提供了除了使用 foundation-rails 外的另一種方式。 範例程式 注意 Foundation 的 scss 不斷在更新，內容中 scss 的部分應對照 Foundation 官方釋出的版本。","link":"/2017/07/10/rails-webpacker-with-foundation/"},{"title":"[譯] sphinx-js 介紹 - Javascript 專案的文件工具","text":"很長一段時間在 javascript 專案，文件的部分並沒有什麼好用的工具。JSDoc 大概是這個領域中唯一的競爭者，並且其設計中有些非常不錯的地方： jsdoc 本質上是程式碼中的註解，通過特定格式的註解搭配指令工具協助我們產生文件，另外也有許多 IDE 使用它來支援提示說明的功能。 明確定義用於描述的結構像是 @constructor, @param 等標籤非常清楚。 像是 Closure COmpiler 這類工具在編譯過程中處理該定義的標籤。 雖然許多編譯工具支援解析這種註解結構但輸出的僅僅只是一個列表針對 functino 或片段程式碼說明的整理而已。根據產出的說明，新的使用者大概可以快速理解整個輪廓和參數的用法。這對小型的函式庫或 API 來說非常實用了。但對於大型專案包含著複雜的概念時就不是這邊方便了。如果我們想要在這些擷取自註解的文件上作點組織編排，加上解釋和介紹，編寫整個段落的說明並附上連結等等，jsdoc 就顯得不夠出色了。 Python 的開發者們長期以來一直習慣使用 Sphinx 來作為它們的專案文件工具，同時這個工具支援許多語言也可以根據需求匯出不同格式的文件，它所支援的索引功能，搜尋，引用參考更顯出這個工具的強大。 甚至有人使用它撰寫了一本書，通過搭配一些套件例如：圖表、Youtube 影片等等都可以產生。不過台的 javascript 版本一直不支援從程式碼擷取文件說明的功能。 現在，sphinx-js 支援了這個功能，給 javascript 開發者一個兩全其美的方案。 sphinx-js 一樣採用標準 jsdoc 的註解格式，您不需要在程式中在加入其他髒髒的東西。事實上它解析的部分仍然是交給 jsdoc 處理。我們只需要在專案的根目錄中初始化 docs 目錄，接著就可以使用 reStructuredText 來撰寫組織文件了，那麼我們該怎麼組織文件呢？我們可以使用 sphinx-js 提供的語法，參考 autodoc 的範例。大致上使用起來像下面這個範例： 1.. autofunction:: linkDensity 然後 sphinx 就會自動去找到該 function： 12345678910111213/** * Return the ratio of the inline text length of the links in an element to * the inline text length of the entire element. * * @param {Node} node - The node whose density to measure * @throws {EldritchHorrorError|BoredomError} If the expected laws of the * universe change, raise EldritchHorrorError. If we're getting bored of * said laws, raise BoredomError. * @returns {Number} A ratio of link length to overall text length: 0..1 */function linkDensity(node) { ...} 接著產生文件 當我們想要追加一些比較長得範例時，我們就可以體會到 sphinx 的彈性了，不需要在 linkDensity 上面的註解加東西。而是在 reStructuredText 檔案。 1234.. autofunction:: linkDensity Anything you type here will be appended to the function's description right after its return value. It's a great place for lengthy examples! 另外針對 ECMAScript 2015 不管時構造函數還是新的 class 語法糖都可以使用 @class 標記，它會自動遍歷類別成員產生文件。您也可以控制其順序、把 private 的類別成員關閉顯示、所有 sphinx 在 python 支援的功能都可以使用。 比起已經非常成熟的 python 慣例 sphinx-js 還支援了參考的用法以避免在同一個 js 物件實例同名碰撞的情況。例如 一個物件有一個靜態方法 foo同時又有一個物件實例方法 foo 這個時候就可以使用 jsdoc 的 namepaths。舉例來說： object#foo 是物件實例的方法 object.foo 是靜態方法 object~foo 是內部成員或函數 由於 jsdoc 仍然負責處理分析註解的任務，所以我們可以利用其相對理解 js 的優勢。因為 js 語言巢狀的特性使得它可以變得非常複雜，誰會希望自己編寫寫下面這樣的完整路徑 1some/file.Class#InstanceMethod.staticMethod~innerMember 幸好，sphinx-js 會自動索引採用 suffix tree 的演算法，簡單說就是會由後面判斷回來，所以我們可以直接就用 innerMember 就好，那如果有另外一個物件也有一個同樣名稱的 innerMember 呢？那我們就往前加一層 staticMethod~innerMember 以此類推直到兩者都成為唯一值。這讓我們可以不用總是寫完整路徑。 使用非常成熟的 sphinx 搭配 jsdoc 的優勢：sphinx-js 成為了一個非常傑出的文件工具，給我們一個新的方式來組織大型 js 專案的文件。如果您已經躍躍欲試的話可以先參考sphinx-js 入門，如果您需要參考一些範例可以看看Fathom 文件 - Rule and Ruleset Reference。 資源 原文 jsdoc sphinx sphinx-js suffix tree 說明","link":"/2017/08/01/sphinxjs/"},{"title":"Rails Webpacker 筆記","text":"在 Javascript 不斷快速變化的今日，對 Rails 而言一直有個相對支援度較不足的地方，那就是支援一些較新的 Javascript 封裝機制（bundle）。不過從 5.1 開始這個大家希望的功能將會支援 - 全新的 webpacker gem。 Rails 5.1 開始內建可以使用 --webpack 參數開啟支援 webpacker 和 yarn，並且支援整合 React，Angular，Vue，elm 等。 建立在開始使用之前我們需要確保 ruby，node，yarn 已經安裝。至於 node 和 yarn 的安裝步驟請參考官方文件。 筆者建議使用 nvm \b安裝 node，並使用 npm 安裝 yarn。這麼做是因為在使用 nvm 支援切換 node 版本的情況下 yarn 安裝全域函式庫\b可能會遇上一些問題。Github Issue \b建立專案 123456$ rails new &lt;project_name&gt; --webpack# 支援其他函式庫$ rails new app --webpack=react$ rails new app --webpack=angular$ rails new app --webpack=vue 這個新的參數 --webpack 會在 Rails 5.1 應用程式建立之後安裝與設定 yarn 與 webpack。一旦應用程式建立，webpacker 也會被安裝，我們就可以在 Rails 中使用 webpack 了。 如果我們的專案是已存在的 4.2 Rails 應用程式那麼可以使用 Gemfile 安裝 webpacker，在安裝 Gem 之後執行： 12$ rails webpacker:install$ rails webpacker:install:vue 除了安裝指令之外我們還可以透過下面的指令查詢 Rails 提供的相關指令 12$ bundle exec rails webpacker$ bundle exec rails -T 設定維持 Rails 一貫的精神，webpacker 一樣也具備一些預設慣例 目錄架構首先，我們來看看這個新的目錄 app/javascript。這個目錄就是用來放置 webpack 將要編譯的 Javascript 檔案，當然也包含 webpack 的 entry 檔，即 packs/ 下的檔案。依據慣例 webpack 的進入點檔案(entry)預設放在 app/javascript/packs，然後其他模組或元件可以放在 app/javascript 目錄下。意思是說假如我們有個 app/javascript/modules/test.js 的 library，在 packs 中的進入檔只要 import test from 'modules/test.js' 就可以載入了。注意到我們可以使用相對路徑 ./modules/test.js 或使用模組路徑的方式。 webpack 設定Rails 的產生器會幫我們加入各種環境使用的 webpack 設定檔到 config/webpack 目錄下。這些設定檔針對不同環境（production/development/test）提供了對應的 webpack 功能，例如：code-splitting，asset-fingerprinting，樣式的部分還支援了 post-css。 Live reloadingwebpacker 還提供了 binstub 可以讓我們執行 webpack-dev-server，在開發環境下可以提供 live reloading 的功能，如果要使用額外的 HRM(Hot Module Replacement) 功能的話則需要安裝其他套件。 整合練習1. 設定/使用 foreman首先讓我們在 Gemfile 的 development 群組中加入 foreman 並安裝來管理多個程序，這是因為我們除了原本的 rails server 這道程序外還需要 bin/webpack-dev-server。接著在專案根目錄建立 Procfile 和 Procfile.dev 設定 foreman。 1web: bundle exec puma -p $PORT 12web: bundle exec rails serverwebpacker: ./bin/webpack-dev-server 同時我們也建立一個簡單的 binstub 用它來執行 foreman 套用 Procfile.dev。在 bin/ 目錄底下建立一個 server 檔案。 123#!/bin/bash -ibundle installbundle exec foreman start -f Procfile.dev 為了能夠執行，我們需要賦予該檔案執行權限 1$ chmod +x bin/server 之後，我們就可以執行下面指令一口氣開啟 rails server 和 webpack-dev-server 1$ ./bin/server 注意：使用 foreman 之後，存取網址會變成 http://localhost:5000 2. 撰寫程式碼現在我們來試著加入一個 counter 模組，第一步我們在 app/javascript 中建立一個 counter 目錄，如上面提到的 webpack 處理的檔案都放置在此，這個 counter 目錄代表著一個模組。然後在這個 counter 目錄中建立兩個檔案 index.js 和 counter.js counter.js 1234567891011121314151617181920212223const incrementNode = document.getElementById('increment')const decrementNode = document.getElementById('decrement')const inputNode = document.getElementById('counter')const counter = { initialize () { incrementNode.addEventListener('click', (event) =&gt; { event.preventDefault() const currentVal = inputNode.value inputNode.value = ~~currentVal + 1 }) decrementNode.addEventListener('click', (event) =&gt; { event.preventDefault() const currentVal = inputNode.value if (currentVal &gt; 0) { inputNode.value = ~~currentVal - 1 } }) }}export default counter index.js 1234567// 不使用相對路徑可以從 `app/javascript` 當作根// import counter from 'counter/counter'import counter from './counter'document.addEventListener('DOMContentLoaded', () =&gt; { counter.initialize()}) 再來為了讓 webpck 處理這個模組我們需要一個進入檔，在 packs/ 目錄下建立 counter.js 檔案。 1import 'counter' 再次強調，不使用相對路徑的話可以把 app/javascript 當作根來取路徑。 3. 建立 view為了展示我們的 counter 模組，讓我們建立一個簡單的 controller 1$ bundle exec rails g controller pages index 這邊單純是為了示範，我們就直接把這個 action 的路由設成 root。修改 routes.rb 1root to: 'pages#index' 最後，我們修改 pages/index.html.erb 12345678910&lt;div class=&quot;counter-wrapper&quot;&gt; &lt;h1&gt;Counter&lt;/h1&gt; &lt;form class=&quot;counter&quot;&gt; &lt;button id=&quot;increment&quot;&gt;Increment +&lt;/button&gt; &lt;input type=&quot;number&quot; name=&quot;counter&quot; id=&quot;counter&quot; value=&quot;0&quot;&gt; &lt;button id=&quot;decrement&quot;&gt;Decrement -&lt;/button&gt; &lt;/form&gt;&lt;/div&gt;&lt;%= javascript_pack_tag 'counter' %&gt; 這邊的重點在 javascript_pack_tag 這個 helper 可以協助我們取得編譯好的 counter script。產出來的 tag 如下 1&lt;script src=”http://localhost:8080/counter.js&quot;&gt;&lt;/script&gt; 4. 執行我們已經完成了整個範例，接著就可以測試看看 1$ bin/server rails server 和 webpack-dev-server 啟動後我們便可以瀏覽 http://localhost:5000/ 看看我們完成的範例。 5. 樣式webpack 強大的地方在於它不僅可以處理 Javascript，只要搭配 loader，也是可以處理各種類型的檔案。這邊我們將示範使用 scss。建立 app/javascript/counter/style.scss 12345678910111213141516171819202122$grey: #f2f2f2;.counter-wrapper { max-width: 500px; margin: 100px auto; padding: 10px; border: 1px solid $grey; form { display: block; margin-bottom: 10px; button { display: inline-block; background: #4fc08d; color: white; border: 1px solid $grey; padding: 5px; border-radius: 5px; } }} 回到 index.js 我們匯入 scss 123456import './style.scss'import counter from './counter'document.addEventListener('DOMContentLoaded', () =&gt; { counter.initialize()}) 就可以在 view 中使用 stylesheet_pack_tag helper。 1&lt;%= stylesheet_pack_tag 'counter' %&gt; 我們回到瀏覽器便可以觀察到 live reload 已經幫我們更新好頁面了，並且樣式的部分增加了如下的 tag 1&lt;link rel=&quot;stylesheet&quot; media=&quot;screen&quot; href=&quot;http://localhost:8080/counter.css&quot;&gt; 部署\b這一小結我們\b來看看關於部署的部分，尤其是部署到 Heroku。假如我們使用 webpacker 那麼 Heroku 預設就會安裝 yarn 和 node。 123$ heroku create$ heroku addons:create heroku-postgresql:hobby-dev$ git push heroku master 參考 webpacker 入門 webpacker github","link":"/2017/08/01/rails-webpacker/"},{"title":"[譯]您閱讀的 Nodejs&#x2F;Express.js 驗證機制教學（很可能)錯了","text":"原文：Your Node.js authentication tutorial is (probably) wrong 最近花了些時間搜尋、研究 Node.js/Express.js 有關驗證機制的教學。大部分的文章要不是不夠完整，要嘛就是在安全性的部分有錯，並可能造成用戶潛在的風險。這篇文章預計要探討這些常見驗證機制的問題、陷阱，以及點出該如何避免發生。同時也檢視一下自己閱讀或寫作的教學。在撰寫文章的同時我仍然在尋找更穩固的全方位驗證方案（會員功能）。同時我也希望可以找到 Nodejs/Express.js 中可以和 Rails 的 Devise 匹敵的方案。 一直以來，在我閒暇的時候一直都在研究、學習各種 Node.js 的教學，似乎每個 Node.js 的開發者都有自己的部落格且習慣分享他們如何正確的完成任務，更準確的說是他們如何完成任務並不一定是正確的。大量的前端開發者開始需要處理後端的程式，進入了後端的世界，嘗試從散落各地片段的教學和程式碼組合出能用的東西，不管是只會複製貼上不懂原理類型的開發者（Cargo Cult Programmer）又或者極度依賴 npm 套件類型的開發者，大家都希望快速的在期限前完成專案。 糟糕的是在 Node.js 世界裡，實作驗證機制某種程度上其實是對開發者的考驗，大部分的開發者都是在摸索中完成功能的，您大概能找到的解決方案就是 Passport。如果我們想要更完整的方案，類似 Ruby on Rails 的套件 Devise 也只能勉強參考 Auth0 這樣的服務。比起 Devise，Passport 只是一個簡單的中介軟體（Middleware），除了驗證之外並沒有提供其他完整驗證機制需要的功能，意思是說 Node.js 的開發者需要自己處理 API token 的機制，重設密碼，更新 token，驗證機制，路由設計，甚至是樣板的部分。有很多的教學在介紹如何使用 Passport 但它們幾乎都有些錯，也沒有完整的實作和處理一個網頁應用程式應該要具備的完整功能。 這裡並不是要跟其他提供教學的作者引戰，不過我們的確會透過他們的範例來說明一些安全性議題上的錯誤。如果您也是某篇教學的作者歡迎您在更新您的教學之後和原文作者聯絡。讓我們一起為了 Node 的安全性作些貢獻。 容易犯錯的地方 1 - 憑證儲存 Credential Storage讓我們從儲存憑證開始。儲存及使用憑證來核對對於認證身份是一種非常基本的方式，這裡說憑證可能比較術語一些，其實就是密碼的角色。過去我們比較常在資料庫或應用程式中處理。而 passport 作為一個 middleware 它其實只幫我們執行 “這個使用者可以放行” 或者 “不行喔！這個使用者沒有權限”的判斷。所以 passport 需要搭配使用驗證機制（策略）像是 passport-local 模組來完成儲存憑證的部分即協助處理存資料庫的部分，此時驗證的憑證就是存在資料庫的密碼。passport-local 也是 possport 作者寫的 strategy。 strategy 翻成策略，大略來說就是如何執行驗證的方式，憑證怎麼來？像是從資料庫的會員資料驗證或者 Facebook 登入等方式。 在我們更深入之前，我們可以參考一份 OWASP 的建議說明 great cheat sheet for password storage，總結來說就是使用 salt （鹽）加密並儲存高度複雜性不可逆的密碼。Coda Hale 的寫的如何儲存密碼也提供了一些建議，雖然它有些爭議。 一些有經驗的開發者可能想要使用 Argon2 - 密碼雜湊競賽的贏家，而且在 Nodejs 可以輕鬆的透過函式庫使用。不過比較可惜的是關於 Argon2 的實作文件和資料在 Nodejs 社群中是比較不足的。畢竟這樣的主題針對性比較強，不如直接使用 bcrypt 。 作為一個 Express.js 和 Passport 新手，第一個看的資料便是 passport-local 的範例，感謝提供了 express 4.x 的範例，不過在這個範例中並不支援資料庫，同時它假設我們會寫死一些帳號，在實際應用上沒啥太大的幫助。 這個範例只展示了一個流程架構，範例中的密碼並沒有加密，並且使用明碼儲存，驗證資料的儲存和相關的加密處理更不在它包含的範圍中。 好吧！讓我們 Google 看看有沒有其他使用 passport-local 的教學。首先找到了 RisingStack 的 Node Hero 系列文章，但這篇文章和官方的範例有相同的問題（該文章在 2017-08-07 補上 bcrypt 加密的部分) 可以說我們提到的文章都是挑過的。沒錯，挑過的意思其實就是 Google 搜尋的前幾個結果。有關 passport-local 稍微完整一點的教學是來自 TutsPlus 的這篇。它使用了 bcrypt 搭配 cost 參數為 10 （定義參數你想要跑多慢，2 的幾次方次）。另外一篇比較值得推薦的教學是來自 scotch.io 的教學 同樣是使用 bcrypt 搭配成本參數為 8。不過這些成本參數真的太低了，目前大部分的 bcrypt 函式庫預設使用 12。 除了儲存密碼的部分這些教學都沒有實作關於重設密碼等相關功能。 補充 容易犯錯的地方 2 - 密碼重置僅次於密碼儲存問題的就是重設密碼，然而在這個部分卻沒有任何基本的教學說明如何使用 passport 實作。密碼重置功能實作上有太多地方可能犯錯，但在這方面卻沒有比較完整的教學，其中最常見犯的錯誤： 可預測的 token：重新設定密碼時需要的驗證 token 是個容易犯錯的地方，使用時間戳記來當 token 就是一個常見的錯誤，寧可使用基本的亂數產生器也不要讓 token 容易被推測出來。 錯誤的儲存：在資料庫中使用未加密的重設密碼 token，這意味著一旦資料庫資料外洩，這些 token 等於有效的密碼。使用隨機碼加密來產生長度較長的 token ，這樣也可以防範攻擊者直接從遠端針對 token 暴力破解。 重置密碼的 token 就跟密碼本身一樣重要應該要被謹慎處理。 token 不會過期失效：一旦 token 不會過期就表示我們給予攻擊者更多的時間去試。 缺少第二層（階段)的資料驗證：常見的安全問題其實就是一種針對重設密碼的第二層驗證，不過關於安全問題也是有這個機制的問題存在。 在驗證的三種方式中 * something you Know * something you Have * something you Are 我們知道 Email 是屬於 something you have 你有這個東西才能通過認證，而不像密碼僅屬於 something you know。也因此我們有必要使用這種方式來實作忘記密碼可以增加一層保護，於是 Email 在流程上便扮演著非常重要的角色，因為我們只會把 token 寄送到該信箱。 Something You Know, Have, or Are 如果您剛接觸處理重設定密碼的功能，建議您看看 Password Reset Cheat Sheet。現在讓我們回到 Node 的世界。 我們到 npm 上面搜尋看看有沒有人實作重置密碼相關的函式庫，我們只找到一個 5 年前出自於大神 substack 的東西。我們都知道 Node 的世界進化的非常快速，5 年前的東西等於是侏羅紀的產物，而且我們還得在雞蛋裡挑骨頭 - V8 的 Math.random() 是可以被預測的，所以不應該使用 Math.random 來產 token，而且它也不是使用 passport。 接著，我們到 Stack Overflow 找找，但這邊沒有太多有幫助的資料，不過你大概可以一直找到一間 Stormpath 的公司不斷在相關的問題張貼他們的服務。不過這些資訊也沒有用了，因為 Stormpath 在 2017-08-17 停止營業了。 好吧！我們回到 Google，似乎有一篇唯一的教學。當我們搜尋 express passport reset 所找到的第一個結果，教學中包含使用了我們先前介紹的 bcrypt 但是計算成本參數為 5 的確遠小於推薦值，除此之外這篇教學和其他文章相較之下算是比較完整的，在 token 部分使用了 crypto.randomBytes 也具備逾期的功能。不過 #2 錯誤的儲存 和 #4 第二層的驗證這兩點並不符合我們的期待。幸好這兩點所造成風險在有逾期限制的情況下降低了些。一般來說如果 token 和 密碼都有加密的話即便資料外洩攻擊者也無法直接偽造加密結果或者使用這些 token。照著上面這篇教學的作法，攻擊者就可以拿著這些未加密的 token 來重設密碼。 容易犯錯的地方 3 - API TokensAPI tokens 就是一種憑證，它和密碼、重設密碼的 token 一樣都是機敏資訊。大部分的開發者也都知道這點，對於他們自己的 AWS key, Twitter secret 都很重視，不過當自己編寫程式的時候這樣的觀念似乎卻沒有一併轉過來。 讓我們從使用 JSON Web Tokens 來實作 API 的驗證憑證。 jwt 具備無狀態的特性，支援黑名單功能，可包含一些聲明資訊這些特性比起單純只有 key/secret 的設計更加優秀。可能連 Node 新手都聽過 jwt 也可能看過 passport-jwt 這東西然後就直接拿它來實作。無論如何，jwt 看似是每個 Node.js 開發者都認為他們應該使用。（Thomas Ptacek 認為 jwt 不好，但恐怕也阻止不了發展的趨勢，在這邊我們先不討論他的觀點）。 我們先 Google express js jwt 然後找到 Soni Pandey 的教學 User Authentication using JWT in Node.js。不過這篇文章對我們沒有太多幫助，因為這篇教學並沒有使用 passport，於此同時我們也發現這篇教學有關於憑證儲存方面的錯誤。 直接將私鑰存在檔案庫中 使用對稱式(可逆)加密來存密碼，然後加密的金鑰跟 JWT secret 共用。 使用 AES-256-CTR 來儲存密碼，正確來說使用 AES 這種模式並沒有幫助，不是很確定為什麼要這麼作，但這麼作可以讓加密的內容增加其他彈性的作法。 讓我們回到 Google 搜尋其他教學。我們在 Scotch 找到一篇還算OK的教學，不過他用了 passport-local 把密碼儲成明碼。 我們點出的這些教學都不能完全照抄，然後這篇教學除了明碼的問題這篇教學也把整個 mongoose 的 User 物件資料都序列化進 jwt 了。我們 clone 了 scotch 的教學，照著步驟執行 http://localhost:8080/setup 建立 User，接著用 Postman 請求 /api/authenticate 來取得 token。 ！ 注意：JSON Web Token 是 signed 不是加密，小弟(譯者)認為 sign 簽章其實是一種統一格式的用途，容易對資料進行判斷和過濾，它不能算是加密，也就是說這個 base64 編碼我們是可以反解回明碼資訊的 ！ 現在，每個人都知道密碼和 token 的逾期資訊還有存在 mongoose 物件上的資料。資料在 http 傳輸過程中，攻擊者就可以用一些側錄工具取得這些資訊。 下一篇教學呢？ Express, Passport and JSON Web Token （jwt) Authentication for Beginners也是一樣有洩漏的問題，大部分的教學都有一樣的問題，到這邊我已經放棄尋找了。 容易犯錯的地方 4 - 限制登入錯誤的頻率另外上面這些教學都沒提到關於鎖定帳號的部分，沒有這個機制攻擊者可以使用像是 Burp Intruder 這種檢查工具使用字典檔不斷的嘗試登入暴力破解。鎖定帳號的機制也可以在使用者下一次登入時增加其他登入所需的資訊藉此防範這種攻擊手法。 同時限制登入頻率也可以幫助我們避免不斷被嘗試登入而導致 bcrypt 大量使用浪費 CPU 效能，甚至導致程式 crash。這個部分沒有找到完整的教學文章，但我們找到許多 Express Middleware 例如：express-rate-limit，express-limiter，express-brute。關於這些函式庫或 Middleware 我無法給予太多建議，甚至我沒有研究它們。一般來說我的建議是使用反向代理功能然後使用 Nginx 的請求（頻率）限制 或負載平衡器來負責這個功能。 驗證機制非常困難我很確定部分文章的作者會說：他只是針對基礎的部分講解！而且不會有人在產品上這麼作。然而我再三強調這是個錯誤的行為，特別是當你寫了篇教學又提供程式碼的時候你可能不知道會影響多少人，畢竟你比那些新手知道更多知識。至少在 Nodejs 的世界裡，如果你還是新手請不要輕易全然相信找到的教學，應該多方謹慎求證，直接複製教學很容易給你的產品帶來災難性的問題。現階段如果你需要一個完整的驗證機制那麼你最好回到基礎一步一步的掌握概念靠自己實作，你可以參考 Rails/Devise 自己一步步實作。雖然 Node.js 看似很容易使用，且大量的開發者在推廣，但不得不說對於那些想要用 javascript 快速開發產品的人來說真的需要注意 Node.js 的世界很多東西的細節還夠不完善，這個社群似乎比較專注那些新穎酷炫的東西。如果你是前端出身的且沒學過其他語言，我個人推薦您選擇 Ruby，借鑑神人們的經驗比較不會自己找自己麻煩。 如果您有在寫教學文，期望您盡可能提供的程式碼可以直接在 production 上使用，至少備註一下該注意什麼。 如果您是死忠的 Node.js 開發者希望您可以從這篇簡短的說明中知道在使用 passport 的時候什麼事情需要避免。這篇文章沒有完整的列出所有該注意的地方，只是起個頭希望您注意一下您的 Express 程式。 附錄（2017-08-10 更新）這篇文章源自於自己發現的問題。現在已收到許多回應，更引起超過預期的爭議。很顯然的這個問題對開發者來說的確是個痛點。如果您還發現其他錯誤，請告知原文作者，我們將會儘快修正，實作是不希望有更多誤導別人的文章。 同時我希望大家不要只是評論這篇文章，讓我們具體的為社群作些貢獻。如果您有發現其他不應該出現在 production 的問題也請您直接告知原文作者。最後，原作者發起了一個 GitLab 用來紀錄相關的議題。","link":"/2017/09/06/your-nodejs-authentication-probably-wrong/"},{"title":"[譯]typeof 與 instanceof 技巧 - 簡易的動態型別檢查","text":"這邊文字要講的是關於使 instanceof 可適用於更多的情形下。 1. 關於 typeof vs instanceof在 javascript 中，當我們需要確認一個值的型別時，我們就必須要選擇對應的方法。大略來說： typeof 檢查某值是否為某種原生型別 1if (typeof value === 'string') instanceof 用來檢查某個值是否為某 class 的實例物件或建構函式。 1if (value instanceof Map) 除此之外，value.constructor 和 value.constructor.name 偶爾也可以派上用場。 光是檢查原生型別和物件的方式不一樣這樣就已經非常不理想了，然後在加上 javascript 一些詭異的行為就讓事情變的更加複雜 typeof null 為 object 並不是 null。(typeof undefined -&gt; undefined) typeof 區分 object 和 function ，而兩者都是一種物件 上面這兩個詭異的行為導致沒有簡單方式直接拿 typeof 來檢查是否為物件 並非所有的物件都是 Object 的物件實例 123456&gt; Object.create(null) instanceof Objectfalseo = {};// 等於o = Object.create(Object.prototype); 2. 讓 instanceof 可以檢查原生型別使用特定的 PrimitiveNumber 類別，下面的程式碼可以讓 expression 表達式 x instanceof PrimitiveNumber 為 true。而能夠辦到這樣的原因是因為我們使用 Symbol.hasInstance 實作了 PrimitiveNumber 的 static method 靜態方法。 關於 Symbol.hasInstance。簡單說就把 Symbol.hasInstance 當作 method 的 key 就是提供我們客製 instanceof 行為的方法。 1234567class PrimitiveNumber { static [Symbol.hasInstance](x) { return typeof x === 'number' }}console.log(123 instanceof PrimitiveNumber) // true 使用 TypeRight 函式庫檢查動態型別 TypeRight 是一個微型的函式庫用來檢查動態型別，另外它使用上面說明的方式實作。其 instanceof 運算子 如下 PrimitiveUndefined PrimitiveNull PrimitiveBoolean PrimitiveString PrimitiveSymbol TypeRight 目前並不提供物件檢查的型別（PrimitiveObject) 不過您可以輕易的加入。 通過這些基本的功能，我們可以使用 TypeRight 檢查函式的參數是否正確 123456789import * as tr from 'type-right'function dist(x, y) { tr.force(x, tr.PrimitiveNumber, y, tr.PrimitiveNumber) return math.hypot(x, y)}dist(3, 4) // 5dist(3, undefined) // TypeError 4. 其他檢查型別的方式目前有兩個提案跟處理檢查型別有關的功能，正處於 stage 0 的狀態 4.1 模式匹配這個提案稱為 ECMAScript Pattern Matching Syntax 是 Brian Terlson 和 Sebastian Markbage 提出的。其中最主要的是 Symbol.matches 的概念，其大概的使用方式入下 12345class PrimitiveNumber { static [Symbol.matches](x) { // (A) return x instanceof this; }} 4.2 Builtin.is() 和 Builtin.typeOf()這個提案是由 James M Snell 提出的。 Builtin.is(value1, value2) 可以檢查 value1 和 value2 是否參考同一個 constructor。這個提案也考慮到了其他面向的問題 1234&gt; Builtin.is(Date, vm.runInNewContext('Date'))true&gt; Builtin.is(Date, Date)true 而 Builtin.typeOf() 看起來就像是 typeof 的擴展，同時支援原生型別和內建的 class 1234567891011Builtin.typeOf(undefined); // 'undefined'Builtin.typeOf(null); // 'null'Builtin.typeOf(123); // 'number'Builtin.typeOf(new Number()); // 'Number'Builtin.typeOf([]); // 'Array'Builtin.typeOf(new Map()); // 'Map'// The builtin counts, not the user-defined classclass MyArray extends Array {}Builtin.typeOf(new MyArray()); // 'Array' 參考 Beyond typeof and instanceof: simplifying dynamic type checks","link":"/2017/08/19/dynamic-type-check/"},{"title":"深入 ECMAScript 5 物件屬性","text":"ECMAScript 5 延續了 ECMAScript 3 增加了新的功能。在規範中也介紹了一些新的 API 其中相對實用的功能莫過於對於物件屬性的改進。這些新的功能讓我們能夠更進一步的控制使用者使用物件的方式，例如：替物件增加 getter, setter，設定可列舉屬性，限制動態 刪除, 增加 屬性的用法，設定成唯讀物件等等。 而最棒的是上面說的這些功能大部分主流的瀏覽器都已經支援了，目前 ECMA-262 已經來到第八版。接下來就讓我們來學習這些新的功能。 Objects從 ES5 開始我們可以設定物件是否可以被擴充，更具體的說就是設定物件能否加入新的屬性。 ES5 提供了兩個方法 preventExtensions，isExtensible 來支援這些功能。 1234var o = {}Object.preventExtensions(o) // 傳回一個被無法擴充的物件Object.isExtensible(o) // 傳回布林，該物件是否為可擴充物件 preventExtensions 會鎖定物件從現在起不得再增加其他屬性，但 修改值, delete 和 Object.prototype的異動仍可被執行。isExtensible只是單純用來判斷該物件是否有被鎖定擴充性。 12345678var o = {}o.name = 'Foobar'console.log(o.name) // #=&gt; Foobarconsole.log(Object.isExtensible(o)) // #=&gt; trueObject.preventExtensions(o)o.url = 'http://www.google.com' // #=&gt; TypeError in strict modeconsole.log(Object.isExtensible(o)) // #=&gt; false Properties 和 Descriptors在支援新的方法之後屬性不再只是單純的鍵值對，我們可以完全的控制它們的行為。 這是因為物件中的每個屬性都有 屬性描述器 Descriptor 。根據描述器的設定，屬性會支援對應的行為，從此我們便可以控制屬性。進一步我們可以使用 Object.defineProperty 和 Object.defineProperties 設定屬性可否修改、刪除等。 在明白屬性與描述器之後，首先要特別提到的是，針對物件的屬性取值分成兩種 原本的直接取值 使用 getter, setter 1234567891011121314151617var o = Object.defineProperty({}, 'name', { value: 'Foobar'})console.log(o.name) // #=&gt; Foobarvar o = Object.defineProperty({}, 'name', { get: function () { this.__name__ = this.__name__ || 'Foobar' return this.__name__ }, set: function (val) { this.__name__ = val }})console.log(o.name) // #=&gt; Foobar// 注意：兩種方式不能並存，如果兩種都設定會出現 TypeError: Invalid property descriptor. Cannot both specify accessors and a value or writable attribute 上面的 value, set, get 就是設定在屬性描述器上的。 除此之外，屬性的描述還支援 writable: 可否寫入，即該屬性能否被修改 enumerable: 是否可在 for..in 被列出 configurable: 是否可 delete ，編輯描述器屬性 方法或描述/物件可否使用 編輯值 物件增加屬性 delete 該屬性 物件 prototype 異動繼承 編輯 descriptor 或 重新定義 value Object.preventExtensions() YES YES YES YES (不得增加新屬性) 單一屬性 configurable: false YES YES YES 單一屬性 writable: false YES YES YES YES Object.seal YES 可新增但不能編輯已存在(含新增)的屬性 Object.freeze 可新增但不能編輯已存在(含新增)的屬性 123456789var o = Object.defineProperty({}, 'name', { value: 'Foobar', configurable: false})Object.defineProperty(o, 'name', { configurable: true})// #=&gt; TypeError: can't redefine non-configurable property &quot;name&quot; 在 descriptor 總共有 5 個屬性可以使用其中 value 和 get set 只能擇一。 幾個重點： 當我們一般使用 new 關鍵字或字面值建立物件時 writable、configurable、enumerable預設為 true 當使用 Object.defineProperty 時writable、configurable、enumerable預設為 false 一旦 configurable: false就不能再重複定義 Object.getOwnPropertyDescriptor除了 Object.isExtensions如果我們想取得 descriptor 的資料也可以使用 Object.getOwnPropertyDescriptor 12345678var o = Object.defineProperty({}, 'name', { value: 'Foobar'})var descriptor = Object.getOwnPropertyDescriptor(o, 'name')console.log(descriptor) // #=&gt; Object { value: &quot;Foobar&quot;, writable: false, enumerable: false, configurable: false }// 這個方法只能取得資料，修改取回的物件並不會實際影響原本屬性的設定 Object.defineProperty 和 Object.defineProperties上面我們雖然開始使用 Object.defineProperty 但沒有對它有任何的介紹，這個方法的重點就是讓我們可以編輯設定 descriptor。接下來我們就直接用程式碼來觀察如何使用 123456789101112131415161718192021222324252627282930313233343536373839404142var o = Object.defineProperty({}, 'value', { value: true, writable: false, enumerable: true, configurable: true})// 立即函式(IIFE) 是為了不讓 name 被其他地方存取;(function () { var name = 'andyyou' Object.defineProperty(o, 'name', { get: function () { return name // 注意：這邊不可以使用 this.name 會陷入無限迴圈 }, set: function (val) { name = val } })})()console.log(o.value) // #=&gt; trueconsole.log(o.name) // #=&gt; andyyoufor (var prop in o) { console.log(prop)}// #=&gt; value// 上面提到預設使用 Object.defineProperty 時 enumerable: false 所以不會列舉出來o.value = false // 嚴格模式下 TypeError// Object.defineProperties 使用方式Object.defineProperties({}, { 'value': { value: true, writable: false }, 'name': { value: 'andyyou', writable: false }}) 關於屬性描述和相關 API 的支援大概是 ES5 最重要的更新，它讓我們可以有更多的彈性和作法。 Object.keys這個方法會回傳物件內 enumerable: true 的屬性，不包含 prototype 就是繼承來的屬性，和 for..in 的結果一致。 123456789101112131415161718var o = { a: 1}Object.defineProperties(o, { b: { value: 2, enumerable: true }, c: { value: 3 // 預設 enumerable 是 false }, d: { value: 4, enumerable: false }})console.log(Object.keys(o)) // #=&gt; ['a', 'b'] Object.getOwnPropertyNames類似於 Object.keys 但它列出的是只要是定義在該物件上的屬性都列出來不管 enumerable，意思是只要不是繼承（從 prototype 找到的屬性）來的屬性都列出。 123456789101112131415161718var o = { a: 1}Object.defineProperties(o, { b: { value: 2, enumerable: true }, c: { value: 3 // 預設 enumerable 是 false }, d: { value: 4, enumerable: false }})console.log(Object.getOwnPropertyNames(o)) // #=&gt; ['a', 'b', 'c', 'd'] instance.propertyIsEnumerable(‘property_name’)12345var o = { name: 'foobar'}console.log(o.propertyIsEnumerable('name')) // #=&gt; true prototype 與 __proto____proto__ 屬性就是原型鍊實際在找尋所謂的繼承屬性的地方，prototype 則是建構函數在使用的，即函式的一個屬性。建構函數在建立物件時會把自己的 prototype 安裝到新建物件的 __proto__。 觀察下面程式碼： 1234567function Car () {}var car = new Car() // 使用建構函式建立物件console.log(car.__proto__ === Car.prototype) // #=&gt; true// car.[[prototype]] 為 car.__proto__ getter 取得的 private 內部屬性 一般物件實字沒有 prototype 內建的 Object，Array，Number 等 9 種建構函式也都是函式物件 Object.getPrototypeOf除了上面的 __proto__之外也有一個新的方法用來取得內部的 [[Prototype]]屬性。 123456function Dog () {}var dog = new Dog()Object.getPrototypeOf(dog) // #=&gt; function Dog ()Object.getPrototypeOf(dog) === dog.__proto__ // #=&gt; true Object.create(prototype, props)建立一個新的物件，其 新物件.__proto__ 等於第一參數傳入的值，新物件.prototype 則會等於傳入參數值的 prototype，也就是說如果傳入一個 function 就會有 prototype，一般物件實字則是 undefined。 第二個參數props 則相同於 Object.defineProperties 的使用方式 12345678910111213141516171819202122232425262728// 觀察不同類型的值建立的結果var javascript = {creator: 'Brendan Eich'}function Ruby () { this.creator = 'Matz'}var ruby = new Ruby()var a = Object.create(javascript, { ext: 'js'})var b = Object.create(Ruby, { ext: 'rb'})var c = Object.create(new Ruby(), { ext: 'rb'})console.log(a.prototype, a.__proto__) // #=&gt; undefined, {creator: 'Brendan Eich'}console.log(b.prototype, b.__proto__) // #=&gt; Ruby.prototype object, function Ruby ()console.log(c.prototype, c.__proto__) // #=&gt; undefined, {creator: 'Matz', constructor: function Ruby ()}// 結論：通常我們不會使用第二種傳入 function 的方式，這麼作純粹是觀察 prototype 和 __proto__ 的差異// 第一種方式傳入物件，如果要替全部產生的物件增加屬性則javascript.version = 'ECMAScript-262 No 8'console.log(a.version) // #=&gt; ECMAScript-262 No 8// 第三種方式使用建構函數建立物件，如果要替全部產生的物件增加屬性則Ruby.prototype.version = '2.4.1'console.log(c.version) // #=&gt; 2.4.1 Object.seal 和 Object.isSealed效果等同於 Object.preventExtensions() 加上所有屬性鎖定 configurable: false。 物件本身不能擴充，但 prototype 可以 123456789101112131415161718192021var o = { name: 'Foobar'}Object.isExtensible(o) // #=&gt; trueObject.seal(o)Object.isExtensible(o) // #=&gt; falseObject.isSealed(o) // #=&gt; trueObject.getOwnPropertyDescriptor(o, 'name') // #=&gt; { value: &quot;Foobar&quot;, writable: true, enumerable: true, configurable: false }// 繼承來的屬性可新增，但不能編輯function Car () { this.name = 'Benz'}var car = new Car()Object.seal(car)Car.prototype.wheel = 4console.log(car.name, car.wheel) // #=&gt; Benz, 4car.name = 'Hyundai'car.wheel = 5 // 繼承來的屬性可新增，但不能編輯console.log(car.name, car.wheel) // #=&gt; Hyundai, 4 Object.freeze 和 Object.isFrozen效果等同於 Object.preventExtensions() 加上所有屬性鎖定 configurable: false， writable: false。 物件本身不能擴充，但 prototype 可以 123456789101112131415161718192021var o = { name: 'Foobar'}Object.isExtensible(o) // #=&gt; trueObject.freeze(o)Object.isExtensible(o) // #=&gt; falseObject.isSealed(o) // #=&gt; trueObject.isFrozen(o) // #=&gt; trueObject.getOwnPropertyDescriptor(o, 'name') // #=&gt; { value: &quot;Foobar&quot;, writable: false, enumerable: true, configurable: false }// 繼承來的屬性可新增，但不能編輯function Car () { this.name = 'Benz'}var car = new Car()Object.freeze(car)Car.prototype.wheel = 4console.log(car.name, car.wheel) // #=&gt; Benz, 4car.name = 'Hyundai'car.wheel = 5console.log(car.name, car.wheel) // #=&gt; Benz, 4 一個 seal 後的物件僅能修改現有的值，一個 freeze 後的物件也屬於 isSealed ，總結當 configurable: false 加上不能擴充 isExtensible =&gt; false等於 isSealed =&gt; true 。加上 writable: false 變成唯讀物件 isFrozen =&gt; true。 參考上面整理的表格希望能夠協助您釐清這一系列的 API 關係與產生效果的差異。","link":"/2017/10/28/javascript-object-property/"},{"title":"Debian&#x2F;Ubuntu 安裝 RabbitMQ","text":"檔案下載 官方教學 使用標準 Ubuntu 或 Debian 檔案庫在官方的 Debian 和 Ubuntu 檔案庫中就有包含 rabbitmq-server。不過一般版本都比較舊。大部分的時候我們可能要從 rabbitmq.com 這邊安裝比較新的版本。您可以從 Debian package 或 Ubuntu package 來檢視版本和相關資料。 您也可以從上面的官方教學中下載 dpkg 或者使用下面的 APT 檔案庫。 對應支援的版本下面列表是支援 RabbitMQ 3.6.3 的對應版本： Ubuntu 14.04 - 17.04 Debian Jessie Debian Wheezy(須參考 Wheezy backports repository ) 如果相依的套件都符合，該套件可能支援其他底層使用 Debian 的 Linux 系統，但我們不保證完成所有細節的測試。 安裝 Erlang/OTPRabbitMQ 需要 Erlang/OTP 來執行。Erlang/OTP 套件在官方的 Debian 和 Ubuntu 檔案庫同樣支援，但一樣版本可能比較舊。建議使用教新的版本，例如 19.3 |Erlang 版本|檔案庫及相關注意事項||20.x|Erlang Solutions 從 RabbitMQ 3.6.11 開始支援，舊版不支援||19.x|Erlang Solutions, Debian Stretch, Debian Jessie backports, Ubuntu Zesty(17.04)||18.x|Erlang Solutions, Ubuntu Yakkety(16.10), Ubuntu Xenial(16.04)||17.x|Erlang Solutions, Debian Jessie, Debian Wheezy backports| 1234567891011121314151617181920212223# 查詢 Ubuntu 版本名稱$ lsb_release -c# $ deb https://packages.erlang-solutions.com/ubuntu &lt;版本名稱&gt; contrib$ deb https://packages.erlang-solutions.com/ubuntu xenial contrib# 為 apt-secure 加入憑證$ wget https://packages.erlang-solutions.com/ubuntu/erlang_solutions.asc$ sudo apt-key add erlang_solutions.asc# 查詢 apt-get 安裝資訊（含線上可安裝版本)$ apt-cache policy &lt;package name&gt;# 安裝 Erlang$ sudo apt-get update$ sudo apt-get install erlang# OR 完整安裝 Erlang （擇一）$ sudo apt-get update$ sudo apt-get install esl-erlang=1:19.3.6# 查詢 Erlang 版本$ erl -eval 'erlang:display(erlang:system_info(otp_release)), halt().' -noshell 固定 Erlang 版本使用 apt package pinning 可以避免不需要的更新，例如直接升到最新可能不支援當前的 RabbitMQ 版本。下面的範例會固定 esl-erlang 套件到 19.3.6 然後 erlang-*是 19.3。 12345678# /etc/apt/preferences.d/erlangPackage: erlang*Pin: version 1:19.3-1Pin-Priority: 1000Package: esl-erlangPin: version 1:19.3.6Pin-Priority: 1000 上面這隻檔案被放在 /etc/apt/preferences.d/ 目錄下即 /etc/apt/preferences.d/erlang。 是否設定正確可以使用下面的指令驗證 1$ sudo apt-cache policy 套件相依性當我們使用 apt 來安裝時，所有的相依套件應該都要被自動安裝。如果您不是使用這種方式則可以從backports 檔案庫自行安裝。 APT 安裝12345678$ echo 'deb http://www.rabbitmq.com/debian/ testing main' | sudo tee /etc/apt/sources.list.d/rabbitmq.list$ wget -O- https://www.rabbitmq.com/rabbitmq-release-signing-key.asc | sudo apt-key add -$ sudo apt-get update$ sudo apt-get install rabbitmq-server 新增設定檔12$ sudo su -$ vi /etc/rabbitmq/rabbitmq.config 123[ {rabbit, [{loopback_users, []}]}]. 最後 12345678# 啟動$ service rabbitmq-server start# OR$ systemctl restart rabbitmq-server# 檢查狀態$ systemctl is-active rabbitmq-server 參考資源 Installing on Debian / Ubuntu erlang-solutions","link":"/2017/09/07/rabbitmq-ubuntu/"},{"title":"[譯] 解析 Javascript 模組機制與建置函式庫觀念","text":"身為前端或 Javascript 的開發者我們或多或少都曾經受到 JavaScript Modules 這個巨大的概念所困擾了。我們都想清楚的理解到底該怎麼使用這些工具以及它們到底在我們的日常開發中扮演什麼角色。 JavaScript 模組是什麼？隨著 JavaScript 的開發越來越複雜，命名空間、變數命名、相依的函式庫等變的越難處理。環繞著模組化的概念不同的解決方案被提出來用來解決這個問題。 比較有無模組的程式碼： 為何我們需要理解 JavaScript 模組？當我們說一個應用程式具備模組化的特性，我們一般是說這個程式是由一系列高度解耦，各自負責不同功能的模組組合而成的。您可能也知道關於低耦合與降低程式之間的相依性可提高一個程式的維護性。如果我們確實的遵守這個原則，很容易可以看出每個部分對整個程式的影響和作用。 從一個具體的例子說起：我平常的工作是設計整個專案的架構，很快的我發現有很多常見的功能幾乎每個專案都會用到，然後通常我就是複製貼上那些程式碼到新專案上。您也發現問題了。每當這些常用功能的程式碼有修改的時候，我就需要手動的去每個專案更新這些變動。因此為了避免這種無聊的任務我決定將這些功能抽成一個個 npm package。這樣一來不只是我，其他團隊也可以重複使用這些功能，並且當有新版本時可以很容易的更新。 這個方式有下面幾個優點： 如果核心程式碼有什麼問題需要修改，我們只需要修改一個地方。 所有專案可以保存同步，只需要使用 npm update 指令。 所以下一步我們就要來試著開發一個函式庫 這也是最困難的地方，當我們決定要建置一個函式庫的時候剎那間好多的問題與新的術語浮現在腦中。像是： 如何讓這個函式庫支援 tree shaking？ 我應該使用哪一種 JavaScript 模組標準（CommonJS, AMD, harmony）? 我該如何處理原始碼的部分？ 我應該要封裝打包原始碼嗎？ 該發佈哪些檔案呢？ 當要建置一個函式庫的時候，這些問題應該也浮現在您的腦中，對嗎？ 這篇文章會試著解釋這些問題。 為了解釋這些問題，我們需要先理解一下主流的模組標準。 JavaScript 模組標準與特性1. CommonJS 使用 node 實作 但模組使用這種標準時，通常使用在 server 端 不支援執行環境／非同步模組載入 使用 require 來載入模組 使用 module.exports 來匯出模組 當我們匯入模組時，實際上是取得一個物件 不支援 tree shaking 不支援靜態解析，所以我們在執行時期取得物件時查看物件屬性 取得的函式庫永遠是物件的副本，所以不支援模組的即時更新 循環管理功能不友善 語法簡單 12345678910// 檔案：log.jsfunction log () { console.log('Example of CJS module system')}module.exports = { log }// 檔案：index.jsvar logger = require('./log')logger.log() 2. AMD（Async Module Definition） 使用 RequireJS 實作 常用於瀏覽器（客戶端），當我們需要動態載入模組的時候適合使用 使用 require 來匯入 語法相較之下複雜 1234567891011121314151617// 檔案：log.js// define(id?, dependencies?, factory);// id 格式為字串，代表模組的名稱，可省略。如果要寫的話，就必須是相對於 data-main 的檔案路徑，但不用加上 js 副檔名。// 陣列為 dependenciesdefine(['log'], function () { return { log: function () { console.log('Example of AMD module system') } }})// 檔案：index.js// 注意：dependencies 表載入的 js ，而其路徑則是相對於 `data-main` ，且不需要寫副檔名。require(['log'], function (logger) { logger.log()}) 3. UMD (Universal Module Definition) 通用型標準 結合 CommonJS + AMD 即支援 CommonJS 的語法加上 AMD 的非同步載入 可以支援 AMD/CommonJS 的環境下使用 UMD 本質上就是建立一個方式讓兩種最廣泛使用的標準都支援，同時也支援全域變數的方式。結論就是 UMD 標準的模組同時相容客戶端與伺服器端。 12345678910111213141516171819202122(function (global, factory) { if (typeof define === 'function' &amp;&amp; define.amd) { define(['exports'], factory) } else if (typeof exports !== 'undefined') { factory(exports) } else { var mod = { exports: {} } factory(mod.exports) global.log = mod.exports }})(this, function (exports) { &quot;use strict&quot;; function log () { console.log('Example of UMD module system') } exports.log = log}) 4. ECMAScript Harmony（ES6） 支援客戶端與伺服器端 支援執行時期/靜態載入 匯入時可以繫結原值（非複製） 使用 import 匯入，export 匯出 靜態解析 - 可以在編譯時匯入／匯出時確定載入的程式碼 Tree shaking 模組即時更新 較佳的循環載入管理 123456789// 檔案：log.jsconst log = () =&gt; { console.log('Example of ES module system')}export default log// 檔案：index.jsimport log from './log'log() 上面我們大概的介紹了關於不同類型的 JavaScript 模組標準。由於 ES Harmony 模組標準還沒被所有工具和瀏覽器支援，並且我們也無法確定當函式庫發佈出去之後，使用者會怎麼使用它們。因此我們必須確保我們的函式庫可以在所有環境下正常運作。 現在讓我們透過設計一個簡單的函式庫來更進一步了解上面提到的問題。 現在，我們要建置一個小型的介面函式庫，所有範例的原始碼發佈在 Github。下面我將分享自身關於如何編譯，封裝，發佈一個函式庫的經驗。 如上圖，我們的這個介面函式庫包含 3 個元件：Button、Card 和 NavBar 最佳實踐1. Tree Shaking 算是一個術語，通常在 JavaScript 中指的是移除那些沒被執行到的原始碼。它必須搭配 ES2015 的 import 和 export。建置工具 rollup 一直致力推廣這個概念。 webpack 和 rollup 都支援 Tree shaking 不過我們在這邊只需要記住我們的程式碼是支援 Tree shaking 的。 123456789101112131415161718192021// 檔案：shakebake.jsconst shake = () =&gt; console.log('shake')const bake = () =&gt; console.log('bake')// 當我們匯出該模組時支援 Tree shakingexport { shake, bake }// 檔案：index.jsimport { shake } from './shakebake.js'// 只有 shake 函式會被包含在輸出的程式碼中// 檔案：shakebake.jsconst shake = () =&gt; console.log('shake')const bake = () =&gt; console.log('bake')// 這樣匯出物件的話沒有支援 Tree shakingexport default { shake, bake }// 檔案：index.jsimport { shake } from './shakebake.js'// shake 和 bake 都會被包含在輸出的程式碼中 2. 發佈所有的模組標準類型 我們應該要支援所有主流的模組標準，即 UMD 和 ES，因為我們不知道使用者是在瀏覽器環境還是使用 webpack 的情況下使用我們的函式庫。 雖然大部分的 bundler （模組工具）例如 webpack、rollup 可以支援 ES 標準，但假如開發者使用 webpack 1.x 那麼就不支援 ES 標準了。 12345678{ &quot;name&quot;: &quot;js-module-system&quot;, &quot;version&quot;: &quot;0.0.1&quot;, ... &quot;main&quot;: &quot;dist/index.js&quot;, &quot;module&quot;: &quot;dist/index.es.js&quot; ...} 在 package.json 中有幾點需要特別注意，main 屬性通常我們設定為編譯後的 UMD 版本 而 module 欄位則指向 ES 的版本。注意到在 module 這個欄位被確定為標準之前可能使用 js:next 或 js:main。 提醒：webpack 使用 resolve.mainfields 來決定該採用 package.json 中的哪個欄位。當我們匯入 npm 套件的使用例如：import * as D3 from 'd3'，webpack 會根據設定決定該使用套件中 package.json 的哪些欄位。當 webpack 的 target 設成 webworker，web 或未指定的時候 1mainFields: ['browser', 'module', 'main'] 如果 target 為 node 1mainFields: ['module', 'main'] 依據我們上面舉的 D3 的例子： 12345{ main: 'build/d3.Node.js', browser: 'build/d3.js', module: 'index',} 上面的設定意味著當我們 import * as D3 from 'd3' 的時候會優先使用 package.json 的 browser 欄位。同樣的如果一個 Nodejs 應用程式使用 webpack 的話則會優先使用 module 欄位。 為了優化效能方面，我們鼓勵發佈 ES 模組。如此一來使用者就不用載入所有的程式碼。 webpack vs rollup vs babel?上方的標題列出了廣泛被使用的封裝建置工具，很難想像沒有這些工具的該如何開發。許多人涉圖比較這些工具希望找出最好的工具。這是一個錯誤的方向，每個工具有它們各自的優點以及當初是為了解決什麼問題而被開發出來，因此我們不應該直接將它們拿來比較。 webpack 是一個很棒的模組封裝工具，廣泛的被用來建置 SPA 專案，內建 code splitting，async loading 等功能。rollup.js 很類似 webpack 不過它不支援非同步載入，主要強調支援 ES6 等新的標準，通常我們會用在封裝函式庫。babel 則是 JavaScript 編譯工具，使得我們可以提前使用 ES6 等新版的 JavaScript 標準語法，不同於上面兩種工具，它只是編譯工具。 總結來說：用 rollup 來打包函式庫，用 webpack 組織應用程式專案。 函式庫該提供哪些？當開始思考該如何建置一個函式庫的時，接著我便開始觀察那些知名的專案看看人家是怎麼組織一個函式庫的專案。 在觀察不同的函式庫和套件之後，我們可以知道不同的目標會使用不同工具與架構，下面就是我的觀察 在上圖您可以清楚的看到我把這些函式庫區分成兩類 介面函式庫（styled-components，material-ui） 核心套件（react，react-dom） 介面函式庫 通常有一個 dist 目錄包含最終打包好以及壓縮過的檔案並支援不同模組標準 ES、UMD、CJS lib 目錄包含編譯過的函式庫 核心套件 通常只有一個目錄包含打包及壓縮過的檔案，支援 CJS、UMD 版本 為什麼介面的函式庫和核心套件需要輸出不同的結果介面函式庫 想像一下如果我們只發佈打包的版本且放在 CDN 上，那麼我們的使用者只能用 &lt;script&gt; 來載入。假如使用者只想使用 &lt;Button /&gt; 元件，卻一定要下載整包程式碼。瀏覽器不像封裝工具會處理 Tree shaking 最後使用者還是得下載完整的檔案。 現在，如果我們將 src 編譯到 lib 然後一樣發佈到 CDN，我們的用戶就可以只下載他要用的部分。 核心套件 核心套件不會透過 &lt;script&gt; 來載入，它們通常是應用程式的一部分。因此我們只需要釋出打包好的版本（UMD，ES）就好，剩下的交給使用者去處理。他們可以使用 UMD 版本但是沒有支援 Tree shaking 又或者使用 ES 版本如果他們的封裝建置工具有支援的話。 編譯與封裝的作法介面函式庫 使用 babel 編譯原始碼支援 ES 模組標準，將結果放到 lib 目錄 使用 rollup 打包與壓縮，支援 CJS、UMD、ES 標準。並透過 package.json 來設定不同標準該使用的檔案 核心套件 不須產生 lib 使用 rollup 打包與壓縮，支援 CJS、UMD、ES，並透過 package.json 來設定不同標準該使用的檔案 通常我們也會將 dist 目錄下的結果發佈到 CDN。 建置慣例通常我們會將各別的建置指令設定在 package.json，您可以參考 rollup config。 其他發佈資訊 License README Changelog Metadata - package.json 在 package.json 中 files 欄位是一個陣列，用來描述套件必須被包含的檔案。舉例來說：我們要包含 lib 和 dist 目錄則設定會是 123{ &quot;files&quot;: [&quot;dist&quot;, &quot;lib&quot;]} 最後將所有的檔案都建置編譯好了之後 1234# 註冊 npm 帳號$ npm whoami # 查看登入的帳號$ npm publish 參考 Anatomy of JS module systems and building libraries","link":"/2017/12/13/anatomy-of-js-modules/"},{"title":"CSS Transitions, Animations 與 Vue","text":"關於 transitions要理解 Vue 轉場與動畫的運作，首先我們需要具備 CSS transitions 和 animations 的基本知識。這邊我們不會完整交代所有的教學，而是重點式的節錄。 讓我們先從 transitions 開始，transitions 中文我們可以稱為轉場，其主要的意思定義 CSS 樣式產生變化時，兩者之間的轉換效果，所謂的轉換效果指的是變化的長度時間，延遲時間，時間控制函式（timing-function）。舉例來說： 123456789// color 在 hover 時轉換，其中 transition 用來設定效果a { color: black; transition: all 1s ease; &amp;:hover { color: cyan; }} transition 相關的設定有 4 + 1 個 transition-property transition-duration transition-timing-function transition-delay transiton (混合寫法) 讓我們先從 transition 的格式介紹起，其他 4 個屬性只是分開設定，其效果一樣。 transition 一次可以針對 0 個 none，1 個 color (參考可設定屬性) 或 全部 all 樣式屬性設定效果。 要設定 2 組以上時使用 , 分隔。transition: color 2s, background-color 5s; 不指定預設為 all timing-function 預設為 ease 時間值例如 1s 出現的順序很重要，第一個時 transition-duration，第二個時 transition-delay。 transition-duration 和 transition-delay 預設為 0s。 123456transition: [property] [duration];transition: [property] [duration] [delay];transition: [property] [duration] [timing-function];transition: [property] [duration] [timing-function] [delay];transition: [property_1] [duration_1], [property_2] [duration_2];transition: all [duration] [timing-function]; 明白了 transition 的核心用法之後，我們來看看 animation。 關於 animationCSS animation 主要由兩個部分組成： 動畫的 CSS 樣式 keyframes 設定起始到結束之間動畫的樣式 類似 transition，animation 有 8 + 1 個相關屬性。 animation-name 設定 @keyframes 名稱 animation-duration 動畫一次循環的時間長度 animation-timing-function 時間控制函式 animation-delay 延遲時間 animation-iteration-count 重播次數，也可使用 infinite 無限循環 animation-direction 執行方向，從 0% 播放到 100% ，反過來播放，或一正一反 normal 正常 reverse 反向 alternate 一正、一反… alternate-reverse 一反、一正… animation-fill-mode 動畫執行前後套用的樣式設定 none 不套用 forwards 使用最後一個 keyframe 的樣式，這個屬性受到 animation-direction 和 animation-iteration-count 影響所以所謂的最後一個 keyframe 會有不同結果 backwards 使用第一個 keyframe both 同時受 forwards 和 backwards 樣式影響 animation-play-state 暫停/恢復 animtion (混合寫法) 如果要測試瀏覽器是否支援 animation 請參考 上面這些屬性主要是用來調整 動畫的時間軸 ，而動畫效果（樣式）則使用 @keyframes 來定義。 123456789101112.slidein { animation: 3s slidein;}@keyframes slidein { 0% { transform: scaleX(0); } 100% { transform: scaleX(1); }} 有了基本的知識之後我們可以開始學習 Vue transition 的部分。 Vue TransitionVue 在 插入，更新 ，刪除 元素的時候，提供了多種套用 transition 效果的方式。這些方式包含： 自動加入 class 整合第三方的 CSS 動畫函式庫 使用 JavaScript 在 transition hook 直接操作 DOM 整合第三方的 JavaScript 動畫函式庫 例如：Velocity.js &lt;transition&gt; 元件Vue 提供一個 transition 元件，讓我們可以輕鬆的在元素進入（entering）或離開（leaving）的流程中加入轉場效果。 所謂的 entering 和 leaving 具體指的是 使用 v-if 渲染的過程，出現（entering）消失（leaving） 使用 v-show 渲染的過程 動態元件 元件的根節點 下面是一個具體的例子 12345678910&lt;div id=&quot;demo&quot;&gt; &lt;button v-on:click=&quot;show = !show&quot;&gt; Toggle &lt;/button&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;p v-if=&quot;show&quot;&gt; Hello, Transition &lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 123456new Vue({ el: '#demo', data: { show: true }}) 1234567.fade-enter-active, .fade-leave-active { transition: opacity .5s;}.fade-enter, .fade-leave-to { opacity: 0;} 當元素被包在 &lt;transition&gt; 元件裡面的時候，如果元素被新增，移除，Vue 具體會執行下列行為： Vue 會自動偵測目標元素是否套用了 css ，然後在適當的時間點自動加入或移除 如果 transition 有設定 JavaScript hook 則 hook 事件會在對應的時間點觸發 如何沒有 css 和 JavaScript hook 那麼新增或移除的動作會在下一偵（brower animation frame）立刻執行，這個概念和 Vue 的 nextTick 是不一樣的 自動加入樣式與慣例自動套用的 class 樣式有一套慣例，Vue 共提供 6 種 class 對應過程中不同的階段 v-enter 當元素進入 DOM 時（顯示/新增元素時，entering），代表 entering transition 開始狀態。class 會在元素加入之前先套用，然後在元素插入完畢後的下一偵移除 v-enter-active 當元素進入 DOM 時（顯示/新增元素時，entering），代表在整個 entering transition 正在運作的狀態。class 會在整個 entering transition 中被套用。class 會在元素被插入之前套用，在整個 transition 或 animation 完成後被移除。這個 class 通常用來定義 duration，delay，timing-function v-enter-to 適用於 2.1.8 以上版本，表整個 entering transition 結束的狀態，在元素被加入後，下一偵加入 class，在同一時間點 v-enter 會被移除，在整個動畫結束時移除。 v-leave 當元素離開 DOM 時（隱藏/移除元素時，leaving），代表 leaving transition 的起始狀態，在一個leaving transition 被觸發時加入 class，然後下一偵 移除 class v-leave-active 類似 v-enter-active 當元素離開 DOM（隱藏/移除元素時，leaving），代表整個 leaving transition 正在運作的狀態。當 leaving transition 被觸發的同時加入 class，在整個 transition 或 animation 完成後移除 class。同樣的的通常會在這個 class 設定 duration，delay，timing-function。 v-leave-to 適用於 2.1.8 以上版本，表示整個 leaving transition 結束的狀態，當 leaving transition 被觸發後的下一偵加入 class，同個時間移除 v-leave，然後當整個 transition 或 animation 完成後移除 class。 這些 class 通常會使用 transition 的 name 來當作前綴，當你使用 &lt;transition&gt; 沒有設定 name 的時候，v- 則是預設值。假如我們使用 &lt;transition name=&quot;my-transition&quot;&gt;&lt;/transition&gt; 則 v-enter 的 class 會是 my-transition-enter。 vue + css animationscss animation 套用的方式和 transition 一樣，唯一的差別是 v-enter 不會在元素插入之後的下一偵移除，會在 animationend 事件移除 重點：v-enter-active 和 v-leave-active 是用來設定 duration, timing-function 的地方，如果是動畫則在這個地方設定 animation-name 等屬性 除了通過 name 搭配慣例來使用 6 種 class 之外也可以之間透過屬性設定自訂 class enter-class enter-active-class enter-to-class leave-class leave-active-class leave-to-class 使用自訂 class 的話會覆寫原本的慣例 transitions + animations為了知道 transition 何時結束，Vue 需要綁定事件。可以是 transitionend或 animationend 怎麼使用取決於套用什麼樣式。如果我們只使用其中一種，那麼 Vue 會自己偵測。 不過在某些情況我們可能在一個元素使用 2 種（transition, animation）舉例來說：我們使用 Vue 來觸發一個 CSS animation 然後這個元素還有 hover 時的 transition 效果，在這種情況我們就必須要定義我們想要 Vue 處理哪種類型 在大部分的情況下，Vue 會自動偵測 transition 是否完成，預設 Vue 會等根元素第一個 transitionend 或 animationend 觸發（同時存在的話會使用 時間比較長的），然而這並不總是我們要的。例如：我們想要編排內部巢狀元素們的 transition 的順序，或讓它們稍微延遲，甚至內部元素 transition 的時間比 root 元素的還長的設定 在這種情況下我們可以使用 &lt;transition :duration=&quot;1000&quot;&gt; 或者 &lt;transition :duration=&quot;{enter: 500, leave: 1000}&quot;&gt; JavaScript hookstransition 和 animation 的核心概念就是在對應的時間點新增，移除 class，enter-active 和 leave-active 用來設定動畫或 transition 的 duration, timing-function 等，enter 和 leave 是開始效果，enter-to 和 leave-to 是結束的效果，事務上 enter 和 leave-to 通常效果一樣，enter-to 和 leave效果一樣。 除了這種在被動的時間點補上 class 的方式外，Vue 也提供對應時間的 JavaScript hook 讓我們在該時間點使用 JavaScript 12345678910111213&lt;transition v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:after-enter=&quot;afterEnter&quot; v-on:enter-cancelled=&quot;enterCancelled&quot; v-on:before-leave=&quot;beforeLeave&quot; v-on:leave=&quot;leave&quot; v-on:after-leave=&quot;afterLeave&quot; v-on:leave-cancelled=&quot;leaveCancelled&quot; &gt;&lt;/transition&gt; 如果只有用 JavaScript hook enter 和 leave 函式如果沒有 (el, done) 的話會自動 call done 結束，如果有參數的話就會卡住等呼叫 done() 關鍵在有沒有帶參數 done 如果想要搭配 css 同步自動 call done 的話記得不要帶 done 參數，一旦參數有 done 就需要手動調用，css 的 transition 是無法自動同步調用的 初始化執行 transition如果您也想要在第一次渲染元素的時候加入 transition 效果，可以在 &lt;transition&gt; 加入 appear 屬性 123&lt;transition appeear&gt;&lt;/transition&gt; 預設會使用已經設定的 entering 和 leaving transition 效果。如果想要初始化時的效果不一樣可以使用如下的參數 1&lt;transition appear appear-class=&quot;&quot; appear-to-class=&quot;&quot; appear-active-class=&quot;&quot;&gt;&lt;/transition&gt; 對應的 JavaScript hook 1234567&lt;transition v-on:before-appear=&quot;&quot; v-on:appear=&quot;&quot; v-on:after-appear=&quot;&quot; v-on:appear-cancelled=&quot;&quot; &gt;&lt;/transition&gt; 元素之間的 transition後續我們會討論元件之間切換的效果，不過除了元件我們也可以對元素之間套用切換的效果例如使用 v-if/ v-else 其中最常見的情況就是一個列表和沒有資料時的切換 123456&lt;transition&gt; &lt;table v-if=&quot;items.length &gt; 0&quot;&gt; &lt;/table&gt; &lt;p v-else&gt;Sorry, no items found.&lt;/p&gt;&lt;/transition&gt; 使用 v-if / v-else 時，如果是上面這種不同 tag 的狀況時是可以正常運作的（兩者會同時執行效果可能不是您想要的效果，下面會有 transition-mode 處理這個問題） 當切換的兩個元素時一樣的時候我們必須讓 Vue 知道如何區分兩者，所以需要給 key 。否則 Vue 因為效能的因素只會把元素中的內容換掉。雖然技術上不是必要的但考量到比較好的作法我們在使用 &lt;transition&gt; 的時候最好為項目設定 key 12345678&lt;transition&gt; &lt;button v-if=&quot;isEditing&quot; key=&quot;save&quot;&gt; Save &lt;/button&gt; &lt;button v-else key=&quot;edit&quot;&gt; Edit &lt;/button&gt;&lt;/transition&gt; 在上面這種情況下我們也可以動態 binding 不同的狀態值到 key 到同一個元素上，例如 12345&lt;transition&gt; &lt;button v-bind:key=&quot;isEditing&quot;&gt; {{ isEditing ? 'Save' : 'Edit' }} &lt;/button&gt;&lt;/transition&gt; 實務上我們是有機會在任意數量的元素之間切換，或者使用多個 v-if ，一個元素 binding 一個動態屬性 1234567891011&lt;transition&gt; &lt;button v-if=&quot;docState === 'saved'&quot; key=&quot;saved&quot;&gt; Edit &lt;/button&gt; &lt;button v-if=&quot;docState === 'edited&quot; key=&quot;edited&quot;&gt; Save &lt;/button&gt; &lt;button v-if=&quot;docState === 'editing&quot; key=&quot;editing&quot;&gt; Cancel &lt;/button&gt;&lt;/transition&gt; 這種時候可以重構成下面這樣 12345&lt;transition&gt; &lt;button v-bind:key=&quot;docState&quot;&gt; {{ buttonMessage }} &lt;/button&gt;&lt;/transition&gt; 12345678910//..computed: { buttonMessage: function () { switch (this.docState) { case 'saved': return 'Edit' case 'edited': return 'Save' case 'editing': return 'Cancel' } }} transition mode到這邊我們的切換效果仍然有些問題。舉例上面開關的效果，在從 on 按鈕切換到 off 按鈕之間，兩個按鈕都會被渲染出來，然後各自執行自己的效果，這是 &lt;transition&gt; 預設的行為，entering 和 leaving 會同時執行 有時這樣的行為會運作正常，例如兩個交換的元素使用 position: absolute; 。又或者它們使用 translate位移的效果，這時同時執行效果就不會很奇怪。 但同時執行有時候不是我們要的效果，因此 Vue 提供了 transition mode in-out 新元素插入的效果先執行完畢，再處理要移除的元素效果 out-in 移除效果先，新增效果後 元件之間的切換元件之間切換又更簡單了我們甚至不需要 key 屬性，直接使用 &lt;component&gt; 來動態切換 123&lt;transition&gt; &lt;component v-bind:is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/transition&gt; 1234567891011121314new Vue({ el: '#root', data: { view: 'v-a' }, components: { 'v-a': { template: '&lt;div&gt;Component A&lt;/div&gt;' }, 'v-b': { template: '&lt;div&gt;Component B&lt;/div&gt;' } }}) 列表的 transition 效果到目前為止我們已經能夠處理的 transition 包含 個別的元素 多個元素一次只顯示一個（v-if/v-else轉場過程的處理） 那麼如何同時處理一個列表（同時出現多個元素），例如使用 v-for。這種情況下我們要使用 &lt;transition-group&gt; 在看範例之前我們還有些關於 &lt;transition-group&gt; 的重點需要先知道 在 Vue 的元件裡面需要有一個根節點，在 &lt;transition&gt; 時沒有問題，但 &lt;transition-group&gt; 不像 &lt;transition&gt;，預設外面會包一個 span 作為 wrapper，如果需要修改則使用 tag 屬性 在 &lt;transition-group&gt; 裡面的元素一定要有 key &lt;transition-group&gt; 元件還有一個特殊的功能，它不只能夠在 entering 和 leaving 時期加入轉場效果，在其他元素位置改變的時候也可以加入效果。要使用這個新功能只需要認識新的 v-mode class，它會在元素產生位置變化替元素加入 class。同樣的跟之前的慣例一樣使用 name 當作前綴還有 move-class 的設定屬性。 這個 class 大部分用來設定 timing-function 我們不需要做其他設定 v-move 會自動套用，唯一要注意的是只有位置移動的元素才會加上 v-move 然後 FLIP 技術無法套用在 display: inline 的元素上，所以要用 display: inline-block; 另外，在移除元素的時候，如果沒有設定 absoulte 那麼因為位置沒有改變所以不會有效果。 參考https://codepen.io/andyyou/pen/geWdYJ 理解 transofrom vs absolute FLIP 的技術並沒有限制在單一軸的方向使用 交錯切換我們可以透過 binding data- 屬性，在 JavaScript transitions 例如：enter時間中錯開執行的時間（delay） 重複使用 transition要重複使用動畫效果，我們可以將 &lt;transition&gt; 和 &lt;transition-group&gt; 封裝進一個元件中在搭配 &lt;slot&gt; 即可 1234567891011121314Vue.component('my-sp-transition', { template: ` &lt;transition name=&quot;very-special-transition&quot; mode=&quot;out-in&quot; @before-enter=&quot;beforeEnter&quot; @after-enter=&quot;afterEnter&quot; &lt;slot&gt;&lt;/slot&gt; &lt;/transition&gt; `, methods: { ... }}) function 化元件尤其適合這種情況。","link":"/2018/03/28/vue-transitions-animations/"},{"title":"Rails 5.2 with webpacker, bootstrap, stimulus starter","text":"Create Project1234# Last few parameters(--skip-* part) is only my habbit not actully required$ rails new &lt;project_name&gt; --webpack=stimulus --database=postgresql --skip-coffee --skip-test$ cd &lt;project_name&gt;$ rails db:create Configure scss architectureIf you are using some front end framework you may like to integrate stylesheet into components with webpack or you just like to integrate stylesheets with webapck like me. This is a way that we integrate that into webpacker. NOTE: This is only the convention of our team you can avoid this step and keep stylesheet in assets/. 1234$ mkdir app/javascript/stylesheets$ touch app/javascript/stylesheets/application.scss$ touch app/javascript/stylesheets/_variables.scss$ touch app/javascript/stylesheets/_base.scss After create files please write down styles as follow: app/javascript/stylesheets/application.scss 12@import 'variables';@import 'base'; app/javascript/stylesheets/_variables.scss 1234$colors: ( major: #00D252, minor: #2F3B59); app/javascript/stylesheets/_base.scss 123h1 { color: map-get($colors, major);} On the top of app/javascript/packs/application.js 1import 'stylesheets/application' （Optional）Integrate stimulus manuallyIf you are not use --webpack=stimulus for create project or install stimulus in existed project. 1234$ yarn add stimulus$ mkdir app/javascript/controllers# To provide a example for testing stimulus$ touch app/javascript/controllers/clipboard_controller.js （Optional）Configure stimulusapp/javascript/s/packs/application.js 123456789101112131415161718/* eslint no-console:0 */// This file is automatically compiled by Webpack, along with any other files// present in this directory. You're encouraged to place your actual application logic in// a relevant structure within app/javascript and only use these pack files to reference// that code so it'll be compiled.//// To reference this file, add &lt;%= javascript_pack_tag 'application' %&gt; to the appropriate// layout file, like app/views/layouts/application.html.erbimport 'stylesheets/application'import { Application } from &quot;stimulus&quot;import { definitionsFromContext } from &quot;stimulus/webpack-helpers&quot;const application = Application.start()// The path you may like to change to under `pack` that path will be `./controllers`// but convention will be in `/app/javascript/controllers`const context = require.context(&quot;controllers&quot;, true, /\\.js$/)application.load(definitionsFromContext(context)) Example of testing stimulus: app/javascript/controllers/clipboard_controller.js 12345678910111213141516171819import { Controller } from 'stimulus'export default class extends Controller { static targets = ['source'] initialize() { console.log('clipboard initialize') } connect() { console.log('clipboard connect') if (document.queryCommandSupported('copy')) { this.element.classList.add('clipboard--supported') } } copy(e) { e.preventDefault() this.sourceTarget.select() document.execCommand('copy') }} Create a example controller and view1$ rails g controller pages example Add app/views/pages/example.html.erb 123456789&lt;h1&gt;Hello, World&lt;/h1&gt;&lt;hr&gt;&lt;div data-controller=&quot;clipboard members dashboard&quot;&gt; PIN &lt;input type=&quot;text&quot; data-target=&quot;clipboard.source&quot; value=&quot;1234&quot; readonly&gt; &lt;button data-action=&quot;clipboard#copy&quot; class=&quot;clipboard-button&quot;&gt; Copy to Clipboard &lt;/button&gt;&lt;/div&gt; Add pack to layoutOpen app/views/layout/application.html.erb then add pack tags to &lt;head&gt; 12&lt;%= stylesheet_pack_tag 'application' %&gt;&lt;%= javascript_pack_tag 'application' %&gt; Add routeconfig/routes.rb 1234Rails.application.routes.draw do # For details on the DSL available within this file, see http://guides.rubyonrails.org/routing.html root 'pages#example'end Then you can test 1$ rails s Navigate to localhost:3000 should see as follow Until here you should complete Rails 5.2 using webpacker with stimulus and stylesheets. For common practical stiuation you may want to use bootstrap v4.x. Install bootstrap12# https://getbootstrap.com/docs/4.1/getting-started/webpack/$ yarn add jquery popper.js bootstrap Import boostrap stylesheetsIn app/javascript/stylesheets/application.scss add bootstrap 123@import '~bootstrap/scss/bootstrap';@import 'variables';@import 'base'; imiport bootstrap JavaScriptapp/javascript/packs/application.js 1import 'bootstrap' Configure webpackerAdd configuration to config/webpack/environment.js. If you do not setup this step, the abilities related to Popper.js such as tooltip will not working. 1234567891011121314151617181920const { environment } = require('@rails/webpacker')const webpack = require('webpack')/** * Automatically load modules instead of having to import or require them everywhere. * Support by webpack. To get more information: * * https://webpack.js.org/plugins/provide-plugin/ * http://j.mp/2JzG1Dm */environment.plugins.prepend( 'Provide', new webpack.ProvidePlugin({ $: 'jquery', jQuery: 'jquery', jquery: 'jquery', 'window.jQuery': 'jquery', Popper: ['popper.js', 'default'] }))module.exports = environment Sometimes you may like to use jQuery in views you should expose jQuery to global expose jQuery to global for views12# https://webpack.js.org/loaders/expose-loader/$ yarn add expose-loader -D Add configuration to config/webpack/environment.js 12345678910/** * To use jQuery in views */environment.loaders.append('expose', { test: require.resolve('jquery'), use: [{ loader: 'expose-loader', options: '$' }]}) Other convention of our team12$ mkdir -p lib/templates/active_record/model$ touch lib/templates/active_record/model/model.rb lib/templates/active_record/model/model.rb 12345678910111213141516171819202122232425262728&lt;% module_namespacing do -%&gt;class &lt;%= class_name %&gt; &lt; &lt;%= parent_class_name.classify %&gt; # scope macros # Concerns macros # Constants # Attributes related macros&lt;% if attributes.any?(&amp;:password_digest?) -%&gt; has_secure_password&lt;% end -%&gt; # association macros&lt;% attributes.select(&amp;:reference?).each do |attribute| -%&gt; belongs_to :&lt;%= attribute.name %&gt;&lt;%= ', polymorphic: true' if attribute.polymorphic? %&gt;&lt;% end -%&gt; # validation macros # callbacks # other private # callback methodsend&lt;% end -%&gt;","link":"/2018/05/02/rails-5-webpacker-stimulus-bootstrap-starter/"},{"title":"tmux 快速入門筆記","text":"什麼是 tmux？ 上面您看到的就是一個 tmux 的畫面。 tmux 的作者解釋：tmux 是一個 Terminal Multiplexer。這個看起來很艱澀的術語背後其實概念很簡單; 就是在一個終端機（一個 Console）下開啟多個視窗，或者分割視窗區塊（在 tmux 中我們會有 視窗 window 和視窗區塊 pane ）。每一個 pane 各自有各自獨立執行一個 Terminal Instance （各自輸入輸出的介面實例）讓我們可以同時執行多個指令，而不需要開啟多個 Terminal 視窗。如果您是 iTerm 的使用者可以把它們概略對應成 Tab 和 Split。 tmux 會在同一個 session （連線狀態下的執行環境）保存這些視窗和視窗區塊。我們可以在任何時間離開這個連線。這被稱為 detaching。然後 tmux 會繼續維持這個 session 直到您把 tmux server 砍掉或者重開機的時候。然後重點是我們隨時可以在重新回到（attaching）上次離開 session 的狀態。 原本我們打開一個 terminal 會和機器建立一個 session 當我們關掉視窗時 session 就會關閉，我們剛下的指令就會被中止。使用 tmux 意味著我們是通過 tmux server 來和機器建立 session，我們的操作視窗或視窗區塊則是跟 tmux server 溝通。 session 概略的說，指的是終端機和主機間建立的一個連線，在這個連線下的執行環境。後續文章將使用 session 。 如果您曾經遠端連線到伺服器工作或使用 ssh 來跟 Raspberry Pi 連線操作，您應該已經猜到這會有什麼幫助。例如：當我們 ssh 斷線的時候，其實對於 tmux 來說只是和 tmux server 中斷，tmux server 會在伺服器端背景繼續執行並保存剛剛的 session。要繼續回到剛剛的 session 只要在 ssh 連線回去並在和 session 連線（attach）即可。 到這邊我們大致已經了解了 tmux 最基本的兩大功能：視窗管理和 session 管理。如果您對於 GUN Screen 已經很熟悉的話這邊對您而言沒有什麼新的東西。tmux 的核心概念就像是一個更輕易使用且更強大的螢幕替代工具。 我們已經討論夠多概念的東西了，接著讓我們動手操作。 入門我們將手把手教您該如何安裝與操作 tmux。不過這邊我們只會介紹最基本的功能。 安裝在大部分作業系統，安裝 tmux 都相當簡單，例如：在 Ubuntu 只要一道指令 sudo apt-get install tmux在 OSX 只要 brew install tmux 就可以了。 建立新的 session當我們要建立一個 session 時只要輸入 tmux 即可 1$ tmux 這個指令會建立一個新的 tmux session，你會看到下面多了一條綠色狀態列。狀態列是 tmux 很重要的一個部分。除了顯示當前的視窗（在左邊）它同時也會顯示一些關於系統的資訊像是時間（在右邊）。狀態列還可以依照需求客製，例如：顯示行事曆，電量等等。 分割視窗區塊（Panes）現在我們已經建立了第一個 session，當我們建立 session 的時候 tmux 預設會開啟一個視窗包含一個單一的視窗區塊。當我們要執行 tmux 的指令時，我們需要先輸入一個前置鍵。預設 tmux 使用 C-b 作為前置鍵。C-b 指的是 Ctrl + b 同時按。接著，要分割區塊使用的指令是 C-b % 這個指令會幫我們把當前的畫面切割成垂直左右的兩個視窗區塊。 備註： C- 指的是 Ctrl + 某個鍵一起按 M- 則是 Alt 或 Option 和某個鍵一起按。 如果要水平切割則是 C-b &quot;。 切換操作的視窗區塊現在我們的操作被侷限在剛剛新建立的視窗區塊中。不過我們想回到左邊的那個。這個時候我們只要使用 C-b 搭配方向鍵即可。現在您可以親自操作看看。 關閉視窗區塊關閉視窗區塊只需要使用 C-d 建立視窗tmux 的視窗類似於 Linux 中建立一個虛擬桌面例如：KDE，Gnome 等。 下面我們直接將常用的操作指令列出： C-b c 建立一個新視窗 C-b p 上一個視窗 C-b n 下一個視窗 C-b &lt;number&gt; 依照編號直接切換（編號顯示於狀態列） session 管理如果您已經完成您的工作，要 detach 只需要 C-b d，又或者 C-b D 可以選擇要從那個 session 離開。要注意的是這些 session 依然在背景執行。 要返回剛剛的 session，第一步我們需要知道要重新連線那個 session。透過使用下面指令可以列出在背景執行的 session 12345$ tmux ls0: 1 windows (created Mon Nov 27 17:18:34 2017) [80x25]1: 1 windows (created Mon Nov 27 17:18:59 2017) [176x23]2: 1 windows (created Mon Nov 27 17:20:10 2017) [80x23] 要連回 session 我們需要指定參數，例如我們要連回第一個 session 則 1$ tmux attach -t 0 -t 0 這個參數我們透過 tmux ls 來取得。 如果您偏好賦予每個 session 一個有意義的名稱，那麼我們可以使用下面這個指令 1$ tmux new -s database 此時這個新建的 session 就會被命名為 database。除此之外我們還可以修改名稱 1$ tmux rename-session -t 0 database 之後當我們要在重新連回該 session 時，只要使用該名稱即可 1$ tmux attach -t database 就是這樣，恭喜您已經學完了 tmux 的基本功能與操作，當然 tmux 還有更多功能，但我們剛剛學習的這些足夠應付大部分的應用。 為什麼使用 tmux?當我完成上面的介紹之後，一個我常見到的反應是：恩，的確看起來很不錯，但為啥我應該用 tmux 和這些奇怪的組合鍵呢？為什麼不能就用 iTerm2 就好？ 恩，沒錯！但我們只需要要單純的視窗管理功能的時候，OSX 的使用者的確只要透過 iTerm 的分頁（Tab）功能就好。針對 Linux 使用者則是選擇使用 Terminator。 1234567# 補充 iTerm2 對應效果Command + d 垂直分割 PaneCommand + Shift + d 水平分割 PaneCommand + Option + &lt;方向鍵&gt; 切換 Pane* [iTerm2 教學](https://www.iterm2.com/documentation-one-page.html) 那為什麼還要去學這個老舊的東西呢？這邊我將點出幾個 tmux 的優點： session 的處理：attach 和 detach 協助我們在不同情境和遠端連線的情況下切換，保留 session。 跨平台：我們可以在 Mac 底下使用，也可以在 Linux 環境下使用，甚至遠端伺服器或 Raspberry Pi，BeagleBones 等等都可以使用一樣的東西。 客製化：我們可以去自訂 tmux 的環境設定並且可以和不同平台環境同步 進階如果您有興趣知道關於 tmux 提供的其他功能，很簡單，輸入 C-b ? 您會看到所有有支援的指令，C-c 離開 Help。 到這邊我認為上面的這些資源足夠幫助您自己進一步去探索 tmux。網路上很多像我一樣分享關於他們使用 tmux 經驗的文章，您可以找到很多人在 Gihub 分享他們的設定。甚至 Brian Hogan 還專門為 tmux 寫了一本書。 現在您自己去探索，嘗試看看。如果您對於自訂修改一些設定有興趣的話可以參考我的另一篇文章自訂 tmux.conf 整理常用的指令紀錄備註 12345678910111213141516171819202122232425262728293031323334353637383940414243# 新增$ tmux# OR$ tmux new -s &lt;your_session_name&gt;# session 列表$ tmux ls# 重新連線 session$ tmux a -t 0# OR$ tmux a -t &lt;session_name&gt;# 刪除 session$ tmux kill-session -t 0# OR$ tmux kill-session -t &lt;session_name&gt;# OR$ tmux kill-session -a # 全部# 刪除 tmux server$ tmux kill-server# 重新命名 session$ tmux rename-session -t 0 &lt;new_session_name&gt;# 快捷鍵/視窗管理# C-b ? Help# C-b c 新增視窗# C-b， 視窗命名# C-b w 視窗列表# C-b f 尋找視窗# C-b &amp; 刪除視窗# C-b % 垂直分割區塊# C-b “ 水平分割區塊# C-b &lt;方向鍵&gt;# C-b p 上一個視窗# C-b n 下一個視窗# C-b &lt;number&gt; 依照編號直接切換（編號顯示於狀態列）# C-b d 離開 session# C-b x 關閉 Pane# C-d 關閉 Pane# C-b z 讓一個 Pane 變成全螢幕，在輸入一次則回到剛剛的尺寸 參考資源 A Quick and Easy Guide to tmux","link":"/2017/11/27/tmux-notes/"},{"title":"使用 PG copy 升級 Heroku Postgres 資料庫","text":"原文：Upgrading Heroku Postgres Databases 本文為 Heroku 官方文件的閱讀 + 翻譯筆記，最新的資料請參考官方網站。 這篇文章將會介紹如何升級 Heroku Postgres 資料庫。這裡所要說的是關於變更資料庫的 plan （付費方案的部分），以及升級資料庫版本。關於資料庫的變更只能夠使用 Heroku CLI 指令介面來完成。 升級/變更一個正在運作的 Heroku Postgres 資料庫是一件特別需要注意的操作。 Heroku 共有三種變更方式。在所有的情況下，變更資料庫方案時，應用程式會需要停止服務一點時間，此時無法寫入任何資料。 升級方式 需求說明 PG copy 可用於所有升級的情況包含從 Hobby 方案變更到其他方案。也可用於升級 Postgres 的版本。 Follower Changeover 變更正式環境資料庫的使用方案，資料庫版本維持一致。僅可用於 Standard，Premium，Private 或 Enterprise 方案的資料庫。需花費幾小時準備 follower ，期間應用程式仍可運作，切換所需的停機時間小於 1 分鐘。 pg:upgrade 升級大型資料庫版本。僅可用於 Standard，Premium，Private 或 Enterprise 方案的資料庫。 適用方式升級的方式取決於下面幾種因素： 如果使用的 Postgres 版本在 9.3 之前並且從未使用 pg:copy，應使用 pg:copy 升級。Postgres 9.3 提供了資料損壞檢核機制，使用 pg:copy 將會避免損壞資料，一旦完成 pg:copy 便可接續使用 pg:upgrade 來升級。 如果使用的 Postgres 版本大於 9.3 ，可以直接使用 pg:upgrade 升級。 如果使用的 Postgres 版本大於 9.3 ，但 bloat 值過大時，建議使用 pg:copy，pg:copy 會重新建立資料表和索引，並移除 bloat。但如果停機時間是比較重要的考量點則使用 pg:upgrade。 123# 查詢 bloat$ heroku plugins:install heroku-pg-extras$ heroku pg:bloat DATABASE_URL --app &lt;app_name&gt; pg:upgrade 針對資料庫為中等數量的關聯與結構的情況，如果您的資料庫包含了上千的資料結構請與 postgres@heroku.com 聯繫。 使用 PG copyPG copy 採用的是原始 PostgreSQL 備份與還原的功能，而不是直接把備份檔複製到硬碟上。 使用案例與時間PG copy 大約需要每 GB 3 分鐘的時間，雖然資料量是主要因素，但大型的資料庫方案具備更快速的 I/O。 指令1234567891011121314# 1. 建立新的資料庫$ heroku addons:create heroku-postgresql:hobby-basic --app &lt;app_name&gt;# （選用）標準型以上的資料庫需要花費點時間，可使用通知指令$ heroku pg:wait# 2. 啟用維護模式$ heroku maintenance:on --app &lt;app_name&gt;# （選用）確保沒有任何程序存取資料庫$ heroku ps:scale worker=0# 3. 複製資料（備註：HEROKU_POSTGRESQL_SILVER_URL 參數是根據您所建立的新資料庫給的值）$ heroku pg:copy DATABASE_URL HEROKU_POSTGRESQL_SILVER_URL --app &lt;app_name&gt;# 4. 切換資料庫$ heroku pg:promote HEROKU_POSTGRESQL_SILVER_URL --app &lt;app_name&gt;# 5. 關閉維護模式$ heroku maintenance:off --app &lt;app_name&gt;","link":"/2017/09/29/upgrade-heroku-postgres/"},{"title":"手把手學習使用 Rails 5.2 ActiveStorage (DirectUpload + ProgressBar)","text":"本文為使用 Rails ActiveStorage 的實作範例筆記。詳細介紹請參考Active Storage 概要，本文僅針對官方教學提供一個對照的實作記錄，如需部署至 Heroku 請參考在 Heroku 使用 Active Storage。 建立 Rails 專案與安裝12345678# 這邊為了後續介紹與 stimulus 搭配我們直接先帶入 --webpack=stimulus 參數$ rails new active_storage_sample --webpack=stimulus --skip-coffee --skip-test$ rails active_storage:install$ rails db:migrate# 設定 config/storage.yml 提供的方式# 設定 config/environments 環境使用的方式# 完整範例 https://github.com/andyyou/active-stroage-sample 由於 active_storage 會使用兩張 table 記錄資料所以需要 _migrate_。 我們在這個實作會練習使用 aws s3 來儲存檔案，即便不預先設定還是可以在使用本地磁碟的方式測試。 如果您不想在這邊練習使用 aws 可以直接跳至下一節。 12# 加入 s3 access key$ EDITOR=vim rails credentials:edit config/storage.yml 設定 123456amazon: service: S3 access_key_id: &lt;%= Rails.application.credentials.dig(:aws, :access_key_id) %&gt; secret_access_key: &lt;%= Rails.application.credentials.dig(:aws, :secret_access_key) %&gt; region: ap-northeast-2 bucket: your_own_bucket 開啟 Gemfile 加入 aws-sdk-s3 並執行 bundle 安裝。 Active Storage 的核心功能需要以下權限：s3:ListBucket、s3:PutObject、s3:GetObject 和 s3:DeleteObject。如果你設定了其它上傳選項，如 ACL 設定，則可能需要額外的權限。 注意：記得要設定 config/environments/development.rb 1config.active_storage.service = :amazon 標準 Form Post 方式新增圖片（單檔/多檔）使用官方提供的標準方式上傳檔案 123# 建立 event scaffold 我們將練習使用 單檔上傳、多檔上傳、upload_direct 參數$ rails g scaffold event name$ rails db:migrate active_storage 的使用方式非常簡單： 1 調整 models/event.rb 1234class Event &lt; ApplicationRecord has_one_attached :cover # 單檔 has_many_attached :banners # 多檔end 2 調整 views/events/_form.html.erb 123456789&lt;div class=&quot;field&quot;&gt; &lt;%= form.label :cover %&gt; &lt;%= form.file_field :cover %&gt;&lt;/div&gt;&lt;div class=&quot;field&quot;&gt; &lt;%= form.label :banners %&gt; &lt;%= form.file_field :banners, multiple: true %&gt;&lt;/div&gt; 3 調整 controllers/events_controller.rb 12345678910111213# premit cover 和 bannersdef event_params params.require(:event).permit(:name, :cover, banners: [])end# 以下為說明，不需使用於範例# 若要附加圖片可以使用 attach@event.attach(params[:cover])# 同步刪除頭像和實際資源檔案。@event.cover.purge# 透過 Active Job 非同步刪除相關模型和實際資源檔案。@event.cover.purge_later 4 為了觀察結果與使用呈現的相關 _helpers_，調整 views/events/show.html.erb 加上 123456789101112131415&lt;p&gt; &lt;strong&gt;Cover:&lt;/strong&gt; &lt;div&gt; &lt;%= image_tag @event.cover if @event.cover.attached? %&gt; &lt;/div&gt;&lt;/p&gt;&lt;p&gt; &lt;strong&gt;Banners:&lt;/strong&gt; &lt;div&gt; &lt;% @event.banners.each do |banner| %&gt; &lt;%= image_tag banner %&gt; &lt;% end %&gt; &lt;/div&gt;&lt;/p&gt; 以上就是最基本的使用方式，我們可以啟動 rails s 並瀏覽 localhost:3000/events來觀察目前的結果。 調整圖片尺寸1 要使用調整圖片尺寸的功能須先安裝 mini_magick，在 Gemfile 解開註解並安裝。 12# Use ActiveStorage variantgem 'mini_magick', '~&gt; 4.8' 2 接著就可以在 views/events/show.html.erb 使用 .variant(resize: '100x100') 方法。 1&lt;%= image_tag @event.cover.variant(resize: '100x100') if @event.cover.attached? %&gt; 刪除圖片1 config/routes.rb 新增路由 123resources :events do delete :destroy_cover, on: :memberend 2 controllers/events_controller.rb 新增 action 與設定 :set_event 12345678before_action :set_event, only: [:show, :edit, :update, :destroy, :destroy_cover]def destroy_cover @event.cover.purge respond_to do |format| format.html { redirect_to event_url(@event), notice: 'Event Cover was successfully destroyed.' } format.json { head :no_content } endend 3 views/events/show.html.erb 加入刪除按鈕 1&lt;%= link_to '刪除', destroy_cover_event_path(@event), method: :delete if @event.cover.attached? %&gt; 多檔上傳刪除單張圖片1 config/routes.rb 新增路由 12345resources :events do delete :destroy_cover, on: :member # DELETE /events/:id/banners/:banner_id delete '/banners/:banner_id' =&gt; 'events#destroy_banner', as: :destroy_banner, on: :memberend 2 controllers/events_controller.rb 新增 action 和設定 :set_event 123456789before_action :set_event, only: [:show, :edit, :update, :destroy, :destroy_cover, :destroy_banner]def destroy_banner @event.banners.find(params[:banner_id]).purge respond_to do |format| format.html { redirect_to event_url(@event), notice: 'Event banner was successfully destroyed.' } format.json { head :no_content } endend 3 views/events/show.html.erb 1234&lt;% @event.banners.each do |banner| %&gt; &lt;%= image_tag banner.variant(resize: '100x100') %&gt; &lt;%= link_to '刪除', destroy_banner_event_path(@event, banner), method: :delete %&gt;&lt;% end %&gt; 多檔上傳刪除多張圖片1 config/routes.rb 新增路由 12# DELETE /events/:id/bannersdelete :destroy_banners, on: :member 完整路由 123456789101112Rails.application.routes.draw do resources :events do delete :destroy_cover, on: :member # DELETE /events/:id/banners delete :destroy_banners, on: :member # DELETE /events/:id/banners/:banner_id delete '/banners/:banner_id' =&gt; 'events#destroy_banner', as: :destroy_banner, on: :member end # For details on the DSL available within this file, see http://guides.rubyonrails.org/routing.htmlend . controllers/events_controller.rb 新增 action 和設定 :set_event 12345678910111213141516before_action :set_event, only: [ :show, :edit, :update, :destroy, :destroy_cover, :destroy_banner, :destroy_banners]def destroy_banners params[:event][:banners].each do |banner_id| @event.banners.find(banner_id).purge end respond_to do |format| format.html { redirect_to event_url(@event), notice: 'Event banners was successfully destroyed.' } format.json { head :no_content } endend 3 views/events/show.html.erb 123456789101112&lt;%= form_for(@event, url: destroy_banners_event_path, method: :delete) do |form| %&gt; &lt;% @event.banners.each do |banner| %&gt; &lt;!--重點：使用 checkbox 勾選並一次刪除 --&gt; &lt;%= check_box_tag :banners, banner.id, false, name: 'event[banners][]' %&gt; &lt;%= image_tag banner.variant(resize: '100x100') %&gt; &lt;%= link_to '刪除', destroy_banner_event_path(@event, banner), method: :delete %&gt; &lt;% end %&gt; &lt;% if @event.banners.attached? %&gt; &lt;input type=&quot;submit&quot; value=&quot;刪除多張圖片&quot;&gt; &lt;% end %&gt;&lt;% end %&gt; 到此我們已經示範了完整的基本使用方式。 Direct Upload預設的 active storage 的流程是將圖片先送到後端，一併處理建立資料庫紀錄和上傳。但如何使用雲端服務的話，這個流程就顯得多此一舉。因此 active storage 也提供 direct upload 的方式直接把圖片從使用者端直接送往雲端服務。而我們接著要實作 ajax 方式的範例也會使用 direct upload。 安裝 activestorage.js1 安裝套件 12# 這裡我們使用 webpacker 的方式，如果需要其他方式請參考官方教學$ yarn add activestorage 2 新增 javascript/packs/direct_upload.js 12import * as ActiveStorage from 'activestorage';ActiveStorage.start(); 3 views/layouts/application.html.erb 加入 pack 1&lt;%= javascript_pack_tag 'direct_upload', 'data-turbolinks-track': 'reload' %&gt; 標準 Direct Upload 使用方式為了範例單純，這邊我們建立一個新的 Post scaffold 其包含一個 cover 和 images 但是這次我們使用不一樣的流程來完成。cover 我們使用標準的 Direct Upload 作法，images 我們整合 ajax 與 stimulus 的作法。 1 建立 scaffold 12$ rails g scaffold post title$ rails db:migrate 2 models/post.rb 加上設定 1234class Post &lt; ApplicationRecord has_one_attached :cover has_many_attached :imagesend 3 views/posts/_form.html.erb 加上 1234&lt;div class=&quot;field&quot;&gt; &lt;%= form.label :cover %&gt; &lt;%= form.file_field :cover, direct_upload: true %&gt;&lt;/div&gt; 到這邊除了 direct_upload 參數跟原本的作法沒有不同，但使用 direct_upload 之後我們多了一些 hooks 可以使用。 direct_upload: true 會在渲染的 HTML 加上 data-direct-upload-url 屬性。 4 controllers/posts_controller.rb 加入 permit 123def post_params params.require(:post).permit(:title, :cover, images: [])end 5 完成的 javascript/packs/direct_upload.js 如下，這是官方提供的範例 123456789101112131415161718192021222324252627282930313233343536373839import * as ActiveStorage from 'activestorage';ActiveStorage.start();addEventListener(&quot;direct-upload:initialize&quot;, event =&gt; { const { target, detail } = event; const { id, file } = detail; target.insertAdjacentHTML(&quot;beforebegin&quot;, ` &lt;div id=&quot;direct-upload-${id}&quot; class=&quot;direct-upload direct-upload--pending&quot;&gt; &lt;div id=&quot;direct-upload-progress-${id}&quot; class=&quot;direct-upload__progress&quot; style=&quot;width: 0%&quot;&gt;&lt;/div&gt; &lt;span class=&quot;direct-upload__filename&quot;&gt;${file.name}&lt;/span&gt; &lt;/div&gt; `);});addEventListener(&quot;direct-upload:start&quot;, event =&gt; { const { id } = event.detail; const element = document.getElementById(`direct-upload-${id}`); element.classList.remove(&quot;direct-upload--pending&quot;);});addEventListener(&quot;direct-upload:progress&quot;, event =&gt; { const { id, progress } = event.detail; const progressElement = document.getElementById(`direct-upload-progress-${id}`); progressElement.style.width = `${progress}%`;});addEventListener(&quot;direct-upload:error&quot;, event =&gt; { event.preventDefault(); const { id, error } = event.detail; const element = document.getElementById(`direct-upload-${id}`); element.classList.add(&quot;direct-upload--error&quot;); element.setAttribute(&quot;title&quot;, error);});addEventListener(&quot;direct-upload:end&quot;, event =&gt; { const { id } = event.detail; const element = document.getElementById(`direct-upload-${id}`); element.classList.add(&quot;direct-upload--complete&quot;);}); 加入 css 12345678910111213141516171819202122232425262728293031323334353637.direct-upload { display: inline-block; position: relative; padding: 2px 4px; margin: 0 3px 3px 0; border: 1px solid rgba(0, 0, 0, 0.3); border-radius: 3px; font-size: 11px; line-height: 13px;}.direct-upload--pending { opacity: 0.6;}.direct-upload__progress { position: absolute; top: 0; left: 0; bottom: 0; opacity: 0.2; background: #0076ff; transition: width 120ms ease-out, opacity 60ms 60ms ease-in; transform: translate3d(0, 0, 0);}.direct-upload--complete .direct-upload__progress { opacity: 0.4;}.direct-upload--error { border-color: red;}input[type=file][data-direct-upload-url][disabled] { display: none;} 整合 Stimulus1 views/layouts/application.html.erb 加入 application 1&lt;%= javascript_pack_tag 'application', 'data-turbolinks-track': 'reload' %&gt; 2 新增 javascript/controllers/uploads_controller.rb 1234567891011import { Controller } from 'stimulus';export default class extends Controller { connect() { console.log('connect to uploads'); } start() { console.log('start upload'); }} 3 views/posts/show.html.erb 加入我們的 upload 元素 並使用 stimulus 的 controller。 123456&lt;p&gt; &lt;strong&gt;Images&lt;/strong&gt; &lt;div data-controller=&quot;uploads&quot;&gt; &lt;input type=&quot;file&quot; multiple=&quot;true&quot; data-action=&quot;change-&gt;uploads#start&quot;&gt; &lt;/div&gt;&lt;/p&gt; 這裡我們預計使用一個 input ，當其取得檔案的時候在搭配 stimulus 執行對應的操作。接著，我們先來處理上傳檔案的部分。 4 確認 controller 中 params 和 before_action 是否取得我們需要的資料，修改 controllers/posts_controller.rb，我們會需要使用 ajax 來對 update 發出請求，所以我們需要對其做一些調整。一個流程我們從路由開始，我們沿用 update ，接著 controller#action 的行為。再回到前端處理。 注意：本文旨是在協助您練習可能的作法，不一定適合您的正式環境。 12345678910111213141516171819# PATCH/PUT /posts/1# PATCH/PUT /posts/1.jsondef update respond_to do |format| if @post.update(post_params) format.html { redirect_to @post, notice: 'Post was successfully updated.' } format.json { # 遵循慣例參數為陣列，但 DirectUpload 一次只會負責一張圖片 image = ActiveStorage::Blob.find_signed(post_params[:images].first) # 從後端取的圖片（resize）的網址 image_url = Rails.application.routes.url_helpers.rails_representation_url(image.variant(resize: '100x100'), only_path: true) render json: { status: :ok, url: image_url, id: image.id } } else format.html { render :edit } format.json { render json: @post.errors, status: :unprocessable_entity } end endend 5 新增 javascript/libs/uploader.js 。這裡為了可以顯示進度，我們參考官方教學的作法。 注意：如果您是直接跳至本節，請記得安裝 activestorage.js 1234567891011121314151617181920212223242526272829303132import { DirectUpload } from 'activestorage';export default class { constructor(file, url, element) { this.file = file; this.url = url; this.element = element; this.directUpload = new DirectUpload(this.file, this.url, this); } upload() { return new Promise((resolve, reject) =&gt; { this.directUpload.create((error, blob) =&gt; { if (error) { reject(error); } else { resolve(blob); } }); }); } directUploadWillStoreFileWithXHR(request) { request.upload.addEventListener(&quot;progress&quot;, event =&gt; this.directUploadDidProgress(event)); } directUploadDidProgress(e) { let progress = this.element.querySelector('.progress-bar'); progress.style.width = ((e.loaded / e.total) * 100) + '%'; }} 6 views/posts/show.html.erb 由於 js 需要一些參數，這邊我們使用 stimulus 的 data api 123456789&lt;p&gt; &lt;strong&gt;Images&lt;/strong&gt; &lt;div data-controller=&quot;uploads&quot; data-uploads-model=&quot;&lt;%= @post.to_json %&gt;&quot; data-uploads-direct-upload-url=&quot;&lt;%= rails_direct_uploads_path %&gt;&quot; &gt; &lt;input type=&quot;file&quot; multiple=&quot;true&quot; data-action=&quot;change-&gt;uploads#start&quot;&gt; &lt;/div&gt;&lt;/p&gt; 7 javascript/controllers/uploads_controller.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import { Controller } from 'stimulus';import Uploader from 'libs/uploader';export default class extends Controller { start(event) { const { target } = event; const _this = this; [...target.files].forEach(file =&gt; { // 準備 image 容器與 progress bar let wrapper = document.createElement('div'); wrapper.classList.add('img-wrapper'); wrapper.insertAdjacentHTML('afterbegin', ` &lt;div class=&quot;progress&quot;&gt; &lt;div class=&quot;progress-bar&quot; style=&quot;width: 0%;&quot;&gt;&lt;/div&gt; &lt;/div&gt; `); const insertTarget = _this.element.querySelector('input[type=file]'); _this.element.insertBefore(wrapper, insertTarget); // 開始上傳 const uploader = new Uploader(file, _this.directUploadUrl, wrapper); uploader.upload() .then(blob =&gt; { // 更新資料庫 fetch(`/posts/${_this.model.id}.json`, { headers: { 'X-CSRF-Token': _this.csrf, 'Content-Type': 'application/json', 'X-Requested-With': 'XMLHttpRequest' }, method: 'PUT', body: JSON.stringify({ post: { images: [blob.signed_id] } }), credentials: 'same-origin' }) .then(res =&gt; res.json()) .then(data =&gt; { wrapper.innerHTML = ` &lt;div class=&quot;lds-dual-ring&quot;&gt;&lt;/div&gt; `; let img = document.createElement('img'); img.src = data.url; img.onload = () =&gt; { wrapper.innerHTML = ''; wrapper.appendChild(img); wrapper.insertAdjacentHTML('beforeend', ` &lt;a href=&quot;/posts/${_this.model.id}/images/${data.id}&quot; data-action=&quot;click-&gt;uploads#destroy&quot;&gt; 刪除 &lt;/a&gt; `); }; }); }); }); target.value = ''; } get model() { return JSON.parse(this.data.get('model')); } get directUploadUrl() { return this.data.get('directUploadUrl') } get csrf() { return document.querySelector('meta[name=&quot;csrf-token&quot;]').getAttribute('content'); }} 8 scss 的部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566.uploads { display: flex; flex-wrap: wrap;}.img-wrapper { display: inline-flex; border: 1px solid #d9d9d9; min-width: 100px; min-height: 100px; border-radius: 3px; margin-right: 15px; padding: 5px; align-items: center; flex-direction: column; justify-content: center; .progress { width: 80%; height: 10px; background-color: #ccc; border-radius: 5px; position: relative; .progress-bar { position: absolute; top: 0; left: 0; bottom: 0; opacity: 0.8; border-radius: 5px; background: #0076ff; transition: width 120ms ease-out, opacity 60ms 60ms ease-in; transform: translate3d(0, 0, 0); } }}.lds-dual-ring { display: inline-flex; width: 64px; height: 64px; justify-content: center; align-items: center;}.lds-dual-ring:after { content: &quot; &quot;; display: block; width: 46px; height: 46px; margin: 1px; border-radius: 50%; border: 5px solid #327ccb; border-color: #327ccb transparent #327ccb transparent; animation: lds-dual-ring 1.2s linear infinite;}@keyframes lds-dual-ring { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); }} 9 刪除功能 - config/routes.rb 123resources :posts do delete '/images/:image_id' =&gt; 'posts#destroy_image', as: :destroy_image, on: :memberend 10 controllers/posts_controller.rb 1234567before_action :set_post, only: [:show, :edit, :update, :destroy, :destroy_image]# DELETE /posts/1/images/2def destroy_image @post.images.find(params[:image_id]).purge render json: { status: :ok }end 11 javascript/controllers/uploads_controller.js 加入刪除功能 1234567891011121314151617destroy(e) { e.preventDefault(); const url = e.target.href; fetch(url, { headers: { 'X-CSRF-Token': this.csrf, 'Content-Type': 'application/json', 'X-Requested-With': 'XMLHttpRequest' }, method: 'DELETE', credentials: 'same-origin' }) .then(res =&gt; res.json()) .then(data =&gt; { e.target.parentElement.remove(); });} 12 調整 views/posts/show.html.erb 123456789101112131415161718&lt;p&gt; &lt;strong&gt;Images&lt;/strong&gt; &lt;div class=&quot;uploads&quot; data-controller=&quot;uploads&quot; data-uploads-model=&quot;&lt;%= @post.to_json %&gt;&quot; data-uploads-direct-upload-url=&quot;&lt;%= rails_direct_uploads_path %&gt;&quot; &gt; &lt;% @post.images.each do |image| %&gt; &lt;div class=&quot;img-wrapper&quot;&gt; &lt;%= image_tag image.variant(resize: '100x100') %&gt; &lt;a href=&quot;&lt;%= destroy_image_post_path(@post, image) %&gt;&quot; data-action=&quot;click-&gt;uploads#destroy&quot;&gt;刪除&lt;/a&gt; &lt;/div&gt; &lt;% end %&gt; &lt;input type=&quot;file&quot; multiple=&quot;true&quot; data-action=&quot;change-&gt;uploads#start&quot;&gt; &lt;/div&gt;&lt;/p&gt;","link":"/2018/06/26/using-active-storage/"},{"title":"快速複習 Flux 和 Redux","text":"FluxFlux 就是一個設計模式，用於管理資料傳遞流程。其核心概念為單一方向性的資料流。 Flux 由下列 3 個角色組成： Dispatcher：接收 action 然後發送給 store，每一個有使用 dispatcher 註冊的 store 都會收到 action。一個應用程式只會有一個 dispatcher。例如： 使用者輸入代辦項目然後點擊 Enter React 擷取事件之後發送一個 ADD_TODO action （dispatch an action） 這個 action 包含代辦項目的文字資料 接著，每一個 store 都會收到這個 action Store：負責管理資料。strore 需要向 dispatcher 註冊，才能夠收到 action。儲存在 store 中的資料只能夠依據 action 變更。變更之後必須要發送一個 change 的事件例如： store 收到 ADD_TODO action store 內部自行將 action 中的資料加入清單中 store 更新完代辦清單之後 emit 一個 change event Action：定義應用程式內部行為。使用一個物件描述將產生的變更行為與資料（payload）例如： 使用者點擊刪除，則發生一個 DELETE_TODO action 1234{ type: 'DELETE_TODO', id: '12'} 使用 3 者搭配 View（React） 來開發 Client-Side 網頁應用程式。 See the Pen oQNzjx by andyyou (@andyyou) on CodePen. ReduxRedux 是給 JavaScript 應用程式使用的一種狀態管理容器。 使用 createStore 建立一個全應用程式唯一的 store，store 須使用 reducer （Pure Function）來變更內部的 state。 執行狀態變更須發送 action （store.dispatch(action)），一個 action 只是一個單純的物件須包含 type 屬性用來描述變更行為，對應的行為在 reducer 中實現。 搭配 React 使用時要將 store 注入，可使用 react-redux 的 其他子元件要取得 state 或 dispatch 則使用 High-Order Component connect Redux 由下列幾個單元組成： Store：整個應用程式只有一個 Store 12345678910import { createStore } from 'redux';const store = createStore(reducer);// 取得狀態store.getState();// 訂閱let unsubscribe = store.subscribe(() =&gt; { console.log(store.getState());});// 解除unsubscribe(); Action：action 是一個單純的物件，須包含 type 屬性。要變更 state 必須要發送 action。 123456const action = { type: 'ADD_TODO', text: 'Learn Redux',};// 發送 action 的方式store.dispatch(action); Reducer：發送了 action 之後，須變更 state ，使 state 變更的計算過程稱為 reducer。reducer 為一函式接收 action 和 state 回傳一個新的計算後的 state。 1234567891011const todos = function(state, action) { switch(action.type) { case 'ADD_TODO': return [ ...state, action.text, ]; default: return state; }} See the Pen rQNRVY by andyyou (@andyyou) on CodePen.","link":"/2018/11/04/recap-review-flux-n-redux/"},{"title":"Google Cloud Platform - Compute Engine 入門","text":"本文僅筆記在 Google Cloud Platform 上搭配本地端 ssh 金鑰快速建立設定 Compute Engine。 您需要先註冊/登入 GCP 搜尋切換至 Compute Engine 設定名稱與選擇區域 本筆記需求是建立一台測試機，使用最小 CPU 即可。 選擇您需要的作業系統 因為需安裝 HTTP 伺服器測試，請記得設定防火牆標記。 加入本地金鑰 *.pub","link":"/2019/04/13/google-cloud-platform-getting-start/"},{"title":"解析 Certbot（Let&#39;s encrypt） 使用方式","text":"如果您曾好奇為什麼在網路上搜尋到關於 Let’s encrypt 的設定有各式各樣的作法，或者想要好好的理解一下 certbot 的使用方式那麼本篇筆記就是您所需要的。 CertbotCertbot 是可在託管伺服器上執行的指令。如果您不具有 shell 的存取權限並且不熟悉相關指令，您應該確認託管供應商是否提供內建 Let’s Encrypt 功能，支援供應商列表。 安裝 為了能夠快速的實作練習，筆者推薦使用任一雲端服務建立 VM 來測試。使用 Google Cloud Platform 為例本文指令以 Ubuntu 18.04 環境為例。 Certbot 團隊自行維護 PPA(Personal Package Archive)。您可以將其加入檔案庫並依據下列指令安裝 123456$ sudo apt-get update$ sudo apt-get install software-properties-common$ sudo add-apt-repository universe$ sudo add-apt-repository ppa:certbot/certbot$ sudo apt-get update$ sudo apt-get install certbot python-certbot-nginx DNS 套件（可選）如果您希望從 Let’s Encrypt 的 ACMEv2 伺服器自動取得憑證或在其他主機上取得憑證，您可以使用 DNS 套件，參考套件列表取得更多使用資訊。要安裝其他套件可以將上面 sudo apt-get install certbot python-certbot-nginx 指令換成 sudo apt-get install python3-certbot-dns-PLUGIN，大寫 PLUGIN 則是套件名稱。 如果您在其他教學看到使用 certbot-auto 指令，本質上和 certbot 是一樣的東西，不過certbot-auto 會自動安裝相依套件。但請注意：certbot-auto 目前（2019-04-12）不支援 DNS 套件，您還是得自行安裝套件後搭配 certonly 取得憑證。 基本使用在網路上有許多關於 Certbot 的教學，您可能感到困惑許多教學的指令或設定流程並不相同。其原因是 Certbot 根據不同的情境提供不同的指令和作法，本質上分成單純取得憑證和自動化取得憑證搭配是否自動設定伺服器的部分就產生多種作法。 如果要支援自動化就必須通過 acme-challenge（http-01 或 dns-01 ）驗證，設定流程複雜的部分多來自於驗證階段的設定。 後續我們將依據下面列表逐一介紹 全自動 (自備 HTTP 伺服器) certbot 半自動（自備 HTTP 伺服器，不調整 HTTP 伺服器設定）certbot certonly webroot （自備 HTTP 伺服器，自行設定 acme-challenge 部分）certbot certonly --webroot 手動（自備 HTTP 伺服器 、其他主機）certbot certonly --manual DNS 套件 certbot certonly --dns-PLUGIN Standalone（Certbot 提供獨立 HTTP 伺服器部分）certbot certonly --standalone 上面筆者只是依照常用的作法概略列出好讓您理解其中的差異，但這並沒有羅列所有作法，分類上也不嚴謹您應該參考官方文件的說明。 全自動設定執行下面指令會自動取得憑證且 Certbox 會編輯 Nginx 的設定協助完成流程，一道指令完成設定。但前提是您的伺服器和 DNS 須先設定好一般 http 連線的部分。 123456789101112131415$ sudo certbot --nginx# 步驟說明（以下步驟皆於伺服器主機上執行）：# 1. 建置一台 Linux 主機或 VM（Ubuntu 18.04）# 2. 安裝 Nginx# 3. 安裝 Certbox# 4. 確認與設定 DNS 設定 A 紀錄指向主機，如果 DNS 沒設定，acme-challenge 會驗證失敗，失敗仍然可以取得憑證但後續無法自動更新。無論是 http-01 或 dns-01 都是驗證您是否擁有網域的控制權以得到後續自動操作的權限，只是驗證的方式有些微不同。# 5. 執行 certbot 全自動指令# 6. 完成# 成功提升訊息# Congratulations! You have successfully enabled &lt;您的網址&gt;# You should test your configuration at:# https://www.ssllabs.com/ssltest/analyze.html?d=&lt;您的網址&gt; 半自動如果您是保守派希望自己設定 Nginx ，則可以使用 certonly 123456789$ sudo certbot --nginx certonly# certonly 具體執行的步驟# 1. 暫時的變更設定，加入新的 *Server 區塊設定* 以通過 ACME Challenge。# 2. 重載 Nginx 設定。(sudo nginx -s reload)# 3. 還原變更的設定。# 4. 重載 Nginx 設定。# 接著您要自行設定 Nginx 安裝憑證。 ACME Challenge ACME Challenge 是為了要證明您具有網域控制權的一種驗證方式，主要是通過您設定一組 A/AAAA （IPv4/IPv6）紀錄指向伺服器，並在伺服器上驗證 challenge 憑證。這也是為什麼自動安裝憑證的流程需要您的網站以及網址是處於線上的狀態（DNS 指向伺服器，伺服器提供對應證明 hash）。 全自動和半自動的差別是在最後是否自動在 Nginx 設定的 server {} 的部分為您自動加入 ssl 相關設定，如果您不想讓 Certbot 接觸 Nginx 設定或著有線上的服務不能中斷的需求，您可以使用 webroot 套件。 注意：全自動和半自動只是筆者依據行為命名好讓您比較容易立即，實際上僅是不同指令的行為。 **另外，如果您希望直接從 Let’s Encrypt 的新 ACMEv2 伺服器取得多子網域通用憑證，您還是需要使用 Certbot 的 DNS 套件**。請確認您已經針對您 DNS 供應商安裝對應套件然後執行下面的指令： 1$ sudo certbot -a dns-plugin -i nginx -d &quot;*.example.com&quot; -d example.com --server https://acme-v02.api.letsencrypt.org/directory dns-plugin 的部分請替換成您想要使用的套件。例如：Cloudflare 要使用 dns-cloudflare。您可能需要提供額外的資訊例如 API 憑證的路徑，更多關於套件的使用請參考相關文件 webroot需要在伺服器不中斷下取得憑證。須自行設定 acme-challenge ，等於是不讓 Certbot 碰到 HTTP 伺服器設定的作法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879# 0. 安裝 Nginx 與 Certbot# 1. 設定 acme-challenge，編輯 /etc/nginx/sites-available/default$ sudo vi /etc/nginx/sites-available/default# 2. 加入設定location ^~ /.well-known/acme-challenge/ { default_type &quot;text/plain&quot;; root /var/www/html/;}# 完整設定參考server { listen 80 default_server; listen [::]:80 default_server; # ... 省略 ... # ↓↓↓↓↓↓↓↓↓↓↓ 重點 location ^~ /.well-known/acme-challenge/ { default_type &quot;text/plain&quot;; root /var/www/html/; } # ↑↑↑↑↑↑↑↑↑↑↑}# 3. 執行 Certbot 取得憑證，這裡的 /var/www/html/ 是因為我們直接使用 Nginx 預設站點$ sudo certbot certonly --webroot -w /var/www/html/ -d &lt;您的網址&gt;# 4. 成功之後會取得下面提升訊息# Saving debug log to /var/log/letsencrypt/letsencrypt.log# Plugins selected: Authenticator webroot, Installer None# Obtaining a new certificate# Performing the following challenges:# http-01 challenge for &lt;您的網址&gt;# Using the webroot path /var/www/html for all unmatched domains.# Waiting for verification...# Cleaning up challenges# IMPORTANT NOTES:# - Congratulations! Your certificate and chain have been saved at:# /etc/letsencrypt/live/&lt;您的網址&gt;/fullchain.pem# Your key file has been saved at:# /etc/letsencrypt/live/&lt;您的網址&gt;/privkey.pem# Your cert will expire on 2019-12-25. To obtain a new or tweaked# version of this certificate in the future, simply run certbot# again. To non-interactively renew *all* of your certificates, run# &quot;certbot renew&quot;# - If you like Certbot, please consider supporting our work by:# Donating to ISRG / Let's Encrypt: https://letsencrypt.org/donate# Donating to EFF: https://eff.org/donate-le# 5. 安裝憑證$ sudo vi /etc/nginx/sites-available/&lt;您的網址&gt;# 6. Nginx 設定server { listen 443 ssl; listen [::]:443 ssl; root /var/www/html; index index.html index.nginx-debian.html; server_name &lt;您的網址&gt;; location / { try_files $uri $uri/ =404; } ssl_certificate /etc/letsencrypt/live/&lt;您的網址&gt;/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/&lt;您的網址&gt;/privkey.pem;}# 7. 加入設定與重載$ sudo ln -s /etc/nginx/sites-available/&lt;您的網址&gt; /etc/nginx/sites-enabled/&lt;您的網址&gt;$ sudo nginx -t$ sudo nginx -s reload 注意：沒有通過 ACME-Challenge（Automatic Certificate Management Environment） 還是可以產生憑證，只是後續無法自動產生/更新憑證。 手動手動的部分支援各種不同的參數，我們只會點出一些指令並紀錄提升訊息，希望能協助您有些基本的理解，查閱官方資料時能夠更容易掌握。 12345678910# 手動驗證可用 --preferred-challenges 參數指定 http 驗證或 dns 驗證，預設為 http。# 1. 單純取得憑證$ certbot certonly --manual# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -# 2. 在其他機器上取得憑證 - macOS$ brew install certbot$ certbot certonly --manual --config-dir ~/your/path/letsencrypt --work-dir ~/your/path/letsencrypt --logs-dir ~/your/path/letsencrypt --preferred-challenges dns 執行指令後您可能會遭遇的執行流程紀錄如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243# httpSaving debug log to /your/path/letsencrypt/letsencrypt.logPlugins selected: Authenticator manual, Installer NonePlease enter in your domain name(s) (comma and/or space separated) (Enter 'c'to cancel):- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -NOTE: The IP of this machine will be publicly logged as having requested thiscertificate. If you're running certbot in manual mode on a machine that is notyour server, please ensure you're okay with that.Are you OK with your IP being logged?- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -(Y)es/(N)o:- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Create a file containing just this data:Ad8wBqsP8mZoiUeN-XL_0v60vHFFjoaZTsGZ9gxGDpw.MUtTMf4SSLHIm0CLmqTzjYVPlBO7pDtO1tvDq90CHW8And make it available on your web server at this URL:http://&lt;您的網址&gt;/.well-known/acme-challenge/Ad8wBqsP8mZoiUeN-XL_0v60vHFFjoaZTsGZ9gxGDpw- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Press Enter to Continue# dns- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -NOTE: The IP of this machine will be publicly logged as having requested thiscertificate. If you're running certbot in manual mode on a machine that is notyour server, please ensure you're okay with that.Are you OK with your IP being logged?- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -(Y)es/(N)o:- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Please deploy a DNS TXT record under the name_acme-challenge.&lt;您的網址&gt; with the following value:KzQ9pmKDC_iP9q4AWhGdGx9TezqoKy-eYo8PFAIYTG9Before continuing, verify the record is deployed.- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Press Enter to Continue 自動更新Certbot 套件內建自動排程可以在到期之前自動更新憑證。因為 Let’s Encrypt 憑證只有 90 天，所以推薦使用這個功能。您可以利用下面的指令測試自動更新： 1234$ sudo certbot renew --dry-run# 檢查自動更新$ sudo systemctl status certbot.timer 手動更新1$ sudo certbot renew -v 移除12345678910# 移除憑證$ sudo certbot delete# 刪除 /etc/nginx/&lt;your site&gt; SSL 設定# 檢查 /etc/letsencrypt/archive, /etc/letsencrypt/live, /etc/letsencrypt/renewal# 直接根據域名刪除$ sudo certbot delete --cert-name &lt;domain_name.com&gt;# 移除 certbot$ sudo apt-get remove certbot python-certbot-nginx 查詢憑證日誌12345https://crt.sh/?q=&lt;您的網址&gt;# 查詢憑證資訊$ sudo certbot certificates 檢查自動化 Job123/etc/crontab//etc/cron.*/*systemctl list-timers 總結現在您可以自行判斷該使用哪種方式，而不是單純照文章執行指令而不知為何。一般來說如果只是測試主機您大可放心的使用全自動的方式，如果是正式主機最好還是使用 webroot 的方式自己設定 HTTP 伺服器。 補充SSL 憑證有三個屬性：驗證方式、加密強度、對應主旨名稱數量。 驗證方式 Extended Validation 最高等級認證 Organization validated 公司組織認證，例如：TWCA 在憑證的Organization(O)，含有組織資訊 12345CN = github.comO = GitHub, Inc.L = San FranciscoS = CaliforniaC = US Domain Validation 最低等級認證，僅做網域認證。例如：Let’s encrypt 對應主旨名稱數量 完全限定域名（Fully qualified domain name），縮寫為FQDN，又譯為完全資格域名、完整領域名稱，絕對領域名稱（Absolute domain name）、 絕對域名，網域名稱的一種，能指定其在域名系統 (DNS) 樹狀圖下的一個確實位置。 一張憑證的主旨名稱（Subject Name）即對應的 FQDN： 一對一 不同網域一對多(SAN/UC) 同網域多對多（Wildcard/萬用憑證/多子網域通用憑證） 參考資源 官方安裝流程 官方取得憑證文件 HTTPS 简介及使用官方工具 Certbot 配置 Let’s Encrypt SSL 安全证书详细教程 安裝 Nginx 自動排程 renew","link":"/2019/04/13/how-to-use-certbot/"},{"title":"gvm on macOS installation cheatsheet","text":"OSX $PATH 設定路徑12345678910# ~/.profile# ~/.bash_profile# ~/.bashrc# ~/.zshrc# /etc/profile# /etc/paths# /etc/paths.d$ /usr/libexec/path_helper -s 移除 OSX 官方 go 安裝檔12345# https://golang.org/doc/install#uninstall$ rm /usr/local/go$ rm /etc/paths.d/go# 使用 gvm https://github.com/moovweb/gvm 查詢環境1$ go env 安裝123456789101112131415161718192021222324252627282930313233343536373839404142# gvm$ bash &lt; &lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer)# OR$ zsh &lt; &lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer)# 重啓終端機# 列出所有版本$ gvm listall# 列出本地版本$ gvm list# OSX 環境有問題的話$ xcode-select --install$ brew update$ brew install mercurial# 重新編譯（Compile）特定版本，需要先安裝好 Go1.4$ gvm install &lt;version&gt;# 直接安裝 Binary，不需要編譯$ gvm install &lt;version&gt; -B# 刪除 gvm$ gvm implodeAre you sure? [Y/n] yGVM successfully removed# 或者$ rm -rf ~/.gvm# 2018-12-06 - Fix Compile Error: failed MSpanList_Insert &amp; Missing go1.4$ gvm install go1.7.3 -B$ gvm use go1.7.3$ gvm install go1.11.2$ gvm use go1.11.2 --default# 編輯 zshrc[[ -s &quot;/Users/andyyou/.gvm/scripts/gvm&quot; ]] &amp;&amp; source &quot;/Users/andyyou/.gvm/scripts/gvm&quot;# export GOPATH=~/Projects/go# gvm 預設 GOPATH# ~/.gvm/pkgsets/go&lt;version&gt;/globalexport PATH=$PATH:$(go env GOPATH)/bin","link":"/2019/04/14/gvm-cheat-sheet/"},{"title":"Deploy Rails 6 to Google App Engine","text":"官方 Rails 5 參考 事前準備 於 Google Cloud Platform 主控台建立專案。 為專案啟用計費功能，如果您尚未啟用，請立即啟用計費功能 安裝並初始化 Google Cloud SDK 設定本機 Rails 環境，本文假設您對於 Rails 的部分已有足夠的理解，故不在此增加冗余的介紹 啟用 Cloud SQL Admin API立即啟用或使用指令介面： 1234567# 切換專案$ gcloud projects list$ gcloud config set project &lt;project_id&gt;# 查詢服務$ gcloud services list --available# 啟用$ gcloud services enable sqladmin.googleapis.com 建立 Cloud SQL Instance 和 Database 建立 PostgreSQL 執行個體 在執行個體中建立資料庫 安裝 gem12$ bundle add pg # 如果尚未安裝$ bundle add appengine 設定資料庫連線12# 取得 Cloud SQL 資料庫資訊$ gcloud sql instances describe &lt;instance_name&gt; 12345678910# config/database.ymlproduction: adapter: postgresql encoding: unicode pool: 5 timeout: 5000 username: &quot;[YOUR_POSTGRES_USERNAME]&quot; password: &quot;[YOUR_POSTGRES_PASSWORD]&quot; database: [your_database_name_production] host: &quot;/cloudsql/[YOUR_INSTANCE_CONNECTION_NAME]&quot; 您也可以一併在 app.yaml 中加入 env_variables。 Active Storage 設定123456# config/storage.ymlgoogle: service: GCS project: [YOUR_PROJECT_ID] credentials: &lt;%= ENV['GOOGLE_APPLICATION_CREDENTIALS'] %&gt; bucket: [YOUR_BUCKET_NAME] 如果您的圖片權限異常 SignedUrlUnavailable 可以取得 credential.json 再試試。 控制台 &gt; APIs &amp; Services &gt; Credentials &gt; Create credentials &gt; Service account key &gt; App engine default service account &gt; JSON &gt; Create。 123456# config/storage.ymlgoogle: service: GCS project: website credentials: &lt;%= Rails.root.join(&quot;your/path.json&quot;) %&gt; bucket: [YOUR_BUCKET_NAME] 設定 app.yaml 部署至 App EngineApp Engine 彈性環境使用 app.yaml 描述部署環境設定，在 Rails 專案根目錄加入 app.yaml 12345678910entrypoint: bundle exec rackup --port $PORTenv: flexruntime: ruby# Rails 5.2+ 之後使用 config/master.keyenv_variables: RAILS_MASTER_KEY: [MASTER_KEY]beta_settings: cloud_sql_instances: [YOUR_INSTANCE_CONNECTION_NAME] 設定完成後執行下列指令： 12345678910111213141516$ gcloud app create$ RAILS_ENV=production bundle exec rails assets:precompile$ gcloud app deploy# 取得專案資訊$ gcloud info# 瀏覽$ gcloud app browse# OR$ gcloud app browse -s &lt;service_name&gt;# 讀取日誌$ gcloud app logs read$ gcloud app logs tail$ gcloud app logs tail -s &lt;service_name&gt; 授予 appengine RubyGem 權限，執行 Migration123456$ gcloud projects list$ gcloud projects add-iam-policy-binding [YOUR-PROJECT-ID] \\ --member=serviceAccount:[PROJECT_NUMBER]@cloudbuild.gserviceaccount.com \\ --role=roles/editor]$ bundle exec rake appengine:exec -- bundle exec rake db:migrate 其他資源與參考12345678910# 取得用於驗證 GCP 服務的本機憑證。$ gcloud auth application-default login# Stackdriver# Add this to config/environments/*.rbRails.application.configure do |config| # Stackdriver Logging specific parameters config.google_cloud.logging.project_id = &quot;YOUR-PROJECT-ID&quot; config.google_cloud.logging.keyfile = &quot;/path/to/service-account.json&quot;end Ruby on Rails GCP Fix Google::Cloud::Storage::SignedUrlUnavailable 外部連線資料庫 使用 IP 位址連結 psql 用戶端 Setting up Rails 5.2 Active Storage, using Google Cloud Storage and Heroku","link":"/2019/05/15/deploy-rails-6-to-app-engine/"},{"title":"匯出 PostgreSQL","text":"1234567891011121314151617# 0. 取得連線字串# 1. Instance Security 記得允許您的 IP 存取# 2. 測試連線$ psql -h [ENDPOINT_URL] \\ -U [USERNAME] \\ -d [DATABASE_NAME]# 輸入密碼# 檢查 - 列出所有資料庫$ \\l# 檢查 - 列出所有 Tables$ \\d# 3. 匯出$ pg_dump -h [ENDPOINT_URL] \\ -U [USERNAME] \\ -f [FILENAME].sql [DATABASE_NAME]","link":"/2019/05/17/dump-psql/"},{"title":"更新 heroku-18","text":"因舊有 Heroku Cedar-14 stack 將進入 EOL。 官方提供了完整的教學。這裡只是簡易的筆記。 12345678910111213141516171819# 查詢$ heroku plugins:install apps-table# 個人帳戶$ heroku apps:table --filter=&quot;STACK=cedar-14&quot;# 團隊$ heroku apps:table --team=&lt;team name&gt; --filter=&quot;STACK=cedar-14&quot;# Clone &amp; Upgrade$ heroku stack:set heroku-18 -a &lt;app_name&gt;$ heroku git:clone -a &lt;app_name&gt;$ cd &lt;app_name&gt;# https://devcenter.heroku.com/articles/ruby-support#supported-runtimes$ git commit --allow-empty -m &quot;Upgrading to heroku-18&quot;$ git push heroku master# 如果您的舊站 Rails 跟我一樣是 5.0 ，且您不想動大刀，那麼最快的方式為# ruby 升至 2.4.6# rails 5.0.7# 搭配 http://railsdiff.org/5.0.0/5.0.7.2","link":"/2019/05/02/upgrade-heroku-18/"},{"title":"Rails 6 Action Text 直接上傳圖片至 Google Cloud Storage 失敗","text":"直接先備份參考解答。 小弟跟上文作者一樣在使用 Rails 6 的 Action Text 時發現圖片無法上傳 Google Cloud Storage，Rails 採用 Google App Engine 方式部署，上傳使用內建 Active Storage。 問題主要是遇到 cors 的錯誤，解法原文已有，本文只是自己的備份筆記，可參考原文更詳細。 1$ gsutil cors get gs://my-bucket-name 無論您是否有取得設定或者遇到 gs://my-bucket-name/ has no CORS configuration，您都可以直接使用下面的方式把 origin 換掉設定即可。 輸入您的來源網址，您不一定是使用 App Engine 123456789[ { &quot;origin&quot;: [&quot;https://app.hubspot.com&quot;], &quot;responseHeader&quot;: [&quot;Content-Type&quot;, &quot;Content-Md5&quot;], &quot;method&quot;: [&quot;PUT&quot;, &quot;GET&quot;, &quot;HEAD&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;], &quot;maxAgeSeconds&quot;: 3600 }] 完成 JSON 之後，下指令設定： 1$ gsutil cors set cors.json gs://my-bucket-name","link":"/2019/06/20/gcs-rails-action-text/"},{"title":"React Beautiful Dnd 快速使用筆記","text":"react-beautiful-dnd 有 3 個主要元件： DragDropContext - 建立一個可 DnD 的範圍。 onDragStart onDragUpdate onDragEnd Droppable - 建立可以被拖曳放入的區塊。 Draggalbe - 可被拖拉元件 安裝 1$ npm i react-beautiful-dnd 於希望 DnD 的位置使用 DragDropContext 包起來，且 onDragEnd 必須設定： 1234567import { DragDropContext } from 'react-beautiful-dnd';&lt;DragDropContext onDragEnd={() =&gt; {}}&gt; {/* Your target */}&lt;/DragDropContext&gt; 使用 Droppable 配置可被拖入的區塊 Droppable 必須設定 droppableId Droppable 使用 render props pattern 意味著內部須使用一個 function。這個 function 使用 provided 將所需的參數代置 DOM provided 是一個物件 provided.droppableProps，該參數須套用至欲被拖放的 DOM 上 ref 參數須設定 provided.placeholder 1234567891011121314impoort { Droppable } from 'react-beautiful-dnd';&lt;Droppable droppableId=&quot;id&quot;&gt; { provided =&gt; ( &lt;List ref={provided.innerRef} {...provided.droppableProps} &gt; {provided.placeholder} &lt;/List&gt; ) }&lt;/Droppable&gt; 將可被拖移的元件使用 Draggable 包起來： draggableId 和 index 必須。 與 Droppable 一樣，children 為 render props pattern 內部項目 ref 須設定，provided.draggableProps 和 provided.dragHandleProps 須套用至元件 123456789101112131415&lt;Draggable draggableId={t.id} index={i} &gt; {p =&gt; ( &lt;Item ref={p.innerRef} {...p.draggableProps} {...p.dragHandleProps} key={t.id} &gt; {t.text} &lt;/Item&gt; )} &lt;/Draggable&gt; onDragEnd 變更排序 123456789101112131415// onDragEnd(result) result 資訊const result = { draggableId: 1, type: 'TYPE', reson: 'DROP', source: { droppableId: 1, index: 0, }, destination: { droppableId: 1, index: 1, }} Reorder: 12345678910111213onDragEnd={result =&gt; { const { source, destination, draggableId } = result; if (!destination) { return; } let arr = Array.from(this.state.todos); const [remove] = arr.splice(source.index, 1); arr.splice(destination.index, 0, remove); this.setState({ todos: arr, });}} 在拖拉的時候，Droppable， Draggable 元件除了 provided 之外還提供了 snapshot 下面是 snapshot 提供的資訊： 123456789const draggableSnapshot = { isDragging: true, draggingOver: 'droppable-id'}const droppableSnapshot = { isDraggingOver: true, draggingOverWith: 'draggable-id'} 回到 DragDropContext 除了 onDragEnd 之外還有 onDragStart 和 onDragUpdate 兩個 events。這兩個事件可以協助我們加入一些樣式： 123456789101112131415161718// onDragStartconst start = { draggableId: 'draggalbe-id', type: 'TYPE', source: { droppableId: 'droppable-id', index: 0, }}// onDragUpdateconst update = { ...start, destination: { droppableId: 'droppable-id', index: 1, }} drag handle 是 Draggable 的一部分用來處理可拖拉的部分（可拖拉整個元件或局部）。 要停止拖拉可以設定 isDragDisabled Droppable 可以限制可被拖入的元件： type 同樣 type 的 Droppable 可以互相拖移 isDropDisabled 控制可否被拖入","link":"/2019/06/04/react-beautiful-dnd-quick-note/"},{"title":"如何使用 react-intl","text":"React 國際化快速概覽：如何建置一個國際化的 React 應用程式。通過本文的協助您可以學會如何偵測使用者的本地資訊，將其儲存在 cookie 並允許使用者變更，提供不同語言的介面，適當的貨幣格式同時也包含一些常見問題的列表。 注意：本文為React Internationalization – How To 的翻譯/專案實作更新，大部分文章為翻譯原文，專案與實作則進行簡化與更新。該文由 react-intl 官方文件所推薦。進行更新當下 react-intl 版本為 v2.9.0，因此稍微備註 v3+ 的一些警告。 術語說明與準備Internationalization 是一個很長的單字，比較常見的兩個縮寫為 intl 或 i18n 。Localization 則為 l10n。 國際化應用程式一般被分為三個主要的功能： 偵測使用者的地區、語系 （locale） 介面上的翻譯 內容格式例如日期，貨幣，數字 本文會聚焦在前端的部分，我們會建立一個簡易的 Universal React Application 並支援多地區多語系（locale）。 讓我們使用樣版專案作為我們的起點，這邊我們使用 Express 實作 Server-Side 渲染，webpack 單純使用 Babel 搭配 @babel/preset-env 和 @babel/preset-react 編譯 Client 端的 JavaScript，然後由 Express 取得編譯結果。使用 nodemon 執行開發環境下的 Express，還有 webpack-dev-server 用於提供資源檔。 簡化更新版 - 除了更新 babel 並移除了 better-npm-run 等套件目標在單純化樣版專案，專注於 react-intl 的學習。 原文專案 Server 端的進入點時 server.js。這裡使用了 @babel/polyfill 以支援我們使用一些新的 JavaScript 特性與語法。至於 Server 端的邏輯則位於 src/server.js。在此我們設定了 Express 並監聽 3001 埠。最後，我們渲染一個非常簡單的元件 components/App.js。 簡化版使用相同目錄結構，但 .jsx 一律變更為 .js。 Client 端的進入點是 src/client.js ，這裡我們將 components/App.js 掛載至 root 元素上，該 HTML 由 Express 產生。 簡化版在命名上作了一些調整，但整體邏輯不變。 在下載完檔案庫的專案之後，執行 npm install 並執行 npm start 即可 123456$ git https://github.com/andyyou/simplify-smashing-react-i18n$ cd simplify-smashing-react-i18n$ npm install# (Optional) git reset to start$ git reset d0d971d --hard$ npm start 然後瀏覽 localhost:3001 可以檢視網站。到此我們完成了基本的準備，可以開始進入主題了。 1. 偵測使用者 locale 資訊有兩種可能的方式可以完成這個需求。基於某些理由，大部分知名的網站包含 Skype 和 NBA 使用 IP 地理位置來判斷使用者的所在地並基於這個訊息去推測使用者使用的語言。然而這個方式不只實作上消耗比較多的資源而且也不是很準確。在人們常旅遊的現代，意味著所在地並不能代表使用者的 locale 。 locale 通常代表使用者的語系、地區、偏好等資料的集合 取而代之的是我們會使用第二種方式，通過在伺服器端擷取 HTTP 標頭的 Accept-Language 來取得使用者偏好的語系。現今主流瀏覽器會在每一個請求加上該資訊。 Accept-Language 請求標頭Accept-Language 請求標頭會提供回應該請求時偏好的語系。還可以替每個語系提供權重，這意味著可以建立使用者偏好的語系列表，預設權重（Quality）為 1 q=1 例如：Accept-Language: da, en-gb;q=0.8, en;q=0.7 表示我偏好丹麥語，但我也接受英式英文和其他類型的英文。我們可以去判斷使用者指定的語言範圍是否符合或前綴字符合 （- 之前）。 值得一提的是這種方式仍然不完美。舉例來說，一個使用者可能在網咖或利用公共電腦使用您的網站。因此為了解決這個問題通常需要提供使用者可以方便變更語系的方式。 實作這裡的範例使用 Express ，我們使用 accept-language 套件來協助我們從 HTTP 標頭比對並取得最接近網站支援的語系。如果都找不到則使用預設語系。對於造訪過的用戶則檢查 cookie 來取回之前的設定。 安裝相依套件： 1$ npm i accept-language cookie-parser js-cookie 接著，修改 src/server.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import express from 'express';import React from 'react';import ReactDOMServer from 'react-dom/server';import cookieParser from 'cookie-parser';import acceptLanguage from 'accept-language';import App from './components/App';const assetUrl = process.env.NODE_ENV !== 'production' ? 'http://localhost:8050' : '/';const renderHTML = componentHTML =&gt; ` &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Hello React&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;${componentHTML}&lt;/div&gt; &lt;script type=&quot;application/javascript&quot; src=&quot;${assetUrl}/public/assets/bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt;`;const detectLocale = (req) =&gt; { const cookieLocale = req.cookies.locale; return acceptLanguage.get(cookieLocale || req.headers['accept-language'] || 'en');};acceptLanguage.languages(['en', 'ru']);const app = express();app.use(cookieParser());app.use((req, res) =&gt; { const locale = detectLocale(req); const componentHTML = ReactDOMServer.renderToString(&lt;App /&gt;); res.cookie('locale', locale, { maxAge: (new Date() * 0.001) + (365 * 24 * 3600), }); return res.end(renderHTML(componentHTML));});const PORT = process.env.PORT || 3001;app.listen(PORT, () =&gt; { console.log(`Server listening on: ${PORT}`);}); 這一步，我們匯入了 accept-language 套件並設定支援英文和俄文 en 和 ru 。然後實作了 detectLocale 函式，首先讀取 cookie 如果沒有則接著查 Accept-Language 標頭，最後如果都沒有則設定 en 為預設。在處理完請求之後加入 Set-Cookie 用於後續的請求。 2. 介面翻譯本文使用 react-intl 來完成我們的需求。這是 React 生態中目前比較流行並經過實戰檢驗的 i18n 套件。它和多數的 React 套件使用相同的方式： 提供 High order components 高階元件加上 React Context 的功能注入多國語系的函式來處理訊息、時間、數字、貨幣格式。 第一步需要設定 Provider，為了完成這步我們將要安裝套件與變更 src/server.js 和 src/client.js 檔案。 1$ npm i react-intl 下面是 src/server.js 主要是加入 react-intl 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import express from 'express';import React from 'react';import ReactDOMServer from 'react-dom/server';import cookieParser from 'cookie-parser';import acceptLanguage from 'accept-language';import { IntlProvider } from 'react-intl';import App from './components/App';const assetUrl = process.env.NODE_ENV !== 'production' ? 'http://localhost:8050' : '/';const renderHTML = componentHTML =&gt; ` &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Hello React&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;${componentHTML}&lt;/div&gt; &lt;script type=&quot;application/javascript&quot; src=&quot;${assetUrl}/public/assets/bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt;`;const detectLocale = (req) =&gt; { const cookieLocale = req.cookies.locale; return acceptLanguage.get(cookieLocale || req.headers['accept-language'] || 'en');};acceptLanguage.languages(['en', 'ru']);const app = express();app.use(cookieParser());app.use((req, res) =&gt; { const locale = detectLocale(req); const componentHTML = ReactDOMServer.renderToString( &lt;IntlProvider locale={locale}&gt; &lt;App /&gt; &lt;/IntlProvider&gt; ); res.cookie('locale', locale, { maxAge: (new Date() * 0.001) + (365 * 24 * 3600), }); return res.end(renderHTML(componentHTML));});const PORT = process.env.PORT || 3001;app.listen(PORT, () =&gt; { console.log(`Server listening on: ${PORT}`);}); 接著是 src/client.js 1234567891011121314import React from 'react';import ReactDOM from 'react-dom';import { IntlProvider } from 'react-intl';import Cookie from 'js-cookie';import App from './components/App';const locale = Cookie.get('locale') || 'en';ReactDOM.render( &lt;IntlProvider locale={locale}&gt; &lt;App /&gt; &lt;/IntlProvider&gt;, document.getElementById('root'),); 現在，IntlProvider 的子元件都可以存取多語系國際化功能的函式。讓我們加入一些翻譯文字到程式中搭配一個按鈕可以變更 locale。這裡我們有兩個方式：不管是 FormattedMessage 元件或者 formatMessage 函式都可以協助我們轉換語系。差別是元件內容會被 span 包起來，這個在作為標籤的內容是沒問題的，但是針對 HTML 屬性例如 alt title 則需要函式。 先讓我們在 src/components/App.js 加入一些範例看看： 12345678910111213import React from 'react';import { FormattedMessage } from 'react-intl';const App = () =&gt; ( &lt;div className=&quot;App&quot;&gt; &lt;FormattedMessage id=&quot;app.hello_world&quot; defaultMessage=&quot;Hello World!&quot; description=&quot;Hello world header greeting&quot; /&gt; &lt;/div&gt;)export default App; 注意到 id 在整個應用程式中必須要是唯一值，因此很合理的是我們可以建立一些命名規則例如： componentName.uniqueIdInComponent。接著，defaultMessage 會使用在預設語系，description 則是用來給那些翻譯者一些資訊。 重新執行 npm start 並重新載入頁面，您一樣可以看到 Hello World 的訊息，不過如果您開啟開發者工具檢視會看到現在文字被 span 包起來了。這種情況下多一個 span 不是什麼太大的問題，不過有時候我們只想要文字本身不要任何標籤。要完成這個需求我們需要直接存取 react-intl 提供的物件。 讓我們回到 src/components/App.js： 1234567891011121314151617181920212223242526import React from 'react';import { FormattedMessage, intlShape, injectIntl, defineMessages } from 'react-intl';const messages = defineMessages({ helloWorld2: { id: 'app.hello_world2', defaultMessage: 'Hello World 2!', },});const App = (props) =&gt; ( &lt;div className=&quot;App&quot;&gt; &lt;FormattedMessage id=&quot;app.hello_world&quot; defaultMessage=&quot;Hello World!&quot; description=&quot;Hello world header greeting&quot; /&gt; &lt;div&gt; {props.intl.formatMessage(messages.helloWorld2)} &lt;/div&gt; &lt;/div&gt;);App.propTypes = { intl: intlShape.isRequired,};export default injectIntl(App); 上面我們增加了不少程式碼。首先，我們必須要使用 injectIntl 將我們的元件包起來，其作用是傳入 intl 物件。為了取得翻譯後的訊息，我們必須要使用 formatMessage 方法和傳入 message 物件。一個 message 物件必須要有一個全域唯一的 id 和 defaultValue 屬性。使用 react-intl 提供的 defineMessages 來定義該物件。 關於 react-intl 最棒的事情就是其生態系。接著，我們可以加入 babel-plugin-react-intl。 注意如果您參考的是原文的檔案庫，請使用 babel-plugin-react-intl@2.4.0 版本。 該 babel 擴充套件會從我們的元件中讀取 FormattedMessages 並建立字典檔。然後我們可以把這份字典檔交給翻譯人員。 事實上您可以單純傳入 formatMessage 一個具備相同屬性的物件即可。使用 defineMessages 的原因是它會加入 babel-plugin-react-intl 的 Hook 協助該套件擷取字典檔。 安裝該套件 1$ npm i babel-plugin-react-intl -D 之後 .babelrc 加入設定 123456789101112131415{ &quot;presets&quot;: [ &quot;@babel/preset-env&quot;, &quot;@babel/preset-react&quot; ], &quot;env&quot;: { &quot;development&quot;: { &quot;plugins&quot;: [ [&quot;react-intl&quot;, { &quot;messagesDir&quot;: &quot;build/messages/&quot; }] ] } }} 注意：package.json 需加入環境變數 NODE_ENV=development。 重啓 Express npm start 或者 npm run express 即可看到 build/messages 目錄被建立在專案根目錄下。內部的檔案結構則是對照原始專案。我們需要合併所有檔案變成單一 JSON 檔案。可以參考scripts。儲存在 scripts/translate.js 。然後在 package.json 加入新的 script 指令： 1$ npm i @babel/cli -D 12345&quot;scripts&quot;: { ... &quot;build:langs&quot;: &quot;babel scripts/translate.js | node&quot;, ...}, 接著，試試指令 1$ npm run build:langs 您應該會看到 build/lang/en.json 被建立了。其內容為： 1234{ &quot;app.hello_world&quot;: &quot;Hello World!&quot;, &quot;app.hello_world2&quot;: &quot;Hello World 2!&quot;} 現在最有趣的部分來了。在 Server 端，我們可以載入所有的翻譯到記憶體，然後根據請求提供對應的語系。然而在 Client 端這個方法並不適用，Client 端只能依據需求一次取得所需的 JSON 檔案，然後自動套用提供給所有元件。 讓我們複製編譯的輸出結果到 public/assets 1$ cp build/lang/en.json public/assets/en.json 接著，建立一份 public/assets/ru.json 1234{ &quot;app.hello_world&quot;: &quot;Привет мир!&quot;, &quot;app.hello_world2&quot;: &quot;Привет мир 2!&quot;} 處理好字典檔之後我們開始調整 Server 和 Client 端的程式碼。 首先是 src/server.js ，因為修改的地方比較多，下面先把重點點出，再列出完整程式碼方便對照： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 匯入相依的函式 addLocaleData、fs、path 等import { addLocaleData, IntlProvider } from 'react-intl';import fs from 'fs';import path from 'path';import en from 'react-intl/locale-data/en';import ru from 'react-intl/locale-data/ru';addLocaleData([…ru, …en]);// 宣告 messages 和 localeData// 一個是字典檔，一個是 react-intl 提供給日期、數字等的格式資源const messages = {};const localeData = {};['en', 'ru'].forEach((locale) =&gt; { localeData[locale] = fs.readFileSync(path.join(__dirname, '../node_modules/react-intl/locale-data/${locale}.js')).toString(); messages[locale] = require('../public/assets/${locale}.json');});// 將 localeData 加入 HTMLconst renderHTML = (componentHTML, locale) =&gt; ` &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Hello React&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;${componentHTML}&lt;/div&gt; &lt;script type=&quot;application/javascript&quot; src=&quot;${assetUrl}/public/assets/bundle.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;application/javascript&quot;&gt; ${localeData[locale]} &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;`;// 在 Provider 加入 messages 參數const componentHTML = ReactDOMServer.renderToString( &lt;IntlProvider locale={locale} messages={messages[locale]}&gt; &lt;App /&gt; &lt;/IntlProvider&gt;);// renderHTML 加入 locale 參數return res.end(renderHTML(componentHTML, locale)); 完整 src/server.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import express from 'express';import React from 'react';import ReactDOMServer from 'react-dom/server';import cookieParser from 'cookie-parser';import acceptLanguage from 'accept-language';import fs from 'fs';import path from 'path';import { IntlProvider, addLocaleData } from 'react-intl';import App from './components/App';import en from 'react-intl/locale-data/en';import ru from 'react-intl/locale-data/ru';addLocaleData([...ru, ...en]);const messages = {};const localeData = {};['en', 'ru'].forEach((locale) =&gt; { localeData[locale] = fs.readFileSync(path.join(__dirname, `../node_modules/react-intl/locale-data/${locale}.js`)).toString(); messages[locale] = require(`../public/assets/${locale}.json`);})const assetUrl = process.env.NODE_ENV !== 'production' ? 'http://localhost:8050' : '/';const renderHTML = (componentHTML, locale) =&gt; ` &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Hello React&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;${componentHTML}&lt;/div&gt; &lt;script type=&quot;application/javascript&quot; src=&quot;${assetUrl}/public/assets/bundle.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;application/javascript&quot;&gt; ${localeData[locale]} &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;`;const detectLocale = (req) =&gt; { const cookieLocale = req.cookies.locale; return acceptLanguage.get(cookieLocale || req.headers['accept-language'] || 'en');};acceptLanguage.languages(['en', 'ru']);const app = express();app.use(cookieParser());app.use((req, res) =&gt; { const locale = detectLocale(req); const componentHTML = ReactDOMServer.renderToString( &lt;IntlProvider locale={locale} messages={messages[locale]}&gt; &lt;App /&gt; &lt;/IntlProvider&gt; ); res.cookie('locale', locale, { maxAge: (new Date() * 0.001) + (365 * 24 * 3600), }); return res.end(renderHTML(componentHTML, locale));});const PORT = process.env.PORT || 3001;app.listen(PORT, () =&gt; { console.log(`Server listening on: ${PORT}`);}); 這裡我們完成了下列幾件事： 快取字典檔（messages）以及針對特定語系（locale-data）、環境為 JavaScript 提供 DateTime，Number 格式 調整 renderHTML 方法，因此我們可以插入特定語系的 locale-data 提供字典檔資源給 IntlProvider 對於 Client 端 src/client.js 123456789101112131415161718192021222324252627import React from 'react';import ReactDOM from 'react-dom';import { IntlProvider, addLocaleData } from 'react-intl';import Cookie from 'js-cookie';import App from './components/App';const locale = Cookie.get('locale') || 'en';fetch(`/public/assets/${locale}.json`) .then((res) =&gt; { if (res.status &gt;= 400) { throw new Error('Bad response from server'); } return res.json(); }) .then((localeMessages) =&gt; { addLocaleData(window.ReactIntlLocaleData[locale]); ReactDOM.render( &lt;IntlProvider locale={locale} messages={localeMessages}&gt; &lt;App /&gt; &lt;/IntlProvider&gt;, document.getElementById('root'), ); }) .catch((error) =&gt; { console.error(error); }); 接著我們需要調整 src/server.js 讓 Express 提供字典檔 JSON 12app.use(cookieParser());app.use('/public/assets', express.static('public/assets')); 在 JavaScript 初始化之後，client.js會從 cookie 取得 locale 並請求 JSON 字典檔。執行完此步驟之後， SPA 應用程式應該要跟之前一樣運作。 是時候來檢查一下是否運作正常了。開啟開發者工具並切換至 Network 頁籤查看 JSON 是否有被成功下載。 為了完成這個段落的功能。讓我們加入 src/components/LocaleButton.js 12# 安裝套件$ npm i prop-types 123456789101112131415161718192021import React from 'react';import PropTypes from 'prop-types';import Cookie from 'js-cookie';const LocaleButton = (props) =&gt; { const handleClick = () =&gt; { Cookie.set('locale', props.locale === 'en' ? 'ru' : 'en'); window.location.reload(); }; return ( &lt;button onClick={handleClick}&gt; {props.locale === 'en' ? 'Russian' : 'English'} &lt;/button&gt; );};LocaleButton.propTypes = { locale: PropTypes.string.isRequired,};export default LocaleButton; 接著，在 src/components/App.js 中匯入使用 12345678910111213141516171819202122232425262728import React from 'react';import { FormattedMessage, intlShape, injectIntl, defineMessages } from 'react-intl';import LocaleButton from './LocaleButton';const messages = defineMessages({ helloWorld2: { id: 'app.hello_world2', defaultMessage: 'Hello World 2!', },});const App = (props) =&gt; ( &lt;div className=&quot;App&quot;&gt; &lt;FormattedMessage id=&quot;app.hello_world&quot; defaultMessage=&quot;Hello World!&quot; description=&quot;Hello world header greeting&quot; /&gt; &lt;div&gt; {props.intl.formatMessage(messages.helloWorld2)} &lt;/div&gt; &lt;LocaleButton locale={props.intl.locale} /&gt; &lt;/div&gt;);App.propTypes = { intl: intlShape.isRequired,};export default injectIntl(App); 一旦使用者變更 locale 我們將會重載頁面確保對應的 JSON 和翻譯被下載。 現在我們已經學會如何偵測用戶的本地資訊和切換語系。在繼續之前讓我們先來討論兩個重要的議題。 複數和樣版在英文大部分的單字有單數和複數的形式 One apple 和 Many apples 。其他語言甚至更複雜例如俄語有 4 種形式。我們希望 react-intl 能夠協助我們處理這個問題。因此它也支援樣版讓我們可以提供多個變數插入樣版之中。下面我們來看看這是如何完成的。 在 src/components/App.js 我們可以如下： 123456789101112const messages = defineMessages({ // ... counting: { id: 'app.counting', defaultMessage: 'I need to buy {count, number} {count, plural, one {apple} other {apples}}' }, // ...});&lt;div&gt;{props.intl.formatMessage(messages.counting, { count: 1 })}&lt;/div&gt;&lt;div&gt;{props.intl.formatMessage(messages.counting, { count: 2 })}&lt;/div&gt;&lt;div&gt;{props.intl.formatMessage(messages.counting, { count: 5 })}&lt;/div&gt; 上面我們定義了一個樣版搭配 count 變數。當 count 為 1 時顯示 1 apple 其他例如 2 則為 2 apples。 formatMessage(descriptor, values) 有兩個參數，這時我們必須要將變數傳入 formatMessage 的第二個參數。 接著重新編譯我們的字典檔並加入俄語的翻譯來檢查我們可以正確的支援英文和俄語。 1$ npm run build:langs 重點整理 本範例開發環境下，只要有使用 FormattedMessage 元件或 defineMessages 方法 babel-babel-plugin-react-intl 就會把需要翻譯的字串擷取到 build/messages 然後我們使用 npm run build:langs 去建立字典檔，不過這只會包含預設語系的而已 將字典檔複製到 public/assets 並翻譯至其他語系 下面是俄語的翻譯： 12345{ &quot;app.hello_world2&quot;: &quot;Привет мир 2!&quot;, &quot;app.counting&quot;: &quot;Мне нужно купить {count, number} {count, plural, one {яблоко} few {яблока} many {яблок}}&quot;, &quot;app.hello_world&quot;: &quot;Привет мир!&quot;} 到此所有情境我們都處理了。可以繼續下一個階段了。 3. 提供特定地區習慣的內容格式，例如日期、貨幣與數字資料應該要依據不同的地區呈現不同格式。舉例來說俄文顯示 500,00 $ 和 10.12.2016 在美國則是 $500.00 和 12/10/2016。 react-intl 提供處理元件處理像是日期，還有相對時間（自己會自動每10秒更新一次） 我們在 src/components/App.js 加入此功能： 123456789101112131415import { FormattedDate, FormattedRelative, FormattedNumber, FormattedMessage, intlShape, injectIntl, defineMessages,} from 'react-intl';// ...&lt;div&gt;{this.props.intl.formatMessage(messages.counting, { count: 5 })}&lt;/div&gt;&lt;div&gt;&lt;FormattedDate value={Date.now()} /&gt;&lt;/div&gt;&lt;div&gt;&lt;FormattedNumber value=&quot;1000&quot; currency=&quot;USD&quot; currencyDisplay=&quot;symbol&quot; style=&quot;currency&quot; /&gt;&lt;/div&gt;&lt;div&gt;&lt;FormattedRelative value={Date.now()} /&gt;&lt;/div&gt; 重新載入頁面您可以注意到 10 秒後 FormattedRelative 會自動更新。您可以在文件上找到更多元件和範例。 現在，我們可能要面對影響通用渲染的問題： 一般來說當伺服器端回傳 HTML 到客戶端，然後客戶端的 JavaScript 初始化大概會產生 2 秒的誤差。這意味著當我們使用 Date.now() 的時候在 Server 端渲染的資料和 Client 端重新渲染的資料會有誤差。為了解決這個問題 react-intl 提供了特殊的屬性 initialNow。它會提供一個 Server 的時間戳記給 Client 端的 JavaScript 使用。通過這種方式 Server 和 Client 校驗就會一致。在所有元件都掛載完畢之後就會使用瀏覽器當前的時間。 下面是 src/server.js 主要變更的地方： 12345678910111213141516171819202122232425262728293031323334const renderHTML = (componentHTML, locale, initialNow) =&gt; ` &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Hello React&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;${componentHTML}&lt;/div&gt; &lt;script type=&quot;application/javascript&quot; src=&quot;${assetUrl}/public/assets/bundle.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;application/javascript&quot;&gt; ${localeData[locale]} &lt;/script&gt; &lt;script type=&quot;application/javascript&quot;&gt;window.INITIAL_NOW=${JSON.stringify(initialNow)}&lt;/script&gt; &lt;/body&gt; &lt;/html&gt;`;app.use((req, res) =&gt; { const locale = detectLocale(req); const initialNow = Date.now(); const componentHTML = ReactDOMServer.renderToString( &lt;IntlProvider locale={locale} messages={messages[locale]} initialNow={initialNow}&gt; &lt;App /&gt; &lt;/IntlProvider&gt; ); res.cookie('locale', locale, { maxAge: (new Date() * 0.001) + (365 * 24 * 3600), }); return res.end(renderHTML(componentHTML, locale, initialNow));}); 然後是 src/client.js 1&lt;IntlProvider initialNow={parseInt(window.INITIAL_NOW, 10)} locale={locale} messages={localeData}&gt; 重啟 npm start 問題被解決了。 注意：initialNow 在 3+ 版本中被移除了。 問題因為 react-intl 使用瀏覽器原生的 Intl API 來處理 DateTime 與 Number 格式。雖然這個規範 2012 年就出現了但是還是有主流的瀏覽器並沒有全面支援。甚至像是 Safari 只有在 iOS 10 之後才部分支援。 這意味著如果您要涵蓋所有沒有支援 Intl 的瀏覽器您需要 Polyfill。感謝 Intl.js ，看起來是完美的解法不過根據經驗它有些缺點。首先是你需要把它加入您的 Bundle 而且它很肥。為了減少下載檔案大小，您可能想只在瀏覽器不支援的情況下才下載 Polyfill 你可以在Intl.js 文件找到解法，不過最大的問題是 Intl.js 不是 100% 精準。意思是 Server 端和 Client 端的 DateTime 和 Number 可能有些許誤差。 我曾試圖嘗試其他解決方案。但都有缺點。因此實作了非常簡易的 polyfill 它只有局部的功能，無法應用在所有情境，但只有 2 KB 。使用它您甚至不需要實作只針對老舊瀏覽器動態加載，使專案簡單一點，您可以 Fork 並擴展它。 結論現在您可能覺得事情變得很複雜，您可能想要自己實作所有的東西。我試過一次，我不建議您這麼做。因為最後您只會完成另一個 react-intl 甚至更糟。您可能想說沒有太多選擇讓這個問題處理的更好一些。 也可能想說可以靠 Moment.js 解決 Intl API 的問題。 幸運的是我都試過了所以我可以節省您的時間。我試過 Moment.js 它或許可以解決部分問題但很肥所以我不推薦。 開發自己的 Polyfill 聽起來也不是好點子，因為您勢必需要和許多 Bug 奮鬥。 希望這篇文章可以協助您得到一些所需的知識去建立多語系與國際化的 React 應用程式。 參考 React Internationalization – How To Github - react-intl","link":"/2019/07/03/react-intl-get-started/"},{"title":"手把手設定 MediaConvert 轉檔 HLS 搭配 S3 + CloudFront","text":"使用 S3 + CloudFront + MediaConvertAWS Elemental MediaConvert 可以編譯您輸入的影音檔案並轉換產出其他格式的影音檔案。MediaConvert 可以從 S3 取得來源檔或者通過 HTTP 或 HTTPS。整體步驟如下： 建立 S3 Bucket 建立 SSL 憑證，後續 CloudFront 欲使用自訂網址 設定 CloudFront 設定 IAM 權限 上傳 Video 使用 MediaConvert 轉譯 建立 S3 BucketS3 Bucket 僅允許 CDN 存取。 建立儲存體 輸入名稱 預設值即可。 預設值即可。 上傳圖片測試。 選擇圖檔 確認上傳 建立 SSL 憑證由於 CloudFront 我們想使用自己的網址，因此需要建立 SSL 憑證。登入 AWS Console 選擇 Certificate Manager。 使用佈建憑證 為了示範流程，選擇【申請公有憑證】 私有憑證的流程也類似如果您使用的是私有憑證請選擇 輸入網域，我們使用 Wildcard * 依照您較方便的方式進行驗證 檢視設定結果 取得驗證流程所需的資訊，至您的 DNS 管理介面設定 本文網址為 Gandi 託管 稍後片刻，驗證成功 設定 CloudFront由 CloudFront 取得 S3 資源，S3 本身不提供直接存取。 選擇您的 Bucket 提供我們要使用的自訂網址 下圖為自動設定 S3 的設定檔 至您的 DNS 設定 CNAME 設定 IAM 權限為了使用 MediaConvert 我們需要先建立角色。 使用 MediaConvert這裡我們練習使用 MediaConvert 將一個 .mp4 轉換成 HLS 串流，您的應用程式可以搭配 AWS SDK 來整合，這裡我們只是要紀錄學習一個使用流程與概念。 第一步我們先回到 S3 上傳一部 mp4 流程跟之前上傳圖片一樣。 完成上傳，接著我們可以切換至 MediaConvert 服務頁面。 選擇【開始使用】 選擇檔案來源 選擇 Bucket 和檔案 輸入設定，這裡您可以依據您的需求設定 Input Selectors，總共有三種類型。不過這裡的示範我們維持預設值即可 在 Video Selector 的部分，指定您需要的欄位值。您不需要自行建立 Video Selector 因為 AWS Elemental MediaConvert 會在建立 Job 的時候自動建立一組。然而服務不會自動偵測影片來源的資訊。您可以在 Video Selector 提供。如果您在這些欄位使用預設值，您還是可以建立一組合法的 Job。 注意：AWS Elemental MediaConvert 不支援多影音串流格式的影片例如 Quad 4K。每一個輸入只能有一個 Video Selector；因此沒有 Add Video Selector 的按鈕可以點。 Audio Selectors 的部分，在 Audio selector 1 ，設定關於主要音源資源的資訊。您不需要建立 Audio selector 1 因為建立 Job 的時候一樣會自動建立一組。 注意： 音頻資源通常包含對話、背景音，配樂等在一個 Track。Tracks 通常由多個聲道 Channels 組成。例如杜比 5.1 每個 Track 有 6 個聲道 a. 針對 Selector type 選擇識別音頻的方式，通常使用 Trackb. 替主要的音源設定識別（Track number，PID 或 Language code），主要的音源可能是 Track 1 對於大部分的情況，每一個 Input Selector 都有一組 Input Track。如果您需要合併多個音軌可以使用 , 分隔列表項目或使用 * 注意：輸出如果要在目錄底下需要以 / 結尾。 Output 如果輸出設定的 Preset 沒有設定的話，那麼至少 Bitrate 一定要設定。 12# 使用 ffmpeg 查詢 Bitrateffprobe -show_format demo.mp4 任務設定必須要設定角色，我們選擇剛剛建立的角色。 建立 Job 完成執行轉檔。 至 S3 檢查產出的結果。 完成 .m3u8 的轉換之後，我們需要調整 S3 和 CloudFront 的設定，因為我們希望可以直接從 CDN 取得 .m3u8 。 S3 先設定 CORS。 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;CORSConfiguration xmlns=&quot;http://s3.amazonaws.com/doc/2006-03-01/&quot;&gt;&lt;CORSRule&gt; &lt;AllowedOrigin&gt;*&lt;/AllowedOrigin&gt; &lt;AllowedMethod&gt;GET&lt;/AllowedMethod&gt; &lt;MaxAgeSeconds&gt;3000&lt;/MaxAgeSeconds&gt; &lt;AllowedHeader&gt;Authorization&lt;/AllowedHeader&gt; &lt;AllowedHeader&gt;Origin&lt;/AllowedHeader&gt;&lt;/CORSRule&gt;&lt;/CORSConfiguration&gt; 注意：CloudFront 一定要允許 Origin 資源 hls.js 測試範例 支援的檔案類型 官方 MediaConvert 教學","link":"/2019/07/19/s3-cloudfront-media-convert-step-by-step/"},{"title":"React Hooks 不是黑魔法，只是陣列","text":"本文旨在提供一些關於 Hooks API 一些乍看之下奇怪的規範以及理解這些規範的見解。 理解 Hook 的運作機制我聽到有些人正在為了理解 Hooks 的黑魔法以及提案奮鬥，因此我試著解開語法提案是如何運作的。 Hooks 規範React 核心團隊在 Hooks 的提案文件上提出了兩個主要是使用規範開發者必須要遵守 不可以在迴圈，條件式或巢狀函式中調用 Hook 只能在 React Function 中調用 第二點是比較容易理解的。要掛載行為到一個函式型元件（Functional Component），您需要以某種形式將行為和元件關聯。 Hooks 中狀態管理都跟陣列有關為了得到清晰的觀念，讓我們看看簡單的 Hooks API 實作。 請注意這只是推測其中一種可能實作 API 的方式，主要是為了呈現思路。這並不是 API 內部運作完全等價的東西。 如何實作 useState() ?讓我們解析範例來展示一個 State Hook 的實作可能的運作 首先，我們從元件開始： 12345678function RenderFunctionComponent() { const [firstName, setFirstName] = useState('Rudi'); const [lastName, setLastName] = useState('Yardley'); return ( &lt;Button onClick={() =&gt; setFirstName('Fred')}&gt;Fred&lt;/Button&gt; );} Hooks API 背後的概念是您可以使用 setter，這個 setter 是 useState 執行之後回傳陣列的第二個值。 setter 可以控制 Hook 管理的 state 。 React 是如何完成上述概念？接著讓我們來說明 React 內部大概的運作機制。下面說明的概念也可以運用在特定執行環境下渲染元件。意思是儲存的資料是位於被渲染的元件外層。該 state 不會和其他元件共用，並且存在渲染該元件之後可以被存取的範圍。 1) 初始化建立兩個空陣列 setters 和 state 設定一個指標為 0 2) 第一次渲染第一次執行元件函式。 每一個 useState() 第一次執行時，會 push 一個 setter function (和一個指標位置繫結) 到 setters 陣列然後 push 狀態到 state 陣列。 3) 隨後渲染每次渲染之後， 指標就會重置，然後這些值就可以從陣列被讀取 4) 事件處理每一個 setter 都有一個參考指向該指標位置，所以觸發 setter 的時候就會變更陣列中 state 的值 簡易的實作下面是一個簡易的實作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152let state = [];let setters = [];let firstRun = true;let cursor = 0;function createSetter(cursor) { return function setterWithCursor(newVal) { state[cursor] = newVal; }}// 下面是 useState 的虛擬碼export function useState(initVal) { if (firstRun) { state.push(initVal); setters.push(createSetter(cursor)); firstRun = false; } const setter = setters[cursor]; const value = state[cursor]; cursor++; return [value, setter];}// 元件使用 Hookfunction RenderFunctionComponent() { const [firstName, setFirstName] = useState('Rudi'); const [lastName, setLastName] = useState('Yardley'); return ( &lt;div&gt; &lt;Button onClick={() =&gt; setFirstName('Richard')}&gt;Richard&lt;/Button&gt; &lt;Button onClick={() =&gt; setLastName('Fred')}&gt;Fred&lt;/Button&gt; &lt;/div&gt; );}// 模擬 React 渲染function MyComponent() { cursor = 0; // 重置 cursor return &lt;RenderFunctionComponent /&gt;}console.log(state); // Pre render: []MyComponent();console.log(state); // First render: ['Rudi', 'Yardley']MyComponent();console.log(state); // Subsequent-render: ['Rudi', 'Yardley']// click the 'Fred' buttonconsole.log(state); // After-click: ['Fred', 'Yardley'] 為什麼順序很重要假設我們在渲染週期基於元件的狀態或一些外部條件改變了 Hooks 的順序會發生什麼事呢？ 讓我們來試試那些 React 核心團隊建議我們不該做的事： 1234567891011121314151617let firstRender = true;function RenderFunctionComponent() { let initName; if (firstRender) { [initName] = useState('Rudi'); firstRender = false; } const [firstName, setFirstName] = useState(initName); const [lastName, setLastName] = useState(&quot;Yardley&quot;); return ( &lt;Button onClick={() =&gt; setFirstName(&quot;Fred&quot;)}&gt;Fred&lt;/Button&gt; );} 第一次渲染上面我們在條件式中使用了 useState 。接著我們來看看會造成什麼問題： 第二次渲染到這一步 firstName 和 lastName 的值都還是正確的，不過我們再觀察一下第二次渲染： 備註：再多讀一次簡易實作，第一次渲染時會 push state 並回傳您給定的值。第二次開始就是直接取值。 所以現在 firstName 和 lastName 都是 Rudi。這是很明顯的錯誤，第一次和後續取值的東西是不一致的。因此 React 團隊規範了使用規則因為不遵循這個規則那麼資料將會不一致。 思考一下 Hooks 是操作一組陣列而您不應該破壞其規則。現在您應該很清楚為什麼不可以在條件式或迴圈調用 Hook 了，因為它是依賴 cursor 來取得陣列中的值，如果改變了順序那麼資料和 setter 就不對了。 結論希望我有清楚的給您一個關於 Hook API 的說明。記得 Hook 真正的價值在於將相關邏輯的狀態組織在一次，並且您應該要小心順序。 React hooks: not magic, just arrays","link":"/2019/07/29/hooks-not-magic-just-arrays/"},{"title":"[譯] 理解 React Hooks","text":"為什麼要使用 Hooks我們都知道元件是由上而下傳遞資料，藉此協助我們分解一個複雜的大型介面，利用較小單位的介面功能（元件）組成。這些元件各自是獨立的，可重複使用的。雖然理想上是如此，可是實務上我們卻常常無法拆解複雜的元件，使其變成更小的單元，那是因為其相關的邏輯和狀態無法被提取到其他 function 或元件中。 這也是有些開發者會說 React 無法達到關注點分離的原因。 這種情況非常常見，包含動畫的部分，表單處理，連結外部的資料等等。試圖解決這些問題常常會遇到下面幾種結果： 大型的元件，難以重構或測試 重複的邏輯散落在不同的元件與生命週期中 被迫採用複雜的設計模式例如 render props 和 high-order 元件 我們認為 Hooks 是這些問題最好的解決方案。Hooks 讓我們可以組織邏輯的部分，使其成為可以獨立並重複使用的單元。 Hooks 在元件內套用了 React 的哲學（明確定義資料流和可組合的特性），而且不僅僅是組件之間。這也是為什麼 Hooks 可以很自然套用在 React 元件上。 不像其他設計模式例如 render props 或 high-order 元件，Hooks 不會在整個元件樹結構中加入多餘的元件結構，也沒有 mixins 的缺點。 即使在第一次看到這東西的時候內心排斥，但我希望您可以嘗試看看。您應該會喜歡的。 Hooks 使 React 檔案容量增加？在我們深入探討 Hooks 之前，您可能擔心在 React 加入 Hooks 概念的部分。這很正常，但我認為短期的學習成本是值得的。 如果 React 社區傾向使用 Hooks，那麼它將會減少一些原本在開發 React 需要克服的問題和學習的概念。Hooks 讓我們只要使用 function 而不需要頻繁的在 function ，class，high-order 元件，render props 之間纏鬥。 就最後實作的容量大小，Hooks 只增加大約 1.5kB。並不是很大。使用 Hooks 通常還可以減少您最後編譯出來的 Bundle 大小，因為 Hooks 通常在優化， minify 的時候會比同樣功能用 class 寫的程式產出更小的 Bundle。 另外，Hooks 沒有包含任何重大變動。就算在您既有的程式碼加入使用依舊可以正常運作。事實上這也是我們推薦的作法，不要大量的改寫已經存在的程式。同樣的我們會很感謝您可以參與 16.7 alpha 提供更多的反饋。 Hooks 究竟是什麼？要理解 Hooks 我們需要退一步思考關於程式碼重複的部分。 在 React 應用程式中有很多方式可以重複使用邏輯的部分。我們可以單純使用 funaion，反覆調用。我們也可以使用元件的方式。雖然元件比較多功能但是它們必須要輸出渲染介面（即 render 是必須的）。當我們提取元件用來處理一些不需要畫面的功能時會變得有麻煩。這也是為什麼會有這麼多複雜的設計模式出現，例如 render props，high-order 元件。難道 React 不能提供一種通用簡單的方式取代這些東西嗎？ 對於重複使用片段程式碼，function 似乎是一個完美的機制。在 funcion 之間移動調整邏輯不需要耗費太多的時間。但是 function 不能使用 React 自身的狀態。您沒辦法在不重構整個 Class 元件或不使用其他設計模式像是 Observables 的情況之下，將一些像是監聽 window size 然後更新 state 或者隨著時間變化調整 state 的行為提取出來。 這些東西都讓 React 的簡易性大受打擊。 Hooks 確實解決這些問題。Hooks 讓我們可以在 function 中使用 React 的功能（例如 state）- 只要調用一個簡單的 function 。React 提供一些內建的 Hooks 讓我們可以使用 React 內部的功能。 由於 Hooks 就是一般的 JavaScript function，您可以組合這些內建的 Hooks 來自訂並擴展 Hooks。這讓您可以將一些複雜的問題用一行程式碼就解決，並且在各個元件中都可以共用又或者分享到社群。 注意，自訂 Hooks 技術上並不是 React 的功能。自訂 Hooks 的功能來自於 Hooks 的設計方式 實作範例例如我們想要讓元件觀察當前瀏覽器視窗 window 的寬（舉例來說針對不同的寬顯示不同的內容）。 我們確實可以透過一些方式完成這個功能。不過通常需要使用 class 搭配生命週期方法。如果您想重複使用，甚至需要動用到 render props 或 high-order 元件。 有了 Hook，我相信沒什麼方式比下面範例這樣更好： 123456function MyResponsiveComponent() { const width = useWindowWidth(); // Our custom Hook return ( &lt;p&gt;Window width is {width}&lt;/p&gt; );} 這段程式碼完全符合其陳述。我們在元件中使用了 window 的 width，接著如果值發生變動 React 會重新渲染元件。這就是 Hook 的目標 - 即使包含 state 或 side effect 都可以讓元件完整陳述性（declarative）。 Declarative programming - a style of building the structure and elements of computer programs—that expresses the logic of a computation without describing its control flow 讓我們來看看如何自訂 Hook。我們將使用 React 內部的 state 來保存 window 的 width。然後使用 side effect 的方式來設定 state 123456789101112131415import { useState, useEffect } from 'react';function useWindowWidth() { const [width, useWidth] = useState(window.innerWidth); useEffect(() =&gt; { const handleResize = () =&gt; setWidth(window.innerWidth); window.addEventListener('resize', handleResize); return () =&gt; { window.removeEventListener('resize', handleResize); } }); return width;} 如您所見，內建的 React Hook 像是 useState，useEffect 提供了一些基本的功能。我們可以在元件中直接使用這些功能或者組合它們變成像是 useWindowWidth。我們就可以像使用內建的 Hook 一樣使用自訂 Hook。 您可以從概覽中學習更多的 Hooks。 Hook 是完全封裝的 - 每次您調用 Hook，會取得一個當前元件內部獨立的 state 。它們不是共用相同的狀態，但共用相同的邏輯。 每個 Hook 可能包含一些 state 或 side effect 您可以在多個 Hook 中傳入不同的資料，就像您平常使用 function 一樣，可以傳入參數並回傳值。因為它們就是 JavaScript function。 下面是一個動畫的範例： 注意到範例中的動畫是靠將不同的參數傳入自訂 Hook 完成的。 123const [{ pos1 }, set] = useSpring({ pos1: [0, 0], config: fast });const [{ pos2 }] = useSpring({ pos2: pos1 }, config: slow);const [{ pos3 }] = useSpring({ pos3: pos2 }, config: slow); 在不同 Hooks 中傳入參數使其可以適用於動畫，訂閱，表單管理，和其他狀態。不像 render props 或 high-order 元件，Hooks 不會在您的元件樹結構中建立一個 return false 的結構。它們更像是一個扁平化的記憶體儲存單元直接掛載到元件上，也沒有多餘的階層。 那麼 Class 呢？我們很喜歡自訂 Hook 的部分而且為了讓 Hook 運作，React 提供了狀態和 side effect 的處理機制，這也是為什麼要內建 useState 和 useEffect。 事實證明這些內建的 Hook 並不只是適用自訂 Hook，它們也適用於一般的情景。因此未來我們傾向讓 Hook 變成主流的方式。 但我們並沒有任何計畫要棄用 Class。在 Facebook 我們有成千上萬的元件是用 Class 元件。我們並不想重寫它們。不過如果社群擁抱 Hooks，那麼有兩種方式定義元件的確有些不合理。 Hook 可以涵蓋所有 Class 能處理的情景並且在提取，測試，重用的面向提供更大的彈性。這也是為什麼 Hook 代表了我們對 React 未來的願景。 Hook 是某種黑魔法?您可能會對於 Hook 的規範 有些驚訝。 雖然 Hooks 必須在元件的上層調用乍看之下很奇怪。即便可以，但您可能也不希望在條件式裡面定義狀態。 如果第一時間覺得很奇怪可以思考一下 - 在過去 4 年裡還沒有 React 開發者抱怨不能在 Class 依據條件定義狀態。 這個設計對於自訂 Hook 不造成額外語法上的混亂和問題起了至關重要的影響。我們認為這個取捨是值得的。 我們已經開始將 Hook 用在產品上幾個月了，也觀察開發者是否會對這些規範感到困惑。我們發現大概幾個小時，人們就會習慣。我承認在一開始我也覺得這些規範感覺像是錯了，不過很快的我就意識到它為什麼存在。 Hooks 並沒有任何黑魔法，如 Jamie 指出的點，它看起來非常類似 123456789101112let hooks = null;export function useHook() { hooks.push(hookData);}function reactsInsternalRenderAComponentMethod(component) { hooks = []; component(); let hooksForThisComponent = hooks; hooks = null;} 每一個元件保存了一個 Hook 列表，並且下次使用 Hook 的時候這個列表會移至下一個項目。 多虧了 Hook 的規範，每次渲染時 Hook 的順序會保持一致，也因此每次調用的時候狀態都會正確。 React 不需要額外的資訊知道哪個元件正在渲染，React 就只是調用該元件。 或許您想知道 React 在哪裡保存了 Hook 的狀態。答案是跟 Class 一樣。React 有一個內部更新佇列，那裡就是唯一的狀態資料來源，不管您是使用哪種方式定義元件。 Hook 不依靠像是 Proxies 或 getters ，因此 Hook 照理來說沒什麼黑魔法，頂多就是 array.push 和 array.pop。 這個設計讓 Hook 不會只限於 React 才能使用。事實上在提案發表後的幾天，已經有人實驗性為 Vue, Web Component 甚至是單純的 JavaScript 實作 Hook API。 最後，如果您是個純粹函數式編程主義者對於 React 依賴可變動的狀態和實作細節感到不滿意，您也可以利用 Algebraic effect （如果 JavaScript 支援）實作一套純函數式的方式。 無論您是從實務派還是理論派的角度來評論分析，我希望至少理由是合理的。如果您還是好奇其他問題，Hooks 提案的作者 Sebastian 也會在 RFC 提供回應。最重要的是我認為 Hook 讓我們可以更輕易的建置元件。 散播愛，不炒作如果上面仍然沒有說服您使用 Hook ，我想我大概也能夠明白。但我依然希望您可以嘗試一次，無論您是否有遇過類似 Hook 試圖想解決的問題，或者您有不同的解決方案歡迎到 RFC 留言。 如果您對於我所說的或者對於 Hook 感到有興趣，那麼這裡需要請您幫個忙。現在有很多人正在學習 React 的路上，如果官方很快的提供教學文件並宣稱這是最佳實踐，那麼他們勢必會感到困惑。並且關於 Hook 還有些東西即便是 React team 也還不是非常清楚。 如果您在撰寫任何關於 Hook 的內容，在還沒穩定的之前麻煩備註這是一個實驗性的功能並且提供官方文件的連結。我們會持續更新。我們也會致力於讓它更全面。 當您在跟其他人談論 Hook 時請保持您的風度。如果您看到任何人誤解，您可以分享您所理解的和相關資源。不過改變是令人感到害怕的，作為一個社群我們應該協助他人而不是選邊站批評。 資源 Making Sense of React Hooks Hooks in react-spring, a tutorial React hooks: not magic, just arrays","link":"/2019/07/29/making-sence-of-react-hooks/"},{"title":"手把手實戰部署 ReactJS 至 Amazon S3","text":"本文嘗試盡可能實作最佳實踐，但部分設定請依據自身需求調整。 大綱 建立一個簡易的 React 應用程式 設定 S3 提供靜態網站託管 部署 進階實戰 - SSL 搭配自訂網域 進階實戰 - S3 進階實戰 - CloudFront 進階實戰 - 自動化腳本 基本上前半段和後半段有蠻多重複的，如果您已經有些 AWS 的使用經驗，可直接跳至進階實戰。 準備 AWS 帳號 AWS IAM User 安裝 AWS CLI 設定 AWS 憑證 設定 AWS 帳號註冊或登入AWS Console，點擊【服務/Services】搜尋【IAM】。 在【IAM】介面點擊左側的【使用者/Users】，我們需要為 Serverless Framework 建立一組使用帳號。這組帳號會授權我們的框架建立、更新、刪除 AWS 上的資源。 點擊【新增使用者/Add User】，輸入使用者名稱和 程式設計方式存取/Programmatic access 。下一步。 至【設定許可】點擊【直接連結現有政策/Attach existing policies directly】選取【AmazonS3FullAccess】。後續直接沿用預設值，建立使用者。授予的許可應該盡遵循最小權限原則，如果您只是針對測試需求可選取【AdministratorAccess】 取得【存取金鑰 ID/Access Key Id】和【私密存取金鑰/Secret Access Key】，後續我們會需要這兩個資料，即我們上面提到的 AWS 憑證。 開啟您的終端機程式： 1234567891011121314# 安裝 AWS CLI$ brew install awscli# 設定預設的 AWS Credential$ aws configureAWS Access Key ID [None]: YOUR KEYAWS Secret Access Key [None]: YOUR KEYDefault region name [None]: us-west-2Default output format [None]: ENTER# 新增其他 Profile 名稱憑證# 後續部分指令，如果您使用多組 Profile 請記得補上 --profile$ aws configure --profile serverless 憑證預設會存放在 ~/.aws 目錄下。 安裝 NodeJS123456# 您可以使用一般 node 或 nvm 這裡僅概列指令$ brew install node# 或$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash$ nvm install node 建立簡易的專案123$ npx create-react-app [YOUR_PROJECT_NAME] # Replace [YOUR_PROJECT_NAME] with `react-s3-demo`$ cd react-s3-demo$ npm start 設定 S3 Bucket切換至 S3 介面 點擊【建立儲存貯體】 注意：儲存佇體名稱（Bucket name）必須要全域唯一。名稱與區域 設定選項，直接使用預設值 設定許可，取消所有封鎖 檢閱，點擊建立儲存佇體 回到列表頁面，選取剛剛建立的儲存佇體。點擊【屬性/Properties】頁籤。您應該可以看到【靜態網站託管/Static Website Hosting】點擊之後，選擇【使用此儲存貯體來託管網站/Use this bucket to host a website】。輸入 index.html。以 React 應用程式來說您的錯誤頁面也會是 index.html。 設定靜態網站託管 現在，儲存佇體已經可以託管靜態網站，我們還需要設定許可權限。點擊【許可/Permissions】接著 【儲存貯體政策/Bucket Policy】貼上下面的設定（取代您的 Bucket Name）： 12345678910111213141516{ &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;AllowPublicReadAccess&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: &quot;*&quot;, &quot;Action&quot;: [ &quot;s3:GetObject&quot; ], &quot;Resource&quot;: [ &quot;arn:aws:s3:::YOUR_BUCKET_NAME/*&quot; ] } ]} 到此步驟關於 AWS S3 的設定已經完成了。 建置與部署開啟我們一開始建立的 React 專案 12$ npm run build$ aws s3 sync build/ s3://react-s3-demo --acl public-read 您也可以將指令加入 package.json 。 進階實戰 - SSL 搭配自訂網域注意：藉由 Amazon Certificate Manager 建立的憑證若要給 CloudFront 使用。您可以使用儲存位於美國東部(維吉尼亞北部) 區域的 AWS Certificate Manager (ACM) 中的憑證，或者您可以使用儲存在 IAM 中的憑證。步驟 1 步驟 2 步驟 3 步驟 4 步驟 5 步驟 6 請至您的網域 DNS 管理介面加入 CNAME 紀錄，通過驗證。 進階實戰 - S3步驟 1 靜態網站搭配 Amazon CloudFront 時，我們可以限制儲存體的存取僅讓 CloudFront 存取即可。 步驟 2 步驟 3 保留預設值由於使用了 Cloud Front 這個步驟可以封鎖項目。 12# 上傳檔案到 S3（移除 --acl）$ aws s3 sync build/ s3://react-s3-demo 注意：封鎖公開存取之後，無法依據上面設定【設定 S3 Bucket】段落的公開的政策，託管的網址會無法取得檔案，另外 aws s3 sync 的 --acl 也會被拒絕。詳細的權限設定請參考下面參考資源。如果想要支援 --acl public-read，可以開啟兩個選項即可。 步驟 4 進階實戰 - CloudFront建立分佈設定： 1234567891011121314151617181920源網域名稱/Origin Domain Name: 您建立的 S3 Bucket源 ID/Origin ID: 保留預設值或可自行設定名稱限制儲存貯體存取/Restrict Bucket Access: 是，如此網站必須通過 CDN 存取源存取身份/Origin Access Identity: 自行設定依據狀況新增或選擇既有授與對儲存貯體的讀取許可/Grant Read Permissions on Bucket: 是，更新儲存貯體政策檢視器通訊協定政策/Viewer Protocol Policy: 重新導向 HTTP 到 HTTPS允許的 HTTP 方法/Allowed HTTP Methods: GET、HEAD、OPTIONS、PUT、POST、PATCH、DELETE自動壓縮物件/Compress Objects Automatically: 是備用網域名稱/Alternate Domain Names(CNAMEs): 您的網域SSL 憑證/SSL Certificate: 自訂 SSL 憑證 步驟 1 步驟 2 步驟 3 步驟 4 步驟 5 步驟 6 步驟 7 步驟 8 步驟 9 設定好之後檢查一下 S3 是否有自動更新政策。 如果您需要使用 AWS 提供的靜態網站託管網址或有其他原因，那麼記得設定【靜態網站託管】。否則不須設定。 步驟 10 到 CloudFront 查看網域名稱 步驟 11 最後到您的網域 DNS 介面補上 CNAME 設定 等待約 10 - 20 分鐘即生效。 針對 React 應用程式的錯誤，CloudFront 記得要導向 index.html 瀏覽 進階 - 自動化腳本下面為 NodeJS 的自動化腳本，您需要安裝 AWS CLI。 ⚠️警告：本腳步請勿直接複製使用，您應該理解並一步步調整成您的狀況。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134const util = require('util');const exec = util.promisify(require('child_process').exec);const fs = require('fs');const S3_BUCKET_NAME = '';// CloudFront ID 用來取得 CloudFront 當前設定。請從 Cloud Front 介面查詢const CLOUD_FRONT_ID = '';// JSON 或 YAML 暫存目錄const TEMP_FOLDER = '.aws';// CloudFront 當前設定檔案const CONFIG_PATH = `${TEMP_FOLDER}/cloudfront.json`;// 更新後設定檔路徑const PATCHED_CONFIG_PATH = `${TEMP_FOLDER}/patched-dist-config.json`;// 部署檔案目錄，請替換成您編譯結果的目錄const DEPLOY_FOLDER = 'build/';// 更新 CloudFront 和 S3 預設物件路徑和錯誤頁面路徑const INDEX_FILENAME_PATTERN = /index.*html/;const ERROR_FILENAME_PATTERN = /500.*html/;async function main() { // 請逐個 function 實驗檢查 createTempFolder(); // 由於使用 CloudFront 快取，為了確保每次更新時檔案為最新的 // 您有兩種選擇：1. 使用 Invalidate 不過依次計費。 2. 檔案名稱每次編譯後加入 Hash 或時間戳記 // 此步驟為更新相關 index.{timestamp}.html and error-{hash}.js 設定 // (可選) 為了更新 CloudFront 設定 await getCloudFrontDistributionConfig(); const { indexFilename, eTag } = modifyCloudFrontDistributionConfig(); // 上傳檔案到 S3 await deployFilesToS3(); // (可選) 為了更新 S3 設定 await updateS3StaticWebsiteHostingConfig(indexFilename); // (可選) 為了更新 CloudFront 設定 await updateCloudFrontDistributionConfig(eTag); // 移除暫存檔 await removeTempFolder();}main();// actionsfunction createTempFolder() { console.log('Creating temp folder...'); if (!fs.existsSync(TEMP_FOLDER)) { fs.mkdirSync(TEMP_FOLDER); }}async function getCloudFrontDistributionConfig() { // 如果您使用的是預設的 AWS 憑證請移除 --profile console.log('Downloading cloudfront distribution config...'); await exec(`aws cloudfront get-distribution-config --id ${CLOUD_FRONT_ID} &gt; ${CONFIG_PATH} --profile [IF_YOU_USE_DEFAUTL_PLEASE_REMOVE]`);}function updateDistConfig(obj, newIndexFilename, newErrorFilename) { Object.keys(obj).forEach((key) =&gt; { if (obj[key] !== null &amp;&amp; typeof obj[key] === 'object') { updateDistConfig(obj[key], newIndexFilename, newErrorFilename); return; } if (typeof obj[key] === 'string') { switch (key) { case 'DefaultRootObject': obj[key] = newIndexFilename; break; case 'ResponsePagePath': if (obj[key].match(INDEX_FILENAME_PATTERN)) { obj[key] = `/${newIndexFilename}`; } if (obj[key].match(ERROR_FILENAME_PATTERN)) { obj[key] = `/${newErrorFilename}`; } break; } } });};function modifyCloudFrontDistributionConfig() { console.log('Modify cloudfront distribution config...'); let indexFilename = ''; let errorFilename = ''; const files = fs.readdirSync(DEPLOY_FOLDER); files.forEach(file =&gt; { if (file.match(INDEX_FILENAME_PATTERN)) { indexFilename = file; } if (file.match(ERROR_FILENAME_PATTERN)) { errorFilename = file; } }); // 讀取並編輯 Distribution Config const { DistributionConfig, ETag } = JSON.parse(fs.readFileSync(CONFIG_PATH, 'utf8')); updateDistConfig(DistributionConfig, indexFilename, errorFilename); fs.writeFileSync(PATCHED_CONFIG_PATH, JSON.stringify(DistributionConfig, null, 2), 'utf8'); return { indexFilename: indexFilename, eTag: ETag, };}async function deployFilesToS3(bucketName) { console.log('Deploy files to AWS S3...'); await exec(`aws s3 rm s3://${S3_BUCKET_NAME} --recursive --profile seefu`); await exec(`aws s3 sync public/ s3://${S3_BUCKET_NAME} --acl public-read --profile [IF_YOU_USE_DEFAUTL_PLEASE_REMOVE]`);}async function updateS3StaticWebsiteHostingConfig(indexFilename) { console.log('Updating AWS S3 static website hosting config...'); await exec(`aws s3 website s3://app.uxtesting.io --index-document ${indexFilename} --error-document ${indexFilename} --profile [IF_YOU_USE_DEFAUTL_PLEASE_REMOVE]`);};async function updateCloudFrontDistributionConfig() { console.log('Updating cloudfront distribution config...'); await exec(`aws cloudfront update-distribution --id ${CLOUD_FRONT_ID} --distribution-config file://${PATCHED_CONFIG_PATH} --if-match ${eTag} --profile [IF_YOU_USE_DEFAUTL_PLEASE_REMOVE]`);}async function removeTempFolder() { if (fs.existsSync(TEMP_FOLDER)) { console.log('Removing temp folder...'); if (fs.existsSync(CONFIG_PATH)) { fs.unlinkSync(CONFIG_PATH); } if (fs.existsSync(PATCHED_CONFIG_PATH)) { fs.unlinkSync(PATCHED_CONFIG_PATH); } fs.rmdirSync(TEMP_FOLDER); }}; 參考資源 Deploy ReactJS App with S3 Static Hosting IAM Policies and Bucket Policies and ACLs! Oh, My! (Controlling Access to S3 Resources) Backup to S3 by CLI","link":"/2019/08/22/deploy-react-app-to-s3-step-by-step/"},{"title":"[譯] 詳解 React 渲染","text":"原文出處 本文主旨於介紹 React 渲染的行為，包含使用 Context 和 React-Redux 之後的渲染行為。 我已經見了太多關於渲染的問題並且這些問題仍然持續出現 - 什麼時候，為什麼 React 會重新渲染元件，如果使用了 Context 或 React-Redux 會如何影響重新渲染的範圍和觸發的時機。經歷了多次的解釋，似乎有這個必要將這些回答彙整成一個較完整的介紹。 注意：這些資訊網路上都已經有了，而且很多人都解釋過了，但人們似乎還是蠻困擾因為資訊散落而不容易有個比較完整的了解，所以這篇文章試著將這些問題整理說明清楚，希望能對您有些幫助。 何謂渲染（Rendering）？渲染是 React 取得元件“定義您想呈現的介面”並整合當下的 props 和 state 資訊的流程。 渲染流程渲染流程中，React 會從元件樹狀結構的根開始往下逐一檢查被標記需要渲染的元件。然後被標記的元件 React 會執行 classComponentInstance.render() 或 FunctionComponent() 最後取得回傳的結果。 元件通常使用 JSX 撰寫，然後會被編譯成純 JavaScript 例如 React.createElement() ，createElement 會回傳 React elements 它們是純 JavaScript 物件，用來描述 UI 的結構 12345678// JSXreturn &lt;Component a={42} b=&quot;string&quot;&gt;Text&lt;/Component&gt;// 編譯為 JSreturn React.createElement(Component, {a: 42, b: 'string'}, 'Text');// 最後回傳 React element{type: Component, props: {a: 42, b: 'string'}, children: ['Text']} 在從元件取得結果之後，React 會比對這個新物件並收集需要對 DOM 產生變更的資訊。這個比對和計算的流程稱為 Reconciliation。 最後 React 會把計算結果同步套用到 DOM 上。 Render 和 Commit 階段概念上整個渲染流程被官方團隊區分為兩個階段： Render 包含解析元件計算差異 Commit 則是真實變更 DOM 的流程 在 Commit 結束之後會同步執行 componentDidMount ， componentDidUpdate ， useLayoutEffect 。接著 React 會設定一個很短的 timeout 來執行 useEffect 。 您可以從示意圖看到 class 元件的生命週期不過它沒有包含 Hook 執行的時間點。 處於實驗階段的新功能 Concurrent Mode，它的功能是它能夠在 Render 階段允許瀏覽器處理事件。React 後續可以恢復繼續執行或中斷，又或者重新計算。一旦完成計算 React 會繼續執行 Commit 流程 關鍵是要理解所謂的渲染不完全等於更新 DOM ，而且元件有可能執行渲染但不對畫面產生任何變化。當 React 渲染元件時： 元件有可能回傳相同的結果，所以 React 並不需要變更介面 在 Concurrent Mode，React 可能渲染元件很多次，但是拋棄不用直到結果符合為止 React 是如何處理渲染流程？渲染佇列初始化渲染完成之後，有幾種方式可以觸發 React 重新渲染 Class 元件 this.setState() this.forceUpdate() Function 元件 useState 的 setter useReducer 的 dispatch 其他 ReactDOM.render 標準流程值得注意的是 React 預設，當上層元件被渲染時，React 會遞迴的渲染所有內部的子元件！ 舉例來說：我們有 A &gt; B &gt; C &gt; D 元件結構，然後這些元件都已經呈現在介面上了。如果使用者點擊了一個在 B 裡面的按鈕變更了一個計數器 counter 的狀態： 在 B 中執行了 this.setState() ，會將重新渲染 B 的任務加入渲染佇列 React 開始渲染流程 因為 A 沒有被標記需要渲染所以跳過 B 被標記需要渲染，所以會重新渲染，然後 B 和之前一樣回傳了 &lt;C /&gt; C 原本沒有被標記需要渲染，但因為 B 重新渲染，React 現在也需要渲染 C 以此類推 D 也是 渲染元件會造成所有子元件重新渲染！ 另外，在預設的渲染流程中，React 不會去管 props 有沒有改變，它會無條件的渲染子元件只要上層元件被重新渲染。 意思是每當您在 &lt;App /&gt; 調用 setState() 的時候，就算沒有任何變更，React 會重新渲染整個元件樹。畢竟 React 本來的賣點就是每次更新都像重新繪製整個畫面。 現在很可能元件樹中大多數的元件都回傳了跟上次一樣的結果，因此 React 不會變更 DOM，但 React 依舊必須要執行取得元件狀態，比對差異，計算的流程。這些都需要花一些時間。 記住，渲染不是不好 - 這是 React 得知如何變更 DOM 的方法 優化渲染效能必須得承認的是 - 渲染可能浪費效能也是事實。如果元件渲染之後的結果是不需變更，那麼渲染流程確實是多餘的。 由於 React 元件渲染的輸出永遠都會基於當下的 props 和 state ，因此如果我們提前得知 props 和 state 沒有變更的話，我們應該也能確定該次渲染的結果應該是一樣，然後我們就可以跳過該次渲染。 通常我們在優化效能時大概有兩個方向 更快的完成相同的任務 減少需執行的任務 優化 React 渲染主要屬於第二種方式。 優化元件渲染的技巧React 提供了一些 API 讓我們可以略過渲染 React.Component.shouldComponentUpdate：class 類型元件中一個可選的生命週期方法，該方法會在 render 之前被調用。如果回傳 false 那麼 React 就會跳過渲染該元件。可以包含任何您想要計算的邏輯，最後回傳一個布林值，大多都是比對上一次的 props 和 state 如果沒有改變就回傳 false React.PureComponent：因為在 shouldComponentUpdate 中比對 props 和 state 是很常見的方式，PureComponent 實作了該行為，可以用來取代 Component + shouldComponentUpdate React.memo() ：內建的高階元件。允許我們傳入一個自己撰寫的元件作為參數，回傳一個新的元件。這個元件預設會檢查 props 是否有變，如果沒有就不再重新渲染。同時支援 class 和 function 類型的元件。另外它可以傳入一個比對的函式作為第二個參數，但你只能比較 props ，所以主要的用途是針對特定欄位。 上面的方式都是使用淺層比對。意思是簡單比對兩個物件的欄位是不是相同，用程式碼來看就是 obj1.a === obj2.a ， === 比對對 JS 引擎來說非常容易因此上述 3 種方式的比對都等於 const shouldRender = !shallowEqual(newProps, prevProps) 另一個比較少被提起的事：如果 React 元件在 render 回傳了一個和上一次相同參考（Reference）的輸出， React 會跳過渲染該子元素。上述這些技術都屬於略過渲染，也就是 React 會跳過渲染其內部的子元件，如此就可以停止遞迴去渲染而產生計算的行為。 新建立的 Props 參考是如何影響優化我們知道如果該元件被標記需要重新渲染，那麼預設 React 就會重新渲染其內部的元件即使它們的 props 沒有變更。意思是 props 是否有變更根本不是重點。 12345678910function ParentComponent() { // 每次渲染會是新的 Reference const onClick = () =&gt; { console.log('clicked'); }; const data = {a: 1, b: 2}; return &lt;NormalChildComponent onClick={onClick} data={data} /&gt;} 每次 ParentComponent 重新渲染的時候就會建立新的 onClick 和 data 參考，然後傳給 NormalChildComponent 不管我們使用箭號函式或傳統的 function 定義 onClick 它都會得到一個新的參考。 也就是說這種時候使用 React.memo 是沒有意義的。使用 React.memo 要注意傳入 props 的參考 123456789const MemoizedChildComponent = React.memo(ChildComponent);function ParentComponent() { const onClick = () =&gt; { console.log('clicked'); }; const data = {a: 1, b: 2}; return &lt;MemoizedChildComponent onClick={onClick} data={data} /&gt;} 例如上面的範例 ParentComponent 每次渲染的時候產生新的參考會導致 MemoizedChildComponent 認為 props 改變了然後就會重新渲染。 意思是： MemoizedChildComponent 即使我們想要略過渲染但每次都會被重新渲染 上述情況比對新舊 props 只是浪費效能 同樣的例如 &lt;MemoizedChildComponent&gt;&lt;OtherComponent /&gt;&lt;/MemoizedChildComponent&gt; 它的子元件也是每次都會每次都會重新渲染，因為 props.children 永遠都是新的參考。 這個小結的重點在於謹慎正確的使用 React.memo 優化 Props 參考class 類型的元件不太需要擔心為 callback 函式建立新參考的問題，因為他們可以使用物件實例方法，如此一來參考都會是一樣的。然而它們還是可能會需要為列表的項目（子元件）建立獨立的 callback 或者在匿名函式中取得一個值然後傳遞給子元件。這些都會造成產生新的參考。對於這種情況 React 並沒有任何內建的方式優化。 而 function 元件，React 提供了兩個 hook 協助重複使用相同的參考：useMemo 可以使用在任何資料，物件（建議使用在複雜計算情境）。useCallback 則針對 callback 函式。 是否該快取所有東西？事實上您不需要對每個往下傳遞的函式或物件使用 useMemo 和 useCallback 。具體的範例可以參考補充一節。 另一個常被提出的問題是為什麼 React 不預設把所有元件使用 React.memo 包起來？ Dan Abramov 已經指出快取還是會耗費效能在比對 props 上，並且很多情況下快取無法阻止重新渲染。為每個元件都套用 React.memo 可能導致更多問題。 測量 React 元件渲染效能使用 React DevTools Profiler 可以檢查每次 Commit 重新渲染了那些元件。藉此可以找到那些非預期渲染的元件。使用開發工具可以了解為什麼它們重新渲染並且修復問題。 Context 渲染流程React Context API 可以協助子元件取得資料。例如任何在 &lt;MyContext.Provider&gt; 底下的元件都可以讀取它的資料而不需要逐層通過 props 傳遞。 Context 不是狀態管理工具，您還是要自己管理那些傳給 Context 的資料。 Context 基礎Context 的 Provider 可以傳入一個 value 屬性。例如：&lt;MyContext.Provider value={42}&gt; 然後內部的子元件就可以使用 Consumer 取得 value 的資料例如： 12345&lt;MyContext.Consumer&gt; {(value) =&gt; ( &lt;div&gt;{value}&lt;/div&gt; )}&lt;/MyContext.Consumer&gt; 或者使用 useContext 取得值 1const value = useContext(MyContext) 更新 ContextReact 會觀察 Provider 的 value 是否有更新。如果 Provider 的 value 是新的參考 React 發現值產生變更就會讓有使用 Consumer 的元件更新 123456789101112131415161718192021222324function GrandChildComponent() { const value = useContext(MyContext); return ( &lt;div&gt;{value}&lt;/div&gt; );}function ChildComponent() { return &lt;GrandChildComponent /&gt;}function ParentComponent() { const [a, setA] = useState(0); const [b, setB] = useState('text'); const value = { a, b, }; return ( &lt;MyContext.Provider value={value}&gt; &lt;ChildComponent /&gt; &lt;/MyContext.Provider&gt; );} 上面範例每次 ParentComponent 渲染的時候，React 會註記 MyContext.Provider 得到新的 value 然後會找到那些有使用 MyContext 取值的元件並強制更新。 每個 Context 只有一個 value 不管它是物件，陣列或其他格式的資料。目前使用 Context 取值的元件並沒有辦法跳過由 Context 造成的重新渲染。 State，Context 和重新渲染現在我們來整理上面學習到的東西 調用 setState() 會把一次元件重新渲染的任務加入佇列 React 預設會遞迴的渲染內部元件 Context Provider 會由使用它的元件來給定 value 通常 Context Provider 的 value 來自上層元件的 state 根據我們一開始提到 React 的預設行為會渲染所有子元件（沒有優化的情況下），意思是一旦上層元件的 state 變更那麼所有子元件都會被更新。 回到上面 Parent/Child/GrandChild 的範例，注意！ GrandChildComponent 會重新渲染是因為 ChildComponent 重新渲染了，而不是上面因為使用了 MyContext 會強制更新。 更新 Context 和優化渲染讓我們修改一下上面的範例 123456789101112131415161718192021222324252627282930function GreatGrandChildComponent() { return (&lt;div&gt;Hi&lt;/div&gt;);}function GrandChildComponent() { const value = useContext(MyContext); return ( &lt;div&gt; {value.a} &lt;GreatGrandChildComponent /&gt; &lt;/div&gt; );}function ChildComponent() { return &lt;GrandChildComponent /&gt;}const MemoizedChildComponent = React.memo(ChildComponent);function ParentComponent() { const [a, setA] = useState(0); const [b, setB] = useState('text'); const value = {a,b}; return ( &lt;MyContext.Provider value={value}&gt; &lt;MemoizedChildComponent /&gt; &lt;/MyContext.Provider&gt; );} 現在如果我們執行了 setA(42) ParentComponent 會重新渲染 新的 Context value 參考產生 React 發現 MyContext.Provider 有了新的 value 因此任何使用 MyContext 的元件都要更新 React 會嘗試要重新渲染 MemorizedChildComponent 不過因為它使用了 React.memo 並且沒有 props 的變動，所以跳過重新渲染 然而因為 MyContext.Provider 更新了，也許深層還有元件需要更新 React 繼續往下檢查，直到 GrandChildComponent 它發現有使用 MyContext 因此 GrandChildComponent 需要被重新渲染 接著因為 GrandChildComponent 重新渲染了所以 GreatGrandChildComponent 也要被重新渲染。 位於 Context Provider 的元件大概都可能需要使用 React.memo - Sophie Alpert 通過這種方式上層元件重新渲染的時候就不用強制渲染所有元件了。或者您也可以利用傳遞相同 props.children 參考的方式 123&lt;MyContext.Provider&gt; {props.children}&lt;/MyContext.Provider&gt; 來避免重新渲染子元件。 React-Redux 渲染流程前陣子最常見的問題大概是各種 Context v.s Redux。這個問題一開始就是錯誤的二分法，因為 Redux 和 Context 處理的是不同的問題。 其中人們最常提到 React-Redux 只會讓需要的元件重新渲染，所以比 Context 好。 這種說法部分是正確的，但答案不僅如此。 React-Redux 訂閱機制很多人提到 React-Redux 內部也是使用 Context，技術上來說 - 沒錯，但 React-Redux 使用 Context 是用來傳遞 Store 物件實例，而不是狀態。意思是傳遞給 &lt;ReactReduxContext.Provider&gt; 的 value 都是一樣的 store 參考。 還記得 Redux Store 會在我們 dispatch action 的時候執行註冊的 callback 函式（加入 subscribe 的函式）。介面必須訂閱 store 然後自行讀取最新的狀態進而觸發重新渲染 。整個訂閱機制的流程並不屬於 React 內部的機制，只有在 React-Redux 得知特定元件需要的資料發生異動的時候 React 才會加入流程。React-Redux 主要就是基於 mapState 或 useSelector 來判斷狀態是否發生變更。 這直接導致和 Context 相較之下在效能表現上的差異。觸發重新渲染的元件看起來會比較少。不過當 store 的狀態變更時， React-Redux 必須要為整個元件結構執行 mapState 或 useSelector 函式。雖然大部分情況執行 mapState 或 useSelector 比起渲染流程耗費的效能比較小，不過如果這些函式需要做一些複雜的轉換或者多餘的更新也是會降低效能。 connect 和 useSelector 的差異connect 是一個高階元件。您可以把您的元件作為參數傳入然後它會回傳一個新的元件。這個新元件添加的功能就是訂閱 store ，執行 mapState 和 mapDispatch ，最後把狀態通過 props 交給您的元件。 connect 產生的元件基本上行為和 PureComponent React.memo 一樣，不過有些微的差異： connect 只有在整合的 props 發生變化的時候才會渲染您的元件。 通常最終整合的 props 包含 {...ownProps, ...stateProps, ...dispatchProps}，所以任何從上層產生 props 的新參考都會造成重新渲染，mapState 也會，也就是影響重新渲染的範圍變大了。 useSelector 是給函式元件使用的 Hook，因為是在元件內部使用所以不像 connect 可以比對阻止上層元件造成的重新渲染。 這就是 connect 和 useSelector 最大的差異，使用 connect 的話元件基本上等於 PureComponent 可以停止因為上層重新渲染導致必須要跟著重新渲染的問題。由於大部分的 React-Redux 應用程式會大量使用 connect ，意味著其實它們已經降低了渲染次數。 React-Redux 會根據資料的更新來觸發 connect 產出的元件進行更新，當然內部的元件可能也會被渲染不過檢查到另外一個 connect 元件是不需要渲染的時候就會停止往下影響。 此外，大量使用 connect 意味著每個元件可能只關注小部分的資料，因此每次狀態變更，造成重新渲染的機會也會降低。 如果您只使用函式元件和 useSelector 。那麼每當 store 變更時，比起 connect 的方式，很大的機會會重新渲染整個元件樹。 如果因為這樣而產生效能的問題，那麼解決辦法就是使用 React.memo 來防止因為上層元件造成多餘的重新渲染 總結 React 預設重新渲染時會遞迴式的影響子元件，所以上層元件重新渲染，內部子元件也會重新渲染 渲染機制是 React 得知該如何調整 DOM 的方法 渲染是需要耗費時間，如果介面沒改變卻產生了多餘的渲染是會累積的 大部分情況傳入 props 的函式或物件產生新的參考不會產生問題 如果 props 沒有變動，React.memo 可以避免不必要的渲染 如果每次渲染都產生新的參考並傳入 props ，那麼 React.memo 也沒用，這種情況下就要將傳入的東西暫存起來，例如 useMemo Context 主要是讓深層的元件可以存取資料，而避免逐層傳遞 props 的問題 Context.Provider 的 value 比對是基於參考來判斷是否需要更新 一旦 value 發生異動，底下有讀取 Context 資料的元件會強制重新渲染 但大部分的情況造成重新渲染的其實是預設行為，就是上層元件更新導致的 所以您應該將 Context.Provider 內部的子元件使用 React.memo 包起來或使用 {props.children} 固定參考的方式，才不會在 Context value 更新時造成多餘的渲染 子元件如果有讀取 Context value ，React 會確保其正確的執行渲染 React-Redux 通過訂閱 store 的方式來判斷是否需要更新，而不是將 state 存在 Context 訂閱機制會在每次 store 更新時運作 React-Redux 確保了只有在元件使用的資料發生變化才會重新渲染元件 connect 的行為跟 React.memo 很接近，因此大量使用 connect 可以最小化渲染次數 useSelector 無法阻止因上層元件造成的渲染，所以偏好使用函式元件的開發者應更注意 React.memo 的時候時機 心得顯然情況是很複雜的不能單純說 - Context 會造成所有東西重新渲染，Redux 不會，所以應該使用 Redux。雖然我希望大家使用 Redux 但我同時也希望大家可以清楚的明白這些運作機制，然後自己判斷該使用什麼。 由於大家老是在問“什麼時候我該使用 Context？什麼使用我該使用 Redux？那就讓我們進一步彙整一些建議 使用 Context 您只是簡單要傳遞資料並且這些資料不會頻繁的變動 如果有些狀態或函式可能貫穿整個應用程式，而且深層的元件也需要存取 您只想使用內建的功能 使用 Redux 應用程式有大量的狀態需要處理 狀態很頻繁的變更 狀態變更的邏輯很複雜 多人維護的專案，專案屬於中大型有大量的程式碼 請注意上面提到的都不是硬性的規則，只是簡單的建議。請花點時間根據遭遇的問題，環境自行思考選擇。希望這篇說明可以幫助您對於 React 渲染的行為有更全面的理解 參考資源 A (Mostly) Complete Guide to React Rendering Behavior You’re overusing useMemo: Rethinking Hooks memoization 補充 - 正確使用 useMemo維持相同參考的問題12345678// 範例想避免 value 的參考變化導致 ExpensiveComponent 重新渲染const MyComponent = ({ page, type }) =&gt; { const value = useMemo(() =&gt; { return getValue(page, type); }, [page, type]); return &lt;ExpensiveComponent value={value} /&gt;} 根據上面範例，使用 useMemo 前請先問自己： getValue 屬於複雜計算耗費效能嗎？如果不是請不要濫用 useMemo 不同的參數例如 page 和 type 會造成 value 的參考不同嗎？如果是 string number boolean null undefined symbol 這些參考都不會變動因此 &lt;ExpensiveComponent&gt; 也不會重新渲染，也就不需要使用 useMemo 基於各種理由快取預設狀態12345678const MyComponent = ({page, type}) =&gt; { const defaultState = useMemo(() =&gt; ({ fetched: operation(), type, }), [type]); const [state, setState] = useState(defaultState); return &lt;ExpensiveComponent /&gt;} 看似沒有什麼問題的範例，但 useMemo 根本不重要。首先我們理解一下範例的意圖，當 type 改變時 defaultState 可以跟著更新，也可以在每次渲染的時候省去一些計算。 看似合理的想法，但這個方法是錯的並且違反 useState 的原則。useState 在第一次掛載初始化之後就不會在使用預設狀態。 雖然type 改變會得到新的 defaultState 但 useState 會直接忽略。 12345678910111213// 比較好的方式const MyComponent = ({page, type}) =&gt; { const defaultState = () =&gt; { // 複雜計算 console.log(&quot;default state exec&quot;); return { name: &quot;andyyou&quot; }; }; const [state, setState] = useState(defaultState); return &lt;ExpensiveComponent /&gt;} 上面這種方式 defaultState 只會在第一次掛載的時候被執行一次。 處理 ESLint Hook 警告沒有經過完整理解只為了解決 ESLint 的警告而照著說明調整反而可能產生 Bug 1234567function Example({ tracker, a, b, c }) { useEffect(() =&gt; { tracker(a, b, c) }, []); return &lt;MyComponent a={a} b={b} c={c} /&gt;} 上面的範例您不在意 props 是否改變，您只想在第一次初始化的時候追蹤 props 。而此時 ESLint 會出現一些警告 React Hook useEffect has missing dependencies: 'tracker', 'a', 'b', and 'c'. Either include them or remove the dependency array. 這個時候您可以關閉警告 1// eslint-disable-next-line react-hooks/exhaustive-deps 但不是最好的解法，這裡建議您可以使用 useRef 123456789101112const initialTrackingValues = useRef({ tracker, params: { a, b, c }});useEffect(() =&gt; { const { tracker, params } = initialTrackingValues.current; tracker(params)}, []); 注意只有 useRef 可以解除這個警告，不要使用 useMemo 來處理這個問題，完全是錯的。 使用 useMemo 處理參考（Reference）的問題大多人使用 useMemo 來快取減少複雜計算和維持參考的問題。第一點減少耗費效能的計算沒有問題。但第二點使用 useMemo 維持參考的一致則並不正確。請不要使用 useMemo 就只為了讓參考一致。 為什麼不要使用 useMemo 維持一致的參考？ 1234function Bla() { const baz = useMemo(() =&gt; [1, 2, 3], []); return &lt;Foo baz={baz} /&gt;} 上面範例 Bla 的值 baz 被快取不是因為 [1, 2, 3] 是耗費效能的計算，只是因為 baz 每次渲染的參考都會改變。 範例看起來沒什麼問題，但 useMemo 並不是處理這種情況最佳的 Hook。 上面我們在 useMemo 的第二個參數傳入空陣列，也就是 [1, 2, 3] 在元件掛載之後就不會改變。結論就是我們快取了一個不會耗費效能的值，這個值在掛載之後就不變了。 如果您發現您遇到類似的情境，請您在好好思考一下是否該使用 useMemo 。 那該怎麼做？ 首先必須回到我們希望在這裡完成什麼？我們並不是想要快取資料，我們想要的是在每次重新渲染的時候維持一致的參考。畢竟我們使用了 [] 作為第二個參數那麼這個變數掛載之後就不會變了。 此時使用 useRef 是比較合理的。 1234funtion Bla() { const { current: baz } = useRef([1, 2, 3]); return &lt;Foo baz={baz} /&gt;} 事實上您還可以使用 useRef 去保存一個耗費效能的函式計算只要該函式不需要因為 props 的改變而需要重新計。 記住，上面的情境是您需要維持一致的參考，但如果您需要保存的是值且會根據 props 等改變那您應該使用 useMemo","link":"/2020/05/31/understand-react-rendering-in-deep/"},{"title":"使用 Sancutm 實作 React SPA 認證","text":"Sanctum 是一套輕量化的 API 認證機制套件。本文會介紹如何使用 Sanctum 支援 React 單頁應用程式認證（會員登入）。我們假設應用程式的前端和後端使用相同 TLD 頂級網域下的子網域，如此才可以使用 Sanctum 基於 Cookie 的驗證流程。利用這種作法可以省去處理 API Token 。為此我們使用 Homestead 設定兩個網域 api.sanctum.test 指向 Laravel 專案的 public 目錄用於提供後端，sanctum.test 指向另一個目錄提供前端的部分。 後端讓我們從 API 開始 1$ laravel new api 我們假設這個 API 提供書籍查詢資料，因此我們建立一個 Book 的資料模型 12$ cd api$ php artisan make:model Book -mr -m 協助產生 Migration 檔案，-r 協助我們產生一個 Restful 風格的 Controller 檔案 - 即包含了 CRUD 等 action。雖然這裡只會用到 index 但藉此知道這些參數也是非常實用的。接著在 Migration 增加欄位。 123456Schema::create('books', function (Blueprint $table) { $table-&gt;id(); $table-&gt;string('title'); $table-&gt;string('author'); $table-&gt;timestamps();}); 執行 migrate 之前記得檢查 .env 確認資料庫建立和相關連線設定是否正確。這裡我使用 pgsql 您可以選擇您熟悉的資料庫 123456DB_CONNECTION=pgsqlDB_HOST=127.0.0.1DB_PORT=5432DB_DATABASE=api-demoDB_USERNAME=homesteadDB_PASSWORD=secret 注意 homestead 和 secret 是 Homestead 預設的資料庫使用者和密碼。 執行 12$ createdb api-demo$ php artisan migrate 更新 DatabaseSeeder.php 加入一些 Book 的資料。（DatabaseSeeder 利用陣列的方式建立資料時， Model 可以不加 $fillable，但如果您的 API 涉及到寫入的話記得補上） 123456789101112131415161718192021222324252627282930use App\\User;use App\\Book;use Faker\\Factory;class DatabaseSeeder extends Seeder{ /** * Seed the application's database. * * @return void */ public function run() { // $this-&gt;call(UserSeeder::class); Book::truncate(); $faker = Factory::create(); for ($i = 0; $i &lt; 50; $i++) { Book::create([ 'title' =&gt; $faker-&gt;sentence, 'author' =&gt; $faker-&gt;name, ]); } User::truncate(); User::create([ 'name' =&gt; 'Andy', 'email' =&gt; 'andy@example.com', 'password' =&gt; Hash::make('password'), ]); }} 執行 php artisan db:seed 建立模擬資料。最後我們還需要加入路由到 routes/api.php 1Route::get('/books', 'BookController@index'); 然後回到 BookController.php 的 index 加入 1return response()-&gt;json(Book::all()); 在正式專案中我們可能會使用 Laravel 的 API Resource 功能來轉換資料，但對於這個範例來說目前的作法已經堪用。 Homestead 補充文章的開頭提到會搭配 Homestead 分別設定兩個子網域。這部分的設定您可以參考官方 Homestead 文件 。這裡補充可能遇到的問題處理方式。 外連本機資料庫如果您使用本機實體機器下的資料庫（非 Homestead 虛擬機中的資料庫）您可能在連線到 http://api.sanctum.test/api/books 的時候遭遇如下錯誤訊息。 1SQLSTATE[08006] [7] fe_sendauth: no password supplied (SQL: select * from &quot;books&quot;) 這是因為您連線的 127.0.0.1 是虛擬機本身而不是實體機的資料庫。如果是這樣您可以在執行 migrate 和 db:seed 之後將連線 DB_HOST 調整為 10.0.2.2。 但是！如果後續有其他 Migration 需要執行都需要先切換回來。為了單純起見建議您還是登入到 Vagrant 使用虛擬機的資料庫 Homestead 資料庫如果您想要使用 Homestead 自帶的資料庫（以 PostgreSQL 為例）我們須進入虛擬機建立資料庫等 1234567891011121314151617181920# 備註如果您調整了 Homestead.yaml 記得重載設定$ vagrant reload --provision# 建立資料庫$ vagrant ssh$ psql -U homestead -h localhost$ create database [DATABASE_NAME];# 進入專案目錄$ php artisan migrate$ php artisan db:seed# 補充 - 建立使用者$ createuser --interactive --pwprompt$ psql# 列出使用者SELECT * FROM &quot;pg_user&quot;;# 列出所有角色 + 權限$ \\du （補充）前端 Nginx因後續我們會使用 react-router-dom 。每次都從首頁進入才開始操作是沒問題的，但如果直接使用連結遇到 404 錯誤，此時可以直接使用 Homestead 提供的 spa 類型在 Homestead.yaml 加入 type 123- map: sanctum.test to: /home/vagrant/spa-demo/build type: &quot;spa&quot; 12# 備註如果您調整了 Homestead.yaml 記得重載設定$ vagrant reload --provision 或者自行調整 Nginx 設定 1234$ vagrant ssh$ sudo vi /etc/nginx/sites-available/sanctum.test$ sudo nginx -t$ sudo nginx -s reload 123location / { try_files $uri /index.html =404;} 前端前端 SPA 的部分我們會使用 create-react-app 來建立。在另外目錄下執行下面指令 12$ npx create-react-app sanctum-spa-demo$ cd sanctum-spa-demo 接著我們安裝 react-router-dom 和 axios 套件 12$ npm i axios react-router-dom$ npm start 現在我們可以建立 Book 元件並使用 axios 讀取書籍資料 123456789101112131415161718192021222324252627// src/components/Books.jsimport React, { useState, useEffect } from 'react';import axios from 'axios';const Books = () =&gt; { const [books, setBooks] = useState([]); useEffect(() =&gt; { const cb = async () =&gt; { const response = await axios.get('https://api.sanctum.test/api/books'); console.log(response); if (response.status === 200) { setBooks(response.data); } }; cb(); }, []); return ( &lt;ul&gt; {books.map(book =&gt; ( &lt;li key={book.id}&gt;{book.title}&lt;/li&gt; ))} &lt;/ul&gt; );};export default Books; 接著在 src/App.js 中使用 Books 元件 1234567891011121314151617181920212223242526// src/App.jsimport React from 'react';import { BrowserRouter as Router, Switch, Route, NavLink,} from 'react-router-dom';import Books from './components/Books';function App() { return ( &lt;Router&gt; &lt;nav&gt; &lt;NavLink to=&quot;/&quot;&gt;Home&lt;/NavLink&gt; {' '} &lt;NavLink to=&quot;/books&quot;&gt;Books&lt;/NavLink&gt; &lt;/nav&gt; &lt;Switch&gt; &lt;Route path='/books' component={Books} /&gt; &lt;/Switch&gt; &lt;/Router&gt; );}export default App; 執行 npm start 造訪 /books 頁面可以看到書籍列表。 現在我們希望只能特定授權的人可以查閱資料。或者 API 可以根據不同的使用者顯示不同的書籍。是 Sanctum 登場的時候到了。 讓我們回到後端專案安裝相關套件。 1$ composer require laravel/sanctum laravel/ui 安裝 laravel/ui 是因為它提供了一些會員認證功能的檔案（包含 Controller 和 View）。vendor:publish 則是為了建立 sanctum-config 123456789101112131415161718192021222324252627$ php artisan ui:authAuthentication scaffolding generated successfully.$ php artisan vendor:publishWhich provider or tag's files would you like to publish?: [0 ] Publish files from all providers and tags listed below [1 ] Provider: Facade\\Ignition\\IgnitionServiceProvider [2 ] Provider: Fideloper\\Proxy\\TrustedProxyServiceProvider [3 ] Provider: Fruitcake\\Cors\\CorsServiceProvider [4 ] Provider: Illuminate\\Foundation\\Providers\\FoundationServiceProvider [5 ] Provider: Illuminate\\Mail\\MailServiceProvider [6 ] Provider: Illuminate\\Notifications\\NotificationServiceProvider [7 ] Provider: Illuminate\\Pagination\\PaginationServiceProvider [8 ] Provider: Laravel\\Sanctum\\SanctumServiceProvider [9 ] Provider: Laravel\\Tinker\\TinkerServiceProvider [10] Tag: cors [11] Tag: flare-config [12] Tag: ignition-config [13] Tag: laravel-errors [14] Tag: laravel-mail [15] Tag: laravel-notifications [16] Tag: laravel-pagination [17] Tag: sanctum-config [18] Tag: sanctum-migrations &gt; 17 Copied File [/vendor/laravel/sanctum/config/sanctum.php] To [/config/sanctum.php]Publishing complete. 然後設定路由 1Route::middleware('auth:sanctum')-&gt;get('/books', 'BookController@index'); 由於我們想要前端專案對應 sanctum.test 網址，然後它會跟後端 api.sanctum.test 溝通取得資料。因此在我們完成 前端變更之後我們可以執行 npm run build，然後 Homestead 對應到 build 目錄。 可以僅使用一台全域的 Homestead 然後設定對應不同的網域。提供我的 Homestead.yaml 作為參考 1234567891011121314151617181920212223ip: &quot;192.168.10.10&quot;memory: 2048cpus: 2provider: virtualboxssl: trueauthorize: ~/.ssh/id_rsa.pubkeys: - ~/.ssh/id_rsa folders: - map: ~/workspace/demo/spa to: /home/vagrant/spa-demo - map: ~/workspace/demo/api to: /home/vagrant/api-demosites: - map: sanctum.test to: /home/vagrant/spa-demo/build type: &quot;spa&quot; - map: api.sanctum.test to: /home/vagrant/api-demo/public 另外 /etc/hosts 記得設定 IP 對應 12192.168.10.10 sanctum.test192.168.10.10 api.sanctum.test 此時試著瀏覽 https://sanctum.test/books 頁面，您應該會在瀏覽器的開發者工具看到 401 Unauthenticated 錯誤。前端需要登入元件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// src/components/Login.jsimport React, { useState,} from 'react';import axios from 'axios';const Login = ({}) =&gt; { const [email, setEmail] = useState(''); const [password, setPassword] = useState(''); const handleSubmit = (e) =&gt; { e.preventDefault(); const cb = async () =&gt; { const response = await axios.post('https://api.sanctum.test/login', { email, password, }); console.log('submit', response); }; cb(); }; return ( &lt;div&gt; &lt;h3&gt;Login&lt;/h3&gt; &lt;form onSubmit={handleSubmit}&gt; &lt;input type=&quot;email&quot; name=&quot;email&quot; placeholder=&quot;Email&quot; value={email} onChange={(e) =&gt; setEmail(e.target.value)} required /&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;Password&quot; value={password} onChange={(e) =&gt; setPassword(e.target.value)} required /&gt; &lt;button type=&quot;submit&quot;&gt; Login &lt;/button&gt; &lt;/form&gt; &lt;/div&gt; );};export default Login; 上面只是基本的表單使用 axios 發送請求到後端然後輸出回應。接著我們在 App.js 使用該元件 123456789101112131415161718192021222324252627282930// src/App.jsimport React from 'react';import { BrowserRouter as Router, Switch, Route, NavLink,} from 'react-router-dom';import Books from './components/Books';import Login from './components/Login';function App() { return ( &lt;Router&gt; &lt;nav&gt; &lt;NavLink to=&quot;/&quot;&gt;Home&lt;/NavLink&gt; {' '} &lt;NavLink to=&quot;/login&quot;&gt;Login&lt;/NavLink&gt; {' '} &lt;NavLink to=&quot;/books&quot;&gt;Books&lt;/NavLink&gt; &lt;/nav&gt; &lt;Switch&gt; &lt;Route path='/login' component={Login} /&gt; &lt;Route path='/books' component={Books} /&gt; &lt;/Switch&gt; &lt;/Router&gt; );}export default App; 一樣 npm run build 之後瀏覽登入頁面輸入我們在 seed 加入的的帳密。這次應該遭遇到的則是 Corss-Origin Request Blocked 錯誤。 （補充）npm-watch每次要測試的時候都忘記 npm run build ？這裡補充一個簡單的方式支援 watch Production Mode。記得先到前端專案下 1$ npm i npm-watch 12345678910111213141516// package.json&quot;scripts&quot;: { ... &quot;watch&quot;: &quot;npm-watch build&quot;, ...},&quot;watch&quot;: { &quot;build&quot;: { &quot;patterns&quot;: [ &quot;.&quot; ], &quot;ignore&quot;: &quot;build&quot;, &quot;extensions&quot;: &quot;*&quot;, &quot;quiet&quot;: false }}, 後續可使用 npm run watch 一旦檔案變更就會執行 npm run build 關於 CORS同源政策是瀏覽器的安全機制，可防止一來源的腳本程式碼（來源指的是例如 http, https, ftp 等 scheme 搭配 hostname 和 port 組成）直接存取其他來源的資料。 CORS（Cross-Origin Resource Sharing）是處理在同源政策保護下讀取其他來源資料的解決辦法。請求的表頭會包含 Origin 資料，而伺服器回應的表頭須包含 Access-Control-Allow-Origin 如果兩者符合瀏覽器便會允許接收該回應。 OK！知道了問題但如果您查看瀏覽器開發者工具的 Network 您會發現我們甚至連 POST 請求都沒有送出。實際上，只有 OPTIONS 請求。為什麼？原因是我們的請求不符合簡單請求的規則，即包含了 Content-Type 是 application/json CORS 詳解 因此會發送一個 OPTIONS 預先請求到伺服器確認，接著伺服器會回應一些 Header 讓瀏覽器檢查是否可以發出請求。由於 Laravel 還沒設定 CORS 因此沒有回應任何 Access-Control- Header，因此請求並沒有發生。前端的部分，瀏覽器會自動處理所以只要調整後端的部分。 事實上，Laravel 7 內建 CORS Middleware，可以通過 config/cors.php 設定。開啟該檔案會看到預設 allowed_origins 為 * 意思是任何請求都是被允許的。那為什麼剛剛的請求無法運作。如果我們在往上一點查看設定檔會看到 paths 意思是下面的設定只會套用到 api 命名空間下的路由。 在 paths 加入 login 即可解決這個問題。 CSRF然後又錯誤，這次是 419 CSRF Token mismatch 錯誤。CSRF（Cross-Site Request Forgery） 是攻擊者在經過認證的環境下執行惡意操作的一種方式。 舉個在 OWASP 文件中提到的例子 - 當你已登入網銀時，攻擊者會透過一些社交手段欺騙您造訪某個連結。惡意連結可能是隱藏在 Email 中的一張 0x0 的圖片或是吸引人點擊的連結等。無論是哪種方式，該網址會嘗試存取網銀的 API，並對您的帳戶造成影響。恐怖的是，由於您已經登入了，因此不需要再進行任何身份驗證流程。 該如何解決這個問題？這裡介紹其中一種方式就是伺服器會先傳送隨機的 Token 到客戶端的 Cookie 然後 Token 包含在請求的 Header 中。如果我們執行 php artisan route:list 會看到 login 路由屬於 web Middleware 群組其中包含了VerifyCsrfToken Middleware，在其 handle 函式我們看到其邏輯如下 1234567891011121314151617public function handle($request, Closure $next){ if ( $this-&gt;isReading($request) || $this-&gt;runningUnitTests() || $this-&gt;inExceptArray($request) || $this-&gt;tokensMatch($request) ) { return tap($next($request), function ($response) use ($request) { if ($this-&gt;shouldAddXsrfTokenCookie()) { $this-&gt;addCookieToResponse($request, $response); } }); } throw new TokenMismatchException('CSRF token mismatch.');} 如果條件不符合就會產生 TokenMismatchException 例外。由於現在這個請求不屬於單純讀取，我們使用的是 POST 請求，不是單元測試，沒有設定例外，只剩 tokenMatch 但我們沒有設定 Token 所以比對一定失敗而產生例外。 OK 這是為我們提供的保護機制。但我們要如何取得 CSRF Token 呢？如果我們停留在伺服器產生的頁面，Laravel 會自動協助我們取得 Token 從 Controller（csrf_token()） 到 View (@csrf) 都很方便。但現在我們不是使用框架提供的 View 我們需要自行取得 CSRF Token。內建 api:auth 沒有提供此功能，此時就是 Sanctum 登場的時候了。Sanctum 允許我們詢問 CSRF Token 然後我們將 Token 含在表頭中。 如果您執行下面查詢路由列表的指令 1$ php artisan route:list 您應該會看到一道 /sanctum/csrf-cookie。這功能是 SanctumServiceProvider 在 boot 方法中定義的。 知道有這道 API 只會讓我們回到 Login 元件調整 12345678910111213const handleSubmit = (e) =&gt; { e.preventDefault(); const cb = async () =&gt; { await axios.get('https://api.sanctum.test/sanctum/csrf-cookie'); const response = await axios.post('https://api.sanctum.test/login', { email, password, }); console.log('submit', response); }; cb();}; Homestead 下的前端專案更新之後請記得 npm run build 或使用 npm-watch 記得一樣要設定 cors 設定檔 1'paths' =&gt; ['api/*', 'login', 'sanctum/csrf-cookie'], 在我們點擊送出按鈕之前請先開啟瀏覽器的開發者工具，到 Firefox 的儲存空間（Storage）或 Chrome 的 Application。您應該可以查閱 Cookie。此時您應該看到 Cookie 為空。點擊送出還是沒有 Cookie…！ 為什麼？ 查看瀏覽器開發工具的 Network 我們的確呼叫了 sanctum/csrf-cookie 並取得 204 的回應 的確有 laravel_session 和 XSRF-TOKEN 但儲存空間 Cookie 那邊卻沒有。 答案是和 Cookie 存取限制有關，也是文章一開始我們提到為什麼要使用一樣頂級網域的原因。從伺服器來的 Set-Cookie 可以設定 domain 指定對哪些網域發送請求的時候要包含該 Cookie。我們看一下 Header 中 XSRF-TOKEN 的部分 1XSRF-TOKEN=&lt;token&gt;; expires=Wed, 08-Jul-2020 04:13:20 GMT; Max-Age=7200; path=/; samesite=lax 沒有包含 Domain 屬性。也就是我們 sanctum.test 的請求並不會自動包含該 Cookie。因此我們需要在後端的 .env 加入 1SESSION_DOMAIN=sanctum.test 再次執行 Cookie 還是沒有送出。這次是因為前端的問題。 XMLHttpRequest 從不同網域取得的回應不能直接設定 Cookie - 即就算收到 Set-Cookie Header 瀏覽器也不會執行，除非 withCredentials設為 true。 因為後續 axios 都需要帶此參數，將這個部分重構後續會比較方便。我們建立一個 src/services 目錄加入 api.js 123456789// src/services/api.jsimport axios from 'axios';const client = axios.create({ baseURL: 'https://api.sanctum.test', withCredentials: true,});export default client; 然後更新 Books 和 Login 有使用 API 的部分。 1import api from '../services/api'; 把 axios 換成 api 。 這次儲存空間或 Application 總算出現 Cookie 了，但回到開發工具的主控台（Console）又看到另一個 Cross-Origin Request Blocked 錯誤。原因是基於安全性考量瀏覽器只會對那些表明支援 withCredentials 的伺服器發送請求。所以我們要回到後端 cors.php 設定 supports_credentials 為 true。 這次我們的登入包含了正確的憑證，您應該可以看到 /login 的請求得到 204 回應。但如果我們切換到 /books 仍然得到 401 未驗證的錯誤。 修正這個錯誤的方式就是使用 Sanctum 的 Stateful Domain。開啟 app/Http/Kernel.php 加入 EnsureFrontendRequestsAreStateful Middleware 到 api 群組。 12345'api' =&gt; [ \\Laravel\\Sanctum\\Http\\Middleware\\EnsureFrontendRequestsAreStateful::class, 'throttle:60,1', \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,], 接著我們來看看這個 Class原始碼做了些什麼。 1234config([ 'session.http_only' =&gt; true, 'session.same_site' =&gt; 'lax',]); 首先，它覆寫了 Session 設定 http_only 為 true ，這表示客戶端的 Script 不能存取 Token，詳細 HttpOnly 介紹可以參考 OWASP 網站說明。同時也設定了 same_site 為 lax 。這是用來防止 Cookie 在其他跨站請求的時候被送出，除非請求是從其他站到您的網站。 12345678return (new Pipeline(app())) -&gt;send($request) -&gt;through(static::fromFrontend($request) ? [ // Middleware ] : []) -&gt;then(function ($request) use ($next) { return $next($request); }); Laravel 的 Middleware 是透過 Pipeline 來處理任務的。該 Class 讓我們可以傳入一個任務處理的陣列並依序帶入資料。 如果您查看 vendor/laravel/framework/src/illuminate/Foundation/Http/Kernel.php 的 sendRequestThroughRouter 方法，您會看到類似的程式碼 1234return (new Pipeline($this-&gt;app)) -&gt;send($request) -&gt;through($this-&gt;app-&gt;shouldSkipMiddleware() ? [] : $this-&gt;middleware) -&gt;then($this-&gt;dispatchToRouter()); 因此 Sanctum 的 EnsureFrontendRequestsAreStateful Middleware 做的其實就是加入了更多處理的 Middleware 。不過只有請求來自前端的時候 - 這也是為什麼會有： 123static::fromFrontend($request) ? [ // some middleware ] : [] 如果請求來自前端則會加入這些 Sanctum 專屬的 Middleware 否則傳入空陣列。static::fromFrontend 會查看 Header 的 Referer ，如果包含在 Sanctum 設定的字串，即可判斷為來自前端的請求。要設定 Referer 可以在 .env 通過 SANCTUM_STATEFUL_DOMAINS 變數設定 1SANCTUM_STATEFUL_DOMAINS=sanctum.test 那哪些是 Sanctum 的 Middleware 呢？ 12345678910[ config('sanctum.middleware.encrypt_cookies', \\Illuminate\\Cookie\\Middleware\\EncryptCookies::class), \\Illuminate\\Cookie\\Middleware\\AddQueuedCookiesToResponse::class, \\Illuminate\\Session\\Middleware\\StartSession::class, config('sanctum.middleware.verify_csrf_token', \\Illuminate\\Foundation\\Http\\Middleware\\VerifyCsrfToken::class),] 這 4 個 Middleware 內建就有了您可以在 web 的 Middleware 看到它們的身影。 EncryptCookies：Cookie 加密，即使有心人士存取了 Cookie 並修改了內容，到伺服器的時候會檢查並拒絕執行。 AddQueuedCookiesToResponse：處理 Cookie Facade 加入佇列的 Cookie。 StartSession：設定與 Laravel 連線階段相關資訊和 Session Cookie，其資訊會被加入回應。 VerifyCsrfToken：檢查 CSRF Token （補充）Postman 取得 CSRF Token因為 axios 會自動幫我們補上 XSRF-TOKEN Header ，所以如果想在 Postman 發送請求的話可以 在 Pre-request Script 加入： 12345678910const Header = require('postman-collection').Header;const cookieJar = pm.cookies.jar();const host = pm.request.url.getHost();const endpoint = host + '/sanctum/csrf-cookie'pm.sendRequest(endpoint, (err, response) =&gt; { cookieJar.get(host, 'XSRF-TOKEN', (err, xsrfToken) =&gt; { pm.request.headers.append(Header.create(xsrfToken, 'X-XSRF-TOKEN')); })}); 登入認證加入 Middleware 可以處理 Cookie 流程的部分。但現在會執行認證機制是因為路由加了 auth:sanctum，意思是使用 Sanctum Guard class 來處理驗證。但如果我們查看 Sanctum Guard class 會發現有點奇怪，官方加入自訂 Guard 文件提到自訂的 Guard 需要繼承 Illuminate\\Contracts\\Auth\\Guard 介面，但原始碼完全沒有 implements 關鍵字而只有 __invoke 這個神奇的方法。 查看 SanctumServiceProvider ，發現是使用文件建議的 $auth-&gt;extend 方法： 12345$auth-&gt;extend('sanctum', function ($app, $name, array $config) use ($auth) { return tap($this-&gt;createGuard($auth, $config), function ($guard) { $this-&gt;app-&gt;refresh('request', $guard, 'setRequest'); });}); tap 簡單說就是建立第一個參數然後帶入第二個閉包，最後會回傳 $guard，接著我們看到 createGuard 的部分 12345return new RequestGuard( new Guard($auth, config('sanctum.expiration'), $config['provider']), $this-&gt;app['request'], $auth-&gt;createUserProvider()); 首先回傳的是RequestGuard物件實例，有實作 Guard 滿足 extend 方法的參數型別。RequestGuard 的第一個參數是閉包，在我們的例子中就是 Sanctum 的 Guard Class，其中的差異就是傳入的是一個帶有 __invoke 的 Class，您可以把它想成是包含狀態的閉包。接著使用 RequestGuard 回傳一個 user 。下面是 Sanctum Gurad 相關程式碼： 12345if ($user = $this-&gt;auth-&gt;guard(config('sanctum.guard', 'web'))-&gt;user()) { return $this-&gt;supportsTokens($user) ? $user-&gt;withAccessToken(new TransientToken) : $user;} 第一行會利用 web Guard 取得 $user 因為我們使用一般的 web 登入的，如果 $user 被找到則回傳。 撇開上面深入的探討，如果您加入 SANCTUM_STATEFUL_DOMAINS 設定，那麼應該可以登入並使用 /api/books API 讀取資料。 SPA現在我們已經完成後端的驗證機制了，該輪到前端的部分。後續文章跟 Sanctum 沒有直接關係，如果您對於前端的部分沒興趣可以直接跳過。 另外注意的是因為 web 路由有使用 RedirectIfAuthenticated Middleware，執行登入前請先記得把 Cookie 清除否則就會因為登入過了而跳轉到 /home 而在開發者工具看到錯誤訊息。 第一步是 App 元件需要一個判斷是否登入的狀態： 1const [isLoggedIn, setIsLoggedIn] = useState(false); 然後加入一個處理函式 123const handleLogin = () =&gt; { setIsLoggedIn(true);}; 接著把函式傳入 Login 元件（還有狀態的部分，如果已登入就不用顯示表單了或者您想要實作跳轉都可以） 123456&lt;Route path='/login' render={(props) =&gt; ( &lt;Login {...props} onLogin={handleLogin} isLoggedIn={isLoggedIn} /&gt; )}/&gt; 到 Login 元件在 handleSubmit 使用我們傳入的函式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import React, { useState,} from 'react';import api from '../services/api';const Login = ({ isLoggedIn, onLogin,}) =&gt; { const [email, setEmail] = useState(''); const [password, setPassword] = useState(''); const handleSubmit = (e) =&gt; { e.preventDefault(); const cb = async () =&gt; { await api.get('sanctum/csrf-cookie'); const response = await api.post('/login', { email, password, }); if (response.status === 204) { onLogin(); } }; cb(); }; return ( &lt;div&gt; &lt;h3&gt;Login&lt;/h3&gt; {isLoggedIn ? ( &lt;div&gt;You are logged in&lt;/div&gt; ) : ( &lt;form onSubmit={handleSubmit}&gt; &lt;input type=&quot;email&quot; name=&quot;email&quot; placeholder=&quot;Email&quot; value={email} onChange={(e) =&gt; setEmail(e.target.value)} required /&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;Password&quot; value={password} onChange={(e) =&gt; setPassword(e.target.value)} required /&gt; &lt;button type=&quot;submit&quot;&gt; Login &lt;/button&gt; &lt;/form&gt; )} &lt;/div&gt; );};export default Login; 現在 App 元件已經知道使用者是否登入的狀態，我們可以將狀態也傳入 Books 元件這樣就可以依據登入與未登入的狀態來執行對應的操作 123456&lt;Route path='/books' render={(props) =&gt; ( &lt;Books {...props} isLoggedIn={isLoggedIn} /&gt; )}/&gt; 如果 isLoggedIn 為 false 的話就不用嘗試讀取 API 載入資料，而是提示使用者應該先登入。 調整 Books 元件 1234567891011121314151617181920212223242526272829303132333435363738import React, { useState, useEffect } from 'react';import api from '../services/api';const Books = ({ isLoggedIn,}) =&gt; { const [books, setBooks] = useState([]); useEffect(() =&gt; { const cb = async () =&gt; { const response = await api.get('/api/books'); if (response.status === 200) { setBooks(response.data); } }; if (isLoggedIn) { cb(); } }, []); return ( &lt;&gt; {isLoggedIn ? ( &lt;ul&gt; {books.map(book =&gt; ( &lt;li key={book.id}&gt;{book.title}&lt;/li&gt; ))} &lt;/ul&gt; ) : ( &lt;div&gt; Please login to read books. &lt;/div&gt; )} &lt;/&gt; );};export default Books; 那登出呢？回到 App 元件調整，如果已經登入的話顯示登出連結，未登入的話則顯示登入連結。如下完整 App 程式碼主要注意 handleLogout 和 authLink 的部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import React, { useState } from 'react';import { BrowserRouter as Router, Switch, Route, NavLink,} from 'react-router-dom';import Books from './components/Books';import Login from './components/Login';import api from './services/api';function App() { const [isLoggedIn, setIsLoggedIn] = useState(false); const handleLogin = () =&gt; { setIsLoggedIn(true); }; const handleLogout = (e) =&gt; { e.preventDefault(); const cb = async () =&gt; { const response = await api.post('/logout'); if (response.status === 204) { setIsLoggedIn(false); } }; cb(); }; const authLink = isLoggedIn ? ( &lt;a href=&quot;&quot; onClick={handleLogout}&gt;Logout&lt;/a&gt; ) : ( &lt;NavLink to=&quot;/login&quot;&gt;Login&lt;/NavLink&gt; ); return ( &lt;Router&gt; &lt;nav&gt; &lt;NavLink to=&quot;/&quot;&gt;Home&lt;/NavLink&gt; {' '} {authLink} {' '} &lt;NavLink to=&quot;/books&quot;&gt;Books&lt;/NavLink&gt; &lt;/nav&gt; &lt;Switch&gt; &lt;Route path='/login' render={(props) =&gt; ( &lt;Login {...props} onLogin={handleLogin} /&gt; )} /&gt; &lt;Route path='/books' render={(props) =&gt; ( &lt;Books {...props} isLoggedIn={isLoggedIn} /&gt; )} /&gt; &lt;/Switch&gt; &lt;/Router&gt; );}export default App; 這個時候直接執行一樣會遇到 CORS 的問題記得在 cors.php 把 logout 加入 paths。 1'paths' =&gt; ['api/*', 'login', 'sanctum/csrf-cookie', 'logout'], 再一次登出，您應該可以看到選單發生變化。 最後我們需要將 isLoggedIn 的狀態存在瀏覽器上，如果不這麼做當使用者重新整理頁面 SPA 的狀態就會消失。我們可以利用 sessionStorage API 來處理這個問題 123456789101112131415161718const [isLoggedIn, setIsLoggedIn] = useState( sessionStorage.getItem('isLoggedIn') === 'true' || false);const handleLogin = () =&gt; { setIsLoggedIn(true); sessionStorage.setItem('isLoggedIn', true);};const handleLogout = (e) =&gt; { e.preventDefault(); const cb = async () =&gt; { const response = await api.post('/logout'); if (response.status === 204) { setIsLoggedIn(false); sessionStorage.setItem('isLoggedIn', false); } }; cb();}; 資源參考 原文","link":"/2020/07/10/sanctum-with-react/"},{"title":"正確使用 Laravel Eloquent","text":"自 Laravel 5.3 之後，看到過許多專案的 Eloquent 關聯與查詢都不是使用相對有效率的用法。這些情況之所以存在是因為有不同的方法可以取得同一個資料集，而且多數看起來非常像。除非您非常了解底層做了什麼，不然判斷哪個方法比較好也不是那麼容易。 例如在 $blog-&gt;posts 和 $blog-&gt;posts() 之間的選擇。 $blog-&gt;posts 會讀取資料庫，讀取跟 $blog 相關的文章，然後建立一個 Post Model 的 Collection。這個操作是很耗費效能的，因爲需要為每個相關的 Model 建立物件實例並賦值。 首先，您應該要先問問自己 - 是否需要 Model 的物件實例？一般來說，您可能只需要幾個欄位的資料，除非您需要欄位自動轉型之類的例如 Carbon 日期型別的資料，不然您應該直接從資料庫取得資料就好。 $blog-&gt;posts() 的話會回傳 Builder 而不會直接執行實際查詢。到此則是該再次問問自己 - 我需要整個資料集合嗎？查詢可以在更具體限縮一點嗎？比較好的方式是盡可能在對資料庫查詢多一點操作，在 PHP 少一點。舉例來說 where 操作在資料庫會比在 Collection 做 where 快。 讓我們繼續看一些範例。 不要使用 Collection 來計算數量$blog-&gt;posts-&gt;count() 會先建立 Post Model 的資料集合，包含所有屬性欄位資料，然後才回傳 Model 的數量。如果 posts 已經載入了，那用這個方式計算當然沒什麼問題，但如果之前沒載入過那就會浪費很多效能。 $blog-&gt;posts()-&gt;count() 則會組合查詢的 SQL 然後從資料庫取得一個數字回來。沒有建立 Model，也沒有屬性。我們就只要數量而已。不是嗎？ 假如是一個 5000 筆資料的查詢，第二個作法大概會比第一個作法快 20 倍左右。不過這會跟您的系統環境有關，注意到查詢的數量越大效率的差異會更加極端。 如果您只需要第一筆資料，不要讀取整個集合這是一個顯而易見的錯誤，但我認為需要再提一次。 $blog-&gt;posts-&gt;first() 跟之前提到的一樣，它會讀取並建立整個集合的物件，然後您只需要第一筆。 如果您只需要第一筆資料那麼您應該使用 $blog-&gt;posts()-&gt;first() 如此在查詢中就會使用 OFFSET 和 LIMIT 而且只會回傳建立一個 Model。 重點是要理解 Model 的方法在調用後回傳了什麼。 如果 Builder 能做到，請不要在 Collection 使用 where$blog-&gt;posts-&gt;where('author', 1) 會先建立所有的 Model，然後遍歷這個集合找到符合條件 author 為 1 的 Model，再建立另一個新的集合，最後回傳資料給您。 我們在資料庫使用的任何索引都將無效，因為這裡是靠 PHP 完成查詢的。 $blog-&gt;posts()-&gt;where('author', 1)-&gt;get() 的話，所有具體的查詢都是在資料庫完成的，如果有索引的話，會加快效率，並且只會回傳符合的資料，就不會建立多餘的物件。 不要在 Collection 使用 pluck，使用 Builder 取代Laravel 專案隨處可見 pluck。我們很多時候只是要某個欄位的值，舉例來說我們需要 Blog 的 post_id 作為 Key 和 name 的資料。 完成上述需求的其中一種方式就是使用 $blog-&gt;posts-&gt;pluck('name', 'id') 但再一次一樣會建立 Collection，也會建立所有列表資料的 Model 物件實例。實際上我們不需要 Model，只需要某個欄位的資料而已，此時我們可以利用 Builder 完成。 另外，$blog-&gt;posts()-&gt;pluck('name', 'id') 看似跟上面幾個點非常像，但行為卻不同。調用 pluck 一樣會傳遞給 Builder ，然後執行 SELECT name, id 的查詢，接著使用資料庫取得的資料建立一陣列。 前面提到，使用 Builder 不會利用 Model 的方法變更物件實例的欄位資料，因爲根本沒有 Model 的物件實例。 此時如果 name 是動態的或者使用 Model 的 getNameAttribute 方法變更，那麼利用 Builder 取得資料的 pluck 將會和 Model 的資料不一樣。請特別注意。 大多數類似的狀況下，使用 Builder 可能產生很大的不同。因此建議您應該多思考一下關於框架背後執行的操作。 參考資料 Using Laravel’s Eloquent Efficiently","link":"/2020/09/08/using-laravel-eloquent-correctly/"},{"title":"如何使用 React Hooks 搭配 Context API 取代 Redux 快速範例入門","text":"本筆記為閱讀 How to Replace Redux with React Hooks and the Context API 後自行實作調整簡化之範例。對於希望直接從範例學習的讀者可自行練習，本範例並非非常完整的教學，不過在能帶給您在使用 Hook 和 Context 上一些啟發： 12# 為簡化專案本範例使用 Parcel$ npm i -g parcel-bundler 建立 Parcel 專案12345$ mkdir demo-hooks-context$ cd demo-hooks-context$ npm init -y$ touch index.html$ touch index.js index.html12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; index.js1console.log('Hello World'); 12$ parcel index.html# Server running at http://localhost:1234 設定 React1234$ npm i react react-dom# 安裝 Babel$ npm i babel-preset-env babel-preset-react --save-dev$ touch .babelrc .babelrc123{ &quot;presets&quot;: [&quot;env&quot;, &quot;react&quot;]} 變更 index.js123456789101112import React from 'react';import ReactDOM from 'react-dom';const App = () =&gt; ( &lt;h1&gt;Hello, React&lt;/h1&gt;);const rootElement = document.getElementById('app');ReactDOM.render( &lt;App /&gt;, rootElement,); 加入 npm scripts1234567{ ... &quot;scripts&quot;: { &quot;start&quot;: &quot;parcel index.html&quot; }, ...} 第一個範例 - 計數器123456# 安裝 constate$ npm i constate# 建立 context 目錄彙整 context 物件# context 物件用於整合 useContext 和 Context 元件$ mkdir context$ touch context/CounterContext.js context/CounterContext.js1234567891011121314151617import { useState } from 'react';import createUseContext from 'constate';// 步驟 1 建立自訂 Hook，包含要使用的 state 和處理函式const useCounter = () =&gt; { const [count, setCount] = useState(0); const increment = () =&gt; setCount(prevCount =&gt; prevCount + 1); const decrement = () =&gt; setCount(prevCount =&gt; prevCount - 1); return { count, increment, decrement, };};// 步驟 2 利用 constate 的函式協助我們建立 Context 物件export const useCounterContext = createUseContext(useCounter); 建立 Counter 和其子元件這裡為了示範共享狀態，所以我們把一個單純可以在同元件的效果拆成多個： 12345$ mkdir views$ touch views/Counter.js$ mkdir components$ touch components/CounterDisplay.js$ touch components/CounterButtons.js views/Counter.js123456789101112131415import React from 'react';import CounterDisplay from '../components/CounterDisplay';import CounterButtons from '../components/CounterButtons';import { useCounterContext } from '../context/CounterContext';// 步驟 3 類似 Redux 的 connect ，將需要取得共享狀態的元件使用 Provider 包起來export default function Counter() { return ( &lt;useCounterContext.Provider&gt; &lt;h3&gt;Counter&lt;/h3&gt; &lt;CounterDisplay /&gt; &lt;CounterButtons /&gt; &lt;/useCounterContext.Provider&gt; );} components/CounterDisplay.js123456789101112import React from 'react';import { useCounterContext } from '../context/CounterContext';export default function CounterDisplay() { // 步驟 4 使用 Context 物件存取共享的狀態 const { count } = useCounterContext(); return ( &lt;div&gt; Counter: {count} &lt;/div&gt; );} components/CounterButtons.js12345678910111213import React from 'react';import { useCounterContext } from '../context/CounterContext';export default function CounterButtons() { // 步驟 4 使用 Context 物件調用處理函式 const { increment, decrement } = useCounterContext(); return ( &lt;div&gt; &lt;button onClick={increment}&gt;Add&lt;/button&gt; &lt;button onClick={decrement}&gt;Minus&lt;/button&gt; &lt;/div&gt; );} 調整 index.js 使用 Counter 元件123456789101112131415import React from 'react';import ReactDOM from 'react-dom';import Counter from './views/Counter';const App = () =&gt; ( &lt;div&gt; &lt;Counter /&gt; &lt;/div&gt;);const rootElement = document.getElementById('app');ReactDOM.render( &lt;App /&gt;, rootElement,); 12# 瀏覽結果$ npm start 第二個範例 - 聯絡人清單功能安裝相依套件1$ npm i lodash 建立相關檔案利用 useReducer 處理複雜的資料結構。 後續可以斟酌再和 redux-starter-kit 的 createSlice 一起使用。 12345678# Context 物件$ touch context/ContactContext.js# 主元件$ touch views/Contacts.js# 子元件 - 聯絡人列表表格$ touch components/ContactTable.js# 子元件 - 新增聯絡人表單$ touch components/ContactForm.js context/ContactContext.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import { useReducer } from 'react';import _ from 'lodash';import createUseContext from 'constate';// 宣告初始化狀態const initialState = { contacts: [ { id: '001', name: 'Andy', email: 'andy@uxtesting.io' }, { id: '002', name: 'Calvert', email: 'calvert@uxtesting.io' }, { id: '003', name: 'Aaron', email: 'aaron@uxtesting.io' }, ],};// 宣告 reducerconst reducer = (state, action) =&gt; { switch (action.type) { case 'ADD': return { contacts: [ ...state.contacts, action.payload, ], }; case 'DEL': return { contacts: state.contacts.filter(contact =&gt; contact.id !== action.payload), }; default: throw new Error(); }};// 自訂 Hook 包含 state, dispatch, 處理函式等const useContacts = () =&gt; { const [state, dispatch] = useReducer(reducer, initialState); const { contacts, } = state; const addContact = (name, email) =&gt; { dispatch({ type: 'ADD', payload: { id: _.uniqueId(10), name, email, }, }); } const delContact = id =&gt; { dispatch({ type: 'DEL', payload: id, }); } return { contacts, addContact, delContact, };};export const useContactsContext = createUseContext(useContacts); views/Contacts.js1234567891011121314import React from 'react';import ContactForm from '../components/ContactForm';import ContactTable from '../components/ContactTable';import { useContactsContext } from '../context/ContactContext';export default function Contacts() { return ( &lt;useContactsContext.Provider&gt; &lt;h1&gt;Contacts&lt;/h1&gt; &lt;ContactForm /&gt; &lt;ContactTable /&gt; &lt;/useContactsContext.Provider&gt; );} components/ContactTable.js12345678910111213141516171819202122232425262728293031323334353637import React from 'react';import { useContactsContext } from '../context/ContactContext';export default function ContactTable() { const { contacts, delContact } = useContactsContext(); return ( &lt;div&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Id&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Email&lt;/th&gt; &lt;th&gt;Action&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; {contacts.map(contact =&gt; ( &lt;tr key={contact.id}&gt; &lt;td&gt;{contact.id}&lt;/td&gt; &lt;td&gt;{contact.name}&lt;/td&gt; &lt;td&gt;{contact.email}&lt;/td&gt; &lt;td&gt; &lt;button onClick={() =&gt; { delContact(contact.id); }}&gt; X &lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; ))} &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; );} components/ContactForm.js12345678910111213141516171819202122232425262728293031323334353637383940414243import React, { useState } from 'react';import { useContactsContext } from '../context/ContactContext';const initialFormState = { name: undefined, email: undefined,};export default function ContactForm() { const [inputs, setInputs] = useState(initialFormState); const { addContact } = useContactsContext(); const onChange = (e) =&gt; { const { name, value, } = e.target; setInputs({ ...inputs, [name]: value, }); }; const onSubmit = (e) =&gt; { e.preventDefault(); const { name, email, } = inputs; addContact(name, email); // Reset setInputs(initialFormState); }; return ( &lt;div&gt; &lt;form onSubmit={onSubmit}&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; onChange={onChange} placeholder=&quot;Name&quot; value={inputs.name || ''} /&gt; &lt;input type=&quot;text&quot; name=&quot;email&quot; onChange={onChange} placeholder=&quot;Email&quot; value={inputs.email || ''} /&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt; &lt;/form&gt; &lt;/div&gt; );} 調整 index.js1234567891011121314151617import React from 'react';import ReactDOM from 'react-dom';// import Counter from './views/Counter';import Contacts from './views/Contacts';const App = () =&gt; ( &lt;div&gt; {/* &lt;Counter /&gt; */} &lt;Contacts /&gt; &lt;/div&gt;);const rootElement = document.getElementById('app');ReactDOM.render( &lt;App /&gt;, rootElement,); 小結希望這兩個小範例能夠讓您建立一些使用上的觀念。使用這種方式可以省去匯入一堆 Redux 相關的函式也可以省去 props 的傳遞。核心觀念就是利用 constate 的 createUseContext 建立一個包含 Provider 和 Hook 集合的 Context 物件。constate 本身原始碼也不多，如果您有興趣理解更細的話可以自行閱讀。 目前這樣的作法有個缺點就是不能使用 Redux DevTool。所以採用前請三思。 資源 Set Up A React Project With Parcel How to Replace Redux with React Hooks and the Context API","link":"/2019/08/11/use-react-hooks-and-context-replace-redux/"},{"title":"Laravel 8 - 快速整合 Jetstream + Socialite","text":"本文為 Laravel 7 — Socialite in Action ( Social Media Login Integration with Facebook, Twitter, LinkedIn, Google) 之更新簡化版本。省略大部分說明只提供步驟紀錄。詳細說明請參考原文。 Create Project1$ laravel new demo 建立專案之後，請建立資料庫和更新 .env。下面以 Postgre SQL 為例 1$ createdb demo .evn 的部分如下： 123456DB_CONNECTION=pgsqlDB_HOST=127.0.0.1DB_PORT=5432DB_DATABASE=demoDB_USERNAME=rootDB_PASSWORD= 安裝 Jetstream12345$ composer require laravel/jetstream$ php artisan jetstream:install inertia --teams$ npm install &amp;&amp; npm run dev# (opt) For customize template you should publish these views$ php artisan vendor:publish --tag=jetstream-views 安裝 Socialite123$ composer require laravel/socialite# (opt) If you meet memory limit error, place `COMPOSER_MEMORY_LIMIT=-1` before command# $ COMPOSER_MEMORY_LIMIT=-1 composer require laravel/socialite 修改 database schema詳細原因請參考 Laravel 7 — Socialite in Action ( Social Media Login Integration with Facebook, Twitter, LinkedIn, Google) 12$ composer require doctrine/dbal$ php artisan make:migration edit_columns_in_users_table 在新增的 migration 檔案中調整如下: 123456789101112131415161718192021public function up(){ Schema::table('users', function (Blueprint $table) { $table-&gt;dropUnique(['email']); $table-&gt;string('password')-&gt;nullable()-&gt;change(); $table-&gt;json('social')-&gt;nullable(); $table-&gt;softDeletes(); $table-&gt;unique(['email', 'deleted_at']); });}public function down(){ Schema::table('users', function (Blueprint $table) { $table-&gt;dropUnique(['email', 'deleted_at']); $table-&gt;dropSoftDeletes(); $table-&gt;dropColumn(['social']); $table-&gt;string('password')-&gt;change(); $table-&gt;string('email')-&gt;unique()-&gt;change(); });} 然後執行 1$ php artisan migrate Model1234567891011121314151617181920212223242526use Illuminate\\Database\\Eloquent\\SoftDeletes;// ...// If you want to support verify you can add implementsclass User extends Authenticatable{ use Notifiable; use SoftDeletes; // ... /** * The attributes that should be cast to native types. * * @var array */ protected $casts = [ 'email_verified_at' =&gt; 'datetime', 'social' =&gt; 'array', ]; // (opt) Most of case you should keep email in lowercase public function setEmailAttribute($value) { $this-&gt;attributes['email'] = strtolower($value); }} Fortify有兩個 Fortify 相關的檔案須修正，原因是我們現在支援 SoftDeletes，注意 email 的規則 unique 須置換為 unique:users,email,NULL,id,deleted_at,NULL 12345678910111213141516171819202122232425262728// app/Actions/Fortify/CreateNewUser.php&lt;?php// ...class CreateNewUser implements CreatesNewUsers{ use PasswordValidationRules; // ... public function create(array $input) { Validator::make($input, [ // ... 'email' =&gt; ['required', 'string', 'email', 'max:255', 'unique:users,email,NULL,id,deleted_at,NULL'], // ... ])-&gt;validate(); return DB::transaction(function () use ($input) { return tap(User::create([ 'name' =&gt; $input['name'], 'email' =&gt; $input['email'], 'password' =&gt; Hash::make($input['password']), ]), function (User $user) { $this-&gt;createTeam($user); }); }); } // ...} 12345678910111213141516171819202122// app/Actions/Fortify/UpdateUserProfileInformaiton.php&lt;?php// ...class UpdateUserProfileInformation implements UpdatesUserProfileInformation{ // ... public function update($user, array $input) { Validator::make($input, [ // ... 'email' =&gt; ['required', 'email', 'max:255', 'unique:users,email,NULL,id,deleted_at,NULL'], // ... ])-&gt;validateWithBag('updateProfileInformation'); // ... } // ...} 取得平台憑證 Client ID 和 Secret將您需要的資訊補在 .env，下面只是局部平台的範例 123456789101112FACEBOOK_CLIENT_ID=FACEBOOK_CLIENT_SECRET=FACEBOOK_CALLBACK_URL=/login/facebook/callbackGOOGLE_CLIENT_ID=GOOGLE_CLIENT_SECRET=GOOGLE_CALLBACK_URL=/login/google/callbackLINKEDIN_CLIENT_ID=LINKEDIN_CLIENT_SECRET=LINKEDIN_CALLBACK_URL=/login/linkedin/callbackTWITTER_CLIENT_ID=TWITTER_CLIENT_SECRET=TWITTER_CALLBACK_URL=/login/twitter/callback Services 設定在 config/services.php 加入設定，您可能注意到 scopes 的部分，但在官方文件沒有關於這段。的確這是額外的設定，我覺得將它們放在一起比較合適您也可以放到 .env。 123456789101112131415161718192021222324252627282930313233'ses' =&gt; [ 'key' =&gt; env('AWS_ACCESS_KEY_ID'), 'secret' =&gt; env('AWS_SECRET_ACCESS_KEY'), 'region' =&gt; env('AWS_DEFAULT_REGION', 'us-east-1'),],'facebook' =&gt; [ 'client_id' =&gt; env('FACEBOOK_CLIENT_ID'), 'client_secret' =&gt; env('FACEBOOK_CLIENT_SECRET'), 'redirect' =&gt; env('FACEBOOK_CALLBACK_URL'), 'scopes' =&gt; ['email', 'public_profile'],],'google' =&gt; [ 'client_id' =&gt; env('GOOGLE_CLIENT_ID'), 'client_secret' =&gt; env('GOOGLE_CLIENT_SECRET'), 'redirect' =&gt; env('GOOGLE_CALLBACK_URL'), 'scopes' =&gt; [ 'https://www.googleapis.com/auth/userinfo.email', 'https://www.googleapis.com/auth/userinfo.profile', 'openid', ],],'linkedin' =&gt; [ 'client_id' =&gt; env('LINKEDIN_CLIENT_ID'), 'client_secret' =&gt; env('LINKEDIN_CLIENT_SECRET'), 'redirect' =&gt; env('LINKEDIN_CALLBACK_URL'), 'scopes' =&gt; ['r_emailaddress', 'r_liteprofile'],],'twitter' =&gt; [ 'client_id' =&gt; env('TWITTER_CLIENT_ID'), 'client_secret' =&gt; env('TWITTER_CLIENT_SECRET'), 'redirect' =&gt; env('TWITTER_CALLBACK_URL'), 'scopes' =&gt; [],], Auth Controller這是本文最重要的段落，也可能是您一直在尋找的部分。我們將建立一個 Controller 來處理 OAuth 回呼的部分 1$ php artisan make:controller Auth/LoginController 檔案建立之後，下面是完整的 app/Http/Controllers/Auth/LoginController.php 程式碼，雖然有點長，但方便您直接複製貼上並完整理解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138&lt;?phpnamespace App\\Http\\Controllers\\Auth;use App\\Http\\Controllers\\Controller;use App\\Providers\\RouteServiceProvider;use Illuminate\\Support\\Facades\\Auth;use Illuminate\\Http\\Request;use Socialite;use App\\Models\\User;use App\\Models\\Team;class LoginController extends Controller{ protected $redirectTo = RouteServiceProvider::HOME; /** * Redirect to authentication page based on $provider. * * @param string $provider * @return \\Illuminate\\Http\\Response */ public function redirectToProvider(string $provider) { try { $scopes = config(&quot;services.$provider.scopes&quot;) ?? []; if (count($scopes) === 0) { return Socialite::driver($provider)-&gt;redirect(); } else { return Socialite::driver($provider)-&gt;scopes($scopes)-&gt;redirect(); } } catch (\\Exception $e) { abort(404); } } /** * Obtain the user information from $provider * * @param string $provider * @return \\Illuminate\\Http\\Response */ public function handleProviderCallback(string $provider) { try { $data = Socialite::driver($provider)-&gt;user(); return $this-&gt;handleSocialUser($provider, $data); } catch (\\Exception $e) { return redirect('login')-&gt;withErrors(['authentication_deny' =&gt; 'Login with '.ucfirst($provider).' failed. Please try again.']); } } /** * Handles the user's information and creates/updates * the record accordingly. * * @param string $provider * @param object $data * @return \\Illuminate\\Http\\Response */ public function handleSocialUser(string $provider, object $data) { $user = User::where([ &quot;social-&gt;{$provider}-&gt;id&quot; =&gt; $data-&gt;id, ])-&gt;first(); if (!$user) { $user = User::where([ 'email' =&gt; $data-&gt;email, ])-&gt;first(); } if (!$user) { return $this-&gt;createUserWithSocialData($provider, $data); } $social = $user-&gt;social; $social[$provider] = [ 'id' =&gt; $data-&gt;id, 'token' =&gt; $data-&gt;token ]; $user-&gt;social = $social; $user-&gt;save(); return $this-&gt;socialLogin($user); } /** * Create user * * @param string $provider * @param object $data * @return \\Illuminate\\Http\\Response */ public function createUserWithSocialData(string $provider, object $data) { try { $user = new User; $user-&gt;email = $data-&gt;email; $user-&gt;name = $data-&gt;name; $user-&gt;social = [ $provider =&gt; [ 'id' =&gt; $data-&gt;id, 'token' =&gt; $data-&gt;token, ], ]; // markEmailAsVerified() contains save() behavior $user-&gt;markEmailAsVerified(); $team = Team::forceCreate([ 'user_id' =&gt; $user-&gt;id, 'name' =&gt; $user-&gt;name.&quot;'s Team&quot;, 'personal_team' =&gt; true, ]); $user-&gt;current_team_id = $team-&gt;id; $user-&gt;save(); return $this-&gt;socialLogin($user); } catch (Exception $e) { return redirect('login')-&gt;withErrors(['authentication_deny' =&gt; 'Login with '.ucfirst($provider).' failed. Please try again.']); } } /** * Log the user in * * @param User $user * @return \\Illuminate\\Http\\Response */ public function socialLogin(User $user) { auth()-&gt;loginUsingId($user-&gt;id); return redirect($this-&gt;redirectTo); }} Routes在 routes/web.php，注意 Laravel 8 的路由設定語法有些改變。 12345678910111213141516&lt;?phpuse Illuminate\\Support\\Facades\\Route;use App\\Http\\Controllers\\Auth\\LoginController;// ...Route::middleware(['auth:sanctum', 'verified'])-&gt;get('/dashboard', function () { return Inertia\\Inertia::render('Dashboard');})-&gt;name('dashboard');Route::get('/login/{provider}', [LoginController::class, 'redirectToProvider']) -&gt;name('social.login');Route::get('/login/{provider}/callback', [LoginController::class, 'handleProviderCallback']) -&gt;name('social.callback'); Views最後在 resources/views/auth/ 補上登入的按鈕則完成。使用 php artisan serve 測試看看吧。 12345678910111213141516171819202122232425262728293031@php $providers = [ 'google' =&gt; [ 'bgColor' =&gt; '#ec462f', 'icon' =&gt; 'fab fa-google', ], 'facebook' =&gt; [ 'bgColor' =&gt; '#1877f2', 'icon' =&gt; 'fab fa-facebook-f', ], 'linkedin' =&gt; [ 'bgColor' =&gt; '#2969b1', 'icon' =&gt; 'fab fa-linkedin-in', ], 'twitter' =&gt; [ 'bgColor' =&gt; '#41aaf1', 'icon' =&gt; 'fab fa-twitter', // ], ];@endphp@foreach($providers as $provider =&gt; $params) &lt;a class=&quot;block py-3 px-4 mb-5/2 rounded-sm text-white text-center font-bold hover:no-underline hover:opacity-75&quot; href=&quot;{{ route('social.login', ['provider' =&gt; $provider]) }}&quot; style=&quot;background-color: {{ $params['bgColor'] }}; min-height: 48px;&quot; &gt; &lt;i class=&quot;tw-float-left tw-inline-block tw-h-5 {{ $params['icon'] }}&quot;&gt;&lt;/i&gt; Login with {{ ucwords($provider) }} &lt;/a&gt;@endforeach","link":"/2020/10/23/laravel-8-integrate-jetstream-socialite/"},{"title":"React DnD 入門","text":"[toc] React DnD 是 React 一系列的單元功能，用來協助您建置介面上複雜的拖拉功能同時維持元件解耦。特別適合像是 Trello 類型的應用程式利用拖拉來轉移資料，並依據拖拉事件變更的狀態改變元件的外觀。 安裝1$ npm i react-dnd react-dnd-html5-backend 第二個套件是支援 React DnD 底層使用 HTML 5 拖拉 API。您可以選擇使用第三方的套件例如 touch backend 範例概覽12345678910111213141516171819202122// 讓 &lt;Card text=&quot;Write the docs&quot; /&gt; 可以拖拉import React from 'react';import { useDrag } from 'react-dnd';import { ItemTypes } from './Constants';// 您的元件export default function Card({ isDragging, text }) { const [{ opacity }, dragRef] = useDrag(() =&gt; ({ item: { type: ItemTypes.CARD, text }, collect: (monitor) =&gt; ({ opacity: monitor.isDragging() ? 0.5 : 1, }), }), []); return ( &lt;div ref={dragRef} style={{ opacity }}&gt; {text} &lt;/div&gt; );} 功能整合您的元件比起現成的元件，React DnD 封裝您的元件並注入相關 props 。如果您曾使用 React Router 或 Flummox 您已經了解這種模式。 單向資料流React DnD 完全支援 React 陳述式且不直接改變 DOM 的渲染流程。透過單向資料在 Redux 以及其他架構都非常好擴充。實際上它就是用 Redux 建置的。 消除平台特殊行為HTML 5 拖拉 API 處於一個尷尬的狀況，每個瀏覽器行為不一致。React DnD 底層為您處理了這個問題。您可以專心在開發您的應用而不是處理瀏覽器造成的問題。 可擴充性和測試性React DnD 底層使用 HTML 5 拖拉 API 但也允許您自訂“後端”（後續我們使用後端代表處理拖拉的底層機制）。您可以客製化基於觸控事件的 DnD 後端，甚至是其他事件。 舉例來說，內建模擬的後端，可以在 Node 環境下測試元件的拖拉操作。 支援觸控可以使用 touch 後端 支援觸控拖拉。 非特定目標React DnD 提供一組原始語法，但不包含任何具備完整功能的元件。比 jQuery UI 和 Interact.js 還低階，專注在正確的執行拖拉功能，視覺方面則交由您自行處理。例如，React DnD 沒有提供排序元件，而是讓您自行使用這些功能組合。 概覽React DnD 不像市面上其他的拖拉功能的函式庫，而且在還沒用過之前，乍看之下使用方式可能沒那麼方便。不過一旦您了解其設計概念，就會覺得這些設計非常合理。建議在開始閱讀其他文件之前線閱讀這些觀念。 其中一些概念類似於 Flux 和 Redux 架構。不是巧合，因為 React DnD 內部就是使用 Redux。 項目和類型（Item &amp; Type）就像 Flux 或 Redux 一樣，React DnD 使用資料，而不是視圖作為唯一來源。當您拖動螢幕上某個物件，我們不說元件或 DOM 節點被拖動，而是特定類型（Type）的項目（Item）被拖動了。 那什麼是項目 Item？一個項目是一單純的 JavaScript 物件，描述被拖動的東西。舉例來說看板類型的應用程式，當我們拖動一張卡片的時候項目 item 大概就是 {cardId: 42}。在西洋棋裡，當你拿起一個棋子 item 可能是 { fromCell: 'C5', piece: 'queen' }。使用物件的形式描述被拖移的資料，讓我們可以保持元件解耦。 Type 類型又是什麼？類型是一個字串或 Symbol ，是一個唯一識別。例如在一個看板應用程式中，您可能有一個 card 類型代表可以被拖動的卡片們和一個 list 類型可拖動的列表。在西洋棋的例子可能就只有一個 piece 類型。 類型的功用是，隨著應用程式持續成長，您可能會有越來越多可以拖拉的東西，但您不希望某些可拖入的區域接受非預期的項目。類型讓我們可以限制拖移來源和拖入目標。您可能有一個類型的列舉型別常數，就像 Redux 的 action types 一樣。 Monitor拖放本質上是有狀態的。不管是不是正處於拖移中，或者是否存在目前拖移的項目、類型，這些狀態資料必須要存在某個地方。 React DnD 使用容器的方式將內部狀態通過 monitor 傳給元件。monitor 讓我們可以更新元件的 props ，讓元件呈現拖拉狀態的改變。 每個元件都需要追蹤拖放的狀態，您可以定義一個狀態收集函式並使用 monitor 取得相關資料。然後 React DnD 會即時調用狀態收集函式並將回傳的值合併到元件的 props 中。 假設我們要凸顯被拖拉的西洋棋格。Cell 元件使用的狀態收集函式可能長的如下： 123456function collect(monitor) { return { highlighted: monitor.canDrop(), hovered: monitor.isOver(), };} 該函式會指示 React DnD 傳入 highlighted 和 hovered 更新的資料到 Cell 的 props。 連接器如果後端處理的是 DOM 事件，但元件是使用 React 來定義描述 DOM 的，那麼後端該如何得知 DOM 節點的監聽。答案是連接器。連接器讓我們預先在 render 函式定義分配角色（拖移來源、拖拉預覽、拖入區域）到 DOM 節點。 實際上，連接器會被當作第一個參數傳入我們上面說的狀態收集函式。讓我們來看看我們可以如何指定拖入區域： 1234567function collect (connect, monitor) { return { highlighted: monitor.canDrop(), hovered: monitor.isOver(), connectDropTarget: connect.dropTarget(), };} 在這個元件的 render 方法，我們可以存取從 monitor 取得的資料和取得 connector 的函式 1234567891011121314151617render() { const { highlighted, hovered, connectDropTarget, } = this.props; return connectDropTarget( &lt;div className={classSet({ 'Cell': true, 'Cell--highlighted': highlighted, 'Cell--hovered': hovered, })}&gt; {this.props.children} &lt;/div&gt; );} 執行 connectDropTarget 會通知 React DnD 該元件的根節點是有效的拖入目標，然後它的 hover 和 drop 事件應該被後端處理。內部的運作機制是利用您給的 callback ref 附加到 React 元素來完成。connector 回傳的函式會被存起來，因此 shouldComponentUpdate 不會破壞它。 拖移來源和拖入目標（Drag Sources &amp; Drop Targets）目前為止我們已經涵蓋了後端；其用來處理 DOM 相關，使用項目和類型來代表資料，狀態收集函式包含 monitor 和 connect 讓我們可以設定一些屬性，React DnD 會幫我們注入元件。 但我們要怎麼設定元件才能取得注入的屬性呢？我們該如何對應拖拉事件執行 Side Effect 的操作？是時候來看 React DnD 主要的抽象單元；拖移來源和拖入目標。它們將類型、項目、Side Effect 操作，狀態收集函式和您的元件結合在一起。 每當您希望某個元件或元件的部分支援拖拉時。您需要將元件包進拖移來源。每個拖移來源會註冊為特定類型，並且從元件的 props 實作產生項目的方法。還可以選擇性的指定一些方法來處理拖拉的事件。這個拖移來源宣告也可以為元件設定狀態收集函式。 拖入目標跟拖移來源非常類似。唯一的差別是一個拖入目標可以註冊多個類型，然後它可以處理 hover 或 drop 事件。 後端React DnD 使用 HTML 拖拉 API。很合理使用它作為預設，因為它內建可以為拖移的 DOM 節點截圖作為拖移時預覽的效果。您不用在滑鼠移動時額外繪製圖像。也是唯一提供處理拖入檔案的 API 。 不幸的是，HTML5 的拖拉 API 有些缺陷。它不支援觸控螢幕，並且 IE 瀏覽器的支援度比不上其他瀏覽器。 這也是為什麼 React DnD 使用外掛套件的方式實作 HTML5 拖拉 API 。您不一定要使用，您完全可以自訂自己的實作，基於觸控事件 ，滑鼠事件或其他。這些外掛的實作在 React DnD 中稱為後端（Backend）。 函式庫目前搭載 HTML 後端，它應該可以滿足大部分網頁應用程式。觸控後端 可以支援行動裝置上的網頁程式。 後端會執行類似 React 的合成事件；抽離瀏覽器的差異並處理原生 DOM 事件。儘管有類似的地方，React DnD 後端並不相依於 React 或其合成事件系統。底層，所有的後段會轉換 DOM 事件到內部的 Redux actions 然後 React DnD 接著後續的處理。 Hooks 和高階元件現在您已經了解 React DnD 各個方面 項目物件和類型 Flux 架構的 DnD 狀態 monitor 觀察 DnD 狀態 狀態收集函式可以將 monitor 的資訊合併進 props 連接器把 DnD 狀態掛到 DOM 節點 現在該來討論如何將這些結合到元件；您有兩個選擇 Hook 形式的 API 和傳統裝飾器模式的 API （高階元件） Hooks目前主流的 React 應用程式會採用 Hook 取代高階元件。Hook 是 React 16.8 的功能之一，主要是支援函式元件可以使用 state 。它也非常適合管理具備狀態的元件和外部狀態進行互動（例如拖移）。 如果您還不熟悉 React Hooks 您可以參考官方文件。 React DnD 提供 Hook 連接您的元件並使用 monitor 提供狀態，渲染。 練習教學在本篇教學我們將使用 React 和 React DnD 建置一個西洋棋遊戲。哈！開玩笑的，完整的西洋棋遊戲已經超出本教學太多。我們只會建置一個簡單的西洋棋盤搭配一個可以被拖移的騎士。 如果你妳已經熟悉 React 您可以直接跳到後面加入拖拉互動一段 我們將使用這個範例展示 react-dnd 資料驅動的核心哲學。您會學到如何建立拖移來源和拖入目標。 設定本節教學使用函式元件和當前主流語法。由於這些語法需要為目標環境使用例如 Webpack，Rollup 或其他編譯工具才能使用，推薦直接使用 create-react-app 。 1$ npx create-react-app demo 建置遊戲設計元件首先，我們從 React 元件開始，這個階段我們不加入拖拉的概念。對這個只有一個騎士的西洋棋遊戲，思考一下針對我們的需求元件大概有： Kngith：唯一的騎士棋子 Square：棋盤上的格子 Board：64 格的棋盤 接著思考屬性部分 Knight 大概不需要任何屬性。它的確需要一個位置，但不需要在 Knight 保存位置的資料，我們可以讓它作為 Square 的子元素就好。 乍看之下 Square 好像需要位置資料，不過再想想，格子好像只需要知道渲染的顏色就好。我們先假設 Square 預設是白色，加入 black 布林屬性。當然 Square 可以加入子元素，就是擺在上面的棋子。 Board 稍微麻煩一點。我們知道棋盤的格子是固定的，因此直接在 Board 寫死格子，而不需要動態傳入 props.children 。但接著棋格還需要包住 Knight，這表示 Board 需要知道 Knight 的位置。Board 需要的資料包含棋格顏色，全部棋子位置的資料，但這個範例來說只需要一個 knightPosition 騎士的位置。我們可以使用二維陣列 [0, 0] 表示 A8 。為什麼不是 A1？為了符合瀏覽器的座標系統。其他方式會大量增加複雜度。 那目前的狀態要存在哪？直接放在 Board 元件中不太理想。元件盡可能減少自有的狀態會比較好，因為 Board 已經包含一些配置棋格的邏輯，如果把全部的邏輯管理放在這邊會變得很冗余。 這個階段我們還不需要處理這個問題，我們的元件只需要假設某個地方會有資料透過 props 傳入，我們只須確保渲染的結果是正確的即可。 建置元件個人傾向由下而上建置元件，由於大部分面對的都不是全新的專案。如果先處理 Board 那至少就得等到 Square 做好才能看到結果。反過來說如果先建置 Square，我們可以立刻看到 Square 的結果不用管 Board 。我覺得可以立馬看到成果挺重要的。 但實際上，我們是從 Knight 開始。 12345678910// src/Knight.jsimport React from 'react';const Knight = () =&gt; { return ( &lt;span&gt;♘&lt;/span&gt; );};export default Knight; 沒錯，我們使用 Unicode 的 ♘ 。好處是可以使用 color 屬性方便調整顏色，但這個範例我們只有一隻騎士所以不需要考慮不同陣營顏色的問題。 1234567891011// src/index.jsimport React from 'react';import ReactDOM from 'react-dom';import './styles.css';import './components/Knight';ReactDOM.render( &lt;Knight /&gt;, document.getElementById('root')); 執行 npm start 可查看結果。開發元件的時候我都會確認結果，如果是在大型專案則會使用 cosmos 。如此我們就不用等到一堆元件都寫完才來排除錯誤。 接著，我們來建置 Square 123456789101112131415// src/Square.jsimport React from 'react';const Square = ({ black }) =&gt; { const fill = black ? 'black' : 'white'; return ( &lt;div style={{ backgroundColor: fill, }} /&gt; )};export default Square; 然後在 index.js 改變進入點讓 Square 包住 Kngith 1234567891011121314// src/index.jsimport React from 'react';import ReactDOM from 'react-dom';import Knight from './Knight';import Square from './Square';ReactDOM.render( &lt;Square black&gt; &lt;Knight /&gt; &lt;/Square&gt;, document.getElementById('root')); 什麼都沒出現！不好意思上面犯了一些錯誤： Square 沒有給任何寬高，整個縮起來。除此之外我們希望格子可以自動填滿容器因此設定 100% Square 忘記加 children 因此就算 Knight 傳入了也不會顯示。 就算我們修正了上面列的還是看不到 Knight 因為 Square 是黑色的，然後預設文字也是黑色的。因此我們要為 Knight 設定文字顏色的屬性。 123456789101112131415161718192021// src/Square.jsimport React from 'react';const Square = ({ black, children }) =&gt; { const fill = black ? 'black' : 'white'; const stroke = black ? 'white' : 'black'; const style = { backgroundColor: fill, color: stroke, width: '100%', height: '100%', }; return ( &lt;div style={style}&gt; {children} &lt;/div&gt; )};export default Square; 如果遇到高無法撐開，可以設定 html, body 的樣式，或給一個外層容器。官方範例的外層有包一個 500x500px 的容器。 終於我們可以來建立 Board 元件，我們先從超級簡化的版本開始： 12345678910111213141516// src/Board.jsimport React from 'react';import Square from './Square';import Knight from './Knight';const Board = () =&gt; { return ( &lt;div&gt; &lt;Square black&gt; &lt;Knight /&gt; &lt;/Square&gt; &lt;/div&gt; );};export default Board; 這邊的目的只是讓 Board 可以先被渲染出來方便我們後續調整： 123456789// src/index.jsimport React from 'react';import ReactDOM from 'react-dom';import Board from './Board';ReactDOM.render( &lt;Board knightPosition={[0, 0]} /&gt;, document.getElementById('root')); 到此，我們依舊看到一樣的結果。是時候加入整個棋盤了。但我們該從何開始？我們該怎麼組織 render 的內容？使用 for 或 map 嗎？ 實際上，我們不會立馬討論這個問題。我們已經知道如何輸出一個棋格不管有沒有包含棋子。我們也知道騎士的位置 knightPosition ，這代表我們可以著手 renderSquare 方法，現在還不用擔心整個棋盤的問題。 第一版的 renderSquare 大概如下： 1234567891011const renderSquare = (x, y, [knightX, knightY]) =&gt; { const black = (x + y) % 2 === 1; const isKnightHere = knightX === x &amp;&amp; knightY === y; const piece = isKnightHere ? &lt;Knight /&gt; : null; return ( &lt;Square black={black}&gt; {piece} &lt;/Square&gt; )}; 我們可以調整 Board 123456789101112131415161718192021222324252627import React from 'react';import Square from './Square';import Knight from './Knight';const renderSquare = (x, y, [knightX, knightY]) =&gt; { const black = (x + y) % 2 === 1; const isKnightHere = knightX === x &amp;&amp; knightY === y; const piece = isKnightHere ? &lt;Knight /&gt; : null; return ( &lt;Square black={black}&gt; {piece} &lt;/Square&gt; );};const Board = ({ knightPosition }) =&gt; { return ( &lt;div style={{ width: '100%', height: '100%' }}&gt; {renderSquare(0, 0, knightPosition)} {renderSquare(1, 0, knightPosition)} {renderSquare(2, 0, knightPosition)} &lt;/div&gt; );};export default Board; 棋格直接往下排是因為我們沒有設定佈局。這裡我們使用 Flexbox，我們在 renderSquare 加入 div 和樣式。一般來說元件封裝需要考慮彈性，而不是把佈局加入元件中。因此這裡我們補在 renderSquare 多加一個 div。 調整後的 Board 和 index.js 如下 12345678910111213141516171819202122232425262728293031323334353637// src/Board.jsimport React from 'react';import Square from './Square';import Knight from './Knight';const renderSquare = (i, [knightX, knightY]) =&gt; { const x = i % 8; const y = Math.floor(i / 8); const isKnightHere = x === knightX &amp;&amp; y === knightY; const black = (x + y) % 2 === 1; const piece = isKnightHere ? &lt;Knight /&gt; : null; return ( &lt;div key={i} style={{ width: '12.5%', height: '12.5%' }}&gt; &lt;Square black={black}&gt;{piece}&lt;/Square&gt; &lt;/div&gt; );};const Board = ({ knightPosition }) =&gt; { const squares = Array.from({ length: 64 }).map((_, i) =&gt; renderSquare(i, knightPosition)); return ( &lt;div style={{ width: '100%', height: '100%', display: 'flex', flexWrap: 'wrap', }} &gt; {squares} &lt;/div&gt; );};export default Board; 123456789101112// src/index.jsimport React from 'react';import ReactDOM from 'react-dom';import Board from './Board';ReactDOM.render( &lt;div style={{ width: 500, height: 500 }}&gt; &lt;Board knightPosition={[0, 0]} /&gt; &lt;/div&gt;, document.getElementById('root')); 現在您可以看到完整的棋盤了 LOL。現在我們可以透過調整 knightPosition 來改變騎士的位置。 加入狀態我們希望 Knight 可以被拖移。為了實現這個目標 knightPosition 需要某種儲存形式保留狀態並且要能被修改。 因為管理狀態會需要你思考一些問題，我們不會在同時一併實作拖拉功能。因此我們從簡單的部分開始；透過點擊特定 Square 然後移動 Knight ，不過騎士還是要遵循西洋棋的規則，不可以亂走。實作這個邏輯已經能夠讓我們充分理解狀態管理，後續我們再將點擊的操作換成拖拉。 React 對於狀態管理並沒有限制，您可以使用 Flux，Redux，Rx 等並且避免大量資料模型分散注意力 不過在這個範例為了單純期間我們不希望加入 Redux，但可以遵循一些簡單的設計模式，當然它無法像 Redux 一樣具備良好的可擴展性，不過在這個範例沒什麼問題。現在我們還沒決定狀態管理的 API，就先假設狀態都放在 Game 模組裡，隨後我們需要在裡面定義一些修改狀態資料的程式碼。 基於上面的假設，我們可以在 index.js 預寫一些還不存在，但我們希望的用法。我們可以使用這種方式來釐清我們所需的 API。 1234567891011121314151617// src/index.jsimport React from 'react';import ReactDOM from 'react-dom';import Board from './Board';import { observe } from './Game';const root = document.getElementById('root');observe((knightPosition) =&gt; ReactDOM.render( &lt;div style={{ width: 500, height: 500 }}&gt; &lt;Board knightPosition={knightPosition} /&gt; &lt;/div&gt;, root )); observe 函式極簡化了模擬訂閱狀態的設計模式。我們當然可以使用 EventEmitter 模擬訂閱機制，不過這裡只需要一個變更的事件不需要將事件變得複雜。 為了驗證這個訂閱 API 可行。我們來實作一隨機移動騎士位置 12345// src/Game.jsexport const observe = (cb) =&gt; { const getRandPosition = () =&gt; Math.floor(Math.random() * 8); setInterval(() =&gt; cb([getRandPosition(), getRandPosition()]), 500);}; 顯然這個東西沒什麼用。我們需要的是和使用者互動，我們需要一個從元件中修改狀態的方法。接下來，我們要實作一個簡單的 moveKnight 函式，讓它可以直接修改內部狀態。這裡得先聲明上面的作法在中等複雜的應用程式中效果就不好了，對於不同的操作應應該只更新對應的狀態，不過這個教學範例還行。 123456789101112131415161718192021// src/Game.jslet knightPosition = [0, 0];let observer = null;export const emitChange = () =&gt; { observer(knightPosition);};export const observe = (o) =&gt; { if (observer) { throw new Error('Multiple observers not implemented'); } observer = o; emitChange();};export const moveKnight = (toX, toY) =&gt; { knightPosition = [toX, toY]; emitChange();}; 現在，我們可以回到我們的元件。現階段的目標是當我們點擊某個 Square，Knight 要移動到那。其中一個方式是將事件放在 Square 身上然後它來呼叫 moveKnight。不過需要傳入 Square 的位置。這裡提供一個不錯的開發建議： 如果元件渲染時不需要某個資料，則它根本不需要。 Square 渲染的時候根本不需要知道位置的資料，因此最好避免將 moveKinght 交給 Square，我們將在 Board 中使用一個 div 綁定 onClick 來包住 Square： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// src/Board.jsimport React from 'react';import Square from './Square';import Knight from './Knight';import { moveKnight } from './Game';const handleSquareClick = (toX, toY) =&gt; { moveKnight(toX, toY);};const renderSquare = (i, [knightX, knightY]) =&gt; { const x = i % 8; const y = Math.floor(i / 8); const isKnightHere = x === knightX &amp;&amp; y === knightY; const black = (x + y) % 2 === 1; const piece = isKnightHere ? &lt;Knight /&gt; : null; return ( &lt;div key={i} style={{ width: '12.5%', height: '12.5%' }} onClick={() =&gt; handleSquareClick(x, y)} &gt; &lt;Square black={black}&gt;{piece}&lt;/Square&gt; &lt;/div&gt; );};const Board = ({ knightPosition }) =&gt; { const squares = Array.from({ length: 64 }).map((_, i) =&gt; renderSquare(i, knightPosition)); return ( &lt;div style={{ width: '100%', height: '100%', display: 'flex', flexWrap: 'wrap', }} &gt; {squares} &lt;/div&gt; );};export default Board; 當然我們也是可以在 Square 上面加入 onClick，但因為無論如何後面要加入拖拉功能的時候還是得把 onClick 事件移除，所以我們就不這麼做了。 現在我們只差把西洋棋騎士移動的規則加入。簡單說騎士只允許走 L 形；因此我們在 Game 補上 canMoveKnight 函式，並且調整初始化的位置到 B1 1234567891011// src/Game.jsexport const canMoveKnight = (toX, toY) =&gt; { const [x, y] = knightPosition; const dx = toX - x; const dy = toY - y; return ( (Math.abs(dx) === 2 &amp;&amp; Math.abs(dy) === 1) || (Math.abs(dx) === 1 &amp;&amp; Math.abs(dy) === 2) );}; 然後在 Board 的 handleSquareClick 使用 canMoveKnight 12345678910// src/Board.js// ...import { moveKnight, canMoveKnight } from './Game';// ...const handleSquareClick = (toX, toY) =&gt; { if (canMoveKnight(toX, toY)) { moveKnight(toX, toY); }}; 加入拖拉功能這是本段教學最核心的一節。我們現在可以來見識一下 React DnD 如何讓拖拉互動的功能變得非常容易整合到既有的元件中。這個段落假設您已經閱讀完概覽一節，對於像是後端，狀態收集函式，類型，項目，拖移來源，拖入目標等詞有了基本的了解。 首先，我們需要安裝 React DnD 和後端的部分： 1$ npm i react-dnd react-dnd-html5-backend 未來，您可以自行使用第三方的後端，但這超出了本教學的範圍。 設定拖拉的執行環境第一件事情，我們需要為應用程式設定 DndProvider 。這個元件盡可能掛在整個結構的上層。然後設定後端 1234567891011121314151617181920212223242526import React from 'react';import { DndProvider } from 'react-dnd';import { HTML5Backend } from 'react-dnd-html5-backend';// ...const Board = ({ knightPosition }) =&gt; { // ... return ( &lt;DndProvider backend={HTML5Backend}&gt; &lt;div style={{ width: '100%', height: '100%', display: 'flex', flexWrap: 'wrap', }} &gt; {squares} &lt;/div&gt; &lt;/DndProvider&gt; );};export default Board; 定義拖拉的項目類型接著，我們要建立拖拉類型的常數。我們只有一個類型，KNIGHT，但我們還是建立一個 Constants 檔案來管理類型常數。 1234// src/Constants.jsexport const ItemTypes = { KNIGHT: 'knight',}; 為騎士加入拖移功能useDrag hook 可以傳入函式參數然後回傳一個物件（暫存資料）。這個物件的 item.type 設定了我們定義的項目類型，接著可以定義狀態收集函式： 12345678const [{ isDragging }, drag] = useDrag(() =&gt; ({ item: { type: ItemTypes.KNIGHT, collect: (monitor) =&gt; ({ isDragging: monitor.isDragging(), }), },})); 讓我們來解析 useDrag 的用法： useDrag 可以傳入指定的物件或工廠函式。item.type 是必須的，指定類型的項目才能被拖移。我們也可以加入其他的資訊例如完整西洋棋遊戲的話我們可以加入棋子的資料，是城堡或主教等，但因為這只是教學範例我們只需要 type 就夠了。 collect 定義狀態收集函式；基本上這就是我們及那個拖拉的狀態轉換合進元件 props 的方法。 回傳的陣列資料包含 陣列第一個資料是 props 物件，這裡包含我們從拖拉系統收集到的資料例如 isDragging 參考函式為第二個值，用來掛載到 DOM 元素以加入 React DnD 的功能。 現在，讓我們來看看如何在 Knight中使用： 1234567891011121314151617181920212223242526272829303132// src/Knight.jsimport React from 'react';import { useDrag } from 'react-dnd';import { ItemTypes } from './Constants';const Knight = () =&gt; { const [{ isDragging }, drag] = useDrag(() =&gt; ({ item: { type: ItemTypes.KNIGHT, }, collect: (monitor) =&gt; ({ isDragging: monitor.isDragging(), }), })); return ( &lt;div ref={drag} style={{ opacity: isDragging ? 0.5 : 1, fontSize: 25, fontWeight: 'bold', cursor: 'move', }} &gt; ♘ &lt;/div&gt; );};export default Knight; 為棋格加入置放的功能Knight 現在可以被拖移了，但不能放到其他格子上。因此這節我們要讓 Square 變成拖入目標。 此時，我們無法避免將位置傳入 Square ，畢竟如果 Square 不知道自己的位置，其實是要怎麼移動到上面。但還是覺得很奇怪因為 Square 在程式中並不會因為這些資料發生改變。當您面對這種問題的時候，建議參考如何拆分容器與顯示元件。 這裡我們要加入一個新元件叫 BoardSquare。它負責渲染我們已經有的 Square 但它負責處理位置和 Board 的 renderSquare 中局部的邏輯。 1234567891011121314// src/BoardSquare.jsimport React from 'react';import Square from './Square';const BoardSquare = ({ x, y, children }) =&gt; { const black = (x + y) % 2 === 1; return ( &lt;Square black={black}&gt; {children} &lt;/Square&gt; );};export default BoardSquare; 然後調整 Board 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// src/Board.jsimport React from 'react';import { DndProvider } from 'react-dnd';import { HTML5Backend } from 'react-dnd-html5-backend';import Knight from './Knight';import BoardSquare from './BoardSquare';import { moveKnight, canMoveKnight } from './Game';const handleSquareClick = (toX, toY) =&gt; { if (canMoveKnight(toX, toY)) { moveKnight(toX, toY); }};const renderPiece = (x, y, [knightX, knightY]) =&gt; { if (x === knightX &amp;&amp; y === knightY) { return (&lt;Knight /&gt;); }};const renderSquare = (i, knightPosition) =&gt; { const x = i % 8; const y = Math.floor(i / 8); return ( &lt;div key={i} style={{ width: '12.5%', height: '12.5%' }} onClick={() =&gt; handleSquareClick(x, y)} &gt; &lt;BoardSquare x={x} y={y}&gt; {renderPiece(x, y, knightPosition)} &lt;/BoardSquare&gt; &lt;/div&gt; );};const Board = ({ knightPosition }) =&gt; { const squares = Array.from({ length: 64 }).map((_, i) =&gt; renderSquare(i, knightPosition)); return ( &lt;DndProvider backend={HTML5Backend}&gt; &lt;div style={{ width: '100%', height: '100%', display: 'flex', flexWrap: 'wrap', }} &gt; {squares} &lt;/div&gt; &lt;/DndProvider&gt; );};export default Board; 現在我們可以在 BoardSquare 加入 useDrop hook。我們的拖入目標只處理 drop 事件： 1234const [, drop] = useDrop(() =&gt; ({ accept: ItemTypes.KNIGHT, drop: () =&gt; moveKnight(x, y),}), [x, y]) drop 方法可以取得 BoardSquare 範圍內 props 的資料，因此當騎士移入格子的時候就知道移動到哪了。 在實務上我們可能會從 beginDrag 方法使用 monitor.getItem() 來讀取拖移來源的資料，但這裡只有一個拖移的項目因此不需要。 在下面的狀態收集函式中，我們會從 monitor 取得目前游標在那個 BoardSquare 上面，我們就可以修改樣式。 1234567const [{ isOver }, drop] = useDrop(() =&gt; ({ accept: ItemTypes.KNIGHT, drop: () =&gt; moveKnight(x, y), collect: (monitor) =&gt; ({ isOver: monitor.isOver(), }),}), [x, y]) 現在的成果看起來還不錯！但還有一個功能還沒完成。就是我們希望 BoardSquare 可以顯示符合規則的移動位置，並且只有在符合規則的時候棋子才可以被移動。 因為 React DnD 的關係要實現這個功能非常容易我們只需要定義 canDrop 方法 123456789const [{ isOver, canDrop }, drop] = useDrop(() =&gt; ({ accept: ItemTypes.KNIGHT, canDrop: () =&gt; canMoveKnight(x, y), drop: () =&gt; moveKnight(x, y), collect: (monitor) =&gt; ({ isOver: monitor.isOver(), canDrop: monitor.canDrop(), }),}), [x, y]); 同時我們也加入 monitor.canDrop() 到狀態收集函式。然後加入一個 Overlay 元件和調整 BoardSquare 123456789101112131415161718192021// src/Overlay.jsimport React from 'react';const Overlay = ({ color }) =&gt; { return ( &lt;div style={{ position: 'absolute', top: 0, left: 0, height: '100%', width: '100%', zIndex: 1, opacity: 0.5, backgroundColor: color, }} /&gt; );};export default Overlay; 123456789101112131415161718192021222324252627282930313233343536373839404142// src/BoardSquare.jsimport React from 'react';import { useDrop } from 'react-dnd';import Overlay from './Overlay';import Square from './Square';import { canMoveKnight, moveKnight } from './Game';import { ItemTypes } from './Constants';const BoardSquare = ({ x, y, children }) =&gt; { const black = (x + y) % 2 === 1; const [{ isOver, canDrop }, drop] = useDrop(() =&gt; ({ accept: ItemTypes.KNIGHT, canDrop: () =&gt; canMoveKnight(x, y), drop: () =&gt; moveKnight(x, y), collect: (monitor) =&gt; ({ isOver: monitor.isOver(), canDrop: monitor.canDrop(), }), }), [x, y]); return ( &lt;div ref={drop} style={{ position: 'relative', width: '100%', height: '100%', }} &gt; &lt;Square black={black}&gt; {children} &lt;/Square&gt; {isOver &amp;&amp; !canDrop &amp;&amp; &lt;Overlay color=&quot;red&quot; /&gt;} {!isOver &amp;&amp; canDrop &amp;&amp; &lt;Overlay color=&quot;yellow&quot; /&gt;} {isOver &amp;&amp; canDrop &amp;&amp; &lt;Overlay color=&quot;green&quot; /&gt;} &lt;/div&gt; );};export default BoardSquare; 加入拖移預覽最後一件事就是我們希望加入拖移時預覽畫面。沒錯，瀏覽器會擷取 DOM 的畫面，但如果您想顯示自訂的圖片呢？ 幸運的是 React DnD 可以很容易完成這個功能。我們只需要加入 preview 參考 123456const [{ isDragging }, drag, preview] = useDrag(() =&gt; ({ item: { type: ItemTypes.KNIGHT }, collect: (monitor) =&gt; ({ isDragging: monitor.isDragging(), }),})); preview 讓我們可以在 render 設定一個 dragPreview ，類似我們在拖移項目使用的一樣。react-dnd 支援 DragPreviewImage 元件我們可以在拖移的時候透過參考顯示一個預覽。 12345678910111213141516return ( &lt;&gt; &lt;DragPreviewImage connect={preview} src=&quot;https://i.imgur.com/cPpanFj.png&quot; /&gt; &lt;div ref={drag} style={{ opacity: isDragging ? 0.5 : 1, fontSize: 25, fontWeight: 'bold', cursor: 'move', }} &gt; ♘ &lt;/div&gt; &lt;/&gt;); 總結這章教學帶我們過了一次如何建立元件，決策狀態設計最後加入拖拉功能。目的是向您介紹 React DnD 符合 React 的理念，加上您應該在深入實作複雜互動之前，先考慮應用程序結構。","link":"/2021/03/07/react-dnd-basic/"},{"title":"新世代建置工具解析(esbuild、Snowpack、Vite、wmr)","text":"本文為翻譯自 Comparing the New Generation of Build Tools 一文加上更新補充。因建置工具更新速度關係，如遇部分內容無法實作或不一致請參考各官方文件。 過去的一年出現了一堆新的開發工具，它們緊跟著那些目前佔據前端世界的建置工具例如：webpack，Babel，Rollup，Parcel，create-react-app。 這些新工具的目的並不是實現一模一樣功能，它們各自有不同想嘗試解決的問題或新增的功能。儘管有所不同，但這些工具都有著共同的目標：改善開發者體驗。 具體來說，本文希望試著分析每個新工具，概述它們的功能，以及為什麼我們需要它們和適用的情境。我知道項目之間的比較很難非常公平，再一次強調這裡比較的項目，它們的關係並非直接的競品。實際上例如 Snowpack 底層就有使用 esbuild 來處理某些事情。 本文的目的是更進一步了解這些工具的前景和它們提供什麼功能可以讓我們簡化開發流程。如此一來我們就知道能有什麼選擇，以及它們是如何組成的，然後在需要的時候我們可以做出比較好的決定。 當然這些論述有受到我使用 React 和 Preact 經驗的影響。個人比較熟悉這些函式庫，但我們也會探討對其他前端函式庫的支援和使用。 關於這些新工具網路上有許多不錯的文章，影片，廣播等。推薦 ShopTalk Show Episode 454 探討關於 Vite 以及 Episode 448 Snowpack 和 wmr 作者的介紹。從這些影片介紹我們知道這些工具如何加速優化了我們的開發工作。 為什麼這些工具會出現？某部分來說我認為這些工具反應了 JavaScript 工具鏈的問題 - 關於在 2016 學習 JavaScript 一文很好的詮釋了問題。這些工具填補了撰寫一個原始 JavaScript 檔案到下載相依函式庫之際的環節。這些新工具內建功能，不用額外再安裝其他相依套件，部分符合了 JavaScript 生態圈的趨勢 - Collapsing Layers。 Snowpack，Vite 和 wmr 已經可以在瀏覽器提供原生的 JavaScript 模組功能。回到 2018，Firefox 60 釋出預設提供 ECMAScript 2015 模組。之後，其他主流瀏覽器也都支援。Node.js 也在 2019 年 11 月搭載原生模組功能。直到 2021 年的今天我們依然在解開 JavaScript 原生模組的可能性。 新工具與當前工具的差異無論我們使用 webpack，Rollup，Parcel 哪一個，這些工具都在建置的過程中使用像是 Babel，TypeScript 等處理 node_modules 並從原始碼封裝了整個程式，然後產出封裝檔（Bundle）給瀏覽器使用。即便它們支援暫存和優化，這個過程還是降低了開發伺服器的速度。 Snowpack ，Vite 和 wmr 開發伺服器則不使用這種模式。相反，它們會等到瀏覽器遭遇 import 語句時才發出模組的請求。只有在請求發生之後，工具才會轉譯請求的模組和模組中匯入的東西，然後提供給瀏覽器執行。由於開發伺服器的工作量減少，因此加快了不少速度。 還有 esbuild 。首先，基本上它是個封裝打包工具，但它跟其他工具不一樣。透過避免大量轉譯和使用 Go 語言並行的特性，讓 esbuild 可非常快速的處理程式碼。 實驗這裡使用一個 React 的範例然後使用每個工具重新建置。這個專案是 Yogita Verma 的 Snap Shot 原版檔案庫 4個不同工具版本 後續我們會比較編譯的結果。重製並包含一些開發常用的套件如 React Router 和 axios 讓我們可以多了解測試其開發體驗。 功能比較在我們深入介紹每一個工具之前，先提一下，它們都支援下列功能但支援的程度不同： 支援原生 JavaScript 模組 TypeScript 編譯（不進行型別檢查） JSX 擴展套件 API 內建開發伺服器 支援 CSS-in-JS 函式庫 這些新工具都可以編譯 TypeScript 為 JavaScript，但即便型別錯誤還是會繼續編譯。針對型別檢查您可以安裝 TypeScript 然後執行 tsc --noEmit 或者在您的編輯器安裝套件來檢查。 esbuildesbuild 是 Evan Wallace （ Figma 的 CTO）開發的。其主要目的為提升建置速度，比起基於 Nodejs 的工具可達到 10 到 100 倍快。跟像是 create-react-app 這類型的工具比起來和開發體驗沒什麼太大關係，但後續出現了很多基於 esbuild 建置的工具，它們補上了其他功能例如 create-react-app-esbuild，estrella，Snowpack。它們都是使用 esbuild 來編譯程式碼。 esbuild 目前還沒 1.0 算是蠻新的專案，不建議直接在正式專案使用，但離 1.0 應該不遠了。同時 esbuild 搭配智能預設值提供了直觀的指令介面 API 。 適用情境esbuild 顛覆了前端工具的世界。在大型專案中增加了幾倍的編譯速度是非常實用的。將來 1.0 版本的時候，估計可以為大型專案提供不少幫助，大量減少等待編譯的時間。 目前還是等待穩定版本再使用在專案的正式版本，但您的一些非正式專案可以開始使用。 esbuild 的超快速度無論您在開發什麼類型的專案都能有所幫助。減少等待建置的時間對於開發體驗肯定是加分的。如果考慮到加速應用程式的開發您也許想從其他比 esbuild 高階的工具起手。不然您還是需要花時間安裝相依套件和設定專案。另外一提如果想要盡可能最小化編譯檔案的大小，使用 Rollup 和 terser，它們產出的檔案稍微小一點。 設定我們從一個比較單純的方式使用 esbuild 建置一個 React 專案開始；單純使用 npm 安裝 esbuild，react，react-dom 不使用其他相依套件。然後建立 src/app.jsx 和 dist/index.html 檔案。接著使用下面指令產生 dist/bundle.js 1$ npx esbuild src/app.jsx --bundle --platform=browser --outfile=dist/bundle.js 注意：如果您檔案中包含 JSX 則檔名須為 .jsx 或加入參數 esbuild app.js --bundle --loader:.js=jsx 如果您使用瀏覽器開啟 index.html 時畫面是空白的且發生錯誤 Uncaught ReferenceError: process is not defnied。可以參考官方文件設定。該錯誤解決方式是加入 1--define:process.env.NODE_ENV=\\&quot;production\\&quot; 封裝任何函式庫給瀏覽器使用時，如果需要 Nodejs 環境變數則需要定義 define 參數。Vue 2.0 也是相同的。Preact 則不會遇到這個問題，因為它沒有使用任何環境變數且，預設就可以在瀏覽器使用。 .jsx 檔案中預設就支援 JSX 語法，但需要匯入 React ，不過 esbuild 也支援自動匯入，設定請參考 auto imports in JSX and/or configure JSX for Preact 使用方式esbuild 提供 --serve 參數支援開發伺服器，讓我們可以直接從記憶體直接存取 JavaScript 模組，確保瀏覽器不會讀取到舊版的模組。不過它不支援 Live、Hot Reload，因此在存檔之後您需要手動讓瀏覽器重新載入，開發體驗不是非常理想。 12# 依據目前的專案結構您也可使用下列指令測試開發伺服器$ npx esbuild src/app.jsx --bundle --outfile=dist/bundle.js --servedir=dist 除了內建的開發伺服器，我們也可以使用 watch 功能搭配其他伺服器；每當檔案儲存的時候它會通知 esbuild 重新編譯。但我們需要伺服器的支援來觀察內容的變更；這裡使用 servor。 1$ npm i servor -D 然後我們就可以在啟動伺服器的同時執行 esbuild 的 watch 模式；讓我們來建立 watch.js 1234567891011121314151617181920212223const esbuild = require('esbuild');const servor = require('servor');esbuild.build({ entryPoints: ['src/app.jsx'], outdir: 'dist', bundle: true, define: { 'process.env.NODE_ENV': '&quot;production&quot;', }, watch: true,});async function serve() { console.log('running server on: http://localhost:8000'); await servor({ browser: true, root: 'dist', port: 8000, });}serve(); 接著可以在指令介面執行 node watch.js 。servor 是不錯的開發伺服器，但沒有支援 Hot Module Replacement，只是對於我們的測試來說已經足夠了。 雖然每次我們存檔的時候都會重建整個應用程式，也需要重新載入。但在這個設定之後，即使電腦配備不高速度也蠻順暢的。想要支援 Live Reload 的話，可以參考這個檔案庫。 支援檔案 esbuild 可以在 JavaScript 匯入 CSS。可以編譯 CSS 並輸出一個跟產出 JavaScript 同檔名的檔案。預設支援打包 CSS @import 語句。不支援 CSS Modules，但未來是有計畫支援的。 esbuild 套件社群持續在成長。例如有 Vue 單檔元件 和 Svelte 元件。 esbuild 可以處理 JSON 檔案，無須進行任何設定即可使用。 可以在 JavaScript 匯入圖片，並設定轉換成 Data URL 或者把它們複製到輸出目錄。但這個功能預設不提供，您可以加入下面的設定： 12loader: {'.png': 'dataurl'}loader: {'.png': 'file'} 處理過程中可能會顯示 Code Splitting 的訊息，多數會以 esm 格式輸出。另外值得一提的是內建支援 Tree-shaking （刪除沒用到的程式碼）而且不能關閉。 正式版本建置使用 minify 和 bundle 參數無法建置出和 Rollup / Terser 一樣小的檔案。這是因為 esbuild 犧牲了一些優化的部分來減少讀取傳入的程式碼，但差異應該不大。加速編譯時間是值得的。在上面提到的 Sanp Shot 專案，esbuild 封裝檔是 177KB，而使用 Rollup 和 terser 的 Vite 產生的是 165KB 。 分析 esbuild 功能 支援 各種前端框架專案建置樣版 X 開發伺服器支援 Hot Module Replacement X Streaming Imports X 預先配置正式環境建置 X 自動支援 PostCSS 和 Preprocessor 轉換 X 轉譯產生 HTML X 支援 Rollup 套件 X 檔案大小 7.34MB esbuild 是一個非常強大的工具，但需要自行進行設定配置。如果您希望預設提供更多功能則可以參考下一個工具 Snowpack 其底層就是使用 esbuild。 定位：An extremely fast JavaScript bundler SnowpackSnowapck 是由 Skypack 和 Pika 的作者開發的建置工具。核心功能是開發時期支援 Unbundled Development ，其概念是在開發時提供瀏覽器個別的檔案。檔案依舊可以使用 Babel，TypeScript，Sass 編譯然後由瀏覽器個別載入，也就是當您變更檔案時 Snowpack 只會重新編譯該檔，然後只重新載入該檔。節錄官方文件的說法：使用封裝工具應該是您想要使用，而不是必須要使用。 其中一個賣點就是加速開發。 預設，Snowpack 不會將所有程式碼封裝打包成一個檔案，瀏覽器載入個別檔案。雖然 esbuild 確實是其中一個相依套件，但 Snowpack 的想法是使用原生 JavaScript 模組，直到你需要封裝成一個檔案的時候才使用 esbuild。 Snowpack 擁有美觀的官方文件包含搭配其他框架的設定說明和專案樣版。一些教學還處於編寫中，已完成的像 React 教學 就非常清楚。另外 Snowpack 似乎以 Svelete 為第一優先。事實上，我第一次聽說 Snowpack 就是在 Svelte Submit 2020， Rich Harris 的 未來的網頁開發。當時提到即將推出的 SvelteKit 應該會使用 Snowpack；後來選擇了 Vite - SvelteKit is in public beta 說明 適用情境想嘗試 Unbundle Deployment 不想增加封裝檔的複雜度， Snowpack 是不錯的選擇。如果您正在開發的專案模組量不大，意味著不會產生大量個別編譯的需求。一個不錯的使用情境是；您正逐步採用 SSR 或靜態應用程式。您可以只使用一點點 Node 生態圈的工具，但仍保留前端框架的好處。 第二，我認為 Snowpack 是一個不錯的 esbuild 強化版。如果您想使用 esbuild 又想要好用的開發伺服器和專案樣版，那麼選 Snowpack 不會錯。 就目前為止的情況，我認為 Snowpack 並不是零設定方案最好的選擇（例如 create-react-app），因為如果您面對的是大型專案，還是需要為了優化安裝套件並自行設定。 設定讓我們直接使用指令搭配 Snowpack 來開啟一個專案 1234$ mkdir demo$ cd demo$ npm init -y$ npm i snowpack 然後調整 package.json 加入 scripts 1234&quot;scripts&quot;: { &quot;start&quot;: &quot;snowpack dev&quot;, &quot;build&quot;: &quot;snowpack build&quot;}, 接著，建立設定檔 1$ touch snowpack.config.js 我認為 Snowpack 神奇的地方就是設定看起來相對單純，例如 123456// snowpack.config.jsmodule.exports = { packageOptions: { source: 'remote', },}; source: remote 啟動了 Streaming Imports 的功能。Streaming Imports 讓 Snowpack 將我們的模組匯入例如 import React from 'react' 轉換成從 Skypack 讀取（即不用先 npm install）。 下一步，建立 index.html 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Hello, Snowpack&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script type=&quot;module&quot; src=&quot;app.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 最後建立 app.jsx 123456789101112131415import React from 'react';import { render } from 'react-dom';const App = () =&gt; { return ( &lt;div&gt; Hello, Snowpack! &lt;/div&gt; );};render( &lt;App /&gt;, document.getElementById('app'),); 神奇的地方來了！現在我們不需要使用 npm 安裝 react 和 react-dom 直接使用下面的指令啟動開發伺服器： 1$ npm start 我們的範例就可以正常執行了！ Snowpack 從 Skypack CDN 讀取 npm 套件，而不是 node_modules 。模組還是預先為瀏覽器優化過的版本，後續 Snowpack 會使用 ./_snowpack/pkg URL 來讀取。 使用方式光是改變從 npm 讀取模組的流程就是一個很大的變動。實際上有部分開發者正在研究新的，基於 CDN 載入的流程。 如果現在我們直接使用一樣的方式建置正式環境的檔案（ npm run build），則 Snowpack 會拋出錯誤。這是因為 Snowpack 從 3.0 版本開始支援 Streaming Imports，但在 3.1 版之前您需要在建置正式版本檔案之前進行 snowpack.deps.json 設定相依版本。可以使用下面指令來設定： 12$ npx snowpack add react$ npx snowpack add react-dom 其他細節可以參考相依性管理 上面指令不會從 npm 安裝套件，但會紀錄使用的套件版本。 如果我們不用 Streaming Imports，Snowpack 開發伺服器也可以從 node_modules 讀取模組，並將這些檔案專案為原生 JavaScript 模組給瀏覽器使用。這表示瀏覽器可以暫存這些檔案直到檔案有變更。開發伺服器會在檔案變更時自動重新載入，但不會保持客戶端的狀態。全部相依的套件無論使用傳統模組格式或 Nodejs API 的格式內建都支援。例如我們在上面 esbuild 的 process.env 問題都會自動處理。 至於像是要在 React 中保留狀態則需要 react-refresh，和一些 Babel 的套件處理。這功能預設不支援，但在很多 React 的專案樣版中都有使用。 1234# https://www.snowpack.dev/concepts/hot-module-replacement#enabling-hmr-%2B-fast-refresh# https://github.com/snowpackjs/snowpack/tree/main/create-snowpack-app/cli$ npx create-snowpack-app demo --template @snowpack/app-tempate-react 支援檔案預設只支援 .jsx。Snowpack 會自動偵測是使用 React 還是 Preact，並以此決定 render 函式。不過如果您希望自訂 JSX 的功能您可以利用套件來安裝設定 Babel。當然 Snowpack 還支援 Vue ，Svelte，編譯 TypeScript（不會檢查型別，須使用額外 TypeScript 套件）。 CSS 可以在 JavaScript 匯入會在執行時期置放到 &lt;head&gt;。CSS Module 也預設支援，只須使用 .module.css 副檔名。 JSON 檔案會直接編譯成一個物件。圖片則是會被複製到目錄下，因為 Unbundled 的設計原則，Snowpack 不會把圖片編譯成 Data URL。 正式版本建置基本上預設 snowpack build 指令會把編譯結果放到輸出目錄下。例如 TypeScript，JSX，JSON，.vue，.svelte 檔案會被編譯成 JavaScript，檔案各自被轉換成 JavaScript 模組。 但這不是那麼適合正式環境，因為當檔案很多的時候，會導致產生大量的網路請求。例如在 Snap Shot 專案中我們檔案總共只有 184KB ，但後續卻向 Skypack 發出 105KB 相依套件的請求。 不過 Snowpack 內部使用 esbuild，因此我們可以使用 bundle，minify 等參數功能來編譯程式，只要在 snowpack.config.js 使用 optimize 物件參數即可 1234567module.exports = { optimize: { bundle: true, minify: true, target: 'es2018' },}; 如此就可以使用 esbuild 提供的優化功能。 由於 esbuild 還沒 1.0，針對正式版本建置， Snowpack 建議使用 webpack 或 Rollup 套件，當然這些都需要額外設定。 分析通過完整功能的開發伺服器，詳細的文件，輕鬆安裝的專案樣版，這些功能讓 Snowpack 提供了輕量級的開發體驗。您可以自行決定封裝應用程式的方式。但如果您希望一個工具同時提供開發伺服器和更多建置功能，您可以參考下一個工具 Vite Snowpack 功能 支援 各種前端框架專案建置樣版 V 開發伺服器支援 Hot Module Replacement V （使用專案樣版） Streaming Imports V 預先配置正式環境建置 X 自動支援 PostCSS 和 Preprocessor 轉換 X 轉譯產生 HTML X 支援 Rollup 套件 V 檔案大小 16MB ViteVite 是由 Vue 作者 Evan You 和 Hades speedruns 開發的。在 esbuild 專注在編譯速度，Snowpack 專注開發伺服器。Vite 則提供兩者；完整的開發伺服器和使用 Rollup 進行優化編譯。 適用情境如果您在尋找的是像 create-react-app 或 Vue CLI 的競品，Vite 是最接近的一個，因為它內建包含這些功能。輕量快速的開發伺服器，零設定即支援正式版本優化。Vite 可以適用於小型的個人專案 Side-Project 或大型正式專案。任何 SPA 應用程式都很適合。 為什麼不使用 Vite？Vite 是一個堅持己見的工具，可能您不同意其中的一些觀點。比如您不想使用 Rollup，或想使用上面提到非常快的 esbuild，或希望預設能提供完整 Babel ，eslint ，和 webpack loaders 生態圈的功能。還有如果您想使用無須額外設定的 Meta-frameworks，那麼您最好繼續使用基於 webpack 的框架，例如 Nuxt.js，Next.js 直到 Vite 的伺服器端渲染功能更完整。 Meta Framework: 一網頁應用程式框架具備常見功能的核心介面，可整合服務和元件的高度擴展性。開放式的結構可和其他元件或框架合併使用。例如 Next.js，Nuxt.js 設定跟 esbuild 和 Snowpack 相比，Vite 包含更多主觀意見的預設值。因為作者的關係， Vue 得到了完全支援，對於 Vue 開發者來說無疑是非常友善的。當然 Vite 可以被使用在任何前端框架而且也提供了一系列樣版。 使用方式Vite 的開發伺服器功能非常強大。Vite 預先使用 esbuild 封裝專案全部的相依套件成一個原生 JavaScript 模組，然後使用 HTTP Header 快取。這表示一旦頁面載入，我們就不需要浪費時間編譯，發送請求，讀取相依模組。 Vite 也提供清楚的錯誤資訊，顯示確切錯誤程式碼段落。使用 Vite 我不曾遇到任何關於讀取相依套件的問題，即便使用 Node API 或其他較舊的格式。它們全部都被轉換成瀏覽器相容的 ES Module。 Vite 的 React 和 Vue 專案樣版都有使用套件來支援 Hot Module Replacement 。Vue 使用 @vitejs/plugin-vue 和 @vitejs/plugin-vue-jsx 。而 React 使用 @vitejs/plugin-react-refresh 。 無論哪種方式，它們都讓我們得到 HMR 和保留客戶端狀態的功能。當然它們使用了更多相依套件包含 Babel。實際上在 Vite 中使用 JSX 並不需要 Babel 。預設情況下 JSX 的處理方式和 esbuild 一樣；就是先轉換成 React.createElement 。 不會自動匯入 React ，但可以設定。 另外值得提到 Vite 也支援伺服器端渲染（處於實驗階段）。目前我們需要自行組織架構，但看起來基於 Vite 構建框架是不錯的機會。作者確實已經著手進行一個叫 VitePress 的專案，一個包含 Vite 優點，預計取代VuePress 的專案。 還有 SvelteKit 也採用 Vite。看起來 CSS 拆分功能是 SvelteKit 後來選擇 Vite 的原因之一。 1234$ npm init @vitejs/app demo$ cd demo$ npm i$ npm run dev 支援檔案針對 CSS，Vite 提供幾乎所有工具的功能，打包 CSS ，CSS Module，也可以安裝 PostCSS 套件並設定 postcss.config.js，Vite 會自動套用這些轉譯功能。 其他 CSS Preprocessors 也可以使用 npm 安裝，例如 SCSS。只要副檔名正確，Vite 就會自動套用對應的處理工具。 圖片匯入預設會複製到輸出目錄並提供存取的 URL，但您可以使用 ?raw 參數將它們轉換成字串存到 JavaScript 中。 JSON 檔案會轉換為 ES Module 並以單一物件形式匯出。還可以提供具名匯入，Vite 會根據 JSON 根節點的欄位搜尋，並移除其他不用的資料（Tree-shaking）。 正式版本建置Vite 使用 Rollup 並預先提供設定，為正式版本建置進行優化。不用額外設定即可適用於大多數使用情境。 輸出的結果包含我們預期 Rollup 提供的功能；封裝，最小化，Tree-shaking。其他還有拆分程式碼，動態載入，非同步程式碼片段載入。舉例來說如果我們請求載入一個 JavaScript 模組，其匯入另一個模組時會預先對該模組進行優化讓兩個模組可以同一時間載入（非同步）。 使用 Vite 的預設值建置 Snap Shot 應用程式最終會得到一個 5KB 和一個 160KB 的 JavaScript 檔案，全部 CSS 自動最小化 2.71KB。 分析為了使開發人員體驗真正無縫順暢的開發流程，預設就支援正式環境版本的建置，這個部分 Vite 做了很多的努力。Vite 已成為很多前端工具的競爭對手。 Vite 功能 支援 各種前端框架專案建置樣版 V 開發伺服器支援 Hot Module Replacement V （使用專案樣版） Streaming Imports X 預先配置正式環境建置 V 自動支援 PostCSS 和 Preprocessor 轉換 V 轉譯產生 HTML X 支援 Rollup 套件 V 檔案大小 17.1MB wmrwmr 是另一個類似 Vite 的建置工具，也是同時提供開發伺服器和整合建置流程。是由 Preact 作者 Jason Miller 開發的。因此肯定對於 Preact 開發者友善。Jason Miller 在 JS party podcast 當來賓的時候曾解釋背後的想法： “當您在開發一個輕量的專案時 Preact 是不錯的選擇。但關於它的建置工具呢？它使用基於 webpack 的建置工具，外面很多專案也都使用 webpack ，但它的確是一個相對笨重的工具。那關於 Prototyping 的建置工具呢？其實那是一個原因，另外一直以來包含我自己在內和 Preact 團隊都沒有特別深入建置工具的生態圈，這些因素促使我們嘗試思考進一步的方向並在”編寫和交付符合主流規範的程式碼” 這個方向達成共識 意思是 wmr 希望輕量化的工具能協助“編寫和交付符合主流規範的程式碼”。 您可能會問 wmr 代表什麼意思？ Web Module Runtime 和 Web Module Replacement 名稱自然浮現，但其實不是它們的縮寫，就像 npm 其實也不是 Node Package Manager 一樣。 wmr 跟 Preact 一樣非常小，只有 2.6MB - 沒有任何 npm 相依套件。就算如此，它還是包含很多很棒的功能包含支援 HMR 的開發伺服器以及正式環境建置的優化。 適用情境如果您要使用 Preact 來開發原型產品的話可使用 wmr 。不需要設定，下載也很快，感覺就像是開加速的靜態檔案伺服器。搭配 TypeScript ，優化建置，靜態 HTML 渲染，wmr 提供了小至中型專案所需要的功能。 如果您不是使用 Preact，React 或完全原生 JavaScript 那麼 wmr 就不太適合您。Preact 團隊有為其他框架提供專案樣版，但文件看來和其他工具相比不是那麼詳細，意味著您可能會踩雷，偶而需要深入原始碼。因此假如您需要大量客製化設定的話不推薦使用。 設定如果您使用的是 Preact ，那如我們所預期不需要額外設定。如果是 React 搭配 wmr 則有兩個步驟，須將 package.json 中的 alias ， htm/preact 換成 htm/react 以及 react 換成 es-react 1234&quot;alias&quot;: { &quot;htm/preact&quot;: &quot;htm/react&quot;, &quot;react&quot;: &quot;es-react&quot;}, 然後在元件中從 es-react 匯入 React 1import { React, ReactDOM } from 'es-react'; 上面程式碼代表我們不是從一般的 React 套件中匯入，而是從 es-react 。因為 wmr 需要依賴相容原生 JavaScript 模組的套件。原廠 React 預設不使用原生模組，而是使用 UMD 模組格式，es-react 套件基本上只是把原廠套件使用 JavaScript 原生模組的方式匯出。 這說明了 wmr 的核心理念就是使用原生模組。另外也可以使用 Skypack 來匯入模組。 12import React from 'https://cdn.skypack.dev/react';import ReactDOM from 'https://cdn.skypack.dev/react-dom'; wmr 預期您會以現代化標準的程式碼進行開發，它們可以直接在瀏覽器執行，同時如果您有使用一些傳統 Node API 格式的模組您可能需要額外的設定。還是以 Snap Shot 專案舉例，您就需要深入那些 Node 模組並將它們轉換成相容的原生模組。如果您使用了很多舊的函式庫，可能導致開發效率變差。而 Preact 生態圈相關的東西都已經處理了，也就是如果您使用 Preact ，wmr 肯定是比較友善的。 wmr 套件部分也支援 Rollup 建置，還有很多 wmr 的範例包含最小化 HTML，使用檔案系統的路由。另外，wmr 也支援其他框架，但沒有提供預先建置的專案樣版。且設定 JSX 轉換就相當困難。 話雖如此，Jason 也已經確定計畫讓 JSX 設定更加方便，還有 wmr 將不針對特定框架，預設支援 JSX 等。 使用方式欲使用 wmr 您可以執行下面指令 1$ npm init wmr demo 或者手動在既有目錄下 12345$ npm init -y$ npm install wmr$ mkdir public$ touch public/index.html$ touch public/index.js 然後在 index.html 中加入 1&lt;script type=&quot;module&quot; src=&quot;./index.js&quot;&gt;&lt;/script&gt; 接著就可以直接在 index.js 中使用 Preact 12import { render } from 'preact';render(&lt;h1&gt;Hello World!&lt;/h1&gt;, document.body); 最後執行下面指令啟動支援 HMR 的開發伺服器 1$ npx wmr wmr 使用 htm 工具來編譯 JSX 可以提供一些不錯的功能。例如您使用 Preact 撰寫一個計數器然後在使用 wmr 的情況下寫錯了： 12345678910111213import { render } from 'preact';import { useState } from 'preact/hooks';function App() { const [count, setCount] = useState(0); return ( &lt;&gt; &lt;button onClick={setCount(cout + 5)}&gt;Click to add 5 to count&lt;/button&gt; &lt;p&gt;count: {count}&lt;/p&gt; &lt;/&gt; );}render(&lt;App /&gt;, document.body); 上面 onClick 中的 count 拼錯了，點擊按鈕執行的時候一定會發生錯誤。通常我們需要依靠 Source Map 的功能來取得錯在哪，但 wmr 不一樣。wmr 則使用 JS 樣版字串的方式，讓您在瀏覽器下盡可能以接近 JSX 的格式得到錯誤訊息。例如我們寫了一段 JSX 1&lt;MyComponent&gt;I am JSX. I am not actually valid Javascript&lt;/MyComponent&gt; htm 輸出的結果看起來像： 1html`&lt;${MyComponent}&gt;I am about as close as it gets to JSX as you can get while being able to run in the browser&lt;/MyComponent&gt;` 看不懂什麼意思？現在如果我們在瀏覽器的開發工具切換到 “Sources” 面板，您會看到如下的資訊： 當然這個範例有點故意，但如此一來您在除錯的時候看到的程式碼是不是更明確了。 wmr 預設支援 Streaming Imports ，因此可以直接從 npm registry 上直接下載。該流程非常複雜，會檢查 npm 套件，移除測試相關的部分，轉換成原生模組，類似於 Snowpack 可以不用 npm 安裝任何東西就建置複雜的專案。 其實 wmr 是第一個支援這個概念的工具。 支援檔案至於 wmr 支援的檔案類型，CSS 可以在 JavaScript 中匯入，CSS Module 也支援。預設不支援 Vue 單檔元件或 Svelte 元件。然而 wmr 內部的 Rollup 和開發伺服器可以搭配 Polka / Express 的中介層來設定，因此它是可以支援其他框架元件的。實際上例如 wmr-vue-plugin 就可以協助編譯 Vue 單檔元件。 “匯入圖片” 轉換 URL 的部分則額外的套件處理。一般則需要使用標準的 JavaScript 語法匯入圖片，例如我們要在 Preact 元件使用圖片： 12345function Dog() { return ( &lt;img src={new URL('./dog.jpg', import.meta.url)} alt=&quot;Dog handing out&quot; /&gt; );} 利用這種方式執行建置的時候，圖片會被複製到輸出的目錄。HMR 不支援圖片，所以變更圖片不會自動反應在瀏覽器上。 還有 JSON 是可以被匯入的，也是轉換成一個物件。但在建置的時候需要 Rollup JSON 套件。 正式版本建置wmr 支援正式環境版本建置包含最小化，Tree-Shaking 。觀察原始碼似乎是使用 Rollup 和 terser，以 Snap Shot 專案來說結果是 164KB 比 Vite 小一點點。 另外還有一種搭配 preact-iso 的方式也可以輸出靜態 HTML ，意味著 wmr 也可以協助 Preact 實作 Meta Framework。 分析對於小型專案搭配 React 或 Preact 的話 wmr 的使用體驗還不錯。 wmr 功能 支援 各種前端框架專案建置樣版 V 開發伺服器支援 Hot Module Replacement V Streaming Imports V 預先配置正式環境建置 V 自動支援 PostCSS 和 Preprocessor 轉換 X 轉譯產生 HTML V 支援 Rollup 套件 V 檔案大小 2.57MB 功能比較上面涵蓋了不少東西，實作比較和內容整理讓我們概略了解這些工具的特性，組成。下面附註一些上面可能有遺漏的比較： 適用情境 工具 esbuild 適用於專案包含大量原始碼。目前不適用於正式專案 Snowpack 小型專案，可自行選擇是否需要封裝打包，也適用於逐步採用 JavaScript 框架，目前還是伺服器端渲染的專案 Vite Vue Cli/create-react-app 的競品，特別適合 Vue 專案 wmr 原型，小型到中型專案，特別適合 Preact 專案 設定 esbuild Snowpack Vite wmr 各種前端框架專案建置樣版 X V V X 檔案大小 7.34MB 16MB 17.1MB 2.57MB 無須設定，支援正式版本建置 X X V V 無須設定，支援HMR 開發伺服器 X V V V 處理 Node 套件 X V V V 開發伺服器 esbuild Snowpack Vite wmr HMR X V V V CSS HMR X V V V 預先建置 npm 相依套件 X V V X 瀏覽器顯示錯誤訊息 X V V X 轉譯產生 HTML X X X V 正式版本建置 esbuild Snowpack Vite wmr Snap Shot 專案建置大小 177KB 多檔總和 184KB 外加 Skypack CDN 相依 105KB 165KB(5KB + 160KB 檔案) 164KB 使用 Go 編譯 V V 當使用 esbuild 時 X X 預先設定正式環境建置 X X V V 非同步 chunk 載入 X X V V 支援 Rollup X V V V 其他 esbuild Snowpack Vite wmr Streaming imports X V X V Server-side rendering X X V V CSS Modules X X V V 自動 PostCSS 和 Preprocessor 轉換 V V V X 結論對於使用上面介紹的工具建置 JavaScript 專案，無論是小型個人專案或大型專案這些工具都提升開發效率。它讓我們知道 JavaScript 生態圈需要什麼，我們是否能免受傳統瀏覽器和模組帶來的困擾。這些工具將通過提供一個更精簡，更快速的開發環境，減少”撰寫的程式碼“和”瀏覽器執行版本“之間的抽象，進一步降低新進人員的門檻。 如果您正因為建置工具而困擾，建議您可以嘗試一下這些新工具。 參考 Comparing the New Generation of Build Tools Comparisons with Other No-Bundler Solutions (Vite) Let’s Learn esbuild! (with Sunil Pai) (Jason Lengstorf) Through the pipeline: an exploration of frontend bundlers (Andrew Walpole) 其他新世代工具 Rome – 完整型工具包含 linting, compiling, bundling, test-running and formatting SWC – 基於 Rust 語言 JavaScript/TypeScript 編譯器 Deno – JavaScript and TypeScript 執行環境 (類似 Node.js)","link":"/2021/04/25/new-generation-of-build-tools-comparsing/"},{"title":"Laravel 8 自動產生 Sitemap","text":"Sitemap 是否真的必須？理論上 Sitemap 協助搜尋引擎的網頁爬蟲發現您網站所有的頁面。Google 文件有詳細說明 如果您網站的頁面都有正確的連結，爬蟲通常可以發現全部的頁面。即便如此，Sitemap 也可以改善網頁抓取尤其是您的網站滿足下拉條件之一時： 您的網站非常大。因此 Google 爬蟲有可能會忽略抓取一些最近更新的頁面 您的網站有大量內容頁面存檔。這些頁面屬於獨立頁面或沒有被妥善連結。如果您的網站本身每個頁面沒有做好參考關聯，您可以將他們列在 Sitemap 上來確保 Google 不會忽略它們。 您的網站是新網站，當下幾乎沒有外部連結。Google Bot 和其他爬蟲是根據某個頁面的連結來找到另一個頁面的。如果外部沒有任何連結，結果就是 Google 可能根本沒有發現您的頁面。 您的網站使用大量媒體內容，顯示在 Google News 或其他網站相容的 Sitemap 註記 針對大型網站，並非所有頁面都會有參考連結（例如電商網站並不是所有的產品在頁面上都有連結），因此定義 Sitemap 就是需要的。但對於小型到中型網站可能全部頁面都有適當的關聯，從 Google 文件得出的結論並不是必須。 不過經常被提到的是如果有 Sitemap 並且將其提供給搜尋引擎那麼抓取的速度會快一點。也很常聽到在 Google Search Console 提供 Sitemap 是有好處的，您可以比較頁面數和 Google 取得的是否一致。通過這種方式，您可以檢測 Google 是否無法抓取您希望抓取的網站部分。 建立 Sitemap想像您有一個 Laravel 應用程式，使用 example.com 網域，每個頁面都有正確關聯。包含首頁，聯絡頁面，專案頁面和一些 NewItem 。使用這個套件您可以如下產生 Sitemap: 1234567891011121314151617use Spatie\\Sitemap\\Sitemap;use Spatie\\Tags\\Url;$sitemap = Sitemap::create() -&gt;add(Url::create('/home')) -&gt;add(Url::create('/contact'));NewsItem::all()-&gt;each(function (NewsItem $newsItem) use ($sitemap) { $sitemap-&gt;add(Url::create(&quot;/news/{$newsItem-&gt;slug}&quot;));});Projects::all()-&gt;each(function (Project $project) use ($sitemap) { $sitemap-&gt;add(Url::create(&quot;/project/{$project-&gt;slug}&quot;));});$sitemap-&gt;writeToFile(public_path('sitemap.xml')); 上面可以完成我們的需求，但有點麻煩。如果您加入其他頁面，請記得回來補上。 產生 Sitemap為了避免手動加入，套件支援了 SitemapGenerator 。這個類別可以自動爬您的網站並產生 Sitemap。 使用 SitemapGenerator 上面範例可以使用下面取代： 123use Spatie\\Sitemap\\SitemapGenerator;SitemapGenerator::create('https://example.com')-&gt;writeToFile(public_path('sitemap.xml')); 您可以輕易的建立一個 Artisan 指令來建立這個 Sitemap 以及排程。如此可以確保新的頁面和內容會自動被加入 1$ php artisan make:command GenerateSitemap 123456789101112131415161718192021222324252627282930313233namespace App\\Console\\Commands;use Illuminate\\Console\\Command;use Spatie\\Sitemap\\SitemapGenerator;class GenerateSitemap extends Command{ /** * The console command name. * * @var string */ protected $signature = 'sitemap:generate'; /** * The console command description. * * @var string */ protected $description = 'Generate the sitemap.'; /** * Execute the console command. * * @return mixed */ public function handle() { // modify this to your own needs SitemapGenerator::create(config('app.url')) -&gt;writeToFile(public_path('sitemap.xml')); }} 它也可以在 Console Kernel 中設定每日執行 1234567// app/Console/Kernel.phpprotected function schedule(Schedule $schedule){ ... $schedule-&gt;command('sitemap:generate')-&gt;daily(); ...} 兩全其美的方式您可以結合兩種方式。您可以自動搭配手動加入： 12345SitemapGenerator::create('https://example.com') -&gt;getSitemap() -&gt;add(Url::create('/extra-page')) -&gt;add(...); -&gt;writeToFile($path); 限制此套件主要目標是小型到中型的網站，基於規範，一個 Sitemap 可以儲存 50000 筆資料，如果超過您會需要 Sitemap Index。另外也關於指定連結的類型如影片，圖片等等，目前此套件不支援。 下面提供一些有支援這些功能，但他們不包含爬蟲功能： refinery29/sitemap RoumenDamianoff/laravel-sitemap dwightwatson/sitemap Github安裝使用 Composer 安裝套件 1$ composer require spatie/laravel-sitemap 此套件會自動註冊。如果您希望自動更新可以參考下面設定步驟。 設定要覆寫預設設定可以先匯出設定檔： 1$ php artisan vendor:publish --provider=&quot;Spatie\\Sitemap\\SitemapServiceProvider&quot; --tag=config 設定檔為。config/sitemap.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?phpuse GuzzleHttp\\RequestOptions;use Spatie\\Sitemap\\Crawler\\Profile;return [ /* * These options will be passed to GuzzleHttp\\Client when it is created. * For in-depth information on all options see the Guzzle docs: * * http://docs.guzzlephp.org/en/stable/request-options.html */ 'guzzle_options' =&gt; [ /* * Whether or not cookies are used in a request. */ RequestOptions::COOKIES =&gt; true, /* * The number of seconds to wait while trying to connect to a server. * Use 0 to wait indefinitely. */ RequestOptions::CONNECT_TIMEOUT =&gt; 10, /* * The timeout of the request in seconds. Use 0 to wait indefinitely. */ RequestOptions::TIMEOUT =&gt; 10, /* * Describes the redirect behavior of a request. */ RequestOptions::ALLOW_REDIRECTS =&gt; false, ], /* * The sitemap generator can execute JavaScript on each page so it will * discover links that are generated by your JS scripts. This feature * is powered by headless Chrome. */ 'execute_javascript' =&gt; false, /* * The package will make an educated guess as to where Google Chrome is installed. * You can also manually pass it's location here. */ 'chrome_binary_path' =&gt; null, /* * The sitemap generator uses a CrawlProfile implementation to determine * which urls should be crawled for the sitemap. */ 'crawl_profile' =&gt; Profile::class,]; 自訂 Sitemap Generator自訂爬蟲配置您可以使用 Spatie\\Crawler\\CrawlProfiles\\CrawlProfile 介面和通過客製 shouldCrawl() 方法控制那些 URL，網址，Sub-Domain 要爬。 1234567891011121314use Spatie\\Crawler\\CrawlProfiles\\CrawlProfile;use Psr\\Http\\Message\\UriInterface;class CustomCrawlProfile extends CrawlProfile{ public function shouldCrawl(UriInterface $url): bool { if ($url-&gt;getHost() !== 'localhost') { return false; } return $url-&gt;getPath() === '/'; }} 然後在設定檔 config/sitemap.php 註冊 123456789return [ ... /* * The sitemap generator uses a CrawlProfile implementation to determine * which urls should be crawled for the sitemap. */ 'crawl_profile' =&gt; CustomCrawlProfile::class, ]; 變更屬性舉例要變更聯絡頁面 /contact 的 lastmod，changefreq，和 priority 1234567891011121314use Carbon\\Carbon;use Spatie\\Sitemap\\SitemapGenerator;use Spatie\\Sitemap\\Tags\\Url;SitemapGenerator::create('https://example.com') -&gt;hasCrawled(function (Url $url) { if ($url-&gt;segment(1) === 'contact') { $url-&gt;setPriority(0.9) -&gt;setLastModificationDate(Carbon::create('2016', '1', '1')); } return $url; }) -&gt;writeToFile($sitemapPath); 忽略連結如果您不希望某些被爬到的連結出現在 Sitemap 可以在 hasCrawled 處理 123456789101112use Spatie\\Sitemap\\SitemapGenerator;use Spatie\\Sitemap\\Tags\\Url;SitemapGenerator::create('https://example.com') -&gt;hasCrawled(function (Url $url) { if ($url-&gt;segment(1) === 'contact') { return; } return $url; }) -&gt;writeToFile($sitemapPath); 防止爬蟲讀取某些頁面您也可以在爬蟲這邊設定忽略某些頁面。注意 shouldCrawl 只有在預設爬蟲或自訂爬蟲有實作 shouldrawlCallback 時才有作用： 123456789101112use Spatie\\Sitemap\\SitemapGenerator;use Psr\\Http\\Message\\UriInterface;SitemapGenerator::create('https://example.com') -&gt;shouldCrawl(function (UriInterface $url) { // All pages will be crawled, except the contact page. // Links present on the contact page won't be added to the // sitemap unless they are present on a crawlable page. return strpos($url-&gt;getPath(), '/contact') === false; }) -&gt;writeToFile($sitemapPath); 設定爬蟲爬蟲本身可以設定執行一些不同的事情。您可以利用 Sitemap Generator 來設定，例如忽略 robot 檢查 12345SitemapGenerator::create('http://localhost:4020') -&gt;configureCrawler(function (Crawler $crawler) { $crawler-&gt;ignoreRobots(); }) -&gt;writeToFile($file); 限制存取頁數1234use Spatie\\Sitemap\\SitemapGenerator;SitemapGenerator::create('https://example.com') -&gt;setMaximumCrawlCount(500) // only the 500 first pages will be crawled 執行 JavaScript 備註：目前在 Laravel 8 啟用該設定並無法正確讀取 Inertia 產生的連結。 Sitemap Generator 會在每個讀取頁面執行 JavaScript ，因此可以讀取使用 JS 產生的連結。要提供此功能只須將 excute_javascript 設成 true。 底層 headless Chrome 會執行 JavaScript 。如何安裝 手動加入連結12345678use Spatie\\Sitemap\\SitemapGenerator;use Spatie\\Sitemap\\Tags\\Url;SitemapGenerator::create('https://example.com') -&gt;getSitemap() // here we add one extra link, but you can add as many as you'd like -&gt;add(Url::create('/extra-page')-&gt;setPriority(0.5)) -&gt;writeToFile($sitemapPath); 加入替代連結多語系的網站對於一個頁面可能有多個替代的版本。基於這個情境您可以加入替代的連結 12345678use Spatie\\Sitemap\\SitemapGenerator;use Spatie\\Sitemap\\Tags\\Url;SitemapGenerator::create('https://example.com') -&gt;getSitemap() // here we add one extra link, but you can add as many as you'd like -&gt;add(Url::create('/extra-page')-&gt;setPriority(0.5)-&gt;addAlternate('/extra-pagina', 'nl')) -&gt;writeToFile($sitemapPath); 純手動建立 Sitemap1234567use Carbon\\Carbon;Sitemap::create() -&gt;add('/page1') -&gt;add('/page2') -&gt;add(Url::create('/page3')-&gt;setLastModificationDate(Carbon::create('2016', '1', '1'))) -&gt;writeToFile($sitemapPath); 資源 Automatically generate a sitemap in Laravel Github","link":"/2021/09/10/laravel-auto-sitemap/"},{"title":"JavaScript 8 種資料格式 4 種轉型數字方式","text":"備忘範例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// ~ Bitwise NOT Operator = ~N = -(N + 1)// ~'abc' = -1// ~~'abc' = 0/* '1.1' */+'1.1'; // 1.1Number('1.1'); // 1.1~~'1.1' // 1parseInt('1.1'); // 1/* '1e1' */+'1e1'; // 10Number('1e1'); // 10~~'1e1'; // 10parseInt('1e1'); // 1/* '1px' */+'1px'; // NaNNumber('1px'); // NaN~~'1px'; // 0parseInt('1px'); // 1/* 'p1' */+'p1'; // NaNNumber('p1'); // NaN~~'p1'; // 0parseInt('p1'); // NaN/* '010' */+'010'; // 10Number('010'); // 10~~'010'; // 10parseInt('010'); // 10 ECMAScript 3 值為 8 ，預設八進制 ES5 之後變更為 10 進制。/* '0xf' */+'0xf'; // 15Number('0xf'); // 15~~'0xf'; // 15parseInt('0xf'); // 15/* [1] */+[1]; // 1Number([1]); // 1~~[1]; // 1parseInt([1]); // 1/* [1, 2] */+[1, 2]; // NaNNumber([1, 2]); // NaN~~[1, 2]; // 0parseInt([1, 2]); // 1// 只要 `+` 為 NaN， `~~` 為 0// parseInt 則看起始字元是否為數值 Falsy12345678if (false)if (null)if (undefined)if (0)if (NaN)if ('')if (&quot;&quot;)if (``)","link":"/2021/08/25/eight-quick-convert-string-to-number/"},{"title":"[譯] CSS 容器查詢 (CSS Container Query)","text":"作為前端開發人員，在過去六年中，我沒有像現在這樣對 CSS 的新功能感到興奮。容器查詢（Container Query）現在已經可以通過在 Chrome 設定參數啟動支援。感謝那些像是 Miriam Suzanne 的人的努力。 我記得看過很多關於支援 CSS 容器查詢的笑話，但最終它成為現實。這篇文章試著了解為什麼我們會需要容器查詢，以及我們如何使用它們簡化開發，更重要的是您可以實現更強大的元件和佈局。 CSS Media Query 的問題一個網頁通常由不同的區塊和元件組成，然後我們利用 CSS Media Query 讓它們支援 RWD。這機制沒有什麼問題，但有一些限制。例如我們可以使用 Media Query 在行動裝置呈現元件最小化的版本。 很多時候，RWD 並不是由 Viewport 或螢幕大小來決定的，而應該是由容器的大小來決定。試想下面的範例： 上面我們由一個非常典型的佈局，其中包含卡片元件。它有兩種形式 在側邊欄的堆疊格式 在右邊的水平排列版本 CSS 有很多方法可以實作，但最常見的是如下面。我們需要先建立一個基本的元件，然後加入變化的版本 12345678910111213141516171819202122.c-article {}.c-article &gt; * + * { margin-top: 1rem;}/* 水平版本 */@media (min-width: 46rem) { .c-article--horizontal { display: flex; flex-wrap: wrap; } .c-article &gt; * + * { margin-top: 0; } .c-article__thumb { margin-right: 1rem; }} 注意到我們加了 .c-article-horizontal 來處理水平版本的元件。如果螢幕或瀏覽器寬（viewport）大於 46rem 那元件就會套用水平版本。 上面的作法還算沒問題，但有點受到限制。我們希望元件可以直接根據父元素的寬來反應變化，而不是瀏覽器的 viewport 大小。 思考一下，如果我們想要在右邊主要區塊使用預設的 .c-article 會變成怎樣？ 那麼，卡片元件將會依據父元素的寬來伸展自己的寬，導致變的太大，如下圖： 這個問題我們就可以使用 CSS 容器查詢來解決。在我們深入之前我們先看一下我們遇到的需求 我們希望元件可以根據上層父元素的寬來調整，假如大於 400px 就切換成水平格式。範例程式如下： 123456789101112&lt;div class=&quot;o-grid&quot;&gt; &lt;div class=&quot;o-grid__item&quot;&gt; &lt;article class=&quot;c-article&quot;&gt; &lt;!-- content --&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class=&quot;o-grid__item&quot;&gt; &lt;article class=&quot;c-article&quot;&gt; &lt;!-- content --&gt; &lt;/article&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213.o-grid__item { contain: layout inline-size;}.c-article { //}@container (min-width: 400px) { .c-article { /* 直接套用水平樣式，而不是預設 .c-article 的樣式 */ }} CSS 容器查詢如何協助我們？使用 CSS 容器查詢我們可以解決上面的問題並建置一個彈性的元件。這意味著在較窄的父元素中，元件會變成一般垂直排列的版本。父元素如果較寬則會使用水平版本。它們都是基於父元素的寬而不是瀏覽器 viewport。 下面是圖示： 右邊紫色寬表示父元素的寬。注意到當父元素變寬，元件會跟著變化。這就是 CSS 容器查詢強大的地方。 容器查詢如何運作？我們現在可以在 Chrome 實驗這個功能。要啟動需要在網址列輸入 chrome://flags 搜尋 container queries 並啟動。 第一步是加入 contain 屬性。由於一個元件會需要基於父元素的寬變動，因此我們需要告訴瀏覽器只需要重繪（Repaint）影響的區域，而不是整個頁面。使用 contain 屬性，我們可以讓瀏覽器知道這個前提。 筆記：有興趣的深入理解 contain 可以參考： 前端三十｜03. [CSS] Reflow 及 Repaint 是什麼？ 提高 CSS 动画性能的正确姿势 CSS新特性contain，控制页面的重绘与重排 MDN - CSS/contain 設定了 layout 的元素即設定了佈局限制，也就是內部（子元素）的樣式變化不會影響外部，外部也不會影響內部。如此可以將渲染元素的數量降低，而不是渲染整個頁面。 inline-size 表示只回應父級元素寬的變化，我嘗試過 block-size 但目前沒作用，如果有任何錯誤請糾正。 注意：這個部分會依據瀏覽器支援的更新有不同的狀態。 12345678910111213&lt;div class=&quot;o-grid&quot;&gt; &lt;div class=&quot;o-grid__item&quot;&gt; &lt;article class=&quot;c-article&quot;&gt; &lt;!-- content --&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class=&quot;o-grid__item&quot;&gt; &lt;article class=&quot;c-article&quot;&gt; &lt;!-- content --&gt; &lt;/article&gt; &lt;/div&gt;&lt;/div&gt; 123.o-grid__item { contain: layout inline-size;} 第一步我們定義了 .o-grid__item 作為 .c-article 元件的父元素容器。下一步加入我們希望支援容器查詢的樣式。 12345678@container (min-width: 400px) { .c-article { display: flex; flex-wrap: wrap; } /* other CSS.. */} @container 等於是 .o-grid__item 元素，然後 min-width: 400px 是寬的條件。我們當然可以加入更多樣式。 下面是展示卡片元件行為的影片 完成的樣式如下： 預設卡片元件的樣式 水平版本卡片樣式搭配小縮圖 水平版本卡片樣式搭配大縮圖 如果父元素太大，則樣式調整為類似橫幅的樣式 接著，讓我們更深入 CSS 容器查詢。 CSS 容器查詢的使用情境CSS 容器查詢與 CSS Grid auto-fit針對某些情況如在 CSS Grid 中使用 auto-fit 有可能會造成非預期的結果，比如一個元件變的太寬或內容不容易閱讀。 為了讓您能了解上面敘述的情境，下面提供一個 auto-fit 和 auto-fill 差異的視覺化圖片 注意！當使用 auto-fit 時，項目會自動擴展多餘的空間。但在 auto-fill 的情況，在欄位數量未達上限的情況是不會挪用當前閒置的空間的。 如果您不是很理解 auto-fit 和 auto-fill 可以參考下面資源： auto-fill ? auto-fit ? 我們不一樣。 auto-fill vs. auto-fit 您現在可能會想說這跟 CSS 容器查詢有什麼關係？那麼如果每一個 Grid Item 就是我們的容器呢，它們都套用了 auto-fit，而我們的元件需要基於它們來調整。 1234567891011121314&lt;div class=&quot;o-grid&quot;&gt; &lt;div class=&quot;o-grid__item&quot;&gt; &lt;article class=&quot;c-article&quot;&gt;&lt;/article&gt; &lt;/div&gt; &lt;div class=&quot;o-grid__item&quot;&gt; &lt;article class=&quot;c-article&quot;&gt;&lt;/article&gt; &lt;/div&gt; &lt;div class=&quot;o-grid__item&quot;&gt; &lt;article class=&quot;c-article&quot;&gt;&lt;/article&gt; &lt;/div&gt; &lt;div class=&quot;o-grid__item&quot;&gt; &lt;article class=&quot;c-article&quot;&gt;&lt;/article&gt; &lt;/div&gt;&lt;/div&gt; 1234.o-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));} 當我們有 4 個元素時如下 當文章數量變少的時候，因為使用了 auto-fit 容器會變寬。如下圖所示第一個看起來還可以，但後面兩個太寬了 如果每一個文章元件都可以隨著自己的父元素寬變化呢？如此我們便能得到 auto-fit 的好處；如果 Grid Item 大於 400px，那麼元件就應該切換成水平版本。 這裡我們可以： 12345678910.o-grid__item { contain: layout inline-size;}@container (min-width: 400px) { .c-article { display: flex; flex-wrap: wrap; }} 同時我們希望當只有一個文章元件的時候顯示橫幅效果的樣式 123456789101112131415161718192021.o-grid__item { contain: layout inline-size;}@container (min-width: 700px) { .c-article { display: flex; justify-content: center; align-items: center; min-height: 350px; } .card__thumb { position: absolute; left: 0; top: 0; width: 100%; height: 100%; object-fit: cover; }} 就這樣我們的元件可以對應各種父元素的寬。不覺得這樣很棒？ 側邊欄和主要區塊很多時候我們需要調整元件讓它能夠適應寬比較窄的容器例如 &lt;aside&gt;。 下圖和此需求完美符合的就是訂閱通知的區塊。當寬變小，我們希望項目堆疊排列，以及當空間足夠的時候則水平排列。 如上圖所示，我們的訂閱通知區塊在兩個大區塊都有。 側邊欄下方 主要區塊下方 如果沒有容器查詢，要完成這個需求會有點複雜，我們須支援不同的 CSS 類別，舉例來說 .newsletter--stacked等等。 我知道我們可以使用 flex 的 wrap 來處理，當空間不夠的時候換行，但這還不夠。我們需要控制更多細節例如： 隱藏特定元素 讓按鈕支援全寬 12345678910111213141516171819202122232425262728293031.newsletter-wrapper { contain: layout inline-size;}.newsletter { /**/}.newsletter__title { font-size: 1rem;}.newsletter__desc { display: none;}@container (min-width: 600px) { .newsletter { display: flex; justify-content: space-between; align-items: center; } .newsletter__title { font-size: 1.5rem; } .newsletter__desc { display: block; }} 下面的影片就是結果的展示： Codepen範例 分頁列分頁列的部分也是很適用於容器查詢。一開始我們可以有上一頁和下一頁按鈕，隱藏其他按鈕，然後當空間夠時顯示全部分頁。 如下圖： 要處理上述狀況，我們需要從預設情形開始處理，然後再處理其他情況。 1234567891011121314151617181920212223242526272829.wrapper { contain: layout inline-size;}@container (min-width: 250px) { .pagination { display: flex; flex-wrap: wrap; gap: 0.5rem; } .pagination li:not(:last-child) { margin-bottom: 0; }}@container (min-width: 500px) { .pagination { justify-content: center; } .pagination__item:not(.btn) { display: block; } .pagination__item.btn { display: none; }} Codepen範例 個人資料 這是另一個非常適合在多個情境使用的例子。小的樣式適合小的 viewport 如側邊欄，大的樣式可以給較寬的情境。 123456789101112131415161718192021.p-card-wrapper { contain: layout inline-size;}.p-card { /* Default styles */}@container (min-width: 450px) { .meta { display: flex; justify-content: center; gap: 2rem; border-top: 1px solid #e8e8e8; background-color: #f9f9f9; padding: 1.5rem 1rem; margin: 1rem -1rem -1rem; } /* and other styles */} 通過上面的方式，我們可以不額外使用其他 Media Query 讓元件在不同情境顯示不同資訊或樣式 Codepen範例 Form 表單元素我還沒深入表單的使用案例，但能直接想到是關於標籤水平和垂直排列的顯示 12345678910111213141516.form-item { contain: layout inline-size;}.input-group { @container (min-width: 350px) { // @container = .input-group display: flex; align-items: center; gap: 1.5rem; input { flex: 1; } }} Codepen範例 測試元件我們已經看了一些 CSS 容器查詢的使用案例，那我們要怎麼測試元件？感謝 CSS 的 resize 屬性； 12345.parent { contain: layout inline-size; resize: horizontal; overflow: auto;} 從 CSS-Only Resizable Elements - Bramus Van Damme 的文章學習到可以利用 resize 來達成測試的目的。 能否輕易的使用 DevTool 為容器查詢偵錯？目前的答案是 - 否。您不能看到任何像是 @container (min-width: value) 的東西，但我認為只是時間問題，未來應該會支援。 是否能提供不支援的瀏覽器替代的方案？可以透過特定的方式來支援。下面有兩篇文章您可以參考： Container Query Solutions with CSS Grid and Flexbox by Stephanie Eckles Container Queries are actually coming by Andy Bell 結論目前來說瀏覽器還沒正式支援，但您已經可以在瀏覽器測試這項功能。作為前端開發者我們應該協助那些功能的開發人員測試。在實驗階段越多的測試，後續的問題將越少。 參考資源 Say Hello To CSS Container Queries CSS Container Query Units","link":"/2021/09/26/css-container-query/"},{"title":"您必須了解關於 AWS 的 IOPS","text":"假如您持續深入了解 AWS ，您肯定會發現系統層面比您想像的還要複雜。EBS 儲存空間也不例外！ 掛載儲存體到一個伺服器或主機看似相對簡單，然後您發現您的應用程式有點慢。不知道到底是什麼原因直到您看到 Stack Overflow 的討論關於 IOPS 和吞吐量（Throughput）的問題。在面對這個問題幾次之後，我決定要研究一下這個問題。 下面是我嘗試理解為什麼 EBS 變成效能瓶頸的原因。 AWS 有 SSD 和傳統的磁盤硬碟，這裡我們說的是 SSD 的部分，如果您不是很確定您使用的，大概多數都是 SSD。 IOPS當提到 EBS 效能，IOPS 是您在 AWS 文件和部落格幾乎都會看到的東西。當然我們會提到其他比 IOPS 還重要的東西，不過讓我們從這裡開始。 IOPS （Input / Output Operations per Second）每秒的輸入輸出操作 每一個操作是指硬碟的讀寫 每一個操作的讀寫資料量可能有所不同 那麼 IOPS 是怎麼計算的？ 計算 IOPS 如果一個操作的資料大於 256KB 則該操作會被切割成多個操作 在 AWS，每一個操作的資料上限是 256 KB，超過 256KB 會被分成多個操作。 意思是如果您執行一個 1024KB 資料的操作，那就是 4 個 IOPS 1024/256 = 4 另外，隨機讀寫小於 256KB 資料的操作可能造成多個操作 IOPS 限制硬碟的 IOPS 是有限制的，大量的操作會快速增加 IOPS 導致達到上限。 吞吐量（Throughput ）限制 您很可能在達到 IOPS 限制之前，就先踩到吞吐量限制 這就是讓 IOPS 變的更複雜的地方。非常有可能因為一次讀取大量的資料，造成根本還沒達到 IOPS 的限制，先遇到吞吐量限制。 舉例來說：如果您的操作資料為 256KB，硬碟吞吐量上限為 250MB，也就是硬碟只有 1000 IOPS。 因為 1000 * 256KB = 256MB，也就是說 1000 個 256KB IOPS 讀寫操作會踩到 250MB 吞吐量限制 從上面範例得知： 256KB 是一個操作被切割成多個 IOPS 的限制 250MB 是這個 gp2 硬碟空間的吞吐量吞吐量限制 真實的吞吐量限制會根據 AWS 硬碟類型（gp2, gp3）和其設定而不同。gp2 的最大限制是 334GB。 GP2 的吞吐量限制計算 1Throughput in MiB/s = ((Volume size in GiB) × (IOPS per GiB) × (I/O size in KiB)) GP3 的吞吐量須明確設定，如果您設定超過 125MB 則需額外付費。GP3 可以直接增加限制。 EC2 也有屬於自己的吞吐量限制，可能您也會遇到。而在新的 Instance 類型比較不會遇到，但還是需要注意網路 IO 的流量。 儲存體佇列儲存體還有可能讓 I/O 進入待辦狀態（Pending）。表示硬碟可能跟不上 IOPS 的請求。CloudWatch 有個稱為 VolumeQueueLength 的測量值就是用來描述上面的佇列值。下面我們會進一步解釋。 GP2 vs GP3 EBS接著我們來討論一下最常見的兩種硬碟類型 GP2, GP3。一般來說您最好選 GP3，但 GP2 類型在建立 EC2 還是維持預設，並且也是 RDS 資料庫目前唯一使用的類型。 下面是關於他們的介紹： GP2GP2 類型是隨著空間大小來擴展 IOPS，每 GB 的空間取得 3 IOPS，對於低於 33.333GB 的硬碟則至少獲得 100 IOPS 吞吐量也是隨著硬碟空間擴展。如上提到的計算吞吐量限制的公式 Throughput in MiB/s = ((Volume size in GiB) × (IOPS per GiB) × (I/O size in KiB))。上限為 250MB。 突發機制信用（Burst Credits）會隨著時間跟著 IOPS 數量增加。（當您突然超過您原本用量限制，會有一個突發機制 Burst Credits 就是暫時會讓你付費使用超出的用量） 1000GB 之後，您會取得 3000 IOPS 並且不再有突發機制。您可以直接控制 GP2 硬碟的部分就只有空間大小。 長時間來說，AWS 當然會希望您購買更多空間大小來解決 IOPS 和吞吐量限制的問題。 GP3GP3 是新類型的硬碟類型。它們比 GP2 便宜並且提供更一致的效能。沒有突發機制的部分。GP3 應該是您的首選硬碟類型。 這種類型從 3000 IOPS 開始起跳，125MB 吞吐量。然後您可以直接付費調整 IOPS 和吞吐量。 從 GP2 轉移到 GP3 是非常簡單的 - 基本上就是調用一個 API 或在 Console 直接調整。AWS 在更改為 GP3 後“優化”EBS 驅動器時可能會有點降速。 這種設定的方式讓您能在調整 GP3 空間大小時還能控制預算。舉例來說您建立了 30GB 的硬碟但是讓吞吐量提高。 使用 GP3 可以比起預購 IOPS （io2）更能有效率的節省預算。參考官方文件 EBS 是效能瓶頸嗎？OK，那我們要怎麼知道 EBS 是造成效能瓶頸的地方？您需要觀察 CloudWatch。下面有些重要的指標 硬碟指標下面在 CloudWatch 的指標是跟 EBS 相關而不是 EC2。 BurstBalance該指標為百分比，應用在 GP2 硬碟上的，GP2 硬碟可以臨時增加到 3000 IOPS。當硬碟超出配給的 IOPS 時，突發機制的信用就會開始扣。到 0% 就表示硬碟達到 IOPS 的極限。 GP3 沒有這種機制因此沒有這個指標。 VolumeQueueLength這是測量有多少操作 “Pending” 了；數字越大越不好。 如果佇列數量非常高，表示您的工作負載在執行超過硬碟能負擔的操作。這是過多操作和吞吐量結合的指標。 那是什麼造成高佇列？基本上官方表示取決不同情況，可參考。 根據曾經管理一些超載硬碟的經驗，可以參考這裡的經驗比對您的狀況。 比較低負載的數值會小於 1，例如 0.00008，而超載的工作，數值通常是低於 2 ，偶爾出現 10 Volume[Read/Write][Bytes/Ops]這個指標是用來告訴您多少 Bytes 正在讀寫，以及多少操作正在發生。值很高的話不一定是不好，但肯定要注意。 Instance 指標下面的指標是在 CloudWatch 跟 EC2 有關的。Nitro/EBS 優化 EC2 實例有些和它們相關的指標。 下面的指標可以在 CloudWatch 找到，但不會出現在 EC2 管理介面的監測頁籤。 EBSByteBalance ESBIOBalance ESB[READ/Write] Bytes ESB[Read/Write] Ops 上面這些指標是用來表示 EC2 相關的一些峰值。然而並沒有找到具體的說明。 下面是一些找到的參考資料： This AWS blog post from 2018 CloudWatch Metrics for EC2 This page on EBS-Optimized instances 雖然找不到具體的說明，但最後一篇文章提供了一些有用的說明 您可以使用 EBSIOBalance 和 EBSByteBalance 指標來協助您確認 Instance 的規格是否正確。這些指標使用百分比表示。指標數值一直都很低的表示目標機器可以考慮提升規格（100% 是用扣的到 0% 等於用光）。如果數值都沒有低於 100% 的是可以考慮調降。 RDS 空間和指標RDS 相關的 CloudWatch 指標並沒有和 EBS 區分開來。值得注意的 RDS 指標（非 Aurora 數據庫）包括與我們上面看到的指標類似： Burst Balance (依據硬碟類型，例如 GP2 1000G 則有 3000 IOPS） Queue Depth Read/Write Throughput Read/Write/Total IOPS RDS 儲存空間在紀錄本文的同時，RDS 並不支援 GP3，這表示您需要配置更多的空間來增加 IOPS 和 Throughput 您也可以使用 io2 - 預購 IOPS 類型的硬碟，這樣就可以付費購買特定數量的 IOPS，但當然它們比一般 GP2 貴。 一個非常盛行的小技巧就是把 RDS 的硬碟升到 5334GB。這樣做不只消除了突發機制，也達到 GP2 IOPS 的上限 16000。吞吐量也到 334GB。 您也可查詢 官方表格 來確認各種規格的差異。 擴展 RDS 儲存空間是單向的。 一旦您升級就不能往下調，只能開新機器搬資料。 如果您正在查詢解決 RDS EBS 瓶頸的問題，您可能發現給資料庫 1000GB 就暫時夠了。每 GB $0.115，大小 5334GB 單一 AZ 一個月要 $613.41，多 AZ 一個月要 $1226.82。 Aurora EBS 效能Aurora 是一個特別的例子。當建立 Aurora 資料庫的時候，您會注意到您沒有任何關於儲存空間的設定。 那麼會有什麼效能上的差異？您可以從這篇文章看到一點線索。 文章似乎表示您的限制是根據實例的規格而不是 EBS 限制： 如果您工作負載需要高 IOPS 和高吞吐量，建議您移至 Aurora，其為針對高負載的需求提供了高效能，高可用性的解決方案。 當使用 Aurora，確保了技術上沒有 IOPS 的限制，但吞吐量還是會基於 Aurora Instance 規格的限制，如果要高吞吐量就選擇高規格的 Aurora Instance。 使用快照（Snapshots）另外值得一提的是當從快照建立 EBS 的時候，您不會立刻取得最大的效能。 您可以通過一些步驟設定，如果有需要的話。AWS 稱這個過程為初始化。您可以閱讀上面連結的文章或者使用 Fast Restore 功能。 快照的這些狀況同樣適用在 RDS 資料庫從快照還原的時候。 參考資源 What You Need to Know About IOPS","link":"/2021/09/24/aws-ebs-iops/"},{"title":"[譯] CSS 容器查詢單位","text":"幾天前（2021-09-18）我看到 Miriam Suzanne 的一則關於 CSS Query 單位支援的 Tweet 。這個功能最一開始是由 Una Kravets 建議提案。我忍不住試試看它們，看看我們可以從這個功能中得到什麼好處。 本文會嘗試解釋每個單位的運作和我們該如何使用它們，尤其是元件該如何因應父元素的寬。如果您還不知道什麼是 CSS 容器查詢。這裡有一些範例介紹和關於容器查詢如何影響我們的實作，如果您還沒有任何概念強烈建議您先閱讀該文章。 提醒：目前 CSS 容器查詢在 Chrome 需要額外設定；到 chrome://flags 搜尋 “Enable CSS Container Queries” 並啟動。 介紹在 CSS 中我們有很多單位並可以根據不同的目的使用它們。最常見的是 px，rem，em。如果要說什麼東西跟 CSS容器查詢單位的運作方式最接近，那麼當屬 viewport 單位。 CSS viewport 單位會根據瀏覽器視窗大小調整。很方便，但我們不希望這個單位總是基於瀏覽器的寬高變化。如果我們可以基於容器元素的寬呢？這就是容器查詢單位存在的目的。 為了清楚理解，我們特別標出 viewport 單位和容器查詢單位的差異在下圖： 在左邊 font-size 是由 rem 和 vw 組成也就是字體大小受到瀏覽器寬的影響。在一些情況下，這種方式沒什麼問題，但的確可能造成非預期的問題因為它是跟瀏覽器視窗關聯。 在處理元件中的 font-size，padding，margin 時，容器查詢單位可以節省我們的開發時間。我們不用手動調整，而是使用查詢單位。 想像一下下面的範例： 我們從卡片元件預設堆疊的樣式開始，到大橫幅樣式。像這樣的一個元件我們可能需要調整下面這些東西 縮圖的大小 字體大小 元素之間的空間 如果沒有查詢單位，我們須手動調整 1234567891011121314151617181920212223242526.card {}.card__title { font-size: 1rem;}/* 水平樣式 v1 */@container (min-width: 400px) { .card__title { font-size: 1.15rem; }}/* 水平樣式 v2 */@container (min-width: 600px) { .card__title { font-size: 1.25rem; }}/* 橫幅樣式 */@container (min-width: 800px) { .card__title { font-size: 2rem; }} 注意到 .card__title 的字體大小在不同查詢條件一直在改變。我們可以利用查詢單位搭配 clamp() 避免重複變更 font-size 的部分 123.card__title { font-size: clamp(1rem, 3qw, 2rem);} 上面這種方式我們只要定義一次即可。 如果您已經熟悉 viewport 單位，那麼容器查詢單位對您來說並不是什麼新東西，只是從基於瀏覽器 viewport 換成容器元素。 範例 容器查詢單位（Query Units）現在我們已經對於查詢單位要解決的問題有了概念，是時候來了解單位本身了，根據 CSS 規範 Query Width （qw）：容器寬的 1%。例如 5qw 等於容器元素寬的 5%。 Query Height（qh）：容器寬的 1%。例如 5qh 會解析為容器元素高的 5%。 還有 qi，qb，qmin，qmax 可以參考規範的說明。 提醒：目前這些單位還在實驗階段，譯者測試除了 qw 之外其他單位尚未理解具體的計算方式。 範例和使用情境卡片元件除了上面的範例，我們也可以使用查詢單位讓堆疊樣式的卡片加入其他樣式例如依據寬讓字體稍微變大： 注意到字體會基於寬稍微變大。如此一來無論卡片放在哪，它都可以運作的非常良好。 範例 根據重要性調整 font-size當一個元素比其他元素大的時候，有可能表示它比較重要。例如 aside 和 main 。&lt;aside&gt; 的標題應該要比 &lt;main&gt; 的標題小。 使用查詢單位的話，我們可以輕鬆完成這個需求： 首先，我們需要將兩個容器定義為 inline-size 的容器， 1234aside,main { container: inline-size;} MDN 文件 - container 屬性 然後，我們就可以使用查詢單位來設定標題樣式 1234.section-title { font-size: clamp(1.25rem, 3qw, 2rem); margin-bottom: clamp(0.5rem, 1.5qw, 1rem);} 範例 簡歷元件 簡歷元件可以在較小的容器例如側邊欄或行動裝置呈現，或則者較大的區塊如頁面的表頭。 我們可以讓元件適應其容器的寬，在這個範例使用者的大頭貼和字體大小都基於寬調整。 12345678910.bio { container: inline-size;}.c-avatar { --size: calc(60px + 10qw); width: var(--size, 100px); height: var(--size, 100px); margin-bottom: clamp(0.5rem, 3qmin, 2rem);} 範例 計數標題有些情況我們需要顯示計數數量，這種情況也非常適合使用查詢單位。 12345678910111213141516171819.article-body { counter-reset: heading;}h2 { container: inline-size; font-size: clamp(1.25rem, 3qw, 2rem); margin-bottom: clamp(0.5rem, 1.5qw, 1rem);}h2:before { --size: calc(1.25rem + 3qw); content: counter(heading); counter-increment: heading; width: var(--size); height: var(--size); font-size: calc(0.85rem + 1qw); margin-right: calc(var(--size) / 4);} 範例 動態間距過去，我們可以利用 viewport 單位來為 Grid 建立動態間距例如 123.wrapper { gap: calc(1rem + 2vw);} 那如果是特定容器中的元件呢？使用 viewport 單位情況會比較複雜，如果使用查詢單位就相對適合。 12345.card { display: flex; flex-direction: column; gap: calc(0.5rem + 1qmin); // qi qb 較小的那個} 如果使用查詢單位但沒有設定 container 會如何？瀏覽器會使用 viewport 單位的方式處理，例如下面範例： 123h2 { font-size: clamp(1.25rem, 3qw, 2rem);} 如果沒有設定容器，那麼 &lt;h2&gt; 的 3qw 會變成 viewport 寬的 3%。因此如果使用查詢單位請注意要設定容器。 總結暫時您可以先知道將來有這些單位即可，這些單位還不適合直接使用在正式環境上。 參考 CSS Container Query Units","link":"/2021/09/29/css-container-query-units/"},{"title":"您可能不知道關於 useState 的 7 件事","text":"在為我們的專案（React）進行程式碼審查的時候，我常發現開發成員沒有意識到關於 useState 提供的一些好用功能或討厭的陷阱。雖然這些觀念不是什麼重大的啟發，但每一個使用 Hook 的人都應該要了解。 更新用的 setter 具有一致的參考為了更具體的說明這點；所謂的更新 setter 就是陣列中的第二個函式，它們在每一次 render 時都會保持一致。因此您不需要將它們加入例如 useEffect 的相依參考。不要管 eslint-plugin-react-hooks 給出什麼警告。 12345const [count, setCount] = useState(0);const onChange = useCallback((e) =&gt; { // setCount 永遠不會變 setCount(Number(e.target.value));}, []); 設定相同的狀態值，什麼也不會執行useState 預設屬於 Pure Function (意指相同的輸入，永遠會得到相同的輸出，而且沒有任何顯著的副作用)。使用相同於當前的值執行更新函式不會有任何變化 - 不會更新 DOM，也不會刷新渲染，什麼事也沒有。 1234567const [isOpen, setOpen] = useState(props.initOpen);const onClick = () =&gt; { // useState 已經為我們判斷了 if (!isOpen) { setOpen(true); }}; 但是對於物件不適用： 12345const [{ isOpen }, setState] = useState({ isOpen: true });const onClick = () =&gt; { // 會觸發更新，因為物件參考是不一樣的 setState({ isOpen: false });}; 回傳 undefined 狀態這表示 setState 可以直接從 useEffect 箭頭函式中回傳。警告：Effect 參數函式不能回傳除了清除用的函式以外的東西 1234useLayoutEffect(() =&gt; { setOpen(true);}, []);useLayoutEffect(() =&gt; setOpen(true), []); useState 即 useReducer事實上，useState 在 React 內部的實作類似於一個 useReducer，只是搭配一個預先定義的 reducer ，至少在 17.0 版本開始是這樣。參考原始碼。如果有人聲稱 useReducer 有更進階的技術優勢，他是騙人的。 您可以使用 callback 初始化狀態您可以使用初始化函式來取代物件 1234const [style, setStyle] = useState(() =&gt; ({ transform: props.isOpen ? null : 'translateX(-100%)', opacity: 0})); 您可以在初始化函式中使用 props 。坦白說，這有點過度優化。您都可以建立一堆 vDOM 了，為啥要擔心一個物件？不過對於繁重的初始化邏輯這的確有幫助。 另外，如果您想要在狀態使用函式，您可以額外在包一層函式 useState(() =&gt; () =&gt; console.log('gotcha!')) 您可以使用 callback 更新狀態Callback 函式也可以用來更新狀態；像一個沒有 action 的 reducer。由於當前的狀態和閉包的狀態值可能不同 123456789101112const [clicks, setClicks] = useState(0);const onMouseDown = () =&gt; { // 這樣會跟預期不一樣，您以為總共 +2 但只有 + 1 setClicks(clicks + 1); setClicks(clicks + 1);};const onMouseUp = () =&gt; { // 維持用閉包紀錄的值 + 1 setClicks(clicks + 1); // 這樣就可以讀取最新當前的值，完成我們的需求 setClicks(clicks =&gt; clicks + 1);}; 比較正確的作法 123456const [isDown, setIsDown] = useState(false);// 不好，每次 isDown 變更都會更新const onClick = useCallback(() =&gt; setIsDown(!isDown), [isDown]);// 比較好const onClick = useCallback(() =&gt; setIsDown(v =&gt; !v), []); 一個狀態更新 = 一次非同步的渲染React 有一個功能稱為 batching，它會強制多個 setState 調用彙整成一次渲染，但不總是如預期的運作。我們來看一下下面的程式碼： 1234567console.log('render');const [clicks, setClicks] = useState(0);const [isDown, setIsDown] = useState(false);const onClick = () =&gt; { setClicks(clicks + 1); setIsDown(!isDown);}; 當您呼叫 onClick 的時候，會渲染幾次取決於您如何調用。查看 範例 使用 &lt;button onClick={onClick}&gt; 會正確彙整成一次渲染 useEffect(onClick, []) 也會正確彙整 setTimeout(onClick, 100)就會觸發額外的渲染 el.addEventListener('click', onClick) 也不會正確彙整成一次渲染 這些在 React 18 會更新，在這之前您需要使用 unstable_batchedUpdates 來強制彙整 12345import {unstable_batchedUpdates} from 'react-dom';unstable_batchedUpdates(() =&gt; { setClicks(clicks + 1); setIsDown(!isDown);}); 總結 [state, setState] = useState() 的 setState 每次渲染參考都一樣 setState(currentValue) 不會做任何事。if (value !== currentValue) 可以省略。 useEffect(() =&gt; setState(true)) 不會破壞 Effect 清除功能 useState 內部的實作是一個預先定義 reducer 的 useReducer 初始化可以使用 callback；useState(() =&gt; initialValue) 當前狀態的更新建議使用 callback，尤其是搭配 useCallback React 彙整多次狀態更新成一次渲染的機制在某些情況下不會正確運作 參考 7 things you may not know about useState","link":"/2021/09/29/seven-things-you-may-not-know-about-usestate/"},{"title":"使用 Zoom API (1)","text":"Zoom API 允許開發者從 Zoom 請求平台的資訊，包含但不限於使用者詳細資料，會議報告，儀表板資料，以及執行平台的一些功能。例如建立新的使用者或刪除會議紀錄。 驗證每一個到 Zoom API 的 HTTP 請求必須經過 Zoom 的驗證。Zoom 支援下列驗證方式： OAuth 2.0 JWT 使用 OAuth 2.0OAuth 2.0 讓應用程式可以利用 Zoom API 獲取 Zoom 的資源例如使用者個人資料。下面提供關於 OAuth 協定的概覽。要開始使用 OAuth 首先必須在 Zoom App Marketplace 為您的應用程式建立 OAuth App。 OAuth 角色OAuth 協定定義了 4 個特定角色。這些角色參與了 Zoom API 驗證的流程： 資源擁有者 - Zoom 的使用者，他們可以授權或拒絕客戶端存取使用者帳戶的資源 資源伺服器 - 提供資源的伺服器。如果您的應用程式整合了 Zoom API 以獲取使用者相關資料，Zoom API 伺服器即資源伺服器。 客戶端 - 發出使用者資料請求的應用程式。如果您的應用程式向 Zoom API 發出請求，那麼您的應用程式即客戶端。 Zoom 驗證伺服器 - 驗證伺服器發出存取金鑰讓驗證成功的客戶端授權取得資源擁有者的資源 一般來說，客戶端，Zoom 使用者，Zoom 驗證伺服器，Zoom API 之前的互動關係如下圖： 客戶端請求 Zoom 使用者授權存取使用者資訊。 使用者授權該應用程式，該應用程式收到授予授權。 應用程式向 Zoom 驗證伺服器提供授予授權資訊驗證是否收到使用者的授權進而允許存取使用者資料。 Zoom 驗證伺服器驗證使用者已經授權該應用程式，並回傳存取金鑰和更新金鑰給應用程式。在調用 Zoom API 時必須使用存取金鑰（Access Token） 應用程式對 ZoomAPI 發出包含存取金鑰的請求。金鑰過期會無效，在這種情況下必須使用更新金鑰請求另一個有效的金鑰。 Zoom API 檢查金鑰無誤之後，使用 JSON 格式回傳請求的資源。如果驗證失敗，而回傳錯誤訊息。 OAuth 授權類型OAuth 授權是由資源擁有者發給客戶端的。授權類型指的是客戶端使用的授權驗證方式。 OAuth 2.0 支援了多種授權的方式。使用 Zoom API 您可以使用 Authorization Code 或 Client Credentials Authorization CodeAuthorization Code 是 Zoom API 最常使用的授權方式。使用方式在OAuth with Zoom有詳細描述 下面對於 Authorization Code 授權流程提供一個步驟的說明 客戶端將使用者導到 Zoom 驗證伺服器。使用者會看到授權請求和 scope 的相關說明。這個流程由 Zoom 所提供。當使用者安裝或重新安裝您的應用程式時，使用者會被導向 Zoom API 的驗證連結。如果要在本地使用您的應用程式對其測試，可以使用測試連結。導向的頁面大概如下圖所示： 使用者點擊授權 使用者會到導向應用程式的 redirect_url同時在 Query String 包含 Authorization Code，導向的連結組成大概如下https://yourappsredirecturl/?code={theauthorizationcode} 客戶端使用 Authorization Code 發送請求到 Zoom 要求 Access Token 12345678910111213141516171819202122232425var request = request('request');var options = { method: 'POST', url: 'https://zoom.us/oauth/token', qs: { grant_type: 'authorization_code', // 下面是 Authorization Code 的範例，您應使用您取得的 Code code: 'B1234558uQ', // 下面是 redirect_uri 範例 redirect_uri: 'https://abcd.example.com', }, headers: { // 下面的憑證是 base64 encoded 的。使用下面的程式碼範例產生您的 // &quot;Authorization: 'Basic ' + Buffer.from(your_app_client_id + ':' + your_app_client_secret).toString('base64')&quot; Authorization: 'Basic abcdesdkjfesjfg', },};request(options, function(error, response, body) { if (error) { throw new Error(error); } console.log(body);}) Client CredentialsClient Credentials 授權方式取得的 Token 只能用在服務層級。意思是無法取得使用者的權限，只針對應用程式。 例如可以使用 Client Credentials 取得聊天機器人服務的 Token 進而使用 Chatbot Messages API。 要使用 Client Credentials，步驟如下： 到 Zoom App Marketplace 的管理介面 在 App Credentials 複製 Client ID 和 Client Secret 發送 POST 請求到下面的驗證網址 https://zoom.us/oauth/token?grant_type=client_credentials 12345678910111213141516var request = require('request');var options = { method: 'POST', url: 'https://zoom.us/oauth/token?grant_type=client_credentials', headers: { // &quot;Authorization: 'Basic ' + Buffer.from(your_app_client_id + ':' + your_app_client_secret).toString('base64')&quot; authorization: 'Basic abcdsdkjfesjfg' }};request(options, function(error, response, body) { if (error) throw new Error(error); console.log(body);}); 在您收到 Access Token 之後就可以使用 Chatbot Messages API 了。 使用 JWTJSON Web Token 讓我們可以使用一個 JSON 物件來建立一個安全傳輸的 Token。JWT 包含簽章的資料協助建立伺服器對伺服器的驗證。 如果只有您會您的 Zoom 帳戶會在應用程式中使用，那麼建議您可以使用 JWT 驗證。要完成這個功能，需要先在 Zoom App Marketplace 註冊 JWT App。使用該 JWT App 產生的 Token 來發送 API 請求即可。 更多詳細介紹可以參考 JWT with Zoom API 請求所有 API 請求必須使用 HTTPS 。https://api.zoom.us/v2/ 是 API 的網址，完整的端點路徑會基於不同的資源而不同。 例如，要取得使用者詳細資料則是 GET https://api.zoom.us/v2/users/{userId} 。如果您的應用程式是已經在 Zoom App Marketplace 註冊帳戶層級的 OAuth 應用程式，您的應用程式必須取得 user:read:admin scope 才能使用這個 User API JWT 應用程式請求JWT 應用程式不需要 scope。您的 JWT 應用程式一般只能存取您自己的帳戶資訊。要檢視特定使用者的資料，您必須要提供 userId 或電子郵件作為 {userId} 。也可以使用 me 這個關鍵字取代 userId 值。 123456789101112131415var request = require(&quot;request&quot;);var options = { method: 'GET', url: 'https://api.zoom.us/v2/users/sjkf1234', headers: { authorization: 'Bearer {yourtokenhere}' // Do not publish or share your token publicly. }};request(options, function (error, response, body) { if (error) throw new Error(error); console.log(body);}); OAuth 應用程式請求使用者層級的 OAuth 應用程式要取得使用者資料， 應用程式必須要有 user:read scope。雖然端點路徑一樣，但 userId 值的行為和帳戶層級應用程式不同。不是使用 userId 或電子郵件，而是必須得使用 me 這個關鍵字作為 userId 的值，否則會收到無效 Token的錯誤。 123456789101112131415var request = require('request');var options = { method: 'POST', url: 'https://api.zoom.us/v2/users/me', headers: { authorization: 'Bearer {yourtokenhere}' }};request(options, function (error, response, body) { if (error) throw new Error(error); console.log(body);}); me 關鍵字您可以任何有 userId 的 API 使用 me 關鍵字。當您使用 me 關鍵字時， API 會使用通過驗證使用者的 Access Token。 例如要使用 API 更新通過驗證使用者的設定，您應該使用 /users/me/settings 而不是 /users/{userId}/settings。","link":"/2021/09/29/using-zoom-api-1/"},{"title":"[譯] 概覽 React 18 新功能","text":"React 18 alpha 已經釋出，穩定版可能幾個月後就會跟進。是時候聊聊加入的新功能了。如果您本來就不知道 React 那您可以略過這篇文章。 介紹新功能之前，我們先來看一些您有可能不熟的概念，例如 SSR，Suspense 還有 Hydration。如果您已經知道這些，您可以直接跳到 React 18 的變更一章。 深入新功能之前需要了解的概念Server Side Rendering伺服器端渲染 SSR 主要和改善使用者體驗和 SEO 有關，並不是針對改善應用程式的效能。當客戶端對一般 React 應用程式請求頁面時，伺服器會回應一些檔案。這種情境下有兩個很重要的檔案：第一個是一個幾乎為空的 HTML，第二個就是 bundle.js。應用程式依據路由在這個空的 HTML 中利用 JS 動態產生內容。這種模式叫做客戶端渲染，因為主要是由客戶端動態渲染。使用者最一開始會看到空白的頁面，接著當 bundle.js 下載完畢會動態渲染。 而 SSR 讓我們可以在伺服器端就產生 HTML 內容。因此當客戶端發出請求，伺服器會讀取需要的資料，渲染 HTML，接著送出回應。瀏覽器渲染的 HTML 會在伺服器端產生，而不再是幾乎沒有內容的 HTML。 Hydration如果應用程式內容很多或您預期使用者的網路很慢，選擇使用 SSR 是合理的。當 bundle.js 還在下載時，就算他們點擊的元素還不能使用，使用者至少可以先看到內容。然後當下載完成，事件掛載到 HTML 節點，一切功能就正常了。這個渲染 React 元件的流程，將事件掛載到 SSR 產生的 HTML 的過程就是 Hydration。 Suspense雖然上面看起來一切都很巧妙，但在使用 SSR 的時候可能會遇到瓶頸。舉例來說伺服器動態渲染 HTML 必須要等資料讀取完成，這表示如果需要從其他伺服器讀取資料就可能會變慢，而且您必須要等它完成，然後才會開始 Hydration 的處理。由於這非常沒有效率，React 工作小組在 2018 年引進了 Suspense Component ，該元件僅適用於 Lazy-Loaded 元件。讓使用者在等待非同步操作時，提供一個替代的內容。而它的行為在 React 18 會改變。 React 18 的變更全新 Root API vs 舊的 Root APIReact 應用程式是透過掛載到 DOM 根元素來建立的。如果您使用框架來建置專案，通常可以在 index.js 找到關聯 index.html 和 App.jsx 的程式碼。即 index.html 載入 index.js ，然後 index.js 負責執行掛載的行為。 12345import * as ReactDOM from &quot;react-dom&quot;import App from &quot;App&quot;// &lt;App/&gt; 元件會被直接掛載到 id 為 &quot;app&quot; 的 DOM 元素上ReactDOM.render(&lt;App tab=&quot;home&quot; /&gt;, document.getElementById(&quot;app&quot;)) 而新的 Root API 使用 ReactDOM.createRoot() 123456789import * as ReactDOM from 'react-dom';import App from 'App';const root = ReactDOM.createRoot(document.getElementById('app'));root.render(&lt;App tab=&quot;home&quot; /&gt;);// 如果有更新不用再整個 DOM 初始化root.render(&lt;App tab=&quot;profile&quot; /&gt;); 但為什麼要這麼做呢？其最大的好處在底層。為了使用下面提到改善的功能，您必須使用新的 Root API 而不是舊的 Root API。 內建功能優化這些優化是屬於被動的，意思是一旦您升級到 React 18 並使用新的 API 就會套用。如果您繼續使用舊的 API 則不會有這些新的好處。 自動 BatchingBatching 是 React 內部的一個處理機制，許多開發者沒有意識到它。而當您多關注開發者工具的 Console，會發現如果您在同一個事件連續的更新狀態，React 只會渲染一次。意思是 React 幫我們把這些操作合在一起，本來狀態更新加重新渲染要兩次會變成一次。 Batching 是一個很棒的機制，可以防止不必要的重新渲染，但 React 17 只支援在單一事件中合併它們。牽扯到 Promise，async，或其他原生事件則不會觸發這個機制。在 React 18，上述這些狀況 Batching 都會自動完成。 1234567891011121314151617181920212223242526function handleClick() { // React 17 會合併 // React 18 依然保持預設行為 setIsBirthday(b =&gt; !b); setAge(a =&gt; a + 1);}function handleClick() { fetchData().then(() =&gt; { // React 18 會合併，但 17 不會 setIsBirthday(b =&gt; !b); setAge(a =&gt; a + 1); })}setInterval(() =&gt; { // React 18 會合併，但 17 不會 setIsBirthday(b =&gt; !b); setAge(a =&gt; a + 1);}, 5000);element.addEventListener(&quot;click&quot;, () =&gt; { // React 18 會合併，但 17 不會 setIsBirthday(b =&gt; !b) setAge(a =&gt; a + 1)}) 另外，還可以使用 ReactDOM.flushSync() 來取消 Batching，但官方不建議頻繁使用它。 123456789101112import { flushSync } from 'react-dom';function handleClick() { flushSync(() =&gt; { setCounter(c =&gt; c + 1); }); // React 已更新 DOM flushSync(() =&gt; { setFlag(f =&gt; !f); }); // React 已更新 DOM} 其他更多細節可以參考 支援元件渲染 undefined直到 React 18，如果一個 Function 元件回傳 undefined，或沒有回傳任何東西。Class 元件的 render 方法回傳 undefined 或沒有回傳則會觸發錯誤警告；需回傳 JSX 元素或 null 。這主要是為了提醒開發者它他們忘記在元件中回傳元素。但 React 開發團隊認為這類型的檢查機制應該歸到 Linter 而不是函式庫內部。因此 React 18 您可以回傳 undefined SSR 支援 Suspense之前的版本在伺服器端並不支援 Suspense。新的 pipeToNodeWritable API 提供了完整的支援，更多資訊可以參考 Uncaptured Suspense在 React 17 如果一個元件還沒解析完成，如元件使用 React.lazy 載入，這時會找上層最近的 &lt;Suspense&gt;，然後渲染它的 fallback 直到該元件載入，如果上層沒有任何 &lt;Suspense&gt; 就會拋出錯誤。在 React 18 如果沒有 &lt;Suspense&gt;，則整個應用程式會暫停，意思是在該元件解析完成之前，什麼都不會渲染。 Suspense fallback 可使用 null 或 undefined之前的版本如果 &lt;Suspense&gt; 沒有 fallback 屬性，則該元件會被忽略並找尋上層下一個 &lt;Suspense&gt;。如果都沒有則拋出錯誤。在版本 18 fallback 可以是 null 或 undefined ，意思是不會往上找，就什麼東西都不渲染，直到該 &lt;Suspense&gt; 的元件解析完成。 併發功能 建議可以先閱讀 併發 CONCURRENCY 的說明，以對這裡說的併發有些了解。重點節錄：併發的意思是任務可以在同一段時間重疊。讓我們使用打電話來比喻。不支援併發意思是，我一次只能和一個人通電話。如果我打給 Alice，然後 Bob 打給我，我必須要掛掉 Alice 的電話然後才能和 Bob 講話。併發表示我每一在同一段時間有多個通話。例如：我還是保持和 Alice 通話狀態只是將電話擺在旁邊，然後跟 Bob 講話，後續還是可以回來和 Alice 講話。注意：併發不是說我一次要跟兩個人對話。而在 React 這個打電話（併發任務）指的是 setState。 程式中的併發指的是能同時執行多個任務的能力。但由於 React 執行在單執行緒上，因此必須決定執行順序（切換任務）。針對這個問題，React 使用一個 dispatcher 用來註冊 callback。在之前的版本，開發者完全不會碰到這些 API。版本 18 加入了併發功能使其有辦法更有效率的渲染內容外加揭露部分 API。這些新加入的併發功能支援多工協作，基於權重渲染，排程和中斷，也因此可以大大的改善使用者體驗。 在 16.3 版本加入的 &lt;StrictMode&gt; 也得到支援。可以提醒開發者使用併發功能時，如果包含不相容的程式碼可能造成錯誤。但顯然的對整個程式使用 &lt;StrictMode&gt; 很容易觸發一大堆警告。因此 React 開發團隊決定開發併發功能而不是併發模式，而您可以在使用併發功能的地方使用&lt;StrictMode&gt; 。 雖然 createRoot 讓整個應用程式變成了官方所謂的併發模式，但元件依舊可以渲染，除非您在元件中使用了下面提到的併發功能。如果您在某個元件使用了併發功能，那它和它的子元素結構就會套用併發渲染且 &lt;StrictMode&gt; 也會啟動相關功能。 startTransition在這個版本之前，React 有個非常重要的規則；沒有任何東西可以干擾渲染。一旦狀態變更，重新渲染就會被執行且沒有辦法阻止直到元件渲染完畢。在新版本，現在每個狀態會被分成；立即更新（Urgent Update）或過場更新（Transition Update）。 立即更新即使用者直覺預期會立刻產生回應，例如滑鼠點擊或按鍵盤。而過場更新則是會有一點延遲的動作例如搜尋；表示它們是可能中斷的。過場更新也是同步的，但在它們執行的時候 UI 不會被鎖住。 12345678910import { startTransition } from 'react';// &quot;立即更新&quot; 會直接顯示使用者輸入的資料， UI 會立刻更新渲染setInputValue(input);// 使用 startTransition 表示這是一個過場更新startTransition(() =&gt; { // 這個變更是可以中斷的 setSearchQuery(input);}); 您可以在這個討論找到上面的範例。如果 setSearchQuery(input) 沒有被標記為過場更新，則每次 input 改變時 UI 會鎖起來。現在利用 startTransition 該狀態變更被標註為過場更新，使用者可以搜尋並隨時在介面更新之前改變想法，不用等介面更新。 過去這種情況，我們可能要自己使用 debounce 來優化介面體驗 1234567891011121314151617import { useState, startTransition } from 'react';export default function App() { const [value, setValue] = useState(''); const onChange = (e) =&gt; { startTransition(() =&gt; { setValue(e.target.value); }); }; return ( &lt;div&gt; &lt;input type=&quot;text&quot; value={value} onChange={onChange} /&gt; &lt;/div&gt; );} 您甚至可以追蹤過場更新的待辦狀態 123456import { useTransition } from 'react';const [isPending, startTransition] = useTransition();{ isPending ? &lt;Spinner /&gt; : null} 想更了解併發概念和 startTransition 可以參考這篇圖文說明。還有這篇實務範例 useDeferredValueuseDeferredValue Hook 可以讓我們延遲更新部分的 UI，在指定時間內頁面持續可以操作。React 會試著盡快更新延遲狀態。如果在 timeoutMs 時間內未能完成就會強制更新，這時 UI 會被鎖起來。換句話說延遲狀態使用的是過場更新，而不是立即更新。 12345import { useDeferredValue } from 'react';cosnt deferredValue = useDeferredValue(value, { timeoutMs: 5000,}); 更多資訊可以參考官方文件 &lt;SuspenseList&gt;&lt;SuspenseList&gt; 支援您調整 &lt;Suspense&gt; 節點顯示的順序，就算完成資料取得的順序是不同的。一般，如果您在同一個階層有多個 &lt;Suspense&gt; ，它們會各自解析，但如果您希望這些元件照特定順序排列，而不是它們讀取資料或解析完成的時間順序。 12345678910111213import { Suspense, SuspenseList } from 'react';&lt;SuspenseList revealOrder=&quot;forwards&quot;&gt; &lt;Suspense fallback=&quot;Loading first item...&quot;&gt; &lt;FirstItem /&gt; &lt;/Suspense&gt; &lt;Suspense fallback=&quot;Loading second item...&quot;&gt; &lt;SecondItem /&gt; &lt;/Suspense&gt; &lt;Suspense fallback=&quot;Loading third item...&quot;&gt; &lt;ThirdItem /&gt; &lt;/Suspense&gt;&lt;/SuspenseList&gt; 上面的範例，即使第三個元件先處理完了，它還是會顯示 Loading third item...，直到前面的項目載入完畢。 revealOrder屬性有 forwards，backwards，together。forwards backwards讓裡面的 &lt;Suspense&gt; 照順向或逆向順序顯示。together則是等全部好在一起顯示。 另外還有一個 tail 屬性，其值支援 collapsed 和 hidden預設 ``會渲染所有元件的fallback。如果您不要 fallback您可以使用 hidden，或者您希望最多渲染一個 fallback可以使用collapsed`。 更多資訊可以參考官方文件 Selective Hydration 與串流化 HTML在我們討論這個概念之前，伺服器端渲染 SSR 包含下面幾個步驟： (伺服器)讀取全部應用程式所需的資料 (伺服器)渲染 HTML (客戶端)載入 HTML 和程式邏輯 (客戶端)執行 Hydration 上面的流程除非當前的步驟完成，不然不會進入下一步。在 4 個步驟完成之後，應用程式才可以開始操作。意思是應用程式至少有 4 個可能造成瓶頸的環節。而 React 18 提供兩個主要的功能來解決問題。 在讀取所有資料之前串流化 HTML如果您將局部頁面包進 &lt;Suspense&gt; 元件，那麼就不會再等這個部分，只要其他元件好了就會繼續。被包起來的元件如果還沒準備好的時候會顯示 fallback。一旦資料讀取完成，React 會傳送補充的 HTML 和 JS 到客戶端，並將內容準確的顯示在它該呈現的地方。因此我們不用再等全部資料都讀取完成，這可以解決第一步可能產生的延遲問題。不過要使用這招您的資料讀取函式庫需要實作相關功能。React 提供的 Server Components 內建整合 Suspense。 如果您的 bundle.js很大的話，第三步載入應用程式邏輯也可能耗費大量時間。為了避免這個問題，您可以實作 Code-Splitting 和 Lazy-Loading。如此就可以依據頁面的需求分批載入邏輯程式。檔案變小，您也不用在一次載入當下用不到的功能可以大大的優化。 全部程式碼載入完成之前執行 Hydration使用 React 18，將元件使用 &lt;Suspense&gt; 包起來，您可以輕易的讓客戶端不再等待該元件。即使缺少局部的 HTML ，程式可以立馬開始 Hydration 的流程。 在全部元件 Hydration 完成之前即可開始操作元件在 React 18，被包在 &lt;Suspense&gt; 的元件 Hydration 流程不會影響使用者和其他已經處理完畢的元件互動。如果被 &lt;Suspense&gt; 包起來的元件包含一些 HTML 已經載入的話，就會直接開始處理 Hydration 。但如果使用者在處理期間，操作另外一個也在處理 Hydration 的元件（例如不耐煩的一直點擊）。這個時候就會優先處理那個被使用者一直操作的元件。它也會紀錄事件並在 Hydration 處理完成後調用。這稱為 Selective Hydration。 參考資源 what’s new in react 18?","link":"/2021/10/14/whats-new-in-react-18/"},{"title":"為使用者研究招募和篩選測試人員","text":"了解招募流程的偏見且避免，讓招募的測試人員能夠真實的代表您的目標群眾。 為研究招募測試人員是非常困難的任務；您必須吸引感興趣的人，安排面試時間，提醒他們記得參加面試。更糟糕的是，有時確實出現的測試者並不是合適的人選，因為他們根本沒有相關的經歷來提供有意義的反饋或見解，即使他們盡了最大努力。次等的測試者會對研究和設計決策產生負面的影響。 篩選調查 (Screening surveys also known as screeners) 是為了收集關於合格測試者經驗資訊的問卷以便： 快速確認和優先考慮能代表目標受眾的合格候選人 排除任何有可能不適合您研究的候選人 本文將會討論篩選調查在使用者研究招募過程的重要性以及如何招募他們的策略。 偏差抽樣首先，對於任何研究，您都希望確保您招募的人能夠代表您的受眾。為了達成這個目標，您需要意識到招募過程可能會偏向某種類型的測試者。 舉例來說，每當您使用遠端測試平台提供測試者的時候，您可能會遇到專業測試者 - 即利用參與不同類型使用者研究測試賺錢的人。雖然這些測試者對於研究來說不一定是不好，但他們的動機可能會導致行為扭曲了研究結果。舉例來說有些人在無指引測試（Unmoderated test）時可能會快速的完成任務或回答問題，而不是以他們具體現實的經歷誠實努力的作答。另一些人甚至可能知道研究員期待什麼結果，並故意加強回應研究的需求。 雖然沒有萬無一失的方法去避開這些專業測試者，但您可以進一步利用篩選調查的回答來確定他們是否合適和誠實來減少這個問題。（例如測試者沒有隨便輸入 ABC 來代替一句有意義的句子）。要知道，篩選調查背後的目的就是減輕審查候選人時的勞力，雖然為了確保合格優質的測試者還是需要付出努力（無論是研究員還是專業的招募人員都是）。 同樣，如果您只依賴您個人的人脈來招募，這些人已經和您多少有些關係，可能不想給出負面反饋。和同事測試也會導致偏差的結果，因為他們可能已經很熟悉專案，組織，甚至不同類型研究的目標。 一般來說，您應該要排除專業的 UX 人員或那些對介面設計感興趣和 UX 相關的從業人員，因為他們對於 UX 問題過於敏感，很有可能他們會提供專家的評論而不是真實使用者的回饋。 即便所有人都是您的目標受眾，您還是需要確保您的研究外部效度（External validity）- 即您的測試者符合目標受眾標準和他們的興趣。例如；某人完全不喜歡運動或健走可能沒有太多動機到戶外用品網站上購物。 如何篩選測試者1. 定義資格標準首先您和您的團隊需要為研究定義測試者標準。同時考慮目標受眾的人口組成和他們使用產品的目的（要詳細了解整個過程可以參考免費的PDF）。這些標準將決定您的招募策略和篩選。 如果您使用自動招募平台，小心不要設定無關的排除條件進而限制了您的調查。例如您擔心遇到專業測試人員，然後您加入了一個排除問題 “您上次參加測試是什麼時候？” 您可能會排除過多的參加者，像是他們就只是第二次參加，而且剛好在這個月參加了不同的測試。 同樣，為了招募專業行銷人員，您可以選擇只接受廣告產業或行銷產業的從業人員，然而專業行銷人員並不是廣告業或行銷公司所獨有的，他們可能在非行銷產業的公司（如雜貨店或服裝店）執行該職位的工作。因此接受多個產業然後搭配職位描述中包含“行銷”關鍵字會更有效率。 2. 構建您的篩選問卷在寫下您的問題時，考慮使用開放式或多選項問題來避免洩漏研究的目標。 舉例來說，Yes No 問題如您有玩過電玩遊戲嗎？就透露出研究可能和電玩遊戲有關。但如果您的問題是：過去 4 週內您曾經從事什麼活動？搭配選項如健行，閱讀，購物，電玩遊戲，那麼意圖就比較不明顯。分散注意力的選項可以讓參加者保持誠實以防止他們對問卷作假。 將最重要的排除標準放在問卷的前面，這樣您就可以快速消除明顯不適合的人，也不會浪費他們的時間。 問卷進行的邏輯可以加快篩選流程，因此考慮挑選一些支援分支功能（如選 A 選項可跳至第 3 題之類的）的問卷工具。 3. 選擇您的招募策略您可以透過多種不同的方式為您的研究尋找參與者。基於您研究每種方法都有其優點和缺點。另外，您可能希望使用多種方式來招募。 專業招募機構有很多專業的招募人員，他們的工作就是協助市場或 UX 研究人員找到符合資格的候選人；大多數甚至還會接手一些和最終測試者互動的工作例如安排時間、溝通、給付款項。這些機構通常在招募一般受眾（條件如性別、背景、財務狀況、年齡）方面可以比較廣泛。 對於招募高度專業人員或特定用戶群也特別有用（例如：尋找特定殘疾或有特殊背景背景的人）。他們經常提前審查參加者，參加者不出席的機率很低。因此他們通常比自動化工具或利用現有的使用者群更貴。 自動招募平台市場上有很多 UX 研究的平台，其中一些支援自動篩選或招募的服務。如果目標是一般受眾，這種方式可能比較好，因爲成本相對低，能夠外包一些招募的工作，而且因為自動化時間相對比較快。然而，使用自動化招聘平台，遇到“專業測試人員”的風險更大，而且有時篩選設定選項（如問卷分支和邏輯功能）會受到工具限制。 既有使用者許多公司會選擇從既有用戶中招募，並建立一群願意嘗試新功能或參與研究的志工。這種方式非常適合招募對特定產品有經驗的對象或取得針對員工的產品意見。 這種方法成本也較低，因為招募對象已經算半合格條件也沒有其他額外的招募費用。但通常還是要提供參加者一些獎勵或補助。還有建置和維護這些資料，安排時間，協調的工作等成本也是比較低的。一些大型企業甚至有專門內部的研究招募人員 - 協助基於各項研究建置、維護測試者資料。 既有用戶通常僅限於已經熟悉您的品牌和產品的人。這種情況下，將很難得到新用戶的意見。現有的使用者可能存在一些抽樣和確認偏差的問題；他們可能會傾向給出正向的反饋。 線上社群和群組（討論版，或專業社群）當既有的使用者和自動化平台無法提供所需不同專業程度的參與者時，求助於線上社群和論壇可以篩選出具有特定經驗，背景，興趣的人。與招聘機構或平台相比，這些群組可以讓您以更低的成本滿足專業的招募需求。 雖然可以幫忙找到一群積極的參與者，但影響的範圍也相對小，僅限於群組的成員。而且他們不一定可以代表目標受眾。尤其是當群組中有些共同的觀點或有意見領袖時，很容易產生取樣偏差或團體迷思（Groupthink）。 與參加者溝通和確定資格也需要更多的時間和精力。 如果您決定聯繫群組或社交媒體平台的成員，建議請務必事先徵得群組管理員的許可。 攔截調查 Intercept studies / Hallway recruiting如果您曾經聽過；請問您是否願意花 5 分鐘參加一項快速的調查嗎？您已經知道什麼是攔截調查了。這類型的調查可以通過虛擬的方式例如在您使用某網站時彈出一個視窗詢問，通過電話語音或在一些公共場合有人直接詢問。非常適合招募訪客、既有客戶、具有特定目標如使用特定功能的參加者。 不幸的是，這些工作非常浪費時間（對於需有人主持或現場對話的情況，無論是否找到參與者，研究人員都必須隨時待命）。根據您需求的特殊性有可能花比預期更多的時間 - 例如，可能很難招募到 100 個有訂閱最新消息的人來進行量化研究。 與既有使用者一樣，這種研究（尤其是線上研究）可能會受到抽樣和確認偏差的影響，因為牽扯到客戶已經和品牌互動。 招募方式 範圍 費用 勞力 時間 偏差風險 專業招募機構 樣本廣泛 一般使用者、專業使用者 高 低 中 低 自動招募平台 樣本廣泛 一般使用者 中 低-中 低 低 現有使用者 樣本受限 既有使用者、資深用戶、員工 低 中 低 中-高 線上社群和群組 樣本受限 專業使用者 低 高 中 中-高 攔截調查 樣本受限 訪客、任務導向的使用者 低 高 中 中 4. 調整招募策略和篩選調查來吸引合適的參與者時間很少或高收入的專業人士例如夜班，輪班工人，高階主管、，醫生，律師可能需要更高的獎勵來證明花在個人生活或工作的時間是值得的。他們也不太可能花大量時間填寫冗長的篩選問卷。 5. 如果您正在為研究招募兩種或更多類型的使用者…您可以嘗試整合所有標準然後只出一份問卷，但需要權衡： 從好的方面說，參加者不需要填寫好幾份問卷，這增加了您取得足夠樣本數量的可能性。 您最終可能得到一個非常複雜的問卷邏輯，或者在候選人填完問卷之後您還是需要手動篩選。 舉例來說，假設您希望招募兩種類型的使用者：_不在技術領域工作的資深用戶_和_在技術領域工作的新手用戶_。您可以利用問卷邏輯分流兩者。或者您可以詢問每一個人是否在技術領域工作，並接著回答是資深用戶或新手用戶的問題；然後看看回覆並檢查是否符合您的需求。 6. 在最後正式核定測試者列表之前審查全部（合格與不符合資格）候選人的問卷如果您和招募機構合作，可以要求他們提供全部填寫的問卷調查或至少提供那些篩選過的資料。 通過查閱這些問卷結果，您可以確認任何適合研究的申請者，如果有大致上符合條件，但不符合完整標準的目標受眾，您可以考慮將他們列入備選名單。 例如：如果您的目標受眾是有多個小孩的父母，主要照顧的叔叔或阿姨可能就不符合資格，但對於研究來說其實還是可以接受的。或者一些參加者由於選了某個答案已經被選出來了，但其實他們也可以是備選，例如他們可能對問題；您持有什麼手機？選了有 Android 手機的選項，但有可能他們 Android 和 iPhone 兩個都有. 7. 如果您不確定符合資格的測試者是否真的適合研究（例如您的招募條件具有高度針對性）這種情況可能需要將研究分成兩部分： 15 分鐘篩選面試 30 - 60 分鐘的研究面試 篩選面試有兩個目的： 評估候選人以進一步確認篩選調查的結果並驗證他們是否適合研究和面試 透過審查資料（例如同意書，溝通方式，設備邀請，是否已按照應用誠實並完成要求的設定）為主要研究會議準備選定的測試者 8. 最後，通知獲取資格的參與者，開始為研究安排時程。避免和半合格的候選人安排任何事情，除非您確定要邀請他們參加研究。一旦您承諾了一個缺，要取消預約，就有義務提供補償。 結論無論您的使用者是誰，您必須要篩選研究對象來確保有效率的使用預算和您的時間。畢竟您的設計決策取決於這些資料。通過招募具有代表性的研究參與者，您的團隊可以減少偏見並建立針對特定用戶需求的體驗。 參考 Recruiting and Screening Candidates for User Research Projects","link":"/2021/11/18/recuriting-and-screening-candidates-for-user-research/"},{"title":"[譯] useEffect 有時候會在瀏覽器繪製（Paint）之前觸發","text":"useEffect 應該在瀏覽器渲染（ paint() ）之後執行，以防止阻塞更新。但您知道它並沒有保證一定在渲染之後觸發？在 useLayoutEffect 中更新狀態（state）會導致同一次渲染中的 useEffect 在渲染之前執行，這是為了有效率的處理佈局的效果。感到困惑嗎？ 來看看一個普通的流程如下： React；渲染 Virtual DOM，Effects 排程，更新實際 DOM 執行 useLayoutEffect React；釋放控制，瀏覽器渲染新的 DOM 執行 useEffect 首先，React 文件並沒有說明具體準確 useEffect 觸發時機；在佈局和渲染之後，在一個延遲時間期間。因此我一直都以為就是類似 setTimeout(effect, 3) 的方式，但其實是使用 MessageChannel 的技巧 。 而文件上更有趣的內容： 雖然 useEffect 會延遲直到瀏覽器繪製（paint）完成，它保證會在下一次新的渲染之前觸發。React 會在下次更新之前刷新之前的 Effects 這是一個不錯的保證 - 您可以確保更新不會不見。但這也意味著 Effect 是有可能在瀏覽器 paint 之前觸發的。 如果 Effect 會在下一次更新開始之前會被刷新 更新是可以在瀏覽器 paint 之前觸發，例如使用 useLayoutEffect，然後 Effect 必然在下次更新之前刷新，即在 paint 之前刷新； 下面是圖示： React 更新 1；渲染 Virtual DOM，排程 Effect，更新 DOM 執行 useLayoutEffect 更新 state，造成重新渲染 執行 useEffect React 更新 2； 從第二次更新執行 useLayoutEffect React 釋放控制，瀏覽器渲染新的 DOM 執行第二次更新的 useEffect 這不是一個非常罕見的例子；避免在 useEffect 直接更新狀態，因為狀態更新會更新 DOM，並且在渲染之後會先得到一個舊的畫面然後更新，導致畫面閃爍。 舉例來說：我們建置一個自適應的輸入欄位，如果欄位寬大於 200px 則多渲染一個清除按鈕。我們需要實際的 DOM 來得知寬。 12345678910111213141516171819const ResponsiveInput = ({ onClear, ...props }) =&gt; { const el = useRef(); const [w, setW] = useState(0); const measure = () =&gt; setW(el.current.offsetWidth); useLayoutEffect(() =&gt; measure(), []); useEffect(() =&gt; { window.addEventListener('resize', measure); return () =&gt; window.removeEventListener(&quot;resize&quot;, measure); }, []); return ( &lt;label&gt; &lt;input {...props} ref={el} /&gt; {w &gt; 200 &amp;&amp; ( &lt;button onClick={onClear}&gt;Clear&lt;/button&gt; )} &lt;/label&gt; );} 我們已經利用 useEffect 延遲了 addEventListener 希望它在 paint 之後在加入監聽事件，但由於 useLayoutEffect 更新了狀態導致被強制在 paint 之前執行。(範例 Sandbox) useLayoutEffect 不是唯一強制提早 Effect 的地方，Refs 例如 &lt;div ref={HERE} /&gt;，requestAnimationFrame 迴圈， Microtasks 排程一樣會導致提早。 但某些情況下渲染流程沒有最佳化其實也沒那麼糟糕。誰會在乎呢？但了解工具的限制對您還是很有幫助的； 下面有 4 個可以學習的地方： 不要太依賴 useEffect 在更新之後觸發即使您知道問題所在，但還是很難確保某些 useEffect 不受 useLayoutEffect 狀態更新的影響： 我的元件沒有使用 useLayoutEffect。但您確定其他函式庫的 Hook 呢？例如 usePopper 我的元件只使用內建的 Hook，但 useContext 或上層元件的 re-render 有可能造成 uLE 狀態更新 我的元件只有 useEffect 和搭配 memo() 。但 Effect 有全域刷新的情況，因此一個在 paint 之前的狀態更新，其子元件還是會受到影響。 現在您可能會考慮不在 useLayoutEffect 更新狀態，但那有點困難。比較好的建議是不要太依賴 useEffect 會在渲染之後觸發，就像 useMemo 也沒有 100% 穩定參考。如果您希望使用者在渲染之後看到某些畫面， useEffect 不是最好的選擇，嘗試 requestAnimationFrame 或 postMessage 。 反過來，假設您沒有聽說在 useEffect 更新 DOM，然後測試看看有沒有閃爍。 不要浪費時間拆分 Layout Effects遵循 useEffect 和 useLayoutEffect 的指導原則，我們可能會把一個 Side-effect 分拆到 useLayoutEffect 和 useEffect 就像上面的範例 1234567// DOM update = layout effectuseLayoutEffect(() =&gt; setWidth(el.current.offsetWidth), []);// subscription = lazy logicuseEffect(() =&gt; { window.addEventListener('resize', measure); return () =&gt; window.removeEventListener('resize', measure);}, []); 但我們知道這樣並沒有什麼差異，兩個 Effect 都會在下次渲染之前刷新。如果我們假設 useEffect 會在渲染之後觸發，您可以 100% 確保在兩個 Effect 之間尺寸不會被變更嗎？如果不是那就讓邏輯全部放在 useLayoutEffect 就好了 12345useLayoutEffect(() =&gt; { setWidth(el.current.offsetWidth); window.addEventListener('resize', measure); return () =&gt; window.removeEventListener('resize', measure);}, []); 不要在 useLayoutEffect 更新狀態這是很好的建議，但說的比做的簡單。在 useEffect 更新狀態也是很糟糕因為閃爍會造成 UX 體驗不好。 有時候狀態更新可以被 useRef 完全取代。更新 ref 不會造成重新渲染，Effect 可以如預期的執行。這裡有篇文章可以參考 如果可以盡量不要依賴 useEffect。 繞過狀態更新如果您發現特定 useLayoutEffect 造成問題，試著繞過狀態更新，直接操作 DOM。 12345678910111213141516const clearRef = useRef();const measure = () =&gt; { // No worries react, I'll handle it: clearRef.current.display = el.current.offsetWidth &gt; 200 ? null : none;};useLayoutEffect(() =&gt; measure(), []);useEffect(() =&gt; { window.addEventListener(&quot;resize&quot;, measure); return () =&gt; window.removeEventListener(&quot;resize&quot;, measure);}, []);return ( &lt;label&gt; &lt;input {...props} ref={el} /&gt; &lt;button ref={clearRef} onClick={onClear}&gt;clear&lt;/button&gt; &lt;/label&gt;); 手動管理 DOM 更新通常比較複雜且容易出錯的，因此在性能很糟的情況下再使用這個技巧。 本文探討了 useEffect 有時候會在 paint 之前執行，常見的原因是在 useLayoutEffect 更新狀態，因為它在 paint 之前重新渲染導致 Effect 必須得提早執行。這些意味著： 在 useLayoutEffect 更新狀態不利於效能，但有時候沒有其他替代方案 不要依賴 useEffect 會在渲染後觸發這個點 在 useEffect 更新 DOM 會造成閃爍 - 將 useLayoutEffect 部分邏輯移到 useEffect 對效能是沒有意義的 在性能問題下，手動 uLE 操控 DOM 的一個理由 參考 useEffect sometimes fires before paint","link":"/2021/11/18/use-effect-trigger-before-paint/"},{"title":"Remix 潮什麼？","text":"前言本文只是快速看一下 Remix 的賣點，至於推不推暫時不好說，待筆者更深入研究分享，但..就目前官網提供的下面賣點，我是已經被點火了。 Remix 專注在網頁的基礎組成和 UX，更簡單的建置更棒的網站。 筆者：乍看之下，用不精準的感覺形容就是 Meteor 流星 React 版。 Remix 是一個全端網頁框架，讓您回到網頁基礎組成並專注在使用者介面進而提供一個快速，流暢，有彈性的使用者體驗。 Remix 無縫整合伺服器和瀏覽器，通過分散式系統和原生瀏覽器的功能支援高效的頁面載入和即時轉換效果，而不是使用靜態建置。基於 Web Fetch API 可以在任何地方執行。原生支援 Cloudflare Workers 當然 serverless 架構和傳統的 Node 環境都可，您可以選擇偏好的使用方式。 速度只是目標的一部分。Remix 追求更好的使用者體驗。從最基本的請求到華麗的效果 Remix 都可以支援您達成。 Remix 的秘技：Nested Routes大部分網站通常具有不同的導覽階層，進而控制不同階層的呈現，通常載入資料和拆分的程式碼片段或元件組成也和網址組成有語意上的關聯。利用巢狀路由 Remix 幾乎可以移除處理載入資料到 state的部分。 大部分的網站都在元件內部 fetch 資料，逐層建立 request，導致降低載入速度和卡頓。Remix 則是在伺服器端平行的載入資料並傳送完整的 HTML，更快，不會卡頓。如此您就可以不用 Spinner, Loader 效果等元件。SSR 也可省去。巢狀路由讓您的應用程式可以更快更即時。 另外，Remix 可在使用者點擊一個連結之前預先平行載入任何東西；資料，模組，CSS 等。0 載入狀態，0 載入前的架構 UI 畫面，0 卡頓。 資料更新在您應用程式中的程式碼大多數都是為了變更資料。想像如果 React 只有 props 沒有 state 會如何？如果有個網頁框架協助您載入資料卻沒有幫助您更新狀態。 而 Remix 則不會在form onSubmit 進行到一半就不管你。表單範例如下： 123456789export default function NewInvoice() { return ( &lt;Form method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;company&quot; /&gt; &lt;input type=&quot;text&quot; name=&quot;amount&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;Create&lt;/button&gt; &lt;/Form&gt; );} 然後對應在伺服器端處理的行為 1234export async function action({ request }) { let body = await request.formData(); // ...} Remix 會在伺服器端執行 action 重新驗證資料甚至也會協助處理反覆送出表單 Race conditions 的問題。 還可以使用最新的 Transition Hooks 實作過度狀態介面，Remix 會處理狀態，您只需讀取即可。或者使用 Optimistic UI 模式您可以直接模擬更新後的結果，Remix 會提供送到伺服器端的資料，您就可以略過使用 Spinner 效果： 12345678910111213141516export default function NewInvoice() { let { submission } = useTransition(); return submission ? ( &lt;Invoice invoice={Object.fromEntries( submission.formData )} /&gt; ) : ( &lt;Form method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;company&quot; /&gt; &lt;input type=&quot;text&quot; name=&quot;amount&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;Create&lt;/button&gt; &lt;/Form&gt; );} 錯誤處理當您的應用程式遇到例外的狀態，使用 Remix 不需要瀏覽器重新刷新頁面。錯誤處理機制也是內建。Remix 會協助您處理伺服器渲染，客戶端渲染的錯誤，甚至是伺服器端處理資料時發生的錯誤。每一個路由元件可以匯出一個錯誤邊界元件。如果錯誤發生會看到邊界元件的內容。 資料參考 Remix 官網","link":"/2021/11/30/remix-run-overview/"},{"title":"從 macOS 轉 window 11 開發者新手指南","text":"基本設定 安裝字體 Operator Mono Lig 安裝 VS Code Install WSL 設定 WSL 開發環境 12345678910111213141516171819202122232425262728293031323334353637# Windows Terminal 相關$ sudo apt-get update$ sudo apt-get upgrade# 使用檔案總管開啟$ explorer.exe .# 複製 ssh keys$ eval `ssh-agent -s`$ ssh-add [SSH_KEY]# C:\\ 路徑$ cd /mnt/c# Windows 下讀取 Linux 目錄 \\\\wsl$\\# Windows Terminal setting.json# C:\\Users\\[USERNAME]\\AppData\\Local\\Packages\\Microsoft.WindowsTerminal_[HASH]\\LocalState\\settings.json# sudo 免密碼$ echo &quot;YOUR_USERNAME ALL=(ALL:ALL) NOPASSWD:ALL&quot; | sudo tee /etc/sudoers.d/will# 安裝 zsh + oh-my-zsh$ sudo apt-get install zsh$ sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;# vim 基本設定$ git clone https://github.com/amix/vimrc.git ~/.vim_runtime# 檢查 ubuntu 版本$ lsb_release -a# 基本工具$ sudo apt-get install wget curl unzip# 列出已安裝套件$ apt list --installed Windows Terminal Themes Windows Subsystem for Linux (WSL) 終極開發人員配置 - 2018 版 MacType - windows 字體蘋果化 各種語言工具可參考 macOS setup 查詢 資料庫 資料庫安裝教學 安裝詳細教學 1234567891011121314151617181920212223242526272829303132# 安裝 Postgre SQL$ sudo apt install postgresql postgresql-contrib# 用於檢查您資料庫的狀態$ sudo service postgresql status# 以開始執行您的資料庫$ sudo service postgresql start# 用來停止執行您的資料庫$ sudo service postgresql stop# WSL 開啟自動啟動 Postgre SQL$ sudo systemctl enable postgresql# 預設管理員 postgres / secret 設定密碼$ sudo passwd postgres# 連線資料庫$ sudo -u postgres psql$ psql -h localhost -U postgres [DATABASE]# 授權$ grant all on schema public to public;# 中斷連線$ \\q# 或者 CTRL + d# 建立使用者$ CREATE USER andy with password 'p@ssw0rd';# 建立新資料庫$ CREATE DATABASE [DATABASE_NAME];$ ALTER USER [USERNAME] WITH SUPERUSER; Nodejs1234567# 安裝 nvm$ sudo apt-get install build-essential libssl-dev# https://github.com/nvm-sh/nvm$ nvm ls-remote$ nvm install node Docker Desktop12345# Powershell$ wsl -l -v# 安裝 Docker Desktop# https://www.docker.com/products/docker-desktop 下載安裝之後，在右下角 Icon 右鍵設定確認使用 WSL 2 引擎和整合，細節參考設定 Docker Remote development in Containers PHP1234567891011121314# https://www.cloudbooklet.com/how-to-install-php-8-on-ubuntu/$ sudo apt install software-properties-common$ sudo add-apt-repository ppa:ondrej/php$ sudo apt update$ sudo apt install php8.0# (選用) 安裝 composer$ sudo apt-get install php8.0-cli unzip zip# 如果 Laravel 缺少函式庫，請補上缺少的。$ sudo apt-get install php8.0-mbstring php8.0-common php8.0-pgsql php8.0-zip php8.0-gd php8.0-intl php8.0-curl php8.0-xsl php8.0-zip# Composer 手動安裝# 官網 https://getcomposer.org/# 下載教學：https://getcomposer.org/download/ Heroku CLI如果您直接安裝 windows 版本遭遇下面錯誤 1@echo: command not found 概略是因為部分函式庫沒有安裝 windows 版本，為了讓事情單純可以直接安裝在 WSL 下 1$ curl https://cli-assets.heroku.com/install-ubuntu.sh | sh 其他參考﹔Issue#600 推薦軟體 Typora Adobe GenP Fork ngrok Fences 3 Seer PowerToys","link":"/2021/12/17/migrate-from-macos-to-window-11/"},{"title":"[譯]在 JavaScript 使用 structuredClone 深度複製","text":"原文﹔Deep-copying in JavaScript using structuredClone 很長一段時間在 JavaScript 對於深度複製或說深拷貝我們都需要自己處理或者使用函式庫。現在平台支援了 structuredClone 雖然在撰文的現階段各大瀏覽器的這個功能都還在試驗階段，但您可以持續觀察Caniuse。目前 Firefox 94 已經在正式版搭載，此外還有 Node 17，Deno 1.14 都支援了這個 API ，可以直接使用。 淺層複製在 JavaScript 中複製值幾乎都屬於淺層複製/淺拷貝，和深度複製相反，意思是當您變更一個巢狀物件副本的值時(複製的物件屬性還包含著物件)會影響原本的物件屬性，反之亦然。因為複製的是參考。舉個例子我們常使用 展開語法 ... 實作 123456789const original = { a: 'string', b: { num: 1, bool: true, },};const shallowCopy = {...original}; 對複製物件的第一層一般屬性變更值不會有什麼問題 12shallowCopy.prop = 'a new prop';console.log(original.prop); // undefined 但如果變更的屬性是物件的(巢狀物件)下一層屬性時就會影響 12shallowCopy.b.num = 2;console.log(original.b.num); // 2 展開語法會遍歷物件屬性和值並將它們加入新建立的物件裡。因此達成了物件的複製，但關於值的部分卻有不同類型。原始值 (不屬於物件的資料類型 string, number, bigint, boolean, undefined, symbol, null) 沒有問題。 但非原時值的資料如物件它們複製的時候是複製參考。也就造成上面說的會互相影響的問題。 深度複製和淺層複製相反，深度複製會使用遞迴的方式處理，每一層的物件都會往下複製，直到下層沒有參考為止。這對於讓本尊和副本之間不要互相影響非常重要。在過去其實沒什麼很優的方式處理。大部分的人可能使用第三方函式庫例如 Lodash 的 cloneDeep() 或者 1const copy = JSON.parse(JSON.stringify(original)); 事實上上面這個方法在過去甚至非常流行，因為效能好。但其實這招也是有缺點 遞迴資料結構﹔JSON.stringify() 無法處理遞迴資料結構(裡面包含了自己的參考) 內建型別﹔JSON.stringify() 無法處理 JS 一些內建型別例如 Map, Set, Date, RegExp, ArrayBuffer 函式﹔JSON.stringify() 無法處理函式 結構複製實際上，平台本身就有很多地方需要深度複製例如﹔將資料儲存在 IndexedDB 時序列化和反序列化。利用 postMessage() 將資料傳給 Web Worker 等情境都需要類似的處理。而內部其實是使用一種稱為結構複製的演算法，過去這功能並沒有提供給開發者。 但現在我們可以使用 structuredClone() 了。 1const copy = structuredClone(original); 功能與限制結構複製解決了大部分 JSON.stringify() 的問題，可以使用遞迴資料結構，JS 內建型別，效能也不錯。 但還是有些限制 Prototypes﹔如果您使用 structuredClone() 複製某類別物件實例 Class Instance 您只會取得單純的物件不會包涵 prototype 的部分 Function﹔如果您的物件包涵了函式則會被移除 不可複製﹔有些值是不可複製的例如 Error 和 DOM 節點 如果您的需求踩到上述的限制，建議您可以使用繼續 Lodash 來處理。 效能目前尚未對其執行完整的性能測試，但之前 2018 年的時候曾經做過，當時 JSON.parse() 對於小型物件是快一點，預期結果應該是差不多的。但還是推薦使用 structuredClone() 結論如果您需要深度複製資料您可以考慮嘗試使用 structedClone()","link":"/2021/12/19/javascript-structured-clone-2021/"},{"title":"Windows 11(WSL2) 支援 Fork 應用程式 CLI","text":"Fork 是一套 git 圖形介面工具。如果您曾經在 macOS 環境下開發，那麼您應該不陌生可以使用指令介面就像 code 那樣。 安裝完 Fork 或您希望使用指令方式啟動的應用程式後取得 exe 路徑 1C:\\Users\\&lt;USERNAME&gt;\\AppData\\Local\\Fork\\ 加入環境變數 開啟 Windows Terminal 執行 fork.exe 確認可以執行之後，可以在您的 bashrc 或 zshrc 補上 alias 1alias fork=&quot;fork.exe&quot; 其他您也可以將一些常用的指令加入 1alias open=&quot;explorer.exe&quot;","link":"/2021/12/14/fork-command-line-on-windows-11/"},{"title":"[譯] Docker Blog - Apache Log4j 2 CVE-2021-44228","text":"2021/12/13 更新 部分 CVE-2021-44228 漏洞已在版本 2.15.0 修正，其餘在 CVE-2021-45046 追蹤。建議更新至 2.16.0 版本 2021/12/15 12:49 PM PT我們知道你們中有很多人正在努力修正 CVSS 分數為 10.0 的 Log4j 2 CVE-2021-44228 漏洞。我們也利用 #hugops 向所有致力於此漏洞工作的人發送相關資訊和最大的祝福，現在使用 Log4Shell。在這個常見的 Java 日誌函式庫 Log2j 的漏洞，能夠遠端執行程式碼，攻擊者可以很容易在各種情境下使用。例如﹔在 Minecraft 伺服器發現允許在聊天紀錄中輸入指令然後這些指令會被送到日誌。這是非常嚴重的漏洞，在函式庫被廣泛使用的情況下很容易被利用。很多開源程式的維護者正努力地修正這個問題。 我們希望在這個充滿挑戰的時刻儘可能協助您，也為您收集相關資訊，包含如何偵測 CVE 和解決辦法 原文將會持訊更新 我中了漏洞了嗎?Log4j 2 版本 2.0 到 2.14.1 具有此漏洞。第一個修正的版本是 2.15.0。但 2.15.0 修正並不完全，目前建議更新的版本是 2.16.0。如果您使用的是 2.0 之前的版本則沒有此漏洞。 如果您使用上述沒有漏洞的版本或者您的日誌紀錄不包含任何使用者輸入的資料，可能不會受到攻擊。然而如果不完全了解全部程式碼或可能輸入日誌的來源可能很難確認。因此您可能希望升級有漏洞的版本。 不幸的是 Docker Desktop 4.3.0 和較早版本的 docker scan 不會在掃描時發現這個漏洞，請升級到 4.3.1+ 如果您是在 Linux 上使用 docker scan 您可以從 Github 下載並依照指示。我們將儘速更新 Linux CLI 版本。 如果您是在新版本是用指令則您應該見到下面訊息 123Upgrade org.apache.logging.log4j:log4j-core@2.14.0 to org.apache.logging.log4j:log4j-core@2.15.0 to fix ✗ Arbitrary Code Execution (new) [Critical Severity][https://snyk.io/vuln/SNYK-JAVA-ORGAPACHELOGGINGLOG4J-2314720] in org.apache.logging.log4j:log4j-core@2.14.0 introduced by org.apache.logging.log4j:log4j-core@2.14.0 要測試這個功能您可以使用包含漏洞的映象檔 1docker scan elastic/logstash:7.13.3 或者擷取出相關資訊 1docker scan elastic/logstash:7.13.3 | grep 'Arbitrary Code Execution' 更多資訊請參考 Docker Hub ScansDocker Hub 安全掃描在 2021/12/13/ 17:00 UTC 時間之後已經可以識別 Log4j 2 漏洞。在這個時間之前的掃描則不會正確反應問題。我們正在研究如何修正此問題。請在更新版本使用 docker scan 補救措施您可能想要使用應用程式層的防火牆 (WAF) 來解決這個問題。在 2.16.0 之前的版本您可以在類別路徑(classpath)移除 JndiLookup 類別 1zip -q -d log4j-core-*.jarorg/apache/logging/log4j/core/lookup/JndiLookup.class Docker 官方映像檔許多官方的映像檔都包含了這個漏洞。更多關於最新狀態可以參考 其他映像檔我們正和合格的提供者進行相關工作。同時在尋找向您顯示”受影響映像檔”的方法，隨著我們得到更多資訊，我們將繼續更新這篇文章。 Docker 基礎設施是否受到影響?Docker Desktop 和 Docker Hub 並未受到 Log4j 2 漏洞影響。Docker 大量使用 Go 語言並不是 Java 。雖然我們內部有使用一些 Java 應用程式，但我們已經確認並未受到 CVE-2021-44228 和 CVE-2021-45046 影響。","link":"/2021/12/22/log4j2-cve-2021-44228/"},{"title":"React 18 - 了解 useSyncExternalStore","text":"在深入 useSyncExternalStore 之前，讓我們先了解一下一些新的術語。 併發渲染與 startTransition併發指的是基於分配任務的優先順序同時執行多個任務的機制。如果您還不明白這個觀念可以參考 Dan Abramov 的說明 重點節錄：併發的意思是任務可以在同一段時間重疊。讓我們使用打電話來比喻。不支援併發意思是，我一次只能和一個人通電話。如果我打給 Alice，然後 Bob 打給我，我必須要掛掉 Alice 的電話然後才能和 Bob 講話。併發表示我每一在同一段時間有多個通話。例如：我還是保持和 Alice 通話狀態只是將電話擺在旁邊，然後跟 Bob 講話，後續還是可以回來和 Alice 講話。注意：併發不是說我一次要跟兩個人對話。而在 React 這個打電話（併發任務）指的是 setState。 在新的 startTransition API 的協助下我們可以選擇在渲染期間讓應用程式保持可操作。換句話說，React 現在可以暫停渲染，這讓瀏覽器可以處理中間的事件。 更多介紹可以參考﹔概覽 React 18 新功能 外部儲存所謂外部儲存就是一個我們可以訂閱的東西，例如 Redux store，全域變數，模組內部變數，DOM 狀態等等。 內部儲存內部則是 props，context，useState，useReducer 這些。 Tearing“Tearing” 指的是視覺上的不一致性。表示介面會發生同一個狀態卻不同值的情況。 在 React 18 之前沒有這個問題。但 React 18 併發渲染的功能讓這個問題可能發生，因為在渲染期間會暫停。在這些暫停，更新之間會讀取新的渲染中使用的資料。這導致 UI 針對同一份資料來源顯示兩個不同的值。 讓我們來看看關於 Tearing 討論中的範例。下面是一個元件需要存取外部儲存來取得顏色。在同步渲染情況下 UI 渲染的顏色一致 而在併發渲染下，一開始讀取的顏色是藍色。然後 React 暫停，此時外部儲存將顏色更新為紅色。當 React 恢復繼續渲染就會取得紅色。這就會造成介面上呈現不一致也就是 “Tearing” 為了修復這個問題，React 團隊加入了 useMutableSource來安全且效率的讀取外部資料(Mutable External Source)。但工作群組的成員回報了既有 API 整合使用的問題導致函式庫維護者很難使用 useMutableSource 到他們的實作。在一陣討論之後 useMutableSource 被重新設計並改名字為 useSyncExternaStore 了解 useSyncExternalStore HookReact 18 新的 useSyncExternalStore Hook 讓我們可以正確的訂閱儲存中的值。 為了協助簡化升級過程，向下兼容，React 提供了 use-sync-external-store 套件。這個套件包含的 “shim” 適用於 React 任何版本。 mark:312345678910111213import { useSyncExternalStore } from 'react';// 或者// 向下相容import { useSyncExternalStore } from 'use-syncexternal-store/shim';// 基本使用方式。getSnapshot 必須回傳 cached/memoized 結果useSyncExternalStore( subscribe: (callback) =&gt; unsubscribe, getSnapshot: () =&gt; state);// 讀取特定欄位const selectedField = useSyncExternalStore(store.subscribe, () =&gt; store.getSnapshot().selectedField); useSyncExternalStore Hook 參數為兩個函式 subscribe 函式註冊了一個訂閱的 callback getSnapshot 是用來檢查已訂閱的資料從上次渲染之後是否有發生變更。它必須是數字，字串這種靜態資料或者 cached / memoized 的物件。然後 Hook 會回傳 Immutable 的資料。 其中也支援 getSnapshot 結果會自動快取 memoize 回傳結果的 API 123456789import { useSyncExternalStoreWithSelector } from 'use-sync-external-store/with-selector';const selection = useSyncExternalStoreWithSelector( store.subscribe, store.getSnapshot, getServerSnapshot, selector, isEqual); 要了解會發生了什麼問題請先觀看這個影片。影片中的範例如下您可以自行測試 上面的例子說明，使用 startTransition 有可能會踩到 “Tearing” 問題。如果要修正問題就需要使用 useSyncExternalStore。 在 useStore ，使用 useSyncExternalStore 取代 useEffect 和 useState 12345678import { useSyncExternalStore, useCallback } from 'react';const useStore = (store, selector) =&gt; { return useSyncExternalStore( store.subscribe, useCallback(() =&gt; selector(store.getState()), [store, selector]); );} 使用新的 Hook 讓程式碼更乾淨，好維護。建議使用 useSyncExternalStore 來處理外部儲存，更簡單也避免潛在的問題發生。 ⚠️⚠️⚠️注意⚠️⚠️⚠️﹔實作併發模式，您必須使用 React 18 新的 render API 否則不會啟動功能 12345import * as ReactDOM from 'react-dom';import App from 'App';const root = ReactDOM.createRoot(document.getElementById('app'));root.render(&lt;App /&gt;); 哪些函式庫受到影響? 函式庫或客製化 Hook 在渲染期間不使用外部儲存，僅使用 props，state，context 的不受影響。 函式庫會處理資料讀取，狀態管理例如 Redux，MobX，Relay 會受到影響，因為他們把狀態儲存到 React 外部。在併發渲染時這些資料可以在渲染過程中更新，而 React 不知道。 參考資料 RFC: useMutableSource Discussion regarding useMutableSource and selector stability Journey of useMutableSource to useSyncExternalStore Meet the new hook useSyncExternalStore, introduced in React 18 for external stores","link":"/2022/01/05/use-sync-external-store-with-solving-problem/"},{"title":"[譯] Remix 快速入門","text":"我們廢話不多說直接進入程式碼的部分。如果您在找尋 15 分鐘快速實作，那本篇就是。 本篇會使用 TypeScript，但我們會在寫完程式之後才添加型別。這不是正常的流程，但因為部分讀者不使用 TypeScript 因此我們不想讓您混亂。一般來說我們應該在寫程式的時候就建立型別，才可以在一開始就享受 TypeScript 的好處。 建立專案123456789101112131415161718$ npx create-remix@latestWelcome to Remix! Let's get you set up with a new project.? Where would you like to create your app? [demo-remix]? Where do you want to deploy? Choose Remix if you're unsure, it's easy to change deployment targets. (Use arrow keys)❯ Remix App Server Express Server Architect (AWS Lambda) Fly.io Netlify Vercel Cloudflare Pages? TypeScript or JavaScript? (Use arrow keys)❯ TypeScript JavaScript? Do you want me to run `npm install`? (Y/n) Y$ cd demo-remix$ npm run dev 須選擇 Remix App Server 我們將對檔案系統做些設定，但不是全部的設定都和這篇教學相容。 瀏覽器開啟 http://localhost:3000 可以看到我們的應用程式正在執行。如果您想，可以花幾分鐘看一下預設的檔案。 如果您的程式沒有正常運作請查閱專案裡的 README.md 看看您是否需要額外的設定。 請確認 postinstall 在啟動應用程式之前正確執行，如果沒有可以手動執行 npm run postinstall 當您的 npm 設定了 ignore-scripts = true 時可能會發生。或者您使用 pnpm 或其他函式庫管理工具不會自動執行 postinstall 第一個路由我們將建置第一個路有 /posts ，在開始之前我們先在 app/root.tsx 加入連結 12{/* 記得載入 Link */}&lt;Link to=&quot;/posts&quot;&gt;Posts&lt;/Link&gt; 您可以加到任何您喜歡的位置。回到瀏覽器點擊連結應該會看到 404，這是因為我們還沒建立路由。 接著，建立 app/routes/posts/index.tsx 12$ mkdir app/routes/posts$ touch app/routes/posts/index.tsx 任何時候您看到終端機指令建立檔案或目錄，您當然可以使用您習慣的方式，mkdir 和 touch 只是我們比較習慣的方式，並且在這裡呈現比較清楚容易。 我們可以將檔案命名為 posts.tsx，但很快我們就會有另一個路由，將它們放在一起會比較適合。而且當路徑指到目錄時 index 路由會被渲染，就跟伺服器 index.html 一樣。 當回傳為 null 時您可能會看到空白的頁面。您已經建立了路由但檔案裏面什麼都沒有，讓我們來加入元件 app/routes/posts/index.tsx 1234567export default function Posts() { return ( &lt;div&gt; &lt;h1&gt;Posts&lt;/h1&gt; &lt;/div&gt; );} 您可能需要重新載入。 載入資料Remix 內建資料載入。如果您的網頁開發經驗是近幾年才開始的您大概會分成；一個後端 API 路由提供資料然後一個前端專案。在 Remix 一個前端元件同時也是自己的 API 路由，而且它已經知道如何從瀏覽器和伺服器端的自己溝通，因此您不需要自己 fetch。 如果您的開發經驗稍微久一點可能熟悉 MVC 框架像是 Rails，那麼您可以將 Remix 路由看作是一個後端的 View 只是樣版採用 React，並且它知道如何無縫在瀏覽器進行 hydrate ，而不是寫入一些分離的 jQuery 程式碼來實作互動操作。它充分的展現了漸進式增強，此外您的路由也是它自己的 Controller。 123456789101112131415161718192021222324import { useLoaderData } from 'remix';export const loader = () =&gt; { return [ { slug: 'my-first-post', title: 'My First Post' }, { slug: '90s-mixape', title: 'A Mixtape I Made Just For You' } ];};export default function Posts() { const posts = useLoaderData(); console.log(posts); return ( &lt;div&gt; &lt;h1&gt;Posts&lt;/h1&gt; &lt;/div&gt; );} Loaders 就是給元件自身使用的後端 API，而且他們已經通過 useLoaderData 連接起來了。在 Remix 路由中前端和伺服器之間有典模糊，這確實有點瘋狂。如果您的伺服器和瀏覽器的 Console 都開啟，您會看到兩者都輸出了文章資料。這是因為 Remix 像傳統的網頁框架一樣是在伺服器端渲染然後傳送完整的 HTML，但它也在客戶端進行 hydrate (跟 render 一樣但是重複使用了已產生的 HTML Node)。讓我們來加入文章連結 123456789101112131415161718192021222324252627282930313233import { Link, useLoaderData } from 'remix';export const loader = () =&gt; { return [ { slug: 'my-first-post', title: 'My First Post' }, { slug: '90s-mixape', title: 'A Mixtape I Made Just For You' } ];};export default function Posts() { const posts = useLoaderData(); console.log(posts); return ( &lt;div&gt; &lt;h1&gt;Posts&lt;/h1&gt; &lt;ul&gt; {posts.map((post) =&gt; ( &lt;li key={post.slug}&gt; &lt;Link to={post.slug}&gt; {post.title} &lt;/Link&gt; &lt;/li&gt; ))} &lt;/ul&gt; &lt;/div&gt; );} 發現 TypeScript 在警告了，我們來處理一下。加入 Post 型別 1234567891011121314151617181920212223242526272829303132333435363738import { Link, useLoaderData } from 'remix';export type Post = { slug: string; title: string;}export const loader = () =&gt; { const posts: Post[] = [ { slug: 'my-first-post', title: 'My First Post' }, { slug: '90s-mixape', title: 'A Mixtape I Made Just For You' } ]; return posts;};export default function Posts() { const posts = useLoaderData&lt;Post[]&gt;(); console.log(posts); return ( &lt;div&gt; &lt;h1&gt;Posts&lt;/h1&gt; &lt;ul&gt; {posts.map((post) =&gt; ( &lt;li key={post.slug}&gt; &lt;Link to={post.slug}&gt; {post.title} &lt;/Link&gt; &lt;/li&gt; ))} &lt;/ul&gt; &lt;/div&gt; );} 好的我們完成了型別的宣告，即使通過網路請求取得也沒問題，因為它們定義在同一份檔案。除非網路在 Remix 取得資料時中斷。現在您同時在元件和 API 得到型別的保護(記得元件已經是自己的 API 路由) 重構建立模組一個穩固的實作就是只處理特定問題。在我們的例子就是讀取和撰寫文章。現在讓我們加入 getPosts 並匯出到我們的模組。建立 app/post.ts 1$ touch app/post.ts 接著我們從路由複製剛剛的程式碼 123456789101112131415161718export type Post = { slug: string; title: string;};export function getPosts() { const posts: Post[] = [ { slug: &quot;my-first-post&quot;, title: &quot;My First Post&quot; }, { slug: &quot;90s-mixtape&quot;, title: &quot;A Mixtape I Made Just For You&quot; } ]; return posts;} 更新 app/routes/posts/index.tsx 路由使用我們剛建立的模組 123456789import { Link, useLoaderData } from &quot;remix&quot;;import { getPosts } from &quot;~/post&quot;;import type { Post } from &quot;~/post&quot;;export const loader = () =&gt; { return getPosts();};// ... 讀取資料來源假如是在真實的專案，我們通常會把資料放在資料庫例如 Postgres，FaunaDB，Supabase 之類的。本篇只是快速入門，因此我們只會是用本機的檔案系統。我們將會讀取本機檔案取代在程式碼寫死資料。 在專案根目錄建立 posts/目錄，注意不是 app 目錄下。 1$ mkdir posts 然後加入一些文章 12$ touch posts/my-first-post.md$ touch posts/90s-mixtape.md 在裡面寫入一些內容，但記得要有 Front Matter (Markdown 開頭的設定區塊) posts/my-first-post.md 1234567---title: My First Post---# This is my first postIsn't it great? posts/90s-mixtape.md 1234567891011121314151617181920212223---title: 90s Mixtape---# 90s Mixtape- I wish (Skee-Lo)- This Is How We Do It (Montell Jordan)- Everlong (Foo Fighters)- Ms. Jackson (Outkast)- Interstate Love Song (Stone Temple Pilots)- Killing Me Softly With His Song (Fugees, Ms. Lauryn Hill)- Just a Friend (Biz Markie)- The Man Who Sold The World (Nirvana)- Semi-Charmed Life (Third Eye Blind)- ...Baby One More Time (Britney Spears)- Better Man (Pearl Jam)- It's All Coming Back to Me Now (Céline Dion)- This Kiss (Faith Hill)- Fly Away (Lenny Kravits)- Scar Tissue (Red Hot Chili Peppers)- Santa Monica (Everclear)- C'mon N' Ride it (Quad City DJ's) 更新 getPosts，改成讀取檔案，這裡我們需要安裝 front-matter 1$ npm add front-matter 更新 app/post.ts 12345678910111213141516171819202122232425262728import path from 'path';import fs from 'fs/promises';import parseFrontMatter from 'front-matter';export type Post = { slug: string; title: string;};const postsPath = path.join(__dirname, '..', 'posts');export async function getPosts() { const dir = await fs.readdir(postsPath); return Promise.all( dir.map(async (filename) =&gt; { const file = await fs.readFile( path.join(postsPath, filename) ); const { attributes } = parseFrontMatter( file.toString() ); return { slug: filename.replace(/\\.md$/, ''), title: attributes.title }; }) );} 這不是 Node 檔案系統教學，因此您需要信任這邊的程式碼。如之前提到的，您可以從資料庫或任何地方讀取 Markdown。 如果您不是使用 Remix App Server，您的路徑可能需要加入額外的 ‘..’ 。同時注意您不能在不包含儲存空間(系統硬碟)的主機(環境)部署這個範例。 您應該注意到 TypeScript 又警告了，讓我們接著處理。 因為我們讀取了檔案，型別不知道裡面有什麼，因此我們需要在執行時期檢查，為了這個我們需要 invariant 方法使其在執行環境檢查。 確保文章有正確的資料 1$ npm add tiny-invariant 更新 app/post.ts 123456789101112131415161718192021222324252627282930313233343536373839import path from 'path';import fs from 'fs/promises';import parseFrontMatter from 'front-matter';import invariant from 'tiny-invariant';export type Post = { slug: string; title: string;};export type PostMarkdownAttributes = { title: string;};const postsPath = path.join(__dirname, '..', 'posts');function isValidPostAttributes(attributes: any): attributes is PostMarkdownAttributes { return attributes?.title;}export async function getPosts() { const dir = await fs.readdir(postsPath); return Promise.all( dir.map(async (filename) =&gt; { const file = await fs.readFile( path.join(postsPath, filename) ); const { attributes } = parseFrontMatter( file.toString() ); invariant(isValidPostAttributes(attributes), `${filename} has bad meta data!`); return { slug: filename.replace(/\\.md$/, ''), title: attributes.title }; }) );} 就算您不是使用 TypeScript 您也可以使用 invariant 檢查。 好! 回到介面上我們應該會看到文章列表。您可以多加入一些文章，重新載入看看變化。 動態路由參數現在是時候讓我們的路由可以檢視文章了，我們希望網址如下 12/posts/my-first-post/posts/90s-mixtape 我們可以使用 “Dynamic segment”，而不是替每一篇文章都建立路由。Remix 會解析並傳給我們，如此我們就可以動態查詢對應的文章。建立動態路由 1touch app/routes/posts/$slug.tsx 1234567export default function PostSlug() { return ( &lt;div&gt; &lt;h1&gt;Some Post&lt;/h1&gt; &lt;/div&gt; );} 現在您可以點擊文章連結應該會看到新頁面。 接著加入 Loader 來存取參數 123456789101112131415import { useLoaderData } from 'remix';export const loader = async ({ params }) =&gt; { return params.slug;};export default function PostSlug() { const slug = useLoaderData(); return ( &lt;div&gt; &lt;h1&gt;Some Post: {slug}&lt;/h1&gt; &lt;/div&gt; );} 我們在檔案名稱前面加上 $ 會在 params 物件加入一個具名的屬性，然後會傳給 Loader，這就是我們查詢文章的方式。 又到了處理 TypeScript 的段落，在 app/routes/posts/$slug.tsx 補上 123456import { useLoaderData } from 'remix';import type { LoaderFunction } from 'remix';export const loader: LoaderFunction = async ({ params }) =&gt; { return params.slug;}; 現在讓我們來讀取文章內容，加入 getPost 函式到文章模組 app/post.ts 12345678910export async function getPost(slug: string) { const filepath = path.join(postsPath, slug + '.md'); const file = await fs.readFile(filepath); const { attributes } = parseFrontMatter(file.toString()); invariant(isValidPostAttributes(attributes), `Post ${filepath} is missing attributes`); return { slug, title: attributes.title };} 在 app/routes/posts/$slug.tsx 使用 getPost 12345678910111213141516171819import { useLoaderData } from 'remix';import type { LoaderFunction } from 'remix';import { getPost } from '~/post';import invariant from 'tiny-invariant';export const loader: LoaderFunction = async ({ params }) =&gt; { invariant(params.slug, 'expected params.slug'); return getPost(params.slug);};export default function PostSlug() { const post = useLoaderData(); return ( &lt;div&gt; &lt;h1&gt;{post.title}&lt;/h1&gt; &lt;/div&gt; );} 我們現在已經可以從資料來源讀取文章了。 注意到 invariant，因為 params 的資料來自網址，我們不能保證 params.slug 一定是被我們定義過的，可能您將檔案換成是 $postId.tsx。實務上最好使用 invariant 檢查，同時它讓 TypeScript 不會警告我們。 網路上有很多 Markdown 的解析器，這篇教學我們將使用 marked 因為它比較簡單。 123npm add marked# 如果使用 TypeScriptnpm add @types/marked 然後回到 app/post.ts 我們要補上文章的內容資料 1234567891011121314import { marked } from 'marked';export async function getPost(slug: string) { const filepath = path.join(postsPath, slug + '.md'); const file = await fs.readFile(filepath); const { attributes, body } = parseFrontMatter(file.toString()); invariant(isValidPostAttributes(attributes), `Post ${filepath} is missing attributes`); const html = marked(body); return { slug, html, title: attributes.title };} 更新 app/routes/posts/$slug.tsx 1234567891011121314151617import { useLoaderData } from 'remix';import type { LoaderFunction } from 'remix';import { getPost } from '~/post';import invariant from 'tiny-invariant';export const loader: LoaderFunction = async ({ params }) =&gt; { invariant(params.slug, 'expected params.slug'); return getPost(params.slug);};export default function PostSlug() { const post = useLoaderData(); return ( &lt;div dangerouslySetInnerHTML={{ __html: post.html }} /&gt; );} 新增部落格文章現在我們部落格的文章需要靠部屬才能新增。雖然這樣的流程還算是一種簡單的方式，不過如果只是打幾個錯字最好還是避免重新部署比較好。這裡的想法就是把文章放到資料庫，這樣我們就需要一個方式來建立文章我們將使用 Actions 來實現。建立管理路由 文章後面會說明 Actions 1$ touch app/routes/admin.tsx 123456789101112131415161718192021222324252627282930import { Link, useLoaderData } from 'remix';import { getPosts } from '~/post';import type { Post } from '~/post';export const loader = () =&gt; { return getPosts();};export default function Admin() { const posts = useLoaderData&lt;Post[]&gt;(); return ( &lt;div className=&quot;admin&quot;&gt; &lt;nav&gt; &lt;h1&gt;Administrator&lt;/h1&gt; &lt;ul&gt; {posts.map((post) =&gt; ( &lt;li key={post.slug}&gt; &lt;Link to={`/posts/${post.slug}`}&gt; {post.title} &lt;/Link&gt; &lt;/li&gt; ))} &lt;/ul&gt; &lt;/nav&gt; &lt;main&gt; &lt;/main&gt; &lt;/div&gt; );} 您應該認出很多程式碼是來自 posts 路由。我們還額外設定了一些 HTML 結構這是因為我們會快速的套用一些樣式 12$ mkdir app/styles$ touch app/styles/admin.css 1234567891011121314151617.admin { display: flex;}.admin &gt; nav { padding-right: 2rem;}.admin &gt; main { flex: 1; border-left: solid 1px #ccc; padding-left: 2rem;}em { color: red;} 把樣式和路由關聯，到 app/routes/admin.tsx 加入 12345import adminStyles from '~/styles/admin.css';// ...export const links = () =&gt; { return [{ rel: 'stylesheet', href: adminStyles}];} 每一個路由可以匯出一個 links 函式，回傳 &lt;link&gt; 的陣列，除了格式是物件而不是 HTML。因此使用 { ref: 'stylesheet', href: adminStyles} 的格式，而不是 &lt;link rel=&quot;stylesheet&quot; href=&quot;...&quot; /&gt;。這麼做是為了讓 Remix 合併所有渲染路由的 links ，彙整在文件上方的 &lt;Links /&gt; 元素裡。如果您好奇可以看看 root.tsx。 OK，您應該要看到簡單的排版，左邊是文章列表，右邊留白我們還沒實作。現在您需要手動輸入 http://localhost:3000/admin 才能造訪管理頁面，因為我們還沒設定連結 Index 路由讓我們是使用 Index 路由來實作右邊的區塊。現在我們要介紹的是”巢狀路由”即根據路由轉換成巢狀元件結構。 利用建立一個目錄設定 admin.tsx 的子路由 12$ mkdir app/routes/admin$ touch app/routes/admin/index.tsx 如果您重新載入，應該看不到任何東西。在 app/routes/admin/ 目錄下的每一個路由，一旦網址符合都可以渲染到 app/routes/admin.tsx 之中。您可以控制要渲染在哪裡。在 admin.tsx 加入 Outlet 1234567891011121314151617181920212223242526272829303132333435import { Outlet, Link, useLoaderData } from 'remix';import { getPosts } from '~/post';import type { Post } from '~/post';import adminStyles from '~/styles/admin.css';export const loader = () =&gt; { return getPosts();};export const links = () =&gt; { return [{ rel: 'stylesheet', href: adminStyles}];}export default function Admin() { const posts = useLoaderData&lt;Post[]&gt;(); return ( &lt;div className=&quot;admin&quot;&gt; &lt;nav&gt; &lt;h1&gt;Administrator&lt;/h1&gt; &lt;ul&gt; {posts.map((post) =&gt; ( &lt;li key={post.slug}&gt; &lt;Link to={`/posts/${post.slug}`}&gt; {post.title} &lt;/Link&gt; &lt;/li&gt; ))} &lt;/ul&gt; &lt;/nav&gt; &lt;main&gt; &lt;Outlet /&gt; &lt;/main&gt; &lt;/div&gt; );} 給我們幾分鐘，剛開始 Index 路由可能會讓您困惑。只要知道當網址上層路由路徑，子路由的 Index 就會對應到 Outlet 。 讓我們先來實作 /admin/new ，也許對您的理解有幫助。建立 app/routes/admin/new.tsx 1$ touch app/routes/admin/new.tsx 12345export default function NewPost() { return ( &lt;h2&gt;New Post&lt;/h2&gt; );} 現在點擊 Index 上面的 “Creae a New Post” ，&lt;Outlet /&gt; 會自動切換到 “new” 路由。 Actions然後我們要在這個 “new” 路由建置一個表單來建立文章 12345678910111213141516171819202122232425262728293031import { Form } from 'remix';export default function NewPost() { return ( &lt;&gt; &lt;h2&gt;New Post&lt;/h2&gt; &lt;Form method=&quot;post&quot;&gt; &lt;p&gt; &lt;label&gt; Post Title: &lt;input type=&quot;text&quot; name=&quot;title&quot; /&gt; &lt;/label&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt; Post Slug: &lt;input type=&quot;text&quot; name=&quot;slug&quot; /&gt; &lt;/label&gt; &lt;/p&gt; &lt;p&gt; &lt;label htmlFor=&quot;markdown&quot;&gt;Markdown:&lt;/label&gt; &lt;br /&gt; &lt;textarea id=&quot;markdown&quot; rows={20} name=&quot;markdown&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;button type=&quot;submit&quot;&gt;Create Post&lt;/button&gt; &lt;/p&gt; &lt;/Form&gt; &lt;/&gt; );} 要完成新增功能我們需要一個表單從使用者那取得資料，然後一個後端處理收到的資料。在 Remix 您一樣需要完成這些。讓我們先在 post.ts 建立儲存資料的功能。在 app/post.ts 新增 createPost 函式 12345678export async function createPost(post) { const md = `---\\ntitle: ${post.title}\\n---\\n\\n${post.markdown}`; await fs.writeFile( path.join(postsPath, post.slug + '.md'), md ); return getPost(post.slug);} 在新增頁面使用 createPost ，編輯 app/routes/admin/new.tsx 加入 action 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import { Form, redirect } from 'remix';import { createPost } from '~/post';export const action = async ({ request }) =&gt; { const formData = await request.formData(); const title = formData.get('title'); const slug = formData.get('slug'); const markdown = formData.get('markdown'); await createPost({ title, slug, markdown }); return redirect('/admin');}export default function NewPost() { return ( &lt;&gt; &lt;h2&gt;New Post&lt;/h2&gt; &lt;Form method=&quot;post&quot;&gt; &lt;p&gt; &lt;label&gt; Post Title: &lt;input type=&quot;text&quot; name=&quot;title&quot; /&gt; &lt;/label&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt; Post Slug: &lt;input type=&quot;text&quot; name=&quot;slug&quot; /&gt; &lt;/label&gt; &lt;/p&gt; &lt;p&gt; &lt;label htmlFor=&quot;markdown&quot;&gt;Markdown:&lt;/label&gt; &lt;br /&gt; &lt;textarea id=&quot;markdown&quot; rows={20} name=&quot;markdown&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;button type=&quot;submit&quot;&gt;Create Post&lt;/button&gt; &lt;/p&gt; &lt;/Form&gt; &lt;/&gt; );} 就這樣。Remix 會幫您處理剩下的事情。當點擊 submit 按鈕，會看到側邊欄自動多了一篇文章。 formData 可以使用和input 的 name 相同值取得 input 資料。好的過程中應該又看到一些 TypeScript 的警告。 在 app/post.ts 加入型別 1234567891011121314export type NewPost = { title: string; slug: string; markdown: string;}export async function createPost(post: NewPost) { const md = `---\\ntitle: ${post.title}\\n---\\n\\n${post.markdown}`; await fs.writeFile( path.join(postsPath, post.slug + '.md'), md ); return getPost(post.slug);} app/routes/admin/new.tsx 也需要處理型別的問題 1234567891011121314151617import type { ActionFunction } from &quot;remix&quot;;export const action: ActionFunction = async ({ request }) =&gt; { const formData = await request.formData(); const title = formData.get('title'); const slug = formData.get('slug'); const markdown = formData.get('markdown'); await createPost({ title, slug, markdown }); return redirect('/admin');} 無論是否使用 TypeScript 我們現在還是有個問題，就是當使用者不提供欄位值的時候(TypeScript 依然在警告 createPost)。讓我們在建立文章之前加入驗證 1234567891011121314151617181920212223242526// app/routes/admin/new.tsxexport const action: ActionFunction = async ({ request }) =&gt; { const formData = await request.formData(); const title = formData.get('title'); const slug = formData.get('slug'); const markdown = formData.get('markdown'); const errors = {}; if (!title) errors.title = true; if (!slug) errors.slug = true; if (!markdown) errors.markdown = true; if (Object.keys(errors).length) { return errors; } await createPost({ title, slug, markdown }); return redirect('/admin');} 注意到我們這次沒有使用 redirect，我們回傳 errors。這些錯誤可以通過 useActionData 取得，就類似 useLoaderData，但資料來自一個 Form Post 之後的 Action。接著在 app/routes/admin/new.tsx 加入驗證資訊的部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import { Form, redirect, useActionData } from 'remix';import type { ActionFunction } from 'remix';import { createPost } from '~/post';//...export default function NewPost() { const errors = useActionData(); return ( &lt;&gt; &lt;h2&gt;New Post&lt;/h2&gt; &lt;Form method=&quot;post&quot;&gt; &lt;p&gt; &lt;label&gt; Post Title: {&quot; &quot;} {errors?.title ? ( &lt;em&gt;Title is required&lt;/em&gt; ) : null} &lt;input type=&quot;text&quot; name=&quot;title&quot; /&gt; &lt;/label&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt; Post Slug: {&quot; &quot;} {errors?.slug ? ( &lt;em&gt;Slug is required&lt;/em&gt; ) : null} &lt;input type=&quot;text&quot; name=&quot;slug&quot; /&gt; &lt;/label&gt; &lt;/p&gt; &lt;p&gt; &lt;label htmlFor=&quot;markdown&quot;&gt;Markdown:&lt;/label&gt; {&quot; &quot;} {errors?.markdown ? ( &lt;em&gt;Markdown is required&lt;/em&gt; ) : null} &lt;br /&gt; &lt;textarea id=&quot;markdown&quot; rows={20} name=&quot;markdown&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;button type=&quot;submit&quot;&gt;Create Post&lt;/button&gt; &lt;/p&gt; &lt;/Form&gt; &lt;/&gt; );} TypeScript 依然有警告，讓我們加入 invariant 和錯誤資訊的物件型別 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import { Form, redirect, useActionData } from 'remix';import type { ActionFunction } from 'remix';import invariant from 'tiny-invariant';import { createPost } from '~/post';type PostError = { title?: boolean; slug?: boolean; markdown?: boolean;}export const action: ActionFunction = async ({ request }) =&gt; { const formData = await request.formData(); const title = formData.get('title'); const slug = formData.get('slug'); const markdown = formData.get('markdown'); const errors: PostError = {}; if (!title) errors.title = true; if (!slug) errors.slug = true; if (!markdown) errors.markdown = true; if (Object.keys(errors).length) { return errors; } invariant(typeof title === 'string'); invariant(typeof slug === 'string'); invariant(typeof markdown === 'string'); await createPost({ title, slug, markdown }); return redirect('/admin');}export default function NewPost() { const errors = useActionData(); return ( &lt;&gt; &lt;h2&gt;New Post&lt;/h2&gt; &lt;Form method=&quot;post&quot;&gt; &lt;p&gt; &lt;label&gt; Post Title: {&quot; &quot;} {errors?.title ? ( &lt;em&gt;Title is required&lt;/em&gt; ) : null} &lt;input type=&quot;text&quot; name=&quot;title&quot; /&gt; &lt;/label&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt; Post Slug: {&quot; &quot;} {errors?.slug ? ( &lt;em&gt;Slug is required&lt;/em&gt; ) : null} &lt;input type=&quot;text&quot; name=&quot;slug&quot; /&gt; &lt;/label&gt; &lt;/p&gt; &lt;p&gt; &lt;label htmlFor=&quot;markdown&quot;&gt;Markdown:&lt;/label&gt; {&quot; &quot;} {errors?.markdown ? ( &lt;em&gt;Markdown is required&lt;/em&gt; ) : null} &lt;br /&gt; &lt;textarea id=&quot;markdown&quot; rows={20} name=&quot;markdown&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;button type=&quot;submit&quot;&gt;Create Post&lt;/button&gt; &lt;/p&gt; &lt;/Form&gt; &lt;/&gt; );} 為了讓事情更有趣，在瀏覽器開發工具停用 JavaScript ，在試試看功能。因為 Remix 是根據 HTML 和 HTTP 基礎功能構成的，就算少了瀏覽器支援 JavaScript 還是可以正常運作，但這不是重點。讓我們放慢腳步為表單加入一些待處理狀態的介面。在 app/routes/admin/new.tsx 仿造一些延遲 1234567891011export const action: ActionFunction = async ({ request }) =&gt; { await new Promise((reslove) =&gt; setTimeout(reslove, 1000)); const formData = await request.formData(); const title = formData.get('title'); const slug = formData.get('slug'); const markdown = formData.get('markdown'); // ...} 使用 useTransition 加入待處理的介面 12345678910111213141516171819202122232425262728import { Form, redirect, useActionData, useTransition } from 'remix';import type { ActionFunction } from 'remix';import invariant from 'tiny-invariant';import { createPost } from '~/post';// ...export default function NewPost() { const errors = useActionData(); const transition = useTransition(); return ( &lt;&gt; &lt;h2&gt;New Post&lt;/h2&gt; &lt;Form method=&quot;post&quot;&gt; {/ ... /} &lt;p&gt; &lt;button type=&quot;submit&quot;&gt; {transition.submission ? 'Creating ...' : 'Create Post' } &lt;/button&gt; &lt;/p&gt; &lt;/Form&gt; &lt;/&gt; );} 現在如果啟用 JavaScript 的話，使用者體驗好了一些。一些您可以做的優化像是新增時自動將 title 轉換填入 slug，讓使用者可以自行在調整。 教學大致上到這裡，您可以思考一下如何建置 /admin/edit 編輯文章。側邊欄的連結可以使用。建立一個新的路由讀取文章，將資料放入欄位，全部需要的程式碼在 app/routes/posts/$slug.tsx 和 app/routes/admin/new.tsx 都有。 希望您會喜歡 Remix。","link":"/2021/12/31/remix-quickstart/"},{"title":"如何使用 Chrome DevTools 的對比檢查","text":"在建置無障礙網站中一個很重要的一部分就是確保可讀性，意思就是要確保足夠的顏色對比度。 舉例來說我們部落格的備註區塊，對比度是足夠的! 您可以試著調整顏色，王兩條曲線上面移動會導致對比度不足。 2 : 1 表示可讀性很差 4.5 : 1 符合最低可讀性，也是無障礙 AA 規範 7 : 1 無障礙檢測等級 AAA 16 : 1 高可讀性 21 : 1 最高對比度，例如黑字白底 概念上是簡單的，但實務上可能會被忽略。有時候顏色看起來 OK 但實際上對比度是不夠的，此時 Chrome DevTools 就可以幫上忙","link":"/2022/01/08/chrome-devtools-contrast-checker/"},{"title":"Inertia - Server-side Rendering (SSR) 以 React 為範例","text":"本文為官方文件翻譯，如使用其他前端框架可參考官方 SSR 支援提前渲染造訪的頁面，並且回傳渲染的 HTML 到瀏覽器。這讓造訪者可以在資源完整載入之前看到並和頁面互動，另外提供的好處像是減少搜尋引擎分析建置索引的時間，優化 SEO。 SSR 尚未支援 Svelte 橋接器。 運作機制當 Inertia 偵測到在 Node.js 環境下運行時，會自動渲染 頁面物件 為 HTML 並回傳。 然而因為大部分 Inertia 應用程式使用像是 PHP 或 Ruby 語言建置，我們會需要使用另一個分開的 Node.js 服務來處理請求，才能渲染頁面回傳 HTML。 設定 Server-side Rendering首先我們需要使用 npm 安裝必要的相依套件 1$ npm i react-dom 同時需要安裝 @inertiajs/server，它提供了一個簡單的 HTTP 伺服器。雖然這個套件不是絕對必要的，它能避免使用變更自有 HTTP 服務所需，一般來說可以讓事情單純一些 1$ npm i @inertiajs/server 接著我們需要建立 resources/js/ssr.js 檔案 1$ touch resources/js/ssr.js 這個檔案會非常類似 app.js ，差別是這不是給瀏覽器使用的，而是 Node.js 下面為完整範例 12345678910111213import React from 'react';import ReactDOMServer from 'react-dom/server';import { createInertiaApp } from '@inertiajs/inertia-react';import createServer from '@inertiajs/server';createServer((page) =&gt; createInertiaApp({ page, render: ReactDOMServer.renderToString, resolve: (name) =&gt; require(`./Pages/${name}`), setup: ({ App, props }) =&gt; &lt;App {...props} /&gt;, })); 請確認加入任何在 app.js 但這裡缺少的東西例如其他套件或自訂的 mixins。不過，並不是所有東西都需要加入，舉例來說 InertiaProgress 就可以被忽略，因為它不會在 SSR 模式被使用。 此外，不要在 ssr.js 使用拆分程式碼，這不會有任何幫助 (mix.extract()) 。當然客戶端 app.js 您完全可以使用。 預設 Inertia SSR 伺服器會使用埠 13714 。但您可以在 createServer 的第二個參數調整。 Vue2 如果您使用 PortalVue 套件，它必須要在 import {createRenderer} from 'vue-server-renderer' 後面。 設定 Laravel Mix為了讓我們的 Webpack 編譯的東西在 Node 正確執行，我們需要安裝 webpack-node-externals 1$ npm i webpack-node-externals 然後，建置一個新的設定檔 webpack.ssr.mix.js 。因為目前使用的 Laravel Mix 不支援在 webpack.mix.js 提供多個設定。 1$ touch webpack.ssr.mix.js 這裡提供一個範例。注意它看起來和 webpack.mix.js 非常類似，不同的地方在於它只編譯 JavaScript 不編譯 CSS。 確認定義的任何 alias 都要記得。接著使用 webpackConfig() 設定 target 為 node 和 externals 使用 [webpackNodeExternals()] 12345678910111213const path = require('path')const mix = require('laravel-mix')const nodeExternals = require('webpack-node-externals')mix .options({ manifest: false }) .js('resources/js/ssr.js', 'public/js') .react() .alias('@': path.resolve('resources/js')) .webpackConfig({ target: 'node', externals: [nodeExternals()], }) 支援 Server-side Rendering 自動 SSR 渲染目前只支援 Laravel adapter。不過，我們正積極的開發 Rails adapter。 下一步我們需要確認 @inertiaHead 被包含在 app.blade.php 的 &lt;head&gt; 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0&quot; /&gt; &lt;link href=&quot;{{ mix('/css/app.css') }}&quot; rel=&quot;stylesheet&quot; /&gt; &lt;script src=&quot;{{ mix('/js/app.js') }}&quot; defer&gt;&lt;/script&gt; @inertiaHead &lt;/head&gt; &lt;body&gt; @inertia &lt;/body&gt;&lt;/html&gt; 最後，我們需要在 inertia.php 啟動 SSR。如果您在 config 目錄下海沒有這支檔案可以執行下面指令 1$ php artisan vendor:publish --provider=&quot;Inertia\\ServiceProvider&quot; 然後設定 ssr 選項下的 enabled 為 true 123456789101112131415161718192021222324252627&lt;?phpreturn [ /* |-------------------------------------------------------------------------- | Server Side Rendering |-------------------------------------------------------------------------- | | These options configures if and how Inertia uses Server Side Rendering | to pre-render the initial visits made to your application's pages. | | Do note that enabling these options will NOT automatically make SSR work, | as a separate rendering service needs to be available. To learn more, | please visit https://inertiajs.com/server-side-rendering | */ 'ssr' =&gt; [ 'enabled' =&gt; true, 'url' =&gt; 'http://127.0.0.1:13714/render', ],// ... 建置應用程式現在您有兩個建置流程 - 一個是客戶端, 一個是伺服器端 12$ npx mix$ npx mix --mix-config=webpack.ssr.mix.js 執行兩個建置指令並確認沒有任何錯誤。記住您現在建置的是一個 “Isomorphic” 同構應用程式，意思是您的應用程式同時可以在瀏覽器和伺服器上執行。 「如果兩個結構是同構的，那麼其上的對象會有相似的屬性和操作，對某個結構成立的命題在另一個結構上也就成立。」簡單來說，同構的意思指的是兩個實體是不相同的，但具有相似的操作行為。 執行 Node.js 服務當檔案建置完成，您應可以使用下面指令執行 1$ node public/js/ssr.js 一旦執行成功，您的應用程式應可支援 SSR 了。實際上您應該要刻意關閉 JavaScript 還能夠瀏覽應用程式。 客戶端 Hydration (僅支援 Vue)搭配這些設定，Vue 會自動使用 hydrate 靜態標籤，而不是全部重新渲染。 然而客戶端 hydrate 要正常運作，伺服器產生的 HTML 必須要符合，否則會看到警告。 正常情況下您產生的頁面元件應該是一致的，如果您看到警告可以參考 Vue 官方文件的說明。 佈署設定當佈署支援 SSR 應用程式時，您會需要同時執行 app.js 和 ssr.js。其中一個方式是更新 package.json 的 prod 1&quot;prod&quot;: &quot;mix --production &amp;&amp; mix --production --mix-config=webpack.ssr.mix.js&quot;, Laravel Forge要在 Forge 啟用 SSR 伺服器，需建立新的 daemon 執行 node public/js/ssr.js 記下 daemon ID 您需要在部署 script 中使用。每當您佈署應用程式時，您需要自動重新開啟 SSR 伺服器。將下面 script 加入 12# Restart SSR server$ sudo supervisorctl restart daemon-123456:daemon-123456_00 Heroku要在 Heroku 啟動 SSR 伺服器則要更新 Procfile 的 web 。先執行 SSR 伺服器在啟動一般伺服器。注意要完成這個操作您需要 heroku/nodejs buildpack。 1web: node public/js/ssr.js &amp; vendor/bin/heroku-php-apache2 public/","link":"/2022/04/11/inertiajs-ssr/"},{"title":"[譯]React Server Component 如何運作深入解析","text":"原文: How React server components work: an in-depth guide推薦參考文章: React 新概念 — Server Components React Server Component (RSC)是個令人激動的新功能，不久的將來將會產生很大的影響包括頁面載入效能，打包檔案大小，和開發 React 應用程式的方式。在 Plasmic 開發 Visual Builder for React 時，我們非常關心效能的問題 - 許多客戶建立了行銷和電商相關的網站。因此就算 RSC 還在實驗階段，我們也已經深入探究。在這篇文章，我們會分享目前的研究成果! [toc] 何謂 React Server ComponentReact Server Component 讓伺服器和客戶端(瀏覽器)可以協作渲染 React 應用程式。思考一下典型 React element 樹狀結構通常是由不同的元件組成，裡面又渲染了更多元件。而 RSC 讓我們有可能在伺服器渲染一些元件，另外一些則交給瀏覽器渲染。 下面是 React 團隊的簡易說明，呈現了最終目標；一個 React 樹狀結構，其中橘色元件是由伺服器渲染，藍色元件則是瀏覽器渲染。 它是 Server-Side Rendering 嗎?RSC 不是 Server-Side Rendering。因為他們名字都有 Server 而且也都是在伺服器端工作，所以確實有點讓人困惑。但最好把兩者分開來看，各自的功能相互獨立不可替代。使用 RSC 不需要使用 SSR，反之也是一樣的狀況。SSR 是模擬了環境來渲染 React 樹狀結構輸出 HTML，也就是說元件沒有區分伺服器端和客戶端，元件都是一樣的，渲染的方式也是一樣的。 另外，SSR 和 RSC 是可以一起使用的，如此一來就可以在伺服器端渲染伺服器元件，然後在瀏覽器 “hydrate” 它們的屬性。後續的文章我們會探討更多關於如何一起使用。 為何要使用它?在 RSC 之前，所有的元件都是客戶端元件 - 它們必須在瀏覽器執行。當瀏覽器造訪了 React 的頁面，會下載所有 React 元件需要的程式碼，構建 React element 樹狀結構，然後渲染到 DOM 或者 “hydrate” DOM。瀏覽器擅長處理這些，並讓我們的應用程式可以互動 - 您可以使用事件處理函式(Event Handler)，管理狀態，根據事件變更 React 結構或直接更新 DOM。 如果是這樣那為什麼我們需要在伺服器渲染呢? 這裡提供一些在伺服器端渲染的優點﹔ 伺服器可以更直接存取資料來源 - 您的資料庫，GraphQL 端點，檔案系統。伺服器可以直接讀取所需的資料而不需要依賴 API，而且通常伺服器端和資料來源會相對緊密，讀取會比瀏覽器快。 伺服器使用一些大型函式庫開銷比較小，例如一個將 Markdown 轉為 HTML 的 npm 套件，因為伺服器不需要反覆下載這些相依套件，瀏覽器的話每次要使用時就要下載整包程式 簡單來說，RSC 讓伺服器和瀏覽器可以各自執行擅長的任務。伺服器元件可以專注在讀取資料上，客戶端元件則關注狀態互動達成更快的載入，減少 JavaScript 檔案大小，優化使用者體驗。 概覽讓我們先快速了解一下它是如何運作的。 我的小孩喜歡裝飾杯子蛋糕，但不太會烤蛋糕。讓他們從頭做一個蛋糕再裝飾大概會是一場惡夢。我需要給他們一袋麵粉，糖，奶油。讓他們使用烤箱，閱讀一些教學然後花上一整天。但如果是我來做這些前置作業的話會快很多 - 我先做好杯子蛋糕和糖霜，再交給他們裝飾。這樣他們可以得到樂趣，我也不用擔心他們使用烤箱。 RSC 其實就是關於實現這種分工 - 讓伺服器先處理擅長的任務，再交給瀏覽器完成剩下的任務。如此一來伺服器交給瀏覽器的東西就變少了 - 而不是麵粉，奶油，烤箱等等。直接給 12 個杯子蛋糕效率高很多。 回到頁面上的 React 樹狀結構，某些元件可以在伺服器渲染，某些在瀏覽器。這裡提供一個簡化的概念說明﹔伺服器照常只渲染伺服器元件，把元件轉換成 HTML 元素例如 div， p 等。每當遇到需要在瀏覽器渲染的客戶端元件就輸出一個”佔位”包含”指示” - 如何使用對應的客戶端元件和 props 來填補空缺。 然後瀏覽器取得這份”指示”和輸出，填補空缺的客戶端元件。登登! 完成。 當然這不是完整真實的執行流程我們很快就會進入那些棘手的細節，但這裡您可以先有個大致上概覽的概念。 客戶端-伺服器端元件區分首先 - 到底什麼是伺服器元件? 到底什麼是給伺服器用的，什麼是給客戶端用的? React 團隊定義 - 根據附檔名決定該元件屬於哪種類型。如果附檔名是 .server.jsx 則為伺服器元件; 如果是 .client.jsx 就是客戶端元件。如果都沒有則元件兩者都支援。 如此一來無論開發者還是打包工具都可以清楚的分辨，特別是打包工具，現在它們通過檢查檔名來分別進行不同的處理。很快您就會看到，打包工具對於讓 RSC 運作扮演著非常重要的角色。 因為伺服器元件是在伺服器執行的，客戶端元件在瀏覽器執行，關於各自能做些什麼有很多限制。但記住最重要的就是客戶端元件不能 import 伺服器元件，因為伺服器元件不能在瀏覽器執行，這會導致程式碼在瀏覽器無法運作。如果客戶端元件相依伺服器元件，那麼最終會導致我們會把那些不合規範的相依全部加入瀏覽器使用的 bundle。 最後一點可能有點難懂; 這表示像下面這樣的客戶端元件是不合規範的 12345678910// ClientComponent.client.jsx// 不可import ServerComponent from './ServerComponent.server';export default function ClientComponent() { return ( &lt;div&gt; &lt;ServerComponent /&gt; &lt;/div&gt; );} 但，如果客戶端元件不能 import 伺服器元件，那我們怎麼辦到像下面圖示那樣的樹狀結構。下圖的伺服器/客戶端元件不是交錯在一起? 我們要如何讓伺服器元件(橘色)掛在客戶端元件(藍色)底下? 雖然您不能在客戶端元件直接 import 和使用伺服器元件，但您可以使用 “composition” 組合的方式，即利用 props.children 傳入的方式 - 客戶端元件依然可以從 props 取得一個暫時不知道是什麼的 ReactNode，而那些 ReactNode 可以是伺服器元件。舉例來說 1234567891011121314151617181920212223242526272829// ClientComponent.client.jsxexport default function ClientComponent({ children }) { return ( &lt;div&gt; &lt;h1&gt;Hello from client land&lt;/h1&gt; {children} &lt;/div&gt; );}// ServerComponent.server.jsxexport default function ServerComponent() { return ( &lt;span&gt;Hello from server land&lt;/span&gt; );}// OuterServerComponent.server.jsx// OuterServerComponent 可以支援客戶端和伺服器元件實例化// 我們把 &lt;ServerComponent /&gt; 作為 children 傳入import ClientComponent from './ClientComponent.client';import ServerComponent from './ServerComponent.server';export default function OuterServerComponent() { return ( &lt;ClientComponent&gt; &lt;ServerComponent /&gt; &lt;/ClientComponent&gt; );} 這個限制將對您如何組織元件發揮 RSC 的功能有著重大的影響。 RSC 渲染生命週期接著讓我們深入渲染 RSC 的細節。使用 RSC 不需要了解全部細節，但對其運作有些了解對於您後續開發與幫助。 1. 伺服器收到請求因為伺服器需要處理一些渲染，因此使用 RSC 的頁面生命週期從伺服器開始，為了回應呼叫 API 而渲染 React 元件。 這個根元件一定是伺服器元件，它可以渲染其他伺服器或客戶端元件。伺服器會根據請求和傳入的資料計算伺服器元件和使用的 props。這種請求通常是為了取得特定 URL 頁面，Shopify Hydrogen 支援更細的方法，React 團隊則提供一個原始實作 2. 伺服器序列化根元件元素為 JSON這一步最終的目標是渲染初始化的 Root 伺服器元件到基本 HTML 標籤的結構中，包含客戶端元件的佔位。然後序列化這個樹狀結構，再送到瀏覽器，接著瀏覽器反序列化，填入客戶端元件，最後渲染結果。 照上面的例子 - 假如我們要渲染 &lt;OuterServerComponent /&gt; 我們是不是可以就 JSON.stringify(&lt;OuterServerComponent/&gt;) 來取得序列化的元素結構? 差不多，但不完全是! 回想一下 React element 實際上就是一個物件有 type 欄位，值可以是字串例如 &quot;div&quot; 或函式 - React 元件物件實例。 123456789101112131415161718&gt; React.createElement('div', { title: 'oh my' }){ $$typeof: Symbol(react.element), type: &quot;div&quot;, props: { title: &quot;oh my&quot; }, ...} &gt; function MyComponent({ children }) { return &lt;div&gt;{children}&lt;/div&gt;}&gt; React.createElement(MyComponent, { children: 'oh my'});{ $$typeof: Symbol(react.element), type: MyComponent, // A function props: { children: 'oh my' } ...} 當您的 React element 是元件時 - 不是基本的 HTML tag - type 欄位會是一個函式，函式不能直接序列化成 JSON! 為了正確地將所有內容序列化成 JSON 字串，React 傳入了 replacer function 來協助 JSON.stringify() 正確的處理函式元件，您可以在 ReactFlightServer.js 中找到 resolveModelToJson() 就是協助的 replacer。 12345678910// replacer 函式範例function replacer(key, value) { if (typeof value === 'string') { return undefined; } return value;}var foo = {foundation: 'Mozilla', model: 'box', week: 45, transport: 'car', month: 7};JSON.stringify(foo, replacer);// '{&quot;week&quot;:45,&quot;month&quot;:7}' 具體來說每當 resolveModelToJson() 看到要序列化的 “React element” 如果是基本的 HTML 標籤如 div 那就是可被序列化的東西，不做任何事 如果是伺服器元件，那會執行元件函式，就是存在 type 的那個函式，然後序列化。這裡的目標是要將伺服器元件轉成 HTML 標籤 如果是客戶端元件，那它也是可被序列化的! type 欄位已進指向模組參考物件，而不是元件函式。 等等!! 什麼意思!? 什麼是模組參考物件?RSC 引入了一個新的 type 欄位值叫做 “模組參考(Module Reference)”取代元件函式，它是可序列化的參考。 舉例來說，ClientComponent React element 看起來可能如下 123456789{ $$typeof: Symbol(react.element), type: { $$typeof: Symbol(react.module.reference), name: 'default', filename: './src/ClientComponent.client.js' }, props: { children: 'oh my' }} 但這種處理是什麼時候發生的 - 我們是在哪邊將客戶端函式變成可序列化的參考的?。 是您的打包工具 (Bunlder) 負責處理的! React 團隊針對 Webpack 提供了官方 RSC 支援，發佈了以 webpack loader 或 node-register 形式的 react-server-dom-webpack 。當一個伺服器元件 “import” 了 *.client.jsx 檔案，取代實際取得該元件的是換成單純取得模組參考物件並包含檔案名稱和匯出名稱。任何客戶端元件函式都不會在伺服器建構的 React 樹狀結構中。 再看看一下上面的例子，在我們要試圖序列化 &lt;OuterServerComponent /&gt; 時，我們最終會得到 JSON 概略如下: 12345678910111213141516171819{ $$typeof: Symbol(react.element), type: { $$typeof: Symbol(react.module.reference), name: 'default', filename: './src/ClientComponent.client.js' }, props: { // 傳入 ClientComponent 的是 &lt;ServerComponent /&gt; children: { // ServerComponent 會直接渲染成 HTML tags $$typeof: Symbol(react.element), type: 'span', props: { children: 'Hello from server land' } } }} 可序列化 React 樹狀結構在這個流程的最後步驟，我們希望在伺服器端得到大概如下的結構然後回送給瀏覽器執行 全部的 props 必須可序列化因為我們要序列化整個 React 結構到 JSON，所有要傳入客戶端元件的 props 或 HTML 標籤也必須要序列化。意思是在伺服器元件您不能傳入事件函式 (Event Handler) 作為 props 12345678// 錯誤! 伺服器元件不能傳入函式做為屬性值function SomeServerComponent() { return ( &lt;button onClick={() =&gt; alert('OHHAI')}&gt; Click me &lt;/button&gt; );} 但須注意的一點是在 RSC 處理過程中如果遇到客戶端元件，我們是不會調用元件函式或進到下面的客戶端元件。因此如果您有一個客戶端元件裡面還有其他客戶端元件 123456789101112131415function SomeServerComponent() { return ( &lt;ClientComponent1&gt; Hello World! &lt;/ClientComponent1&gt; );}function ClientComponent1({ children }) { return ( &lt;ClientComponent2 onChange={() =&gt; {}}&gt; {children} &lt;/ClientComponent2&gt; )} ClientComponent2 根本不會在 RSC JSON 結構中出現; 我們只會看到 ClientComponent1 的模組參考和 props。因此在 ClientComponent1 裡面傳入事件處理函式給 ClientComponent2 完全是沒問題的。 3. 瀏覽器重新建構 React 樹狀結構瀏覽器收到 JSON 並且開始重新構建 React 樹狀結構以便在瀏覽器渲染結果。當遇到 type 是模組參考時，我們希望將它換成實際的客戶端元件函式。 再一次這個工作需要打包工具的幫助; 之前是打包工具幫我們在伺服器端將函式替換成模組參考，現在打包工具知道該如何在瀏覽器把參考換成元件函式。 重建的 React 樹狀結構看起來入下 然後我們就可以像往常一樣渲染和 “commit” 結構到 DOM。 可以搭配 Suspense 使用嗎?Yes! “Suspense” 在上述所有步驟中都扮演者不可或缺的角色。 我們在本文中故意避開談論 Suspense，因為 Suspense 是個龐大的主題應該獨立介紹。但簡短提一下 - Suspense 讓我們可以在React 元件尚未準備好，例如讀取資料還沒好時，拋出 Promise。這些 Promise 會在 “Suspense boundary” 被攔截 - 每當一個 Promise 從 &lt;Suspense&gt; 底下被拋出，React 會暫停渲染直到 Promise 完成，然後繼續工作。 當我們在伺服器端呼叫伺服器元件函式以產生 RSC 輸出時，當這些函式需要讀取資料，可能會拋出 Promise。如果遇到這種情況就會輸出一個佔位，直到 Promise 完成，會在調用一次伺服器元件函式，如果成功則輸出完整的程式碼片段。事實上我們在建立 RSC 串流時，遇到 Promise 會暫停，解析完成則繼續補上額外的程式碼。 同樣的，在瀏覽器，我們以串流的方式 fetch() RSC JSON。這個流程也一樣，如果有 Suspense 佔位且串流中沒有相關內容就拋出 Promise。或者是模組參考但元件還沒下載好也一樣。 多虧了 Suspense，您可以在伺服器元件讀取資料時以串流的方式處理 RSC 輸出，然後瀏覽器可依逐步渲染取得的資料並動態讀取需要的客戶端元件。 RSC 傳輸格式那到底伺服器輸出了什麼? 如果您在讀到上面 “JSON” 和 “串流”的時候覺得困惑，您的疑惑是對的! 那到底伺服器是怎麼以串流的方式把資料傳到瀏覽器? 是個簡單的格式，一個 JSON blob 一行搭配標記 ID。下面是 &lt;OuterServerComponent /&gt; 的 RSC 輸出範例 12M1: {&quot;id&quot;: &quot;./src/ClientComponent.client.js&quot;, &quot;chunks&quot;: [&quot;client1&quot;], &quot;name&quot;:&quot;&quot;}J0: [&quot;$&quot;, &quot;@1&quot;, null, {&quot;children&quot;: [&quot;$&quot;, &quot;span&quot;, null, {&quot;children&quot;: &quot;Hello from server land&quot;}]}] 上面片段，M 開頭的行，定義了客戶端元件模組參考，包含了可以在 bundle 搜尋元件函式的資訊。J 開頭定義的是 React 元素結構，@1 則指向由 M 定義的客戶端元件。 這個格式具備支援串流特性 - 只要客戶端讀取一行，就可以解析 JSON 執行對應更新。如果伺服器在渲染時遇到 Suspense boundary，您就會看到多個 J 對應 “解析完成之後，會取得的程式碼資訊”。 例如: 123456789101112131415161718192021222324252627282930313233343536373839// Tweets.server.jsimport { fetch } from 'react-fetch';import Tweet from './Tweet.client';export default function Tweets() { const tweets = fetch('/tweets').json(); return ( &lt;ul&gt; {tweets.slice(0, 2).map((tweet) =&gt; ( &lt;li&gt; &lt;Tweet tweet={tweet} /&gt; &lt;/li&gt; ))} &lt;/ul&gt; );}// Tweet.client.jsexport default function Tweet({ tweet }) { return ( &lt;div onClick={() =&gt; alert(`Written by ${tweet.username}`)} &gt; {tweet.body} &lt;/div&gt; );}// OuterServerComponent.server.jsexport default function OuterServerComponent() { return ( &lt;ClientComponent&gt; &lt;ServerComponent /&gt; &lt;Suspense fallback={'Loading tweets'}&gt; &lt;Tweets /&gt; &lt;/Suspense&gt; &lt;/ClientComponent&gt; );} RSC 串流資料看起來如下: 12345M1:{&quot;id&quot;:&quot;./src/ClientComponent.client.js&quot;,&quot;chunks&quot;:[&quot;client1&quot;],&quot;name&quot;:&quot;&quot;}S2:&quot;react.suspense&quot;J0:[&quot;$&quot;,&quot;@1&quot;,null,{&quot;children&quot;:[[&quot;$&quot;,&quot;span&quot;,null,{&quot;children&quot;:&quot;Hello from server land&quot;}],[&quot;$&quot;,&quot;$2&quot;,null,{&quot;fallback&quot;:&quot;Loading tweets...&quot;,&quot;children&quot;:&quot;@3&quot;}]]}]M4:{&quot;id&quot;:&quot;./src/Tweet.client.js&quot;,&quot;chunks&quot;:[&quot;client8&quot;],&quot;name&quot;:&quot;&quot;}J3:[&quot;$&quot;,&quot;ul&quot;,null,{&quot;children&quot;:[[&quot;$&quot;,&quot;li&quot;,null,{&quot;children&quot;:[&quot;$&quot;,&quot;@4&quot;,null,{&quot;tweet&quot;:{...}}}]}],[&quot;$&quot;,&quot;li&quot;,null,{&quot;children&quot;:[&quot;$&quot;,&quot;@4&quot;,null,{&quot;tweet&quot;:{...}}}]}]]}] J0 現在多了一個額外的子階層 - Suspense 的部分，它的 children 指向 @3。有趣的是 @3 現在還沒定義。當伺服器完成讀取推文(tweets) ，就會輸出 M4 其定義了模組參考 Tweet.client.js 元件。然後 J3 定義了應該要被放到 @3 位置的東西。接著J3 的 children 執行 M4 即 Tweet 元件。 這裡另一個要注意的是，打包工具自動將 ClientComponent 和 Tweet 分成兩個分開的檔案，讓瀏覽器可以延遲載入 Tweet 。 使用 RSC 格式資料那瀏覽器要怎麼把這個串流格式的資料變成實際的 React element? react-server-dom-webpack 包含了處理 RSC 回應並重建的功能。下面是簡化版的 “Root client component” 123456789101112import { createFromFetch } from 'react-server-dom-webpack';function ClientRootComponent() { const response = createFromFetch(fetch('/rsc?...')); return ( &lt;Suspense fallback={null} &gt; {response.readRoot()} &lt;/Suspense&gt; );} 我們使用 react-server-dom-webpack 來讀取從 API 取回的 RSC 回應。然後 response.readRoot() 會回傳 React element 並且隨著串流的資料更新。在取得任何資料之前會拋出 Promise - 因為還沒有內容準備好。然後當它處理第一個 J0，會建立對應的 React element 結構，處理 Promise ，React 恢復渲染流程，但當遇到還沒準備好的 @3 參考，另一個 Promise 會拋出。一旦 Promise 完成，讀取 J3 ，React 會再次恢復渲染。因此當我們使用串流形式的回應，我們可以持續更新渲染元素直到全部完成。 為何不直接輸出 HTML為何要發明一個全新的傳輸格式? 客戶端的目標是重新建構 React 元素。比起解析 HTML 來建立元素使用這種方式會相對簡單，並且這樣我們對後續變更可以 “commit” 最小的 DOM 變更。 這真的比單純從客戶端元件讀取資料好嗎?反正我們都需要發送 API 請求到伺服器來讀取資料，這樣真的比我們請求只讀取資料，然後全部在客戶端渲染好嗎? 這取決於您需要渲染什麼到畫面上。使用 RSC，您可以優化讀取效能，預先處理要顯示的資料。如果您只需要渲染一小部分資料，需要下載大量的 JavaScript 又或者多種資料讀取互相依賴需要一個接一個讀取，這些情況在伺服器上直接處理會快很多。 那麼關於 Server-Side Rendering 呢?我知道! 我知道! React 18 您是可以 SSR 和 RSC 一起使用，在伺服器端產生 HTML，在瀏覽器 “hydrate” RSC。後續會有更多關於這個題目的探討。 更新渲染的伺服器元件那如果我需要更新伺服器元件呢? 舉例來說，如果我切換檢視頁面從 A 產品頁到 B 產品頁? 由於渲染發生在伺服器，這會發出另一個 API 請求並取得新的 RSC 傳輸資料。好消息是，一旦瀏覽器取得新內容它可以執行一般的差異比對然後只做最小的 DOM 變動，並且狀態和事件函式都會在。對客戶端元件來說，這個更新跟完全在瀏覽器發生的情況沒有不同。 目前，您必須從伺服器根元件來重新渲染整個 React 樹狀結構，但未來，是可能可以從階層下的節點渲染。 為什麼需要為了 RSC 採用 Meta-Framework (Next.js / Shopify Hydrogen)React 團隊表示 RSC 最初的意思是建議通過 Meta-Framework 來使用，而不是直接使用。但為什麼要這樣? Meta-Framework 可以為我們提供什麼? 你不一定要這麼做，但使用 Meta-Framework 會輕鬆很多。通常 Meta-Framework 會提供友善的抽象，你就不用思考如何在伺服器產生 RSC 傳輸資料，還有要怎麼在瀏覽器使用。 另外，Meta-Framework 也支援 SSR，同時他們做了很多工作確保如果您使用 RSC 後伺服器產生的 HTML 可以被正確的 “hydrate”。 如您所見，您還需要處理打包工具的設定才能在瀏覽器正確的使用客戶端元件。目前已經有 webpack 的支援，Shopify 正在開發 Vite 的整合。這些套件目前都須變成 React 檔案庫的一部分，因為 RSC 需要的很多東西都還沒公開。不過一旦開發完成，後續應該是可以在不用 Meta-Framework 的情況下使用。 RSC 可以使用了嗎?RSC 目前您可以在 Next.js 實驗版本使用，還有 Shopify Hydrogen 開發版，但不適合在正式產品。後續的部落格文章會深入探討這些框架如何使用 RSC。 不過毫無疑問，RSC 將會成為 React 未來重要的一部分。這是 React 的答案 - 提供更快的頁面載入，減少 JavaScript bundle，縮短互動時間。至於如何使用 React 構建多頁面應用程式，更全面的探討，可能還沒有準備好，但很快就會開始關注了。","link":"/2022/02/02/react-server-component-in-depth-guide/"},{"title":"Chrome 使用序列埠","text":"Web Serial API 連接裝置溝通。 Web Serial API 為新功能支援專案的其中一部分，Chrome 89 已支援 何謂 Web Serial API?序列埠是雙向溝通的介面支援傳送和接收。 Web Serial API 為網頁提供一種方式通過 JavaScript 讀取和寫入到連接裝置。連接裝置就是裝置連接到系統上的系列埠或者可移除的 USB 和藍芽模擬的系列埠。 換句話說 Web Serial API 連接了網頁和實體裝置使網頁可以和裝置例如微控制器或 3D 列印機溝通。 當作業系統要求應用程式使用 Serial API 而不是 USB API 來溝通時，Web Serial API 也是 WebUSB 的好夥伴。 序列埠是依序通訊界面，在 60 年代初期推出。用於連續傳送和接收資料，一次傳輸一個 byte。常見的序列埠有 RS-232 ，60 年代的桌機幾乎都是標配，其他標準包含 RS-422 RS-485。雖然主流的電腦已經淘汰使用，但這些埠在產業還是很常見。大部分的序列埠使用 9-pin DB-9 連接器，通常稱為 COM 埠。 過去 COM 埠被用在連接硬體和電腦。硬體元件包含麥克風，數據機，印表機。然而今日 COM 埠大多只出現在工業環境。 序列埠非常可靠這已經被驗證了 60 多年。而 COM 埠最大的限制就是資料傳輸非常小，例如 RS-232 只有 1Mbps。 而 USB ，簡言之是 Universal Serial Bus 通用序列匯流排，也是一個埠支援電腦和硬體溝通。 總而言之，序列埠的設計是提供一個簡單的一對一連線，可靠，但速度不快。而 USB 提供了高速資料傳輸且一個埠可以掛載裝置 建議使用情境在教育，興趣，以及工業部門使用者會連接外部設備到電腦。這些裝置通常由微控制器透過客製的軟體使用序列連線來控制。而某些客製軟體是使用 Web 技術開發的。 Arduino Create Betaflight Configurator Espruino Web IDE Microsoft MakeCode 有些情況下 Web 是通過手動安裝的代理應用程式和裝置通訊的。或者使用框架例如 Electron 打包的應用程式。還有使用者需要執行額外步驟例如複製編譯的應用程式到電腦。 上面這些情境，都可以利用提供讓網頁和裝置直接溝通來改善使用體驗 使用 Web Serial API偵測功能要檢查瀏覽器是否支援 Web Serial API 123if ('serial' in navigator) { // The Web Serial API is supported} 開啟序列埠 - 連線Web Serial API 在設計上是非同步的。主要是因為資料隨時都可以發送和接收，如此可以防止網頁 UI 阻塞。 要開啟序列埠首先需要存取 SerialPort 物件。為此，您可以調用 navigator.serial.requestPost() 開啟瀏覽器提示視窗選擇埠或者使用 navigator.serial.getPorts() 從已經授權的序列埠列表中選擇其中一個 123document.querySelector('button').addEventListener('click', async () =&gt; { const port = await navigator.serial.requestPort();}); 1const ports = await navigator.serial.getPorts(); navigator.serial.requestPort() 函式支援一可選物件參數可以定義過濾條件。可以用於過濾利用 USB 連線的特定裝置，例如符合 USB 供應商(usbVendorId) 或產品識別(usbProductId) 12345678const filters = [ { usbVendorId: 0x2341, usbProductId: 0x0043 }, { usbVendorId: 0x2341, usbProductId: 0x0001 },];const port = await navigator.serial.requestPort({ filters });const { usbProductId, usbVendorId } = port.getInfo(); 呼叫 requestPort() 提示視窗，讓使用者選擇裝置然後回傳 SerialPort 物件。一旦取得 SerialPort 物件，執行 port.open() 搭配希望的調變速率 (baudRate)。baudRate 屬性設定序列發送資料的速度。這是用來描述每秒幾 bit (bps) 的單位。確認裝置的文件取得正確的值，如果設定錯誤則發送和接受的資料會變亂碼。有些模擬序列埠的 USB 和藍芽裝置，這個值可以任意設定，因為會被忽略。 鮑（Baud）即調變速率。鮑率可以被理解為單位時間內傳輸符號的個數（傳符號率）。以 RS232 為例通常是 300, 1200, 2400, 9600, 19200, 38400, 115200 等。假設設定為 9600 則等於每秒 9600 bit 的傳輸速率。 123const port = await navigator.serial.port.requestPort();await port.open({ baudRate: 9600 }); 在連接序列埠時，您也可以設定其他屬性； dataBits: 每幀的資料 bit 數量(7 或 8) stopBits: 幀尾的停止位數(1 或 2) parity: 同位元檢查模式 (none, even, odd) bufferSize: 讀寫緩衝區的大小(必須小於 16 MB) flowControl: Flow 控制模式(none 或 hardware) 讀取序列埠Web Serial API 的輸入和輸出的串流由 Streams API 處理 如果串流對您來說比較陌生可以參考 Streams API 概念。本文只涉及基本的串流處理。 在序列埠連線建立之後， SerialPort 物件的 readable 和 writable 會回傳 ReadableStream 和 WritableStream。它們可以用來對裝置接收和傳送資料，資料傳輸使用 Uint8Array 物件實例。當裝置傳來資料時，port.readable.getReader().read() 會非同步的傳送兩個屬性; value 和 done 。如果 done 為 true ，那麼序列埠表示已關閉或沒有其他資料了。執行 port.readable.getReader() 會建立讀取器和鎖住 readable ，當 readable 鎖住時，序列埠不能關閉。 123456789101112131415const reader = port.readable.getReader();// 監聽序列埠裝置while (true) { const { value, done } = await reader.read(); if (done) { reader.releaseLock(); break; } // 值為 Unit8Array // 轉為字串 // new TextDecoder().decode(value) // String.fromCharCode.apply(null, value) console.log(value);} 一些非關鍵的讀取錯誤可能會發生例如緩衝溢出，偵發生錯誤，或同位元檢查錯誤(奇偶校驗)。這些例外可以透過在目前迴圈的外層檢查 port.readable 加入另外一個迴圈來擷取。這是因為只要不是嚴重錯誤 ReadableStream 都會自動建立。如果是嚴重的錯誤例如裝置移除則 port.readable 會變成 null 。 123456789101112131415161718while (port.readable) { const reader = port.readable.getReader(); try { while(true) { const { value, done } = await reader.read(); if (done) { reader.releaseLock(); break; } if (value) { console.log(value) } } } caatch (error) { // 處理非關鍵錯誤 }} 如果裝置傳回文字，你可以將 port.readable Pipe 給 TextDecoderStream 如下。一個 TextDecoderStream 是一個轉換的串流可以讀取 Unit8Array 並將它們轉換位字串。 123456789101112131415const textDecoder = new TextDecoderStream();const readableStreamClosed = port.readable.pipeTo(textDecoder.writable);const reader = textDecoder.readable.getReader();// 監聽資料while (true) { const { value, done } = await reader.read(); if (done) { reader.releaseLock(); break; } console.log(value);} 寫入資料要傳資料給裝置，需傳入資料到 port.writable.getWriter().write()。當需要關閉的時候可以執行 port.writable.getWriter() 的 releaseLock() 。 1234567const writer = port.writable.getWriter();const data = new Unit8Array([104, 101, 108, 108, 111]); // helloawait writer.write(data);// 允許埠稍後關閉writer.releaseLock(); 下面範例將 TextEncoderStream Pipe 給 port.writable 12345const textEncoder = new TextEncoderStream();const writableStreamClosed = textEncoder.readable.pipeTo(port.writable);const writer = textEncoder.writable.getWriter();await writer.write('hello'); 關閉埠執行 port.close() 若 readable 和 writable 已經解鎖 releaseLock() ，則關閉序列埠。 1await port.close(); 然而，黨持續使用迴圈讀取裝置資料時，port.readable 會一直鎖住知道出錯。這種情況執行 reader.cancel() 會強制 reader.read() 立刻 resolve 回 { value: undefined, done: true } 然後允許迴圈執行 reader.releaseLock() 123456789101112131415161718192021222324252627282930313233// 沒有搭配 transform streamlet keepReading = true;let reader;async function readUntilClosed() { while (port.readable &amp;&amp; keepReading) { reader = port.readable.getReader(); try { while (true) { const { value, done } = await reader.read(); if (done) { break; } } console.log(value); } catch (error) { // 處理錯誤 } finally { reader.releaseLock(); } } await port.close();}const closedPromise = readUntilClosed();document.querySelector('button').addEventListener('click', async () =&gt; { keepReading = false; reader.cancel(); await closedPromise;}); 如果使用 Transform Streams (TextDecoderStream, TextEncoderStream)則關閉會更複雜一點。reader.cancel()，writer.close()，port.close() 要依序調用。錯誤會通過 Transform Stream 到序列埠。因此傳遞不會立刻發生，您需要 readableStreamClosed 和 writableStreamClosed ; 稍早利用 port.readable 和 port.writable 建立的 Promise 。 取消讀取會使串流中止; 這也是為何需要 catch 並忽略錯誤 1234567891011121314151617181920212223242526// 使用 Transform streamconst textDecoder = new TextDecoderStream();const readableStreamClosed = port.readable.pipeTo(textDecoder.writable);const reader = textDecoder.readable.getReader();while (true) { const { value, done } = await reader.read(); if (done) { reader.releaseLock(); break; } console.log(value);}const textEncoder = new TextEncoderStream();const writableStreamClosed = textEncoder.readable.pipeTo(port.writable);reader.cancel();await readableStreamClosed.catch(() =&gt; { /* Ignore the error */});writer.close();await writableStreamClosed;await port.close(); 監聽連線與中斷如果序列埠是由 USB 裝置提供，那麼裝置可能隨時和系統連線或中斷。當網頁獲得存取權限應可以監聽 connect 和 disconnect 事件。 12345678navigator.serial.addEventListener('connect', (event) =&gt; { // TODO: Automatically open event.target or warn user a port is available.});navigator.serial.addEventListener('disconnect', (event) =&gt; { // TODO: Remove |event.target| from the UI. // If the serial port was opened, a stream error would be observed as well.}); Chrome 89 之前 connect 和 disconnect 事件會觸發一個自訂的 SerialConnectionEvent 物件和一個 SerialPort 介面的 port 屬性。您可以使用 event.port || event.target 來處理過度狀況。 處理訊號在建立連線之後，您可以利用虛列埠查詢和設定訊號來檢查裝置或控制。這些訊號為布林值。例如一些裝置如 Arduino 如果進入編程模式 DTR 訊號會啟動。 設定 輸出訊號 和取得 輸入訊號 分別由 port.setSignals() 和 port.getSignals() 完成 12345678// 關閉中斷訊號await port.setSignals({ break: false });// 啟動 DTR 訊號await port.setSignals({ dataTerminalReady: true });// 關閉 RTS 序號await port.setSignals({ requestToSend: false }); 12345const signals = await port.getSignals();console.log(`Clear To Send: ${signals.clearToSend}`);console.log(`Data Carrier Detect: ${signals.dataCarrierDetect}`);console.log(`Data Set Ready: ${signals.dataSetReady}`);console.log(`Ring Indicator: ${signals.ringIndicator}`); 轉換串流 Transforming Streams當您從序列埠接收資料時，不一定會一次取得全部資料。它可能是任意片段。更多資訊可以參考 Streams API 概念。 要處理這個問題，您可以使用一些內建的串流轉換，他們可以支援解析進來的串流資料並回傳解析後的資料。串流轉換位於裝置和具體讀取使用資料的迴圈之間。在資料使用之前可以套用任意轉換。可以把它想成一條產線，一個配件進來，每一步驟都可以調整。 例如建立一個將串流根據斷行分組的轉換類別。其 transform() 每次有資料進來就會被調用。它可以將資料送到佇列或存下稍後在處理。flush() 在串流關閉時會呼叫，並處理還沒處理的資料。 要使用串流轉換類別，您需要將串流 pipe 給它。在我們上面的範例我們將原來的輸入 pipe 給 TextDecoderStream，我們需要使用 pipeThrough() 給新的 LineBreakTransformer 1234567891011121314151617class LineBreakTransformer { constructor() { this.chunks = ''; } transform(chunk, controller) { this.chunks = chunk; const lines = this.chunks.split('\\r\\n'); this.chunks = lines.pop(); lines.forEach((line) =&gt; controller.enqueue(line)); } flush(controller) { controller.enqueue(this.chunks); }} 12345const textDecoder = new TextDecoderStream();const readableStreamClosed = port.readable.pipeTo(textDecoder.writable);const reader = textDecoder.readable .pipeThrough(new TransformStream(new LinkBreakTransformer())) .getReader(); 要替裝置 debug ，可以使用 tee() 方法來分開串流。兩個串流的建立和使用各自獨立，我們可以將其中一個導到 Console 檢查。 1const [appReadable, devReadable] = port.readable.tee(); 開發小技巧在 Chrome 使用內建頁面對 Web Serial API 除錯也很簡單，開啟 about://device-log 您可以看到所有序列裝置相關的事件 Codelab在 Google Developer Codelab 您可以使用 Web Serial API 和 BBC micro:bit 互動 瀏覽器支援Web Serial API 在桌機 (Chrome OS, Linux, macOS, Windows) 版本的 Chrome 支援。 Polyfill在 Android 上可以使用 Serial API Polyfill 搭配 WebUSB API 和 USB 的序列埠溝通。該 polyfill 僅限於可使用 WebUSB API 存取的設備硬體和作業系統，因為它尚未被內置設備驅動程式支援。 安全與隱私規格作者設計與實作 API 的核心原則定義在 Controlling Access to Powerful Web Platform Features 包含控制，透明度，人體工程。使用此 API 主要由權限模型控制，該權限模型一次僅授予對單個設備的訪問權限。為響應用戶提示，用戶必須採取主動步驟來選擇特定的串行設備。 反饋Chrom 團隊很歡迎聽到關於 Web Serial API 您的想法和經驗。 關於 API 設計如果有關於 API 無法如預期運作? 或其他未支援的方法或屬性需求? 可在 Web Serial API Github repo 新增您的想法。 問題回報是否發現相關實作 Bug? 可至 https://new.crbug.com 。確認提供足夠資訊和提供簡易重現問題的步驟 資源 Read from and write to a serial port","link":"/2022/04/11/serial-web-api/"},{"title":"使用 Gitlab CI&#x2F;CD, Envoy 測試與佈署 Laravel 應用程式 (Ubuntu 22.04)","text":"介紹Gitlab 支援持續整合的功能，讓我們可以簡單的佈署變更的程式碼到伺服器。 本文我們將學習如何為 Laravel 專案設定 Envoy 任務, 然後到通過 持續交付 使用 Gitlab CI/CD 測試和佈署。 這裡假設您對於 Laravel, Linux 伺服器和 Gitlab 有基本的的經驗。 Laravel 是使用 PHP 撰寫的高品質網頁開發框架。有不錯的社群，優秀的文件。除了一般路由，Controllers，請求，回應，視圖，樣板這些內建功能，Laravel 還包含其他豐富的功能例如 Cache，事件，語系，身份驗證等等。 我們將使用一個 PHP 的 SSH 任務執行器 - Envoy。其採用簡單，輕量化的 Blade 語法 設定任務，然後我們可以在遠端伺服器上執行指令，例如從 Git 檔案庫複製專案，安裝 Composer 相依套件，執行 Artisan 指令。 初始化 Laravel 專案我們假設您已經安裝好了一個新的 Laravel 專案, 因此讓我們從單元測試和初始化 Git 開始。 單元測試每一個新建的 Laravel 會有包含兩種類型的測試: 功能 Feature 和單元 Unit, 它們在 tests 目錄下。這裡是 tests/Unit/ExampleTest.php 12345678910111213&lt;?phpnamespace Tests\\Unit;...class ExampleTest extends TestCase{ public function testBasicTest() { $this-&gt;assertTrue(true); }} 這個測試只是單純判斷給定的值是否為 true。 Laravel 預設使用 PHPUnit 測試。如果我們執行 vendor/bin/phpunit 12$ vendor/bin/phpunit# OK (1 test, 1 assertions) 這個測試將會在後續 Gitlab CI/CD 持續交付時用來檢查我們的應用程式。 push 至 Gitlab因為我們已經可以在本地端執行應用程式了，是時候將程式碼推送到 git 檔案庫。我們在 Gitlab 上建立一個新專案例如名稱 example 然後可以遵循下面指令 123456$ cd example$ git init$ git remote add origin git@gitlab.example.com:&lt;USERNAME&gt;/example.git$ git add .$ git commit -m 'Initial commit'$ git push origin main 設定正式伺服器在開始設定 Envoy 和 Gitlab CI/CD 之前，讓我們快速確認伺服器環境已經準備好可以佈署。我們需要在 Ubuntu 環境安裝 LEMP How To Install Linux, Nginx, MySQL, PHP (LEMP stack) on Ubuntu 22.04 How To Install and Configure Laravel with Nginx on Ubuntu 22.04 (LEMP) How To Install Node.js on Ubuntu 22.04 How To Install and Use PostgreSQL on Ubuntu 22.04 1234567891011121314151617181920212223242526272829### Nginx$ sudo apt update$ sudo apt install nginx# 檢查設定$ sudo nginx -t# 重載設定$ sudo systemctl reload nginx### PostgreSQL$ sudo apt install postgresql postgresql-contrib### PHP$ sudo apt install php8.1-fpm php-pgsql# For Larvel$ sudo apt install php-mbstring php-xml php-bcmath php-curl### Composer# https://www.itzgeek.com/how-tos/linux/ubuntu-how-tos/install-laravel-on-ubuntu-22-04.html$ sudo apt install -y curl$ curl -sS https://getcomposer.org/installer | sudo php -- --install-dir=/usr/bin --filename=composer### Nodejs through nvm$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash$ nvm install 18# Laravel 權限設定$ sudo chown -R www-data.www-data /var/www/&lt;YOUR_PROJECT&gt;/storage$ sudo chown -R www-data.www-data /var/www/&lt;YOUR_PROJECT&gt;/bootstrap/cache 新增使用者接著讓我們建立新的使用者用來佈署我們的應用程式, 且我們使用 Linux ACL 賦予這個使用者必須的權限 123$ sudo adduser deployer# 賦予權限$ sudo setfacl -R -m u:deployer:rwx /var/www 如果您的主機未安裝 ACL 可以使用下面指令 12# 安裝 ACL$ sudo apt install acl 新增 SSH Key假設我們想要從我們私人的 Gitlab 檔案庫佈署應用程式到伺服器。首先我們需要為 deployer 產生一組無密碼的的 SSH Key Pair。 1234# 擇一$ ssh-keygen -t rsa -b 2048 -C &quot;&lt;comment&gt;&quot;# 或$ ssh-keygen -t ed25519 -C &quot;&lt;comment&gt;&quot; 如何將具有 SSH 存取權的使用者帳戶新增至 Amazon EC2 Linux 執行個體？ 接著我們需要複製私鑰，用於 SSH 連線到伺服器以完成自動佈署的功能。 12345# 複製公鑰到 authorized_keys 如此 SSH 才能登入$ cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys# 複製私鑰$ cat ~/.ssh/id_rsa 將私鑰加入到 Gitlab 專案的 CI/CD 變數。專案的 CI/CD 變數是使用者定義的變數，放在 .gitlab-ci.yml 之外是為了安全性的目的。在 Gitlab 專案下 Settings &gt; CI/CD 可以找到。 我們欄位的 KEY 為 SSH_PRIVATE_KEY ， VALUE 則是剛剛複製的私鑰。後續我們會在 .gitlab-ci.yml 使用這個變數，讓 deployer 帳號不用密碼連線到遠端伺服器。 同時我們也需要將公鑰加入到專案 Project &gt; Settings &gt; Repository 的 Deploy Keys 如此外部才能夠利用 SSH 存取檔案庫(我們的伺服器主機下載 git repo)。 Title 可以隨意命名，然後將公鑰貼到 Key 欄位。 接著可以 git clone 我們的檔案庫到伺服器上，注意要使用 deployer 帳戶，因為它才有相關檔案權限。 1$ git clone &lt;YOUR_GIT_REPO_SSH_URL&gt; 設定 Nginx12345678# (可選)手動新增專案目錄 - 若非直接使用 deployer 拉取檔案庫$ sudo mkdir /var/www/app$ sudo chown -R $USER:$USER /var/www/app# 新增設定檔$ sudo vi /etc/nginx/sites-available/&lt;YOUR_DOMAIN&gt;# 編輯設定$ sudo ln -s /etc/nginx/sites-available/&lt;YOUR_DOMAIN&gt; /etc/nginx/sites-enabled/ Nginx &lt;YOUR_DOMAIN&gt; 設定: 123456789101112131415161718192021222324252627282930313233server { listen 80; server_name server_domain_or_IP; root /var/www/app/current/public; add_header X-Frame-Options &quot;SAMEORIGIN&quot;; add_header X-XSS-Protection &quot;1; mode=block&quot;; add_header X-Content-Type-Options &quot;nosniff&quot;; index index.html index.htm index.php; charset utf-8; location / { try_files $uri $uri/ /index.php?$query_string; } location = /favicon.ico { access_log off; log_not_found off; } location = /robots.txt { access_log off; log_not_found off; } error_page 404 /index.php; location ~ \\.php$ { fastcgi_pass unix:/var/run/php/php8.1-fpm.sock; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name; include fastcgi_params; } location ~ /\\.(?!well-known).* { deny all; }} 確認 root指向正確的目錄。 補充: 設定 SSL 搭配 Let’s Encrypt 補充: 解析 Certbot（Let’s encrypt） 使用方式 設定 Envoy到此我們已經準備好 Laravel 應用程式的正式環境了。接著就是使用 Envoy 執行佈署。要使用 Envoy 我們需要先在本機安裝 - 更多資訊可以參考Laravel 教學 1$ composer require laravel/envoy --dev Envoy 運作機制Envoy 雖然使用 Blade 語法來定義任務，但其實不需要 Blade 引擎。我們在專案根目錄建立一個 Envoy.blade.php 12345@servers(['web' =&gt; 'remote_username@remote_host'])@task('list', ['on' =&gt; 'web']) ls -l@endtask 檔案頂部的 @servers 有個陣列參數，包含一個鍵 web 對應的值是伺服器的位置，例如 deployer@192.168.1.1 。然後我們使用了 @task 來定義 bash 指令，這些指令會在調用任務時在伺服器端執行。在本機我們可以執行 1$ php vendor/bin/envoy run list 上面指令會執行我們定義的 list 任務，它會連線到伺服器然後列出目錄下的內容。 Envoy 並不相依於 Laravel 因此任何 PHP 應用程式都可以使用。 零停機時間佈署每次當我們要佈署專案到正式伺服器時，Envoy 會從 Gitlab 下載最新版本。Envoy 不需要任何停機就可以完成這些任務，因此我們不需要擔心在佈署的時候有人造訪我們的網站。我們的佈署流程為從 Gitlab 複製最新版本，安裝 Composer 相依套件，最後切換為最新版本。 @setup佈署流程的第一步是在 @setup 設定一系列的變數。您可以變更 app 的名稱: 1234567@setup $repository = 'git@gitlab.com:&lt;USERNAME&gt;/example.git'; $releases_dir = '/var/www/app/releases'; $app_dir = '/var/www/app'; $release= date('YmdHis'); $new_release_dir = $releases_dir .'/'. $release;@endsetup $respository 是 git 檔案庫的路徑 $releases_dir 是應用程式佈署的目錄 $app_dir 為整個應用程式的實際路徑 $release 包含日期，因此每一次佈署新版本，我們會得到一個以日期作為名稱的新目錄 $new_release_dir 新版本的完整路徑，目的只是讓任務撰寫可以更單純清楚 @story@story 定義了任務清單，整合成單一任務調用。這裡我們有三個任務分別是 clone_repository, run_composer, update_symlinks。 12345@story('deploy') clone_repository run_composer update_symlinks@endstory 接著我們來逐一建立這些任務。 複製檔案庫第一個任務是如果目錄不存在的話，建立 releases 目錄，然後複製檔案庫的 main 分支到新版本目錄。releases 目錄下會包含我們佈署的所有版本。 1234567@task('clone_repository') echo 'Cloning repository' [ -d {{ $releases_dir }} ] || mkdir {{ $releases_dir }} git clone --depth 1 {{ $repository }} {{ $new_release_dir }} cd {{ $new_release_dir }} git reset --hard {{ $commit }}@endtask 隨著專案持續開發，git 歷史紀錄可能會非常長。由於每一個版本我們都會建立一個目錄，因此沒必要每次都包含全部紀錄。 --depth 1 參數就可以節省系統空間。 安裝 Composer 相依套件12345@task('run_composer') echo &quot;Starting deployment ({{ $release }})&quot; cd {{ $new_release_dir }} composer install --prefer-dist --no-scripts -q -o@endtask --prefer-dist 安裝套件使用編譯後版本 (source | dist) --no-scripts 關閉在根套件定義的 Scripts -q 不輸出執行相關資訊 -o 轉換 PSR-0/4 自動載入為 classmap 以取得更快速的 autoloader。建議在正式環境使用，但執行會耗費多一點時間 切換新版本在準備好新版本之後，接著是移除 storage 目錄，建立兩個軟連結指向 storage 和 .env 。然後我們需要建立另一個軟連結用新版本取代目前 app 目錄下的 current。current 連結永遠指向最新版本。 1234567891011@task('update_symlinks') echo &quot;Linking storage directory&quot; rm -rf {{ $new_release_dir }}/storage ln -nfs {{ $app_dir }}/storage {{ $new_release_dir }}/storage echo &quot;Linking .env&quot; ln -nfs {{ $app_dir }}/.env {{ $new_release_dir }}/.env echo &quot;Linking current release&quot; ln -nfs {{ $new_release_dir }} {{ $app_dir }}/current@endtask 如您所見，我們使用 ln 搭配 -nfs 參數將 storage, .env, current 指向新版本。 bootstrap/cache 目錄可能需要相同處理。 完整腳本現在我們的任務腳本已經完成了，但仍需要確認 deployer@192.168.1.1 和 /var/www/app 目錄名稱是否符合您伺服器上的設定。 123456789101112131415161718192021222324252627282930313233343536373839404142@servers(['web' =&gt; 'deployer@192.168.1.1'])@setup $repository = 'git@gitlab.com:&lt;USERNAME&gt;/example.git'; $releases_dir = '/var/www/app/releases'; $app_dir = '/var/www/app'; $release= date('YmdHis'); $new_release_dir = $releases_dir .'/'. $release;@endsetup@story('deploy') clone_repository run_composer update_symlinks@endstory@task('clone_repository') echo 'Cloning repository' [ -d {{ $releases_dir }} ] || mkdir {{ $releases_dir }} git clone --depth 1 {{ $repository }} {{ $new_release_dir }} cd {{ $new_release_dir }} git reset --hard {{ $commit }}@endtask@task('run_composer') echo &quot;Starting deployment ({{ $release }})&quot; cd {{ $new_release_dir }} composer install --prefer-dist --no-scripts -q -o@endtask@task('update_symlinks') echo &quot;Linking storage directory&quot; rm -rf {{ $new_release_dir }}/storage ln -nfs {{ $app_dir }}/storage {{ $new_release_dir }}/storage echo &quot;Linking .env&quot; ln -nfs {{ $app_dir }}/.env {{ $new_release_dir }}/.env echo &quot;Linking current release&quot; ln -nfs {{ $new_release_dir }} {{ $app_dir }}/current@endtask 另外還有一件事情需要在執行自動佈署之前完成，就是第一次佈署需要手動複製應用程式的 storage 目錄到伺服器的/var/www/app 目錄下。您可能希望建立另一個 Envoy 任務來完成這件事。環境變數也需要為 Laravel 應用程式建立 .env 到相同路徑。每次佈署新版本將使用這些相同的資料。 如果遭遇目錄權限問題，可嘗試將目錄的權限要換成 www-data 或其他附加權限的方式如調整 Nginx user。 在本機執行 php vendor/bin/envoy run deploy 就可以佈署應用程式，但透過 CI 環境 Gitlab 也可以幫我們處理這個步驟。 接著，把剛剛寫的 Envoy.blade.php 推到檔案庫。為了讓事情單純一些我們直接 commit 到主線 main 不用其他分支。 使用 GItlab 持續整合我們已經在 Gitlab 上準備好了我們的應用程式，我們當然可以手動佈署。但也可以進一步使用自動化持續交付的方式。我們會使用自動化測試檢查每一個 commit 盡可能提早發現問題，然後如果測試一切正常則佈署到目標環境。 Gitlab CI/CD支援 Docker來處理測試和佈署流程。如果您不熟悉 Docker 可以參考設定自動建置 為了能夠使用 Gitlab CI/CD 建置, 測試和佈署，我們需要準備工作環境。因此我們將使用符合 Laravel 應用程式的最低需求的 Docker Image 。當然還有其他方式可以完成這個需求，但可能導致建置變慢，這不是我們想要。 建立 Container Image在專案根目錄建立 Dockerfile 原文 Dockerfile 使用 php7 搭配 MySQL，下面範例則更新為 8 與搭配 PostgreSQL。如果您使用的是 MySQL 可以參考原文或上方連結。 123456789101112131415161718FROM php:8.1RUN apt-get updateRUN apt-get install -y git curl libjpeg-dev libpng-dev libfreetype6-dev libbz2-dev libpq-dev libzip-dev# RUN apt-get install -y nodejs npmRUN apt-get cleanRUN docker-php-ext-configure pgsql -with-pgsql=/usr/local/pgsqlRUN docker-php-ext-install gd pdo_pgsql zip# gd mbstring xmlRUN curl --silent --show-error &quot;https://getcomposer.org/installer&quot; | php -- --install-dir=/usr/local/bin --filename=composerRUN composer global require laravel/envoy 我們使用官方 PHP Docker Image，由 Debian buster 搭配最基本的安裝，預先安裝了 PHP。然後使用 docker-php-ext-install 來安裝需要的 PHP 擴充。 設定 Gitlab 容器註冊現在我們有了 Dockerfile 讓我們繼續建置和 push 到 Gitlab Container Registry Registry 是儲存 Image 的地方。開發者可能會需要維護私有的 Image 。使用 Gitlab Container Registry 表示您不需設定和管理其他服務或使用其他 Registry 在您的 Gitlab 專案底下找到 Container Registry。如果您沒看到該功能可能需要到 Seetings &gt; General &gt; Visibility 的 Project Features, Permissions 開啟該功能。 要使用 Container Registry 首先需要登入 Gitlab Registry。確認本機安裝好了 Docker 然後執行下面指令 1$ docker login registry.gitlab.com 接著 build 和 push 12$ docker build -t registry.gitlab.com/&lt;USERNAME&gt;/example .$ docker push registry.gitlab.com/&lt;USERNAME&gt;/example 恭喜! 您剛剛 push 了第一個 Docker Image 到 Gitlab Registry。如果您重新載入頁面將會看到剛剛的 Image。當然您也可以使用 Gitlab CI/CD 來建置和 push Docker Image。 後續我們將會在 .gitlab-ci.yml 使用這個 Image 來處理測試流程和佈署。現在讓我們先 commit Dockerfile 設定 Gitlab CI/CD為了能夠使用 Gitlab CI/CD 來建置和測試我們的應用程式，我們需要 .gitlab-ci.yml 這和 Circle CI 與 Travis CI 類似，但是 Gitlab 內建的。 我們的 .gitlab-ci.yml 如下 12345678910111213141516171819202122232425262728293031323334353637383940image: registry.gitlab.com/&lt;USERNAME&gt;/example:latestservices: - postgres:12.2-alpinevariables: POSTGRES_DB: $POSTGRES_DB POSTGRES_USER: $POSTGRES_USER POSTGRES_PASSWORD: $POSTGRES_PASSWORD POSTGRES_HOST_AUTH_METHOD: truststages: - test - deployunit_test: stage: test script: - cp .env.example .env - composer install - php artisan key:generate - php artisan migrate - venor/bin/phpunitdeploy_production: stage: deploy script: - 'which ssh-agent || ( apt-get update -y &amp;&amp; apt-get install openssh-client -y )' - eval $(ssh-agent -s) - echo &quot;$SSH_PRIVATE_KEY&quot; | tr -d '\\r' | ssh-add - - mkdir -p ~/.ssh - '[[ -f /.dockerenv ]] &amp;&amp; echo -e &quot;Host *\\n\\tStrictHostKeyChecking no\\n\\n&quot; &gt; ~/.ssh/config' # - ~/.composer/vendor/bin/envoy run deploy --commit=&quot;$CI_COMMIT_SHA&quot; - ~/.config/composer/vendor/bin/envoy run deploy --commit=&quot;$CI_COMMIT_SHA&quot; environment: name: production url: http://192.168.1.1 when: manual only: - main 注意如果無法取得變數，可能是變數預設只 export 到受保護的分支。另外上面 ~/.composer/vendor/bin/envoy 的路徑可能會不同，~/.config/composer/vendor/bin/envoy 為測試可執行的路徑。 Image 與服務Runner 主要會執行 .gitlab-ci.yml 定義的腳本。image 設定則告訴 Runner 使用哪個 Image 。services 定義額外的 Image 可以和主要 Image 連結。這裡我們使用之前定義的 Image，同時加上使用 postgres。 如果您希望測試不同的 PHP 版本和資料庫，您可以定義不同的 image 和 services。參考 services 可連接的 Image 設定 CI/CD 變數Gitlab CI/CD 支援 CI/CD 變數。這裡我們使用了 PostgreSQL 作為資料庫。因此我們需要設定 PostgreSQL 的名稱和密碼POSTGRES_DB, POSTGRES_USER, POSTGRES_PASSWORD 。 MySQL 的變數: 12345variables: MYSQL_DATABASE: homestead MYSQL_ROOT_PASSWORD: secret DB_HOST: mysql DB_USERNAME: root 同時 Laravel 的 .env 的 DB_HOST 要從 127.0.0.1 換成 postgres。或者把要覆寫的環境變數寫在上面 variables 下。 例如: 12345678variables: POSTGRES_DB: my_db POSTGRES_USER: homestead POSTGRES_PASSWORD: secret POSTGRES_HOST_AUTH_METHOD: trust DB_HOST: postgres DB_USERNAME: homestead DB_PASSWORD: secret 更多環境變數的使用與說明可以參考 Docker 頁面說明: PostgreSQL MySQL 第一個任務 - Unit Test我們將需要的指令定義到 unit_test 的 script 底下。這些指令包含 Artisan 指令是用來準備 Laravel 應用程式的最終我們會執行 phpunit 測試。 12345678unit_test: stage: test script: - cp .env.example .env - composer install - php artisan key:generate - php artisan migrate - vendor/bin/phpunit 佈署到正式環境deploy_production 任務則是將應用程式佈署到伺服器。要使用 Envoy 我們需要 $SSH_PRIVATE_KEY，若已經加入到 Gitlab 專案則 Envoy 就可以執行。注意 Gitlab 預設只將 CI/CD 變數 export 到受保護的分支。如果您解除了保護有可能無法取得變數。 如之前提到的，Gitlab 也提供持續交付 environment 設定，可以告訴 Gitlab 任務要佈署到正式環境。url 是用來產生連結的您可以在 Gitlab 專案 Deployents &gt; Environments 找到開啟網站的連結。 only 則是告訴 Gitlab CI/CD 任務只有在 main 分支 Pipeline 建置的時候執行。 最後 when: manual 則是使用手動執行，讓我們可以自行在 Gitlab Pipeline 頁面上點擊執行。 12345678910111213141516deploy_production: stage: deploy script: - 'which ssh-agent || ( apt-get update -y &amp;&amp; apt-get install openssh-client -y )' - eval $(ssh-agent -s) - echo &quot;$SSH_PRIVATE_KEY&quot; | tr -d '\\r' | ssh-add - - mkdir -p ~/.ssh - '[[ -f /.dockerenv ]] &amp;&amp; echo -e &quot;Host *\\n\\tStrictHostKeyChecking no\\n\\n&quot; &gt; ~/.ssh/config' # - ~/.composer/vendor/bin/envoy run deploy --commit=&quot;$CI_COMMIT_SHA&quot; - ~/.config/composer/vendor/bin/envoy run deploy --commit=&quot;$CI_COMMIT_SHA&quot; environment: name: production url: http://192.168.1.1 when: manual only: - main 您可能也希望在Staging environment加入其他任務，方便在最後佈署之前測試您的應用程式。 開啟 Gitlab CI/CD到此我們已經準備好所有需要的東西了。要使用 Gitlab CI/CD 您只需要 commit 我們的 .gitlab-ci.yml 且 push 到 main 分支。就會觸發 Pipeline 執行了。 在單元測試通過之後可以在頁面上點擊按鈕執行 deploy_production 。如果一切順利執行您的應用程式就會佈署。 佈署成功之後可以到 Deployments &gt; Environments 查看。 在我們這個範例，您可能會想理解我們應用程式的目錄架構。在佈署之後 /var/www/app 下會有三個目錄 current，releases，storage 以及 .env 檔案。current 為軟連結指向最新版本。.env 是 Laravel 使用的環境變數。如果您 cd current 應該會發現 .env 是指向 /var/www/app/.env 的連結，同樣 storage 也是指向上層目錄。 到此我們完成了全部的教學。您可以依據您的需求做更多的調整。 參考資源 Test and deploy Laravel applications with GitLab CI/CD and Envoy Gitlab CI/CD using PostgreSQL Using SSH keys with GitLab CI/CD ~/.composer not found issue","link":"/2022/05/20/test-and-deploy-laravel-with-gitlab-envoy/"},{"title":"TinyMCE 6 處理圖片上傳, 整合 Laravel, React, TypeScript","text":"若您只想參考如何快速整合 Laravel + TypeScript + TinyMCE 範例可直接至最下方該節。 TinyMCE 使用 Image Uploader 上傳編輯圖片。這讓 TinyMCE 支援了圖片編輯的功能。通過其他方式加入的本地圖片也使用這個功能上傳。例如使用 paste_data_images設定搭配拖拉圖片，或使用 PowerPaste 套件，TinyMCE 會自動更新 &lt;img&gt; 的 src 屬性。 使用 editor.uploadImages() 可以上傳本地圖片。這個功能支援讓使用者在所有圖片上傳完成之前可以儲存內容。一旦這種情況發生且遠端圖片路徑還沒好，則圖片會存成 Base64 格式。 注意: 在送出編輯器內容之前，執行 editor.uploadImages() 以避免圖片儲存成 Base64 格式。可利用 Success Callback 在全部圖片上傳完成再執行。這個 Success Callback 可以通過 POST 儲存編輯器的內容。 使用 uploadImages 然後提交表單123tinymce.activeEditor.uploadImages().then(() =&gt; { document.forms[0].submit();}); 使用 uploadImages 搭配 jQuery12345tinymce.activeEditor.uploadImages().then(() =&gt; { $.post('ajax/post.php', tinymce.activeEditor.getContent()).done(() =&gt; { console.log('Uploaded images and posted content as an ajax request.'); });}); 注意: TinyMCE 不支援 SVG 是為了保護使用者，因為 SVG 可能包含一些可執行的攻擊。 Image Uploader 需求一個伺服器端上傳處理(Upload Handler)負責上傳圖片到遠端伺服器。程式必須: 接受圖片 合適的儲存圖片 回傳 JSON 物件包含圖片上傳的路徑 這裡提供一個 PHP 上傳處理的實作範例。 圖片透過 HTTP POST 傳送到 Image Uploader 每張圖片發送一個 POST。而利用 images_upload_url 設定網址對應的 Image Handler 圖片處理必將圖片存在應用程式。例如: 儲存在 Web 伺服器的目錄 儲存在 CDN 伺服器 儲存在資料庫 儲存在資源檔案管理系統 圖片上傳時建議在 POST 使用標準化的名稱 blobid0, blobid1, imagetools0, imagetools1 注意: 確保上傳處理程式為每一張圖產生唯一的名稱。一個常見的方式就是把當前的時間加到檔名尾巴，時間粒度到毫秒。例如 blobid0-1458428901092.png 或 blobid0-1460405299-0114.png。 警告: 如果檔名重複，檔案會被複寫。 伺服器端的上傳處理必須要回傳一個 JSON 物件包含 location 屬性。這個屬性表示上傳圖片的遠端路徑和檔名。 圖片上傳參數images_upload_url 或 images_upload_handler 參數可以設定上傳圖片的功能。其他參數則是可選的。 必須: images_upload_url 或 images_upload_handler 其他可選參數 images_upload_base_path images_upload_credentials images_reuse_filename images_upload_url該參數讓您設定一個 URL 指定伺服器端的上傳處理函式。每當您調用 editor.uploadImages() 就會觸發上傳，或自動上傳如果 automatic_uploads 選項有提供也會觸發。上傳處理函式應回傳一個新的路徑如下格式 123{ &quot;location&quot;: &quot;folder/sub-folder/new-location.png&quot;} 請務必查閱伺服器端實作範例 1234tinymce.init({ selector: 'textarea', images_upload_url: 'postAcceptor.php',}); images_upload_handlerimages_upload_handler 參數可以設定一個 function 用以取代 TinyMCE 預設的 JavaScript 函式，您可以自訂邏輯。 該函式包含 2 個參數 blobInfo progress 回呼函式接收 value 1 到 100 並且需回傳一個 Promise 其需要 resolve 上傳完成的圖片 URL 或 reject 錯誤訊息。錯誤訊息可以是一個字串或物件包含: message 顯示的錯誤訊息 remove 是否從 document 移除圖片，預設為 false 當參數沒設定時，TinyMCE 會使用 XMLHttpRequest 一次上傳一個圖片並解析 resolve Promise 傳入 JSON 的 location。 範例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const example_image_upload_handler = (blobInfo, progress) =&gt; new Promise((resolve, reject) =&gt; { const xhr = new XMLHttpRequest(); xhr.withCredentials = false; xhr.open('POST', 'postAcceptor.php'); xhr.upload.onprogress = (e) =&gt; { progress((e.loaded / e.total) * 100); }; xhr.onload = () =&gt; { if (xhr.status === 403) { reject({ message: 'HTTP Error: ' + xhr.status, remove: true }); return; } if (xhr.status &lt; 200 || xhr.status &gt;= 300) { reject('HTTP Error: ' + xhr.status); return; } const json = JSON.parse(xhr.responseText); if (!json || typeof json.location != 'string') { reject('Invalid JSON: ' + xhr.responseText); return; } resolve(json.location); }; xhr.onerror = () =&gt; { reject( 'Image upload failed due to a XHR Transport error. Code: ' + xhr.status ); }; const formData = new FormData(); formData.append('file', blobInfo.blob(), blobInfo.filename()); xhr.send(formData); });tinymce.init({ selector: 'textarea', // change this value according to your HTML images_upload_handler: example_image_upload_handler,}); 整合 Laravel with axios 範例1234567891011121314151617const image_handler = () =&gt; { const axios = (window as any).axios; const formData = new FormData(); formData.append('file', blobInfo.blob(), blobInfo.filename()); return axios .post(route('dashboard.assets.create'), formData, { onUploadProgress: (e) =&gt; { progress((e.loaded / e.total) * 100); }, }) .then((response: any) =&gt; { return response.data.location; }) .catch((error: any) =&gt; { console.log(error); });} 12345678910111213141516// async 範例const handler: UploadHandler = async (blobInfo, progress) =&gt; { const axios = (window as any).axios; const formData = new FormData(); formData.append(&quot;file&quot;, blobInfo.blob(), blobInfo.filename()); try { const response = await axios.post(&quot;/upload&quot;, formData, { onUploadProgress: (e: ProgressEvent) =&gt; { progress((e.loaded / e.total) * 100); }, }); return response.data.location; } catch (error) { console.log(error); } }; images_upload_base_path該參數可以指定 basepath 會在設定的 images_upload_url 加上該路經 12345tinymce.init({ selector: 'textarea', images_upload_url: 'postAcceptor.php', images_upload_base_path: '/some/basepath',}); images_upload_credentialsimages_upload_credentials 參數設定當呼叫 images_upload_url 網址時應該一起傳送憑證例如 Cookie 或者 Header 中驗證的資料。當其設定為 true 時憑證會一併傳給 Handler 類似於 withCredentials 屬性 12345tinymce.init({ selector: 'textarea', images_upload_url: 'postAcceptor.php', images_upload_credentials: true,}); images_reuse_filename預設 TinyMCE 會為每一個上傳檔案產生唯一的檔名。有時這可能會造成非預期的副作用。例如當 automatic_uploads 開啟時，使用 Enhanced Image Editing 套件編輯圖片，即使圖片一樣，但其結果會變成不同檔名上傳。 設定 images_reuse_filename 為 true 則 TinyMCE 會使用真實圖片檔名，而不是產生新的名稱。需要注意對應 &lt;img&gt; 的 src 會被換成上傳到伺服器的檔名，下一次同樣的檔名依舊會被上傳。 123456tinymce.init({ selector: 'textarea', automatic_uploads: true, images_upload_url: 'postAcceptor.php', images_reuse_filename: true,}); CORS 因素設定跨來源資源共用來上傳圖片到不同的網域。 CORS 包含了一些限制，即使是上傳圖片到同一個伺服器，但有些情況還是需要一些 CORS Headers 例如 同樣網域，不同 Port 使用 IP 而不是網域 頁面和上傳程式的 HTTP 和 HTTPS 不一樣 呼叫上傳程式的 URL 來源和當前頁面的 URL 來源必須要一致。否則需要 CORS headers。通過相對路徑來設定上傳程式可以避免這點。 如果發生 CORS 錯誤您可以在瀏覽器開發者工具 Console 找到。 PHP 範例 有提供關於 CORS 的設定，參考 $accepted_origins 。 快速實作 Laravel 整合 TinyMCE with TypeScript 安裝套件 1$ npm install --save tinymce @tinymce/tinymce-react 使用 npm build 方式可參考官網，這裡使用對應版本 CDN 的方式。在 app.blade.php 加入對應版本的 TinyMCE Script 簡易 Controller 範例 12345678910Route::get('/', function () { return Inertia::render('Index');});Route::post('/upload', function (Request $request) { if ($request-&gt;hasFile('file')) { $path = $request-&gt;file('file')-&gt;storePublicly('tinymce'); return response()-&gt;json(['location' =&gt; Storage::url($path)]); }}); JS 範例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import React from 'react';import { useForm } from '@inertiajs/inertia-react';import { Editor } from '@tinymce/tinymce-react';enum ToolbarMode { default = 'wrap', floating = 'floating', sliding = 'sliding', scrolling = 'scrolling',}interface BlobInfo { id: () =&gt; string; name: () =&gt; string; filename: () =&gt; string; blob: () =&gt; Blob; base64: () =&gt; string; blobUri: () =&gt; string; uri: () =&gt; string | undefined;}type ProgressFn = (percent: number) =&gt; void;type UploadHandler = ( blobInfo: BlobInfo, progress: ProgressFn) =&gt; Promise&lt;string&gt;;export default function Index() { const form = useForm&lt;{ content: string; }&gt;({ content: '', }); const handler: UploadHandler = async (blobInfo, progress) =&gt; { const axios = (window as any).axios; const formData = new FormData(); formData.append('file', blobInfo.blob(), blobInfo.filename()); try { const response = await axios.post('/upload', formData, { onUploadProgress: (e: ProgressEvent) =&gt; { progress((e.loaded / e.total) * 100); }, }); return response.data.location; } catch (error) { console.log(error); } }; return ( &lt;Editor id='content' init={{ height: 600, menubar: false, paste_data_images: true, plugins: 'advlist autolink lists image link quickbars charmap preview anchor searchreplace visualblocks code fullscreen insertdatetime media table code help wordcount', toolbar: 'code undo redo | styles | ' + 'fontsize forecolor backcolor | ' + 'bold italic underline strikethrough subscript superscript removeformat | ' + 'alignleft aligncenter alignright | ' + 'bullist numlist outdent indent |' + 'quickimage media link table', toolbar_mode: ToolbarMode.default, content_style: 'img { max-width: 100%; }', images_upload_handler: handler, }} initialValue={form.data.content} onEditorChange={(value) =&gt; form.setData('content', value)} /&gt; );} 參考資源 Tiny Docs - Handling image uploads Laravel 9 + Inertia.js + React + TypeScript Typescript with Laravel","link":"/2022/06/03/tinymce-upload-image-laravel-react-ts/"},{"title":"[譯] React: 您可能不需要一個 Effect","text":"Effect 是讓您可以脫離典型 React 設計模型的一個方式。它讓您可以跳脫到 React 之外並讓您的 React 元件同步外部系統，比如使用非 React 的套件，網路，瀏覽器 DOM 。假如沒有涉及外部，例如您想要在某些 props 或 state 發生變更時更新元件的 state ，那麼您不應該使用 Effect。移除不必要的 Effect 可以讓您的程式碼更容易維護，執行效率更好，減少錯誤的產生。 本文您將學習 為什麼以及如何移除不必要的 Effect 如何快取耗費效能的計算而不使用 Effect 如何重置和調整元件 State 而不使用 Effect 如何在多個事件處理函式共享邏輯 哪些邏輯應該移到事件處理函式中 如何通知上層元件狀態變更 為什麼以及如何移除不必要的 Effect有兩種常見的案例，您不應該使用 Effect: 您不需要 Effect 來轉換整理渲染呈現需要的資料。舉例來說，您希望在顯示之前過濾一個列表。您可能會覺得寫一個 Effect 在列表變更的時候更新一個狀態變數。然而這很沒效率。當您更新狀態時，React 會先呼叫您的元件函式來計算應該呈現在畫面的東西。接著 React 會 “commit” 變更到 DOM 更新畫面。接著 React 會執行 Effect，如果 Effect 也同時立刻更新狀態，則會重啟整個流程! 為了避免不必要的渲染，直接在元件頂部轉換資料則可。每當 props 或 state 變更，那些程式都會自動重新執行。 您不需要 Effect 來處理互動事件。例如您想要發送一個 POST 請求給 /api/buy ，然後當完成購買時顯示提示視窗。在購買按鈕的點擊事件，你可以確實知道是使用者點擊了。而 Effect 執行時，你不會知道使用者做了什麼，例如哪個按鈕被點擊。這也是為什麼通常直接在對應的事件處理函式處理對應的互動。 您確實需要 Effect 來同步外部系統。例如您可以使用 Effect 來保持同步 jQuery 套件的資料到 React 狀態。您也可以使用 Effect 來 fetch 資料，例如同步一個查詢的搜尋結果。注意，主流的一些框架支援更有效率的做法來讀取資料，而不是單純使用 Effect。 為了協助您獲得正確的觀念和直覺想法，讓我們看一些常見的具體範例！ 基於 props 或 state 更新狀態假設您一個元件有兩個狀態: firstName 和 lastName 。您希望使用這兩個資料組合出 fullName 。同時您希望 fullName 會隨著 firstName 或 lastName 更新而更新。您第一個想法可能是增加一個 fullName 狀態然後使用 Effect 更新。 12345678910function Form() { const [firstName, setFirstName] = useState('Taylor'); const [lastName, setLastName] = useState('Swift'); // 避免多餘的狀態和 Effect const [fullName, setFullName] = useState(''); useEffect(() =&gt; { setFullName(firstName + ' ' + lastName); }, [firstName, lastName]);} 這是複雜化需求。同時也沒效率; 導致先渲染了一次 fullName 舊資料的狀況，然後又立刻重新渲染。這種情況是不需要多一個狀態變數和 Effect 123456function Form() { const [firstName, setFirstName] = useState('Taylor'); const [lastName, setLastName] = useState('Swift'); // 正確作法: 渲染時會立刻計算新值 const fullName = firstName + ' ' + lastName;} 當某些需要的資料可以用 props 或 state 計算出來的時候，不要放到 state，直接計算即可。這能優化您的程式碼，避免額外關聯連續的更新，程式碼會更精簡，且減少錯誤的發生。您可以避免一些因為狀態同步造成的 Bug。如果這個方式您感覺很陌生可以參考 Thinking in React 快取耗效能的計算元件使用從 props 取得的 todos 和 filter 計算 visibleTodos。您可能直覺想要把計算結果放到 state 然後利用 Effect 更新。 123456789function TodoList({ todos, filter }) { const [newTodo, setNewTodo] = useState(''); // 避免多餘的狀態和 Effect const [visibleTodos, setVisibleTodos] = useState([]); useEffect(() =&gt; { setVisibleTodos(getFilteredTodos(todos, filter)); }, [todos, filter]);} 如同稍早的範例，state 和 Effect 都是不必要的。 12345function TodoList({ todos, filter }) { const [newTodo, setNewTodo] = useState(''); // 正確作法, 如果 getFilteredTodos() 計算不複雜直接計算即可 const visibleTodos = getFilteredTodos(todos, filter);} 在大部分的狀況，上面的程式碼是 ok 的。但 getFilteredTodos() 計算可能非常耗效能，或者 todos 資料很多。 在這種情況，您不希望因為其他不相關的狀態更新重新計算 getFilteredTodos() ，例如 newTodo 更新的時候。 此時，您可以使用 useMemo 快取耗效能的計算 123456789import { useMemo, useState } from 'react';function TodoList({ todos, filter }) { const [newTodo, setNewTodo] = useState(''); // 正確作法 const visibleTodos = useMemo(() =&gt; { return getFilteredTodos(todos, filter); }, [todos, filter]);} 或者單行的形式 123456789import { useMemo, useState } from 'react';function TodoList({ todos, filter }) { const [newTodo, setNewTodo] = useState(''); const visibleTodos = useMemo( () =&gt; getFilteredTodos(todos, fitler), [todos, filter] );} 這樣 React 就會知道 useMemo 裡面的函式只有在 todos 或 filter 變更的時候才重新計算。React 會記住 getFilteredTodos() 回傳的資料。後續的渲染如果 todos 和 filter 都一樣則是用上一次記住的資料，如果不同則會在執行一次計算。 包在 useMemo 的函式不要包含副作用的操作。 如何判斷是否為耗效能的計算? 一般來說除非您的計算牽扯到上千個物件，否則都在合理範圍。您可以加入 console 測量花費的時間。 123console.time('filter array');const visibleTodos = getFilteredTodos(todos, filter);console.timeEnd('filter array'); 執行測量您將會在開發者工具 Console 看到像是 filter array: 0.15ms 的訊息，如果紀錄的時間加總很大，例如 1ms 或更久。那麼快取就是合理的。您可以將計算的部分包在 useMemo 來驗證互動時的計算時間是否有減少。 12345console.time('filter array');const visibleTodos = useMemo(() =&gt; { return getFilteredTodos(todos, filter); // Skipped if todos and filter haven't changed}, [todos, filter]);console.timeEnd('filter array'); useMemo 並不會加速第一次渲染。它只能協助在後續更新時略過不必要的計算。 注意您的機器可能比使用者的快，因此建議模擬比較差的環境來測試效能。例如 Chrome 有提供 CPU Throttling 功能。 同時在開發環境測試效能並不能保證準確的結果。例如Strict Mode 開啟的情況下您會發現每個元件渲染了兩次。 為了盡可能準確，您應該建置正式版然後測試。 當 props 變更時重新設定狀態下面 ProfilePage 元件可以從 props 取得 userId。頁面包含一個留言的輸入框，然後使用了一個 comment 狀態變數來儲存資料。某天您注意到一個問題: 當您從 A 個人資料頁到 B 時，comment 並沒有重置。其結果造成很容易發錯留言。要修正這個問題您希望當 userId 改變時可以清除 comment 12345678export default function ProfilePage({ userId }) { const [comment, setComment] = useState(''); // 避免在 props 改變時在 Effect 重置狀態 useEffect(() =&gt; { setComment(''); }, [userId]);} 這種處理方式很沒效率，因為 ProfilePage 和子元素會先使用舊資料渲染，才又更新(多渲染一次)。要為每個在 ProfilePage 有用到狀態的元件都要對應處理會讓事情複雜化。例如；如果有個內嵌的留言介面您希望它的狀態也要因為切換 userId 清除。 事實上您可以利用 key 來讓 React 知道每個使用者資料元件概念上是不一樣的。 123456789export default function ProfilePage({ userId }) { return &lt;Profile userId={userId} key={userId} /&gt;;}function Profile({ userId }) { // 元件內的狀態會自動重置 const [comment, setComment] = useState(''); // ...} 一般來說在渲染同一個位置的元件時，React 會保留狀態。利用傳入 userId 到 key 屬性，如果 userId 不同 React 會把 Profile 視為兩個不同的元件，並且不會共享狀態。 每當 userId 改變 React 會重新建立 DOM 和重置狀態。結果就是每當切換使用者資料則 comment 也會自動被清除。 注意到這個範例只匯出 ProfilePage 。渲染 ProfilePage 不需要使用 key 。Profile 使用 key 只是一個實作的細節。 當 props 變更時調整狀態有時候您希望當 props 可以重置或調整局部狀態，但不是全部。 List 元件會通過 props 收到 items 列表，然後被選取的項目會存放到 selection 狀態變數。當 props 收到不一樣的陣列時，您希望設定 selection 為 null。 123456789function List({ items }) { const [isReverse, setIsReverse] = useState(false); const [selection, setSelection] = useState(null); // 避免當 props 變更時使用 Effect 調整狀態 useEffect(() =&gt; { setSelection(null); }, [items]);} 這也一樣不理想。每次 items 改變，List 和子元素, 元件會用舊的 selection 渲染一次。然後執行 Effect 才更新。最後 setSelection(null) 會造成另一次重新渲染，然後 List 和其他內部元件再次一個循環。 移除 Effect，直接調整狀態即可。 1234567891011function List({ items }) { const [isReverse, setIsReverse] = useState(false); const [selection, setSelection] = useState(null); // 比較好的做法是直接調整狀態 const [prevItems, setPrevItems] = useState(items); if (items !== prevItems) { setPrevItems(items); setSelection(null); }} 紀錄上一次渲染的資料確實有點難以理解，但這比在 Effect 更新狀態的處理方式好。上面範例 setSelection 在該次渲染期間直接被執行。React 會在執行到 return 時立刻重新渲染 List ，此時 React 還沒有渲染 List 的子元件和更新 DOM。因此 List 的子元件跳過了渲染 selection 舊資料的部分。 當您在渲染時期直接更新元件，React 會拋棄回傳的 JSX 並立刻重新嘗試渲染。為了避免緩慢的聯級重試，在渲染期間 React 只讓您更新同一個元件的 state。如果您在此元件渲染時期直接更新另外一個元件的狀態，將會看到錯誤訊息。而判斷條件像 items !== prevItems 是必要的，為了避免無限迴圈。您可以向上面那樣調整狀態，但任何副作用例如變更 DOM 或使用 timeout 應該維持放在事件處理函式或 Effect 以保證元件的可預測性。 雖然這樣的模式比起 Effect 比較有效率，但大多數的元件應該不需要這麼處理。不管您是如何處理，基於 props 或其他 state 調整狀態會讓您的資料流變的不容易理解。時時檢查看是否您可以利用 key 重置狀態或直接在渲染流程計算。例如取代儲存選取的項目，您可以直接儲存 ID 12345678function List({ items }) { const [isReverse, setIsReverse] = useState(false); const [selectedId, setSelectedId] = useState(null); // 直接在渲染流程計算 const selection = items.find((item) =&gt; item.id === selectedId) ?? null; // ...} 現在我們根本不需要調整狀態。如果清單項目的 ID 被選取，selection 會在渲染時期計算，如果沒有選取因為沒有找到匹配的項目則為 null 。這個行為跟之前稍微有點不同，但可以說好很多，因為即便 items 變更我們還是可以維持正確的 selection。但你需要在使用 selection 的地方多一些邏輯處理，因為 selectedId 可能找不到項目。 在事件處理函式間共享邏輯假如您有一個產品頁面有兩個按鈕 (購買和結帳) 他們都是購買產品的功能。您希望當使用者加入產品到購物車時顯示提示 toast。 在兩個按鈕的 click 事件加入 showToast() 有點重複的感覺，因此您可能想在一個 Effect 處理: 1234567891011121314151617function ProductPage({ product, addToCart }) { useEffect(() =&gt; { // 避免在 Effect 處理特定事件邏輯 if (product.isInCart) { showToast(`Added ${product.name} to the shopping cart!`); } }, [product]); function handleBuyClick() { addToCart(product); } function handleCheckoutClick() { addToCart(product); navigateTo('/checkout'); }} 這邊 Effect 是不必要的。同時也很容易造成 Bug。例如您的應用程式在頁面切換重載時會記住購物車內容。如果您加入一個產品到購物車然後刷新頁面，提示會再次出現。每次您刷新頁面就會出現。因為 product.isInCart 是 true 然後 Effect 會執行 showToast()。 當您不確定程式碼應該要放在 Effect 或事件處理函式中時，問自己這段程式碼執行是為了什麼理由。只有在程式碼是因為元件顯示所以必須對應執行的時候才是用 Effect。上面這個例子，提示視窗是因為使用者點擊按鈕，不是因為頁面載入顯示。刪除 Effect 並將共享的邏輯放到兩個事件處理函式。 12345678910111213141516function ProductPage({ product, addToCart }) { // 特定事件使用的邏輯應從對應事件處理函式呼叫 function buyProduct() { addToCart(product); showToast(`Added ${product.name} to the shopping cart!`); } function handleBuyClick() { buyProduct(); } function handleCheckoutClick() { buyProduct(); navigateTo('/checkout'); }} 移除不必要的 Effect 修復 Bug。 發送 POST 請求下面 Form 元件會發送兩種類型的 POST 請求。當掛載的時候會發送統計分析的事件。當填完表單並點擊送出的時候，會發送 POST 到 api/register : 12345678910111213141516171819202122function Form() { const [firstName, setFirstName] = useState(''); const [lastName, setLastName] = useState(''); // 正確，每次元件顯示的時候需要執行 useEffect(() =&gt; { post('/analytics/event', { eventName: 'visit_form' }); }, []); // 避免特定事件邏輯在 Effect 處理 const [jsonToSubmit, setJsonToSubmit] = useState(null); useEffect(() =&gt; { if (jsonToSubmit !== null) { post('/api/register', jsonToSubmit); } }, [jsonToSubmit]); function handleSubmit(e) { e.preventDefault(); setJsonToSubmit({ firstName, lastName }); }} 讓我們套用之前的標準到這個範例。 分析統計的 POST 請求應該維持在 Effect 處理。因為送出請求的理由是因為表單載入顯示就要記錄。但這在開發時期會觸發兩次，可以參考這裡解決這個問題。 然而， /api/register 請求並不是每次元件顯示就要送出。我們只希望在特定時間發送; 當時用者點擊按鈕時。它應該只發生在特定互動情況。請刪除第二個 Effect 並將邏輯移到事件處理函式 123456789101112131415function Form() { const [firstName, setFirstName] = useState(''); const [lastName, setLastName] = useState(''); // 正確，每次元件顯示的時候需要執行 useEffect(() =&gt; { post('/analytics/event', { eventName: 'visit_form' }); }); function handleSubmit(e) { e.preventDefault(); // 特定事件的邏輯應移至事件處理函式 post('/api/register', { firstName, lastName }); }} 當您在抉擇否將邏輯放到事件中或 Effect，您該問的是; 從使用者的角度來看邏輯是什麼。如果是特定操作那就放在事件處理函式。如果是每當使用者看到元件出現在畫面都需要執行則放到 Effect。 初始化應用程式某些邏輯只需要在程式載入的時候執行一次。您可能將它們放到 Effect 1234567function App() { // 避免將只執行一次的邏輯單純放到 Effect useEffect(() =&gt; { loadDataFromLocalStorage(); checkAuthToken(); }, []);} 然而，您很快會發現在開發時期會執行 2 次。這會造成一些問題 - 舉例來說，這可能造成驗證 Token 無效，因為該函式並沒有設計成可以被執行兩次。一般來說，您的元件應該要保持能被重新掛載的彈性。包含頂層的 App 元件。雖然在實務上可能不會被重新掛載，但所有元件遵循相同的規則可以比較容易的組織和重複使用。如果部分邏輯必須在應用程式載入額時候執行一次，而不是每次掛載都執行，您可以在最上層加入變數追蹤其是否被執行: 123456789101112let didInit = false;function App() { useEffect(() =&gt; { if (!didInit) { didInit = true; // 正確實作每當應用程式載入時只執行一次的邏輯 loadDataFromLocalStorage(); checkAuthToken(); } }, []);} 您也可以在模組初始化階段和應用程式渲染之前執行: 123456if (typeof window !== 'undefined') { checkAuthToken(); loadDataFromLocalStorage();}function App() {} 頂層的程式碼在元件載入的時候會執行一次，就算該元件沒有被渲染也會執行。為了避免匯入元件導致效能變差或非預期的行為，請不要過度使用此模式。將應用程式層級的初始化邏輯應放在 App.js 或是進入點的模組。 通知上層元件狀態變更假如您寫了一個 Toggle 元件內部包含一個 isOn 狀態，它是一個布林值。有不同的方式可以觸發，點擊或拖拉。您可能希望當這個 Toggle 內部狀態改變的時候通知上層元件，因此您增加了 onChange 事件並在 Effect 呼叫 1234567891011121314151617181920function Toggle({ onChange }) { const [isOn, setIsOn] = useState(false); // 避免, onChange 太晚執行 useEffect(() =&gt; { onChange(isOn); }, [isOn, onChange]); function handleClick() { setIsOn(!isOn); } function handleDragEnd(e) { if (isCloserToRightEdge(e)) { setIsOn(true); } else { setIsOn(false); } }} 如之前提到的，這不是理想的處理方式。Toggle 會先更新自己的狀態，然後 React 更新畫面。然後 React 執行 Effect，執行 onChange 把狀態值交給上層元件。現在上層元件會更新自己的狀態，開始另一回合的渲染。任何時候一次完成所有事情會比較好。 刪除 Effect 並在事件裡同時更新兩者的狀態: 123456789101112131415161718192021function Toggle({ onChange }) { const [isOn, setIsOn] = useState(false); function updateToggle(nextIsOn) { // 在事件直徑更新狀態 setIsOn(nextIsOn); onChange(nextIsOn); } function handleClick() { updateToggle(!isOn); } function handleDragEnd(e) { if (isCloserToRightEdge(e)) { updateToggle(true); } else { updateToggle(false); } }} 使用這個方式，Toggle 元件和上層元件會在同一個事件更新狀態。React 基於 batches updates 的機制一起更新，因此只會渲染一回。 您也許還可以刪除狀態，單純從上層元件接收 isOn 12345678910111213function Toggle({ isOn, onChange }) { function handleClick() { onChange(!isOn); } function handleDragEnd(e) { if (isCloserToRightEdge(e)) { onChange(true); } else { onChange(false); } }} 將狀態往上搬 讓上層元件可以利用自己的狀態完整控制 Toggle。這意味著上層元件必須包含更多邏輯，但整體來說可以有較少的狀態。每當您需要去維持兩個不同的狀態變數同步時，這就是您應該嘗試將狀態往上搬的訊號。 將資料傳入上層下面範例 Child 元件會讀取一些資料然後傳給 Parent 元件 12345678910111213141516function Parent() { const [data, setData] = useState(null); return &lt;Child onFetched={setData} /&gt;;}function Child({ onFetched }) { const data = useSomeAPI(); // 避免在 Effect 把資料傳入 parent useEffect(() =&gt; { if (data) { onFetched(data); } }, [onFetched, data]);} 在 React，資料流是從上層元件流向子元件。當你發現錯誤的時候，您可以沿著元件向上追蹤資料來源，直到找到某個元件傳錯 props 或錯誤的狀態。當子元件在 Effect 更新上層元件的狀態。資料流會變更非常難以追蹤。如果子元件和上層元件都需要相同的資料，建議讓上層元件來讀取資料。 12345678function Parent() { const data = useSomeAPI(); // 較佳: 由上而下傳遞資料 return &lt;Child data={data} /&gt;;}function Child() {} 如此一來並刻意保持資料流的可預測性; 資料是由上而下傳遞。 訂閱外部儲存有時候，您的元件會需要訂閱一些外部資料。這些資料可能來自第三方函式庫或瀏覽器內建 API。由於這些資料可能在 React 不知情的情況下變更，您會需要手動訂閱。這種情況很常使用 Effect 處理 1234567891011121314151617181920212223242526function useOnlineStatus() { // 不夠理想: 在 Effect 手動儲存訂閱 const [isOnline, setIsOnline] = useState(true); useEffect(() =&gt; { function updateState() { setIsOnline(navigator.onLine); } updateState(); window.addEventListener('online', updateState); window.addEventListener('offline', updateState); return () =&gt; { window.removeEventListener('online', updateState); window.removeEventListener('offline', updateState); }; }, []); return isOnline;}function ChatIndicator() { const isOnline = useOnlineStatus();} 這裡元件訂閱一個外部資料，這個範例是瀏覽器的 API navigator.onLine。初始狀態為 true。每當瀏覽器的資料改變，元件會更新狀態。 雖然使用 Effect 處理這種狀況非常常見，但 React 有專門的 Hook ，在遇到訂閱外部資料的狀況時應優先選擇。刪除 Effect 使用 useSyncExternalStore 取代。 useSyncExternalStore 原始碼 官方文件 1234567891011121314151617181920212223function subscribe(callback) { window.addEventListener('online', callback); window.addEventListener('offline', callback); return () =&gt; { window.removeEventListener('online', callback); window.removeEventListener('offline', callback); };}function useOnlineStatus() { // 較佳; 使用內建 Hook 處理訂閱外部資料 return useSyncExternalStore( subscribe, () =&gt; navigator.onLine, () =&gt; true );}function ChatIndicator() { const isOnline = useOnlineStatus(); // ...} 比起使用 Effect 手動同步資料到 React 狀態，這種方式比較不會發生錯誤。一般來說您會寫一個自訂的 Hook 像上面的 useOnlineStatus() ，如此在個別的元件就可以重複使用。更多關於訂閱外部儲存的資訊可以參考官方文件。 讀取資料很多應用程式會使用 Effect 實作 fetch 資料。使用這種方式讀取資料十分常見: 123456789101112131415function SearchResults({ query }) { const [results, setResults] = useState([]); const [page, setPage] = useState(1); useEffect(() =&gt; { // 避免讀取資料而沒有清除的邏輯 fetchResults(query, page).then((json) =&gt; { setResults(json); }); }, [query, page]); function handleNextPageClick() { setPage(page + 1); }} 這邊不需要把 fetch 搬到事件處理函式。 不過這裡似乎和之前的範例有些矛盾，不是說需要基於用戶角度的理由，那這裡應該要放到事件處理函式。考慮到不只是單純打字輸入或換頁才讀取。搜尋條件通常可能預先由 URL 取得，使用者可能回上一頁或下頁操作而沒有打字或切換頁面。不管 page 和 query 從哪來。當這個元件顯示的時候，您會希望 results 會根據當前的 page 和 query 保持同步網路取得的資料。這就是為什麼這裡使用 Effect。 不過上面的程式碼有 Bug。想像您快速輸入 “hello” 然後 query 的變化會是 “h” 到 “he”，”hel”，”hell”，”hello”。每次變更都會觸發讀取，但回應並不會保證照順序返回。例如 “hell” 回應比 “hello” 返回的還慢。因為會執行 setResults() 如此將會顯示錯誤的搜尋資料。這就是所謂的 “race condition”: 兩個不同的請求相互競爭並且產生跟預期不一樣的順序。 要修正 race condition 的問題，您需要加入清除的功能用來忽略過期的回應 1234567891011121314151617181920function SearchResults({ query }) { const [results, setResults] = useState([]); const [page, setPage] = useState(1); useEffect(() =&gt; { let ignore = false; fetchResults(query, page).then((json) =&gt; { if (!ignore) { setResults(json); } }); return () =&gt; { ignore = true; }; }, [query, page]); function handleNextPageClick() { setPage(page + 1); }} 這確保當 Effect 讀取資料時，除了最後的請求，其他的會被忽略。 處理 race condition 並不是讀取資料會遭遇的唯一問題。你也需要思考如何快取回應(如此使用回上一頁會立刻看到之前的畫面，而不是重新讀取)，如何從伺服器讀取(初始化的 server-side 渲染的 HTML 包含讀取的資料)，如何避免連續階層請求(子元件讀取資料不需要等上層讀取完畢)。這些問題任何 UI 函式庫都會遇到，不是只有 React。處理這些問題非常繁瑣，這也是為什麼最新的主流框架提供更有效率內建的讀取機制，而不是直接使用 Effect。 如果您沒有使用框架，可以考慮下面的範例 123456789101112131415161718192021222324252627function SearchResults({ query }) { const [page, setPage] = useState(1); const params = new URLSearchParams({ query, page }); const results = useData(`/api/search?${params}`); function handleNextPageClick() { setPage(page + 1); }}function useData(url) { const [result, setResult] = useState(null); useEffect(() =&gt; { let ignore = false; fetch(url) .then((response) =&gt; response.json()) .then((json) =&gt; { if (!ignore) { setResult(json); } }); return () =&gt; { ignore = true; }; }, [url]); return result;} 您可能還想加入一些錯誤處理以及追蹤資料是否正確載入的邏輯。可以自訂 Hook 或者使用社群中許多的解決方案。雖然跟框架內建功能相比可能效能差一點，但將讀取邏輯獨立到一個自訂 Hook 後續採用其他策略或增加其他處理機制會比較方便。 一般來說，每當您必須使用 Effect ，留意是否可以將片段功能擷取到一個更具語意自訂的 Hook ，或專門針對某個 API 就像上面 useData 一樣。在元件中越少 useEffect 會更好維護。 概括 如果您能在渲染時期計算出值，就不要使用 Effect 快取耗費效能的計算可以使用 useMemo 而不是 useEffect 重置元件狀態可以使用 key 要根據 props 的變更調整狀態，請在渲染期間設定 如果程式碼是因為元件顯示就要執行的理由就放在 Effect，其他應該放在對應事件 如果您需要更新一些元件的狀態，最好在單一事件處理 每當你嘗試同步狀態時，請考慮將狀態往上層搬 你可以在 Effect 讀取資料，但記得清除的部分，避免 Race condition 參考 You Might Not Need an Effect","link":"/2022/08/10/you-might-not-need-an-effect/"},{"title":"Laravel 如何在 Jetstream 或 Fortify 覆寫登入後導向","text":"由於專案已經陸續採用 Laravel Jetstream 並且遇到一個需求; 根據使用的類型在登入時導向不同路由。想像一個情境，您有一般使用者和管理員，而管理員擁有後台功能。通常可能會需要將管理員導向後台介面。 使用 Laravel Jetstream 或 Fortify，要實作這個功能並不直覺，特別是使用兩階段驗證。 Jetstream 和 Fortify 驗證機制Jetstream 底層使用 Laravel Fortify，因此流程是一樣的。 Fortify 使用 Action Pipeline 來將請求派送到一系列的 class 類別，這些類別各自負責一個任務，例如嘗試驗證使用者或將他們導向兩階段驗證。 如何覆寫導向Fortify 支援完全自訂這些 Pipeline 但有比較簡單的方式覆寫導向的部分。 在驗證流程的最後一步 Pipeline 會從服務容器中擷取 Laravel\\Fortify\\Contracts\\LoginResponse 類別並回傳。意思是我們可以覆寫 LoginResponse 達到自訂導向的需求。 預設 LoginResponse 看起來如下: 123456789101112131415161718192021&lt;?phpnamespace Laravel\\Fortify\\Http\\Responses;use Laravel\\Fortify\\Contracts\\LoginResponse as LoginResponseContract;class LoginResponse implements LoginResponseContract{ /** * Create an HTTP response that represents the object. * * @param \\Illuminate\\Http\\Request $request * @return \\Symfony\\Component\\HttpFoundation\\Response */ public function toResponse($request) { return $request-&gt;wantsJson() ? response()-&gt;json(['two_factor' =&gt; false]) : redirect()-&gt;intended(config('fortify.home')); }} 由於 Fortify 使用多個 Action 來執行個別人任務，LoginResponse 這一步執行的任務非常簡單乾淨。 要自訂導向，首先將在 app/Http/Responses 加入自訂的 LoginResponse ，然後自訂 toResponse 方法讓使用者基於我們的條件導向不同的路由 12345678910111213141516171819&lt;?phpnamespace App\\Http\\Responses;use Laravel\\Fortify\\Contracts\\LoginResponse as LoginResponseContract;class LoginResponse implements LoginResponseContract{ /** * @param $request * @return mixed */ public function toResponse($request) { $home = auth()-&gt;user()-&gt;is_admin ? '/admin' : '/dashboard'; return redirect()-&gt;intended($home); }} 然後在 FortifyServiceProvider ，我們可以繫結自訂的 LoginResponse 覆寫 Fortify 預設提供的。 123456789101112131415161718&lt;?phpnamespace App\\Providers;// ...use App\\Http\\Responses\\LoginResponse;use Laravel\\Fortify\\Contracts\\LoginResponse as LoginResponseContract;class FortifyServiceProvider extends ServiceProvider{ /** * Bootstrap any application services. * * @return void */ public function boot() { // ... $this-&gt;app-&gt;singleton(LoginResponseContract::class, LoginResponse::class); }} 兩階段驗證這個解決方案幾乎完美的解決了我們的需求。但有一個缺失的地方，就是兩階段驗證。如果使用者有兩階段驗證，那麼 Fortify 會回傳不一樣的 Response 類別。幸好，兩階段驗證也是使用服務容器繫結。這次我們需要覆寫容器中的 Laravel\\Fortify\\Http\\Responses\\TwoFactorLoginResponse 類別，然後一樣在 FortifyServiceProvider 繫結。 1234567891011121314151617181920&lt;?phpnamespace App\\Providers;// ...use App\\Http\\Responses\\LoginResponse;use Laravel\\Fortify\\Contracts\\LoginResponse as LoginResponseContract;use Laravel\\Fortify\\Contracts\\TwoFactorLoginResponse as TwoFactorLoginResponseContract;class FortifyServiceProvider extends ServiceProvider{ /** * Bootstrap any application services. * * @return void */ public function boot() { // ... $this-&gt;app-&gt;singleton(LoginResponseContract::class, LoginResponse::class); $this-&gt;app-&gt;singleton(TwoFactorLoginResponseContract::class, LoginResponse::class); }} 注意: 我們直接使用同樣的 LoginResponse 覆寫 TwoFactorLoginResponse，因為兩者的功能應該是一樣的。 覆寫其他 Jetstream 和 Fortify 功能其他在 Jetstream 和 Fortify 的功能也可以用類似的方式自訂。如果您深入套件 FortifyServiceProvider 的程式碼在 registerResponseBindings 方法中應該可以看到 123456789101112131415161718192021222324252627282930313233&lt;?phpnamespace Laravel\\Fortify;// ...class FortifyServiceProvider extends ServiceProvider{ // ... /** * Register the response bindings. * * @return void */ protected function registerResponseBindings() { $this-&gt;app-&gt;singleton(FailedPasswordConfirmationResponseContract::class, FailedPasswordConfirmationResponse::class); $this-&gt;app-&gt;singleton(FailedPasswordResetLinkRequestResponseContract::class, FailedPasswordResetLinkRequestResponse::class); $this-&gt;app-&gt;singleton(FailedPasswordResetResponseContract::class, FailedPasswordResetResponse::class); $this-&gt;app-&gt;singleton(FailedTwoFactorLoginResponseContract::class, FailedTwoFactorLoginResponse::class); $this-&gt;app-&gt;singleton(LockoutResponseContract::class, LockoutResponse::class); $this-&gt;app-&gt;singleton(LoginResponseContract::class, LoginResponse::class); $this-&gt;app-&gt;singleton(TwoFactorLoginResponseContract::class, TwoFactorLoginResponse::class); $this-&gt;app-&gt;singleton(LogoutResponseContract::class, LogoutResponse::class); $this-&gt;app-&gt;singleton(PasswordConfirmedResponseContract::class, PasswordConfirmedResponse::class); $this-&gt;app-&gt;singleton(PasswordResetResponseContract::class, PasswordResetResponse::class); $this-&gt;app-&gt;singleton(RegisterResponseContract::class, RegisterResponse::class); $this-&gt;app-&gt;singleton(SuccessfulPasswordResetLinkRequestResponseContract::class, SuccessfulPasswordResetLinkRequestResponse::class); } // ...} 這些 Response 類別都是可以自訂的。","link":"/2022/07/15/how-to-override-login-redirects-in-jetstream-or-fortify/"},{"title":"2023 部署 Next.js 至 Google Cloud Run (混搭 Cloud Build, Gitlab CI, Secret Manager)","text":"本文的核心為將 Next.js 部署至 Google Cloud Run，CI 的部分會使用 Gitlab CI，主要會依據採用不同服務分成兩種流程： 在 Gitlab CI 建置 Docker Image 暫存到 Gitlab 後續部署到 Cloud Run Gitlab CI 搭配 Cloud Build 部署到 Cloud Run 本文希望可以儘量補充其他教學遺失的環節，幫助您可以自行選擇想用的服務調整流程。 [toc] 使用 Gitlab CI 建置 Docker Image 暫存到 Gitlab 後續部署至 Cloud Run1. 建立 Next.js 專案12345$ npx create-next-app [PROJECT_NAME]# 測試專案$ cd [PROJECT_NAME]$ npm run dev 2. Docker 化 Next.js 專案在 Next.js 專案根目錄下 1$ touch Dockerfile 下面 Dockerfile 是參考官方範例修改而成的。隨著時間演進可能有所不同，建議您可以也可以一起參考官方的範例調整。 另外，為了減少正式環境建置檔案大小複製了 /app/.next/standalone 則 next.config.js 須增加設定 output: &quot;standalone&quot; 1234567/** @type {import('next').NextConfig} */const nextConfig = { reactStrictMode: true, output: &quot;standalone&quot;,};module.exports = nextConfig; Dockerfile 如下，採用複數 Stage / Layer 的理由是為了縮小最後 Image 的大小： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 安裝相依套件FROM node:16-alpine AS deps# 查看 https://github.com/nodejs/docker-node/tree/b4117f9333da4138b03a546ec926ef50a31506c3#nodealpine# 理解為何需要 libc6-compatRUN apk add --no-cache libc6-compatWORKDIR /app# 根據偏好的套件管理工具安裝套件，您也可以使用 yarnCOPY package.json package-lock.json ./RUN npm ci --omit=dev# 僅在需要的時候重新編譯原始碼FROM node:16-alpine AS builderWORKDIR /appCOPY --from=deps /app/node_modules ./node_modulesCOPY . .# Next.js 收集一般使用資料 - Telemetry# 查看更多資料: https://nextjs.org/telemetry# 如果您需要關閉資料收集可以解開註解ENV NEXT_TELEMETRY_DISABLED 1RUN npm run build# 正式環境 Image, 複製全部檔案並執行 NextFROM node:16-alpine AS runnerWORKDIR /appENV NODE_ENV production# 如果您需要關閉資料收集可以解開註解ENV NEXT_TELEMETRY_DISABLED 1# 您可以變更成您希望的群組和使用者名稱RUN addgroup --system --gid 1001 nodejsRUN adduser --system --uid 1001 nextjsCOPY --from=builder /app/public ./public# 自動利用輸出軌跡來減小圖像大小# https://nextjs.org/docs/advanced-features/output-file-tracingCOPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/staticUSER nextjsEXPOSE 3000ENV PORT 3000CMD [&quot;node&quot;, &quot;server.js&quot;] 完成 Dockerfile 之後可以執行 docker build 和 docker run 進行本地測試 12$ docker build -t andyyou/nextjs .$ docker run -p 3000:3000 andyyou/nextjs 現在您可以瀏覽 http://localhost:3000 它會顯示跟之前本地開發伺服器一樣的內容。到此我們已經成功的 Docker 化一個 Next.js 應用程式。另外建議您可以閱讀 Nodejs 與 Docker。 3. 設定 Google Cloud Service這個 CI 流程大部分我們都在 Gitlab 處理，會用到 GCP 的部分只有 Cloud Run，但在發佈的過程我們會需要一組 Service Account 的金鑰。因此本節的設定： 建立 GCP 專案 啟用 Cloud Run API 建立授權一組 Service Account 並取得 JSON Key GCP 權限部分： Editor - 允許 Service Account 啟用/停用 API 或從 Google Cloud SDK 安裝更新 Cloud Run Admin - 允許 Service Account 執行 Cloud Run 指令，例如 deploy 應用程式 Storage Admin - 允許 Service Account 推送 push Docker Image 到 Google Container Registry Service Account User - 允許 Service Account 在 Cloud Run 中使用 Service Account 部署 備註：關於權限的部分可以依據您的需求調整，此處僅為展示。 4. 建立 .gitlab-ci.yml在開始撰寫 .gitlab-ci.yml 之前，請先建立好我們的 Gitlab Repository ，我們還需要將 Cloud Run 的服務名稱，Google Project ID，Service Account 金鑰設到 Gitlab ，如此 CI 才能讀取相關資料。 登入 Gitlab &gt; 專案 &gt; 左邊選單 Settings &gt; CI/CD &gt; Variables 新增變數。下面變數您應該可以在 GCP Console 以及剛剛下載的 JSON 取得。GCP_CLOUD_RUN_SERVICE_NAME 您可以自訂就是這個專案服務的名稱。 如果要在其他分支使用變數記得取消 Protect variable。 GCP_SERVICE_KEY GCP_PROJECT_ID GCP_CLOUD_RUN_SERVICE_NAME 接著，我們就可以使用 Gitlab CI 將 Next.js 專案部署到 Cloud Run 了 1$ touch .gitlab-ci.yml .gitlab-ci.yml 檔案如下： 1234567891011121314151617181920212223242526272829303132333435363738394041image: dockerservices: - docker:dindvariables: DOCKER_HOST: tcp://docker:2375 DOCKER_DRIVER: overlay2 CI_IMAGE: $CI_REGISTRY_IMAGE/$GCP_CLOUD_RUN_SERVICE_NAME:$CI_COMMIT_SHORT_SHA DEPLOY_IMAGE: gcr.io/$GCP_PROJECT_ID/$GCP_CLOUD_RUN_SERVICE_NAME:$CI_COMMIT_SHORT_SHAstages: - build - deploybuild: stage: build before_script: - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY script: - docker build -t $CI_IMAGE . - docker push $CI_IMAGEdeploy: stage: deploy image: google/cloud-sdk:slim before_script: - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY script: - docker pull $CI_IMAGE - docker tag $CI_IMAGE $DEPLOY_IMAGE - echo $GCP_SERVICE_KEY &gt; key.json - gcloud auth activate-service-account --key-file key.json - gcloud config set project $GCP_PROJECT_ID - gcloud auth configure-docker - docker push $DEPLOY_IMAGE - gcloud run deploy $GCP_CLOUD_RUN_SERVICE_NAME --image $DEPLOY_IMAGE --project $GCP_PROJECT_ID --platform managed --region asia-east1 --allow-unauthenticated when: manual only: - main 然後您就可以到 Gitlab &gt; CI/CD &gt; Pipeline 去發佈。 5. 補充 - 環境變數處理假設您沒有把 .env 相關的檔案 commit 到 Git 檔案庫上。上面的範例遺漏了一個沒有處理的部分，Next.js 在建置時期會無法取得環境變數，導致前端部分無法使用，即便您後來在 Cloud Run 介面補上這些變數也無法讀取。 這裡提供一個簡單的方式即先將變數以 VAR1=a,VAR2=b,VAR3=c 的格式儲存到 Gitlab 的 CI/CD 環境變數。然後利用 --build-arg 參數將變數傳入 Docker 建置流程，在稍微變更一下 Dockerfile 來處理。下面為兩個設定檔案 這裡示範補上一個 NEXT_ENV 環境變數。 Dockerfile 的部分注意 RUN npm run build 之前補上 ARG 等 12345678910111213// ...FROM node:16-alpine AS builderWORKDIR /appCOPY --from=deps /app/node_modules ./node_modulesCOPY . .ENV NEXT_TELEMETRY_DISABLED 1ARG NEXT_ENVRUN echo $NEXT_ENV | tr &quot;,&quot; &quot;\\n&quot; &gt; .env.productionRUN npm run build// ... .gitlab-ci.yml 則在 build 階段補上 --build-arg 1234567build: stage: build before_script: - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY script: - docker build -t $CI_IMAGE . --build-arg &quot;NEXT_ENV=$NEXT_ENV&quot; - docker push $CI_IMAGE 進階 - 使用 Gitlab CI 搭配 Google Cloud Build 部署至 Cloud Run開始前概略介紹 Cloud Run 是一個託管計算平台，提供自動擴展無狀態，無伺服器的容器 Cloud Build 是一個服務，可以在 Google Cloud Platform 執行編譯建置的任務 Gitlab CI 是 Gitlab 服務的一部分，可以在開發者將程式碼推送到檔案庫時建置和測試軟體 本節和上一節的差異為這次我們不在 Gitlab 編譯 Docker Image 而是將任務直接交給 Cloud Build 後續的部署也是一樣都由 Cloud Build 處理。以及我們會使用 Secret Manager 來處理正式環境的環境變數。 1. 設定 Google Cloud Service 如果您還沒有 GCP 專案請先建立專案，或參考上面章節。 啟用 Cloud Build 啟用 Cloud Run API 啟用 Secret Manager 登入您的 GCP 切換至 Cloud Build &gt; Settings，在 Service account permissions 下面確認 Cloud Run &amp; Service Accounts &amp; Secret Manager Secret Accessor 為 ENABLED 參考上面建立 Service Accout 的步驟不過這次我們需要的權限是 Cloud Build Service Agent和 Secret Manager Secret Accessor ，一樣取得 JSON 檔案。您也可以直接至 Google IAM 去調整。 登入 GCP &gt; Secret Manager &gt; Create Secret &gt; 使用 VAR1=a,VAR2=b,VAR3=c 格式建立您的環境變數。 2. 建立或使用既有 Next.js 專案您可以參考上面章節建立專案或使用既有的專案。除此之外我們還需要 3. 設定 Gitlab CI/CD, Cloud Build 與 Docker從上概覽，整個流程的順序會是我們靠 .gitlab-ci.yml 使用 gcloud builds submit 將 cloudbuild.yaml 腳本和專案本身一併交給 Cloud Build。然後 Cloud Build 依據 cloudbuild.yaml 讀取 Secret Manager 的資料 建置 Docker Image 推送 Docker Image 到 Registry 使用 gcloud 指令部署到 Cloud Run 第一步我們先搞定 Gitlab CI，一樣到 Gitlab 專案下左邊選單 Settings &gt; CI/CD &gt; Variables 設定環境變數 GCP_SERVICE_KEY GCP_PROJECT_ID 1$ touch .gitlab-ci.yml .gitlab-ci.yml 檔案如下 123456789101112131415image: google/cloud-sdk:slimstages: - deploydeploy: stage: deploy script: - echo $GCP_SERVICE_KEY &gt; key.json - gcloud auth activate-service-account --key-file key.json - gcloud config set project $GCP_PROJECT_ID - gcloud builds submit . --config=cloudbuild.yaml when: manual only: - main 注意到這裡我們使用 Google 的 Image 支援 gcloud 相關指令。如果您希望在 Gitlab 這邊也增加 test 和 build 階段可以自行增加。我們這裡單純演示使用 Cloud Build 的部分。 4. 建立 cloudbuild.yaml接著我們新增 cloudbuild.yaml 檔案如下。注意 Secret Manager 的使用。您可以閱讀一下官方文件，有個重點 -c 後面的指令是不可以拆開的。 12345678910111213141516171819202122232425262728293031steps: - name: &quot;gcr.io/cloud-builders/docker&quot; entrypoint: &quot;bash&quot; args: [ &quot;-c&quot;, &quot;docker build -t gcr.io/$PROJECT_ID/nextjs . --build-arg NEXT_ENV=$$NEXT_ENV&quot;, ] secretEnv: [&quot;NEXT_ENV&quot;] - name: &quot;gcr.io/cloud-builders/docker&quot; args: [&quot;push&quot;, &quot;gcr.io/$PROJECT_ID/nextjs&quot;] - name: &quot;gcr.io/cloud-builders/gcloud&quot; args: [ &quot;run&quot;, &quot;deploy&quot;, &quot;nextjs&quot;, &quot;--image&quot;, &quot;gcr.io/$PROJECT_ID/nextjs&quot;, &quot;--platform&quot;, &quot;managed&quot;, &quot;--region&quot;, &quot;asia-east1&quot;, &quot;--allow-unauthenticated&quot;, ]availableSecrets: secretManager: - versionName: projects/$PROJECT_ID/secrets/NEXT_ENV/versions/1 env: &quot;NEXT_ENV&quot; 5. 調整 Dockerfile12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# 安裝相依套件FROM node:16-alpine AS deps# 查看 https://github.com/nodejs/docker-node/tree/b4117f9333da4138b03a546ec926ef50a31506c3#nodealpine# 理解為何需要 libc6-compatRUN apk add --no-cache libc6-compatWORKDIR /app# 根據偏好的套件管理工具安裝套件，您也可以使用 yarnCOPY package.json package-lock.json ./RUN npm ci --omit=dev# 僅在需要的時候重新編譯原始碼FROM node:16-alpine AS builderWORKDIR /appCOPY --from=deps /app/node_modules ./node_modulesCOPY . .# Next.js 收集一般使用資料 - Telemetry# 查看更多資料: https://nextjs.org/telemetry# 如果您需要關閉資料收集可以解開註解ENV NEXT_TELEMETRY_DISABLED 1ARG NEXT_ENVRUN echo $NEXT_ENV | tr &quot;,&quot; &quot;\\n&quot; &gt; .env.productionRUN npm run build# 正式環境 Image, 複製全部檔案並執行 NextFROM node:16-alpine AS runnerWORKDIR /appENV NODE_ENV production# 如果您需要關閉資料收集可以解開註解ENV NEXT_TELEMETRY_DISABLED 1# 您可以變更成您希望的群組和使用者名稱RUN addgroup --system --gid 1001 nodejsRUN adduser --system --uid 1001 nextjsCOPY --from=builder /app/public ./public# 自動利用輸出軌跡來減小圖像大小# https://nextjs.org/docs/advanced-features/output-file-tracingCOPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/staticUSER nextjsEXPOSE 3000ENV PORT 3000CMD [&quot;node&quot;, &quot;server.js&quot;] 到此推送到 Gitlab 之後就可以部署了。本文的使用範例都是經過測試，希望可以提供一些幫助。 另外，兩個方式都是使用 --build-arg 的方式傳遞，如果您專精 Docker 有更好的作法歡迎告訴我 XD。 參考資源 Deploy to Cloud Run using GitLab CI Build repositories from GitLab This Is How I Deploy Next.js into Google Cloud Run with Github Actions Deploying to Cloud Run using Cloud Build","link":"/2023/01/12/deploy-nextjs-to-cloud-run-with-gitlab-ci/"},{"title":"(譯) 關於 React 併發功能與 Suspense 您所需要了解的事","text":"使用者介面（UI）是由許多不同“部分”組成，而每個部分會以不同的頻率回應使用者的操作。有些例如表單的輸入欄位（&lt;input&gt;），需要即時回應使用者的操作，而其他像是內容很長的“篩選列表”或切換頁面則稍微慢一些。 在同步渲染的情況下，也就是沒有併發功能的 React 或者大部分的 JavaScript UI 框架/函式庫。一些回應比較慢的介面操作就會阻塞執行而拖累較快回應的部分。 React 併發功能就是為了解耦/分離回應快和慢的介面，使渲染慢的部分在背景繼續執行而不阻塞較快的部分，達到每個部分可以各自回應使用者的操作。 併發渲染並不會讓應用程式提升效率變快，只是利用上敘分離的方式讓使用起來感覺體驗變快了。 本文將探討 React 併發功能（React Concurrent），了解其解決的問題以及如何利用。 遭遇的問題想像一下，您正開發一個在客戶端執行篩選的篩選列表元件，雖然篩選邏輯本身沒有額外呼叫伺服器，但不管是因為什麼原因，這個篩選邏輯非常耗費 CPU 效能，需要渲染時間。在這個假設下，我們有兩個主要的 UI 元素，一個輸入欄位，它的值會用來當作篩選條件，另一個就是列表內容。為了示範這個假設我們提供了下面的範例 上面範例的 &lt;List /&gt; 故意使用 sleep 變慢，進而導致同步渲染阻塞。當我們開始輸入篩選條件時，整個 UI 介面會凍結一下下，然後直接變成最後的結果。 理想情況下我們應該可以找方法優化這個元件讓其渲染加速，但有時候優化的部分我們能做的有限，有時候即便優化了渲染還是不如預期。在那些情況下，我們希望那些回應快的部分可以維持，不要被慢的部分拖累。這個範例只有 &lt;List /&gt; 是慢的，卻因爲一個元件阻塞讓整個 UI 犧牲變慢，而罪魁禍首就是同步渲染。 同步渲染沒有併發功能時（即沒有 startTransition , useTransition, useDeferredValue)，React 會同步渲染元件，意思是一旦開始渲染，除了例外錯誤，沒有任何事情可以阻止。它只會在完成這個渲染後才繼續其他任務。實務上這表示不管渲染多久，任何新的事件只會發生在渲染完成之後。 在這個實驗，我們有個 input 元件和會延遲 2 秒渲染的 &lt;Slow /&gt; 元件。&lt;Slow /&gt; 沒有 props 並且有 memo 快取，因此當 input 變更的時候並不會讓其重新渲染，然後每次我們點擊按鈕取得不同的 key 的時候會強制 &lt;Slow /&gt; 重新渲染。 我們點擊按鈕讓 &lt;Slow /&gt; 重新渲染並同時在 input 嘗試輸入內容。雖然確實可以輸入，但當 JavaScript 忙著渲染元件時，這些互動並不會中斷渲染，而是等 &lt;Slow /&gt; 渲染完成之後才顯示結果。觀察 Console 的輸出就能證明這些操作的回應是在 sleep 之後發生的。這就是所謂緩慢的元件會阻塞較快的元件，一旦開始渲染緩慢的元件，我們就只能等它們完成才能對其他元件進行更新。 解決方案為了解決這個問題，React 18 引進了所謂的併發渲染。 讓我們從發動一個更新開始。在有併發渲染的情況下，一個更新也就是任何會造成進行渲染的行為，例如我們呼叫 setState 設定新值就會造成更新 123456789101112131415161718const Component = () =&gt; { const [count, setCount] = useState(0); // 會造成更新，重新渲染 const handleIncrement = () =&gt; { setCount((count) =&gt; count + 1) }; // 如果傳入一樣的值並不會造成更新 // 實際上第一次呼叫會更新，但後續就不會了 const handleSame = () =&gt; { setCount(count); }; return ( &lt;&gt; &lt;button onClick={handleIncrement}&gt;Increment&lt;/button&gt; &lt;button onClick={handleSame}&gt;Same&lt;/button&gt; &lt;/&gt; );} 接著，我們將所謂的更新區分爲兩種： 高權重（緊急）更新 - High Priority(Urgent) 低權重（非緊急）更新 - Low Priority(Non-Urgent) 產生高權重更新一般是因為呼叫了 setState，useReducer 的 dispatch 或者使用 useSyncExternalStore （訂閱的 store 的資料）。也就是產生一次原來一般的同步渲染，這種渲染一旦開始就無法中斷。 此外，值得一提的是當整個應用程式第一次渲染，也就是 ReactDOM.createRoot，這個渲染也是高權重更新。 而低權重更新通常由 startTransition 或 useDeferredValue 觸發，它們會在高權重更新完成之後執行，並且可以被任何高權重的更新中斷。 1234567891011121314151617const Component = () =&gt; { const [filter, setFilter] = useState(''); const [delayedFilter, setDelayedFilter] = useState(''); const [isPending, startTransition] = useTransition(); const handleInputChanged = (e) =&gt; { setFilter(e.target.value); startTransition(() =&gt; { setDelayedFilter(e.target.value); }); }; return ( &lt;&gt; &lt;input value={filter} onChange={handleInputChanged} /&gt; &lt;/&gt; )} 當一個低權重的渲染被中斷，它會等中斷它的高權重更新渲染完畢，然後再重新開始渲染。 一個重要的特性，就是它們會和其他相同權重的更新合併，也就是全部的高權重更新會在同一個 call stack 執行，也就只會產生一次渲染。低權重更新也是相同的。 1234567891011121314151617181920212223const Component = () =&gt; { const [filter, setFilter] = useState(''); const [otherFilter, setOtherFilter] = useState(''); const [delayedFilter, setDelayedFilter] = useState(''); const [delayedOtherFilter, setDelayedOtherFilter] = useState(''); const [isPending, startTransition] = useTransition(); const handleInputChange = (e) =&gt; { // 下面兩個更新會合併成一次高權重渲染 setFilter(e.target.value); setOtherFilter(e.target.value.toUpperCase()); startTransition(() =&gt; { // 下面兩個更新則會合併成一次低權重更新的渲染 setDelayedFilter(e.target.value); setDelayedOtherFilter(e.target.value.toUpperCase()); }) }; return ( &lt;input filter={filter} onChange={handleInputChange} /&gt; )} 當回應慢的 UI 操作出現的時候，為了保持回應快的 UI 繼續運作，就把這些更新分成高權重和低權重。 通過這樣的方式，當回應慢的 UI 在處理時，出現了回應快的部分要更新，回應快的更新會中斷回應慢的部分，然後當快速的部分完成後回頭繼續渲染較慢的部分。 併發篩選列表這裡有個一樣的篩選列表範例，但現在我們使用併發功能來將快速與較慢的部分分離 上面範例有很多需要說明的地方，讓我們從改寫的地方開始。 第一，我們建立了新的 delayedFilter 狀態，然後傳入 &lt;List /&gt; 變成是觸發低權重更新。 第二，當使用者操作 input 的時候，我們會觸發高權重更新和一個低權重更新。 然後我們有使用 memo 快取了 &lt;List /&gt; ，現在 &lt;List /&gt; 不會因為上層元件 &lt;App /&gt; 渲染更新就更新，只會在 props 不同的時候才會重新渲染。 讓我們來進一步解析，當 &lt;App /&gt; 第一次渲染的時候，這是一個高權重渲染，因為是由 ReactDOM.createRoot 觸發的，因此 filter 和 delayedFilter 都是空字串。然後我們在 input 輸入 “tasty”，每次鍵盤輸入時，高權重更新和低權重更新都會觸發。 高權重更新永遠會在低權重更新之前執行，因此在第一鍵按下的時候，第一個高權重觸發，並執行渲染，只有高權重更新的效果會被修改，filter 的值變成 t ，但 delayedFilter 還是維持空字串。在這個情況下，直到低權重的更新完成，&lt;List /&gt; 是不會變的。 delayedFilter 不會在高權重更新時取得資料，加上 &lt;List /&gt; 有被塊錢，因此收到一樣的 delayedFilter 資料是不會更新的。 一旦高權重更新完成，並且提交變更了 VDOM 之後（Insertion Effect &gt; 變更DOM &gt; Layout &gt; Layout Effect &gt; Paint &gt; Effect 流程結束後）會開始低權重更新，此時 filter 的值是 “t”，然後 delayedFilter 也取得 “t” 。 但是，如果在低權重渲染的期間，我們輸入的下一個字 “a” 這時也會同時造成兩個更新，一個高權重和一個低權重。 因為高權重更新發動了，低權重更新會被中斷。 到此 filter 變成 “ta” 但 delayedFilter 還是 “” 空值。低權重更新的狀態只有在渲染完成並 commit 時才會發生（關於 commit 可參考資源React 渲染一文），與此同時高權重更新看到的這些值還沒變化。 我們可以把低權重更新看作是一份草稿，意思是只要被高權重更新打斷，就暫時不會被提交更新。 當高權重更新渲染時，delayedFilter 還是保持一樣的資料，回應慢的 &lt;List /&gt; 就不會被渲染。 當高權重更新完成後，會在回去處理這些低權重更新，如此循環直到我們停止操作 input ，當沒有其他高權重更新發生時候，低權重更新最終會完成渲染。上面這段描述您可以透過觀察 Console 證明了解。 同時您也可能注意到有時候低權重更新甚至沒有發動和中斷，這是因為輸入太快，在低權重更新都還沒開始之前就被高權重更新取消了。 整個流程乍看之下有點困惑，但有個非常適合的比喻可以說明這個概念。 併發渲染大略等於版控分支流程假設我們在開發一個應用程式，通常我們會使用 git 作為版控。當然我們會有一個主線 main 代表正式環境版本的程式碼。開發新功能的時候，我們會建立分支，例如 feature/awesome-feature，然後當開發工作完成，會合併回主線 main。 而當正式環境有某些嚴重的問題時，通常會立刻建立像是 hotfix/fix-nasty-bug 的分支，完成之後也會合併回主線。 當我們已經在開發某些功能時，突然需要先處理某個問題。因為修正問題通常會比發佈新功能來的緊急，因此我們會中斷開發，然後先處理問題直到我們解決問題並合併回主線。 只有在問題修正之後，我們才會回到新功能開發，然後需要先將 main 的更新先合回新功能的分支。 在這個例子中，一旦我們完成問題修正，我們就可以回去繼續開發新功能直到完成，但很有可能又再一次被其他問題中斷。 您大概意會到了，功能開發就類似低權重更新，可能隨時被一些嚴重需要修正的問題打斷。 同時，在完成問題修正之後，我們回到功能開發之前會需要先 pull 那些修正的結果，大致上相當於回到低權重更新時需要重新開始並且把高權重更新的東西也放進去。 如此您應該對於 React 的併發模式更加理解了，後續我們將更深入的解析。 併發功能併發功能發佈時，只有兩種方式可以開啟併發功能，分別是過渡 Transition 和延遲值 Deferred Value。 兩個功能都根據相同的原則運作：我們可以標記特定的更新爲低權重更新，然後就如同我們上面看到的說明。 Transition (useTransition)Transition API 提供一種命令式的方式讓我們標記更新爲低權重，透過 startTransitoin 接收的參數函式，任何在裡面發生的狀態變更都屬於低權重。 我們已經在上面篩選範例看過如何使用 Transition 了。 行為細節還有一些 Transitions API 的行為值得討論：startTransition 永遠會觸發高權重更新和低權重更新。呼叫 startTransition ，甚至我們在內部沒有觸發任何更新，它還是會觸發一個高權重更新，沒錯！您沒看錯是一個高權重更新和一個低權重更新。 老實說我不是真的很了解這麼做的目的，但無論如何這個知識點可能在您除錯的時候派上用場。 startTransition 的 callback 會立刻執行，傳入 startTransition 的函式也會立刻同步執行。這對於偵錯來說很重要，我們才不會被搞混亂。同時這也意味著我們不應該在這個 callback 裡面執行耗費效能的操作，否則也是會阻塞渲染。 總結來說在 startTransition 裡面觸發耗費效能的更新渲染是可以的，它們會在背景執行，但不要直接在裡面執行大量計算。 在 startTransition 內部更新的狀態必定在同一個呼叫堆疊(call stack)。標記低權重更新，也必須要在同一個堆疊中否則不起作用。（如果這裡您不懂 call stack 可以參考） 理解 JavaScript 中的事件循環、堆疊、佇列和併發模式（Learn event loop, stack, queue, and concurrency mode of JavaScript in depth） 理解 Javascript 中的執行環境與堆疊 意思是下面範例可能不會如您所預期一般作用： 12345678startTransition(() =&gt; { // 輪到 setTimeout callback 被調用時 // 已經是在另一個呼叫堆疊了 // 這個執行會被標記為“高權重更新” setTimeout(() =&gt; { setCount((count) =&gt; count + 1, 1000); });}); 12345startTransition(async () =&gt; { await asyncWork(); // 這裡也是在不同的 call stack setCount((count) =&gt; count + 1);}); 123456startTransition(() =&gt; { asyncWork().then(() =&gt; { // 不同堆疊 setCount((count) =&gt; count + 1); })}) 如果我們想使用上面這些結構或者說非同步 API ，則我們需要換個組織方式。 12345setTimeout(() =&gt; { startTransition(() =&gt; { setCount((count) =&gt; count + 1); });}); 12345await asyncWork();startTransition(() =&gt; { setCount((count) =&gt; count + 1);}); 12345asyncWork().then(() =&gt; { startTransition(() =&gt; { setCount((count) =&gt; count + 1); });}); 全部 Transition 都會合併在同一次渲染中。 這其實是我們之前提到低權重更新的特性或者說新功能，多個低權重更新會被合併到一次渲染。然而，這裡我認為有必要在重提一次。 當這些低權重更新被中斷，處於待處理的狀態時，如果另一個 B 低權重更新在第一個 A 低權重更新處理之前被觸發，則所有低權重更新會在同一次渲染執行。 此外，目前還有一個全套用或不套用的規範，意思是即便元件樹狀結構下某個低權重更新已經完成，但其他非相關的元件還在處理更新，“中斷”會讓它們全部重新開始。 Transition 只能用在狀態上，ref 是不行的. 雖然您可以在 startTransition 的 callback 裡面做幾乎所有的操作包含 ref ，但只有 setState 能標記低權重更新，換句話說只有狀態變更會收到影響。 注意到 filter 和 delayedFilter 保持同時在高權重更新發生變更。 意思是即便您在 startTransition 裡面變更 ref 但它的行為依舊和你不使用 Transition 一樣。值變了 &lt;List /&gt; 就會被觸發渲染導致原本問題還是存在。 延遲值 useDeferredValue相較於 Transition API 命令式風格的寫法，useDeferredValue 屬於宣告式。（Imperatively vs Declarative 可自行查詢）。 useDeferredValue 回傳一個低權重更新的狀態結果，且可以把值作為參數傳入。當前值和上一次的值不一樣時會觸發一個低權重更新。 在我們深入探討之前我們先來使用 useDeferredValue 處理一樣的篩選列表問題。 第一次應用程式渲染時會觸發高權重更新，且第一次呼叫 useDeferredValue 時它不會觸發低權重更新，只會回傳初始化的值。所以在第一次渲染 filter 和 deferredFilter 都是 &quot;&quot; 空值。 在第一次渲染之後，您可以輸入 “t” 然後因為 setFilter 會觸發一個高權重更新。 高權重更新時，filter 值會變成 &quot;t&quot; ，因此呼叫 useDeferredValue 會收到 &quot;t&quot;，但它會保持上一次的值 &quot;&quot; 直到低權重更新的渲染完成。 然後在高權重更新渲染完成之後，會因為 useDeferredValue 收到一個不一樣的值觸發一個低權重更新。 在低權重更新渲染，useDeferredValue 回傳的值會被設成最後收到的值，而且只有在低權重更新渲染時期收到的值才會被接收。 從這一刻開始它跟 Transition API 範例的工作流程就很類似，您可以通過觀察 Console 證明它們非常相似。 行為細節在低權重更新渲染期間傳入新值到 useDeferredValue 不會再觸發另一個更新。 如同之前提到的，useDeferredValue ，在低權重更新渲染期間會回傳收到最新的值，即便在低權重更新重新渲染期間收到的值和之前高權重更新中接收到的值不一樣。 換個說法，兩次不同的更新 render 就是執行 2 次我們元件的程式碼，在高權重更新時，如果 useDeferredValue 接到新值會觸發低權重更新，接著在執行低權重更新的時候收到的新值不會在觸發其他更新，而且會直接回傳這次收到的值。 雖然我們在高權重和低權重更新時傳入不同值到 useDeferredValue ，因為 isPending 只有在高權重渲染時期會是 true ，即便如此你會看到一切幾乎沒有變化，重點是在低權重渲染期間收到什麼值，而且不會額外觸發渲染。 不同 useDeferredValue 觸發的更新會在一次渲染中合併。這類似於所有的 Transition 也會在一次渲染合併一樣。所以即便在不相干的元件呼叫多次 useDeferredValue ，它們的更新還是會合併在一次低權重渲染。 Suspense到此我們已經討論了如何使用併發模式處理那些會造成效能瓶頸的元件，然而我們也可以用它們來處理 IO 相關元件。由於 IO 操作在 JavaScript 中可以利用非同步的方式完成，因此即便沒有併發功能，IO 相關的元件也不會造成上面提到的阻塞問題。IO 雖然不會阻塞，但我們等待 IO 的時候通常還是會渲染一個等待的效果。 使用 Suspense 讀取資料時，卻會遇到另一個問題。 現在我們可以不用在 Effect 中讀取資料（也就是完成渲染之後讀取資料），使用 Suspense 我們可以在渲染期間讀取。 我們不再需要等渲染完成才能開始讀取資料，但也不是沒有缺點。例如，如果我們想維持顯示舊資料，直到我們讀取完新資料，而不是永遠顯示載入中。這種情況以前我們會使用 useEffect 達成 這個範例要呈現的效果是，當我們第一次或重新載入頁面渲染時，此時還沒有任何資料，這個時候會顯示“載入中”。然後當我們切換頁面時，我們不會顯示載入中，而是保持顯示舊資料直到新資料載入完成。 但是如果是使用 Suspense 來讀取資料，無論是第一次渲染還是切換頁面，Suspense 都會顯示 fallback。 這時如果您希望 Suspense 可以使用這種顯示舊資料的行為，那我們就需要併發功能。 總體的思路是使用低權重更新來變更導致重新載入的狀態，因此當元件處於待處理狀態時是在背景執行，於此同時保持了舊資料在高權重更新渲染。 這裡有兩個範例一個採用 Transition 一個採用延遲值。我們不深入 suspenseFetchData 的細節，因為目前沒有穩定版本的 Suspense API 可以用來讀取資料，還有這裡不希望造成讀者困惑。 `useDeferredValue` 範例 其他注意事項現在我們了解 React 的併發功能是如何運作以及如何運用。不過下面還是有些其他注意事項希望和您分享。 暫停點 - Preemption每當我們有所謂非平行的併發時（即我們的例子，當併發渲染發生在單一執行緒）就需要搶占，也就是說，為了切換任務，我們需要在切換到另一個之前停止當前正在執行的任務。 而允許我們中斷的“地方”，就是我所說的暫停點（請注意，這裡的“暫停”不是 Suspense）。 在不鎖定的多執行緒的環境下，每一行程式碼都可以是一個暫停點，意思是任何時候不管已經執行了什麼，執行緒可以為了讓讓其他執行緒執行而暫停。 而在 React ，暫停點需要在每個元件渲染之間。這段資訊很重要，因為這表示個別元件的渲染不能被中斷，一旦元件開始渲染就會路到達 return 。 在到下一個元件渲染之前會一直檢查是否有高權重更新。 上面範例使用 Transition 支援併發功能的篩選列表，但做了些調整。 這次我們不讓 &lt;List /&gt; 本身成為耗費效能的元件，而是在裡面渲染新的 &lt;Slow /&gt;元件，就如其名這個元件就是現在效能的瓶頸。 這裡有兩個重要的事情需要注意： 第一，根據我們中斷低權重更新的速度，我們會在中斷發生之前有不同的 &lt;Slow /&gt; 需要被渲染。 第二，&lt;Slow /&gt; 產生的 console.log 永遠成對出現，意味著一旦開始渲染 &lt;Slow /&gt; 我們無法中斷它。 如果我們可以在 &lt;Slow /&gt; 渲染時期中斷它，我們應該不會看到他們成對出現。 結論就是我們應該避免在單一元件裡有耗費效能的操作，也不應該把它們亂拆成多個元件，拆成多個元件也不能解決問題。 真的無法避免這種情況發生，即便是併發模式也無能為力，因為一旦開始渲染某個回應慢的元件我們也無法觸發其他高權重更新，而之前的範例都是在低權重更新開始渲染之前就中斷它。 小結：我們應該通過低權重更新去更新那些耗效能的元件，延遲它們的渲染。 低權重和高權重更新都只有一個階級雖然針對併發渲染 React 內部有很多順序權重，但只會是高權重或低權重，沒有中間值。 所有高權重更新都是相同權重的，低權重也一樣。 這表示低權重更新，不管來自沒有直接關係的元件，或者來自 Transition 或 Defered Value，他們的權重都是一樣的，也會被合併在同一次渲染。也會遵循全套用或不套用的原則。 123456789101112131415161718192021222324252627282930313233343536373839404142export default function App() { const [filter, setFilter] = useState(''); const [delayedFilter, setDelayedFilter] = useState(''); const deferredFilter = useDeferredValue(filter); const [isPending, startTransition] = useTransition(); useDebug({ filter, delayedFilter, deferredFilter }); return ( &lt;div className=&quot;container&quot;&gt; &lt;input value={filter} onChange={(e) =&gt; { setFilter(e.target.value); startTransition(() =&gt; { setDelayedFilter(e.target.value); }); }} /&gt; {isPending &amp;&amp; 'Recalculating...'} &lt;List filter={delayedFilter} /&gt; &lt;/div&gt; );}const List = memo(({ filter }) =&gt; { const filteredList = list.filter((entry) =&gt; ( entry.name.toLowerCase().includes(filter.toLowerCase()) )); sleep(100); return ( &lt;ul&gt; {filteredList.map((item) =&gt; ( &lt;li key={item.id}&gt; {item.name} - ${item.price} &lt;/li&gt; ))} &lt;/ul&gt; );}); 可以注意到 delayedFilter 和 deferredFilter 永遠都是同步的，也不會觸發額外的更新。 併發模式除錯替併發元件除錯是非常棘手的事，因為它們會渲染兩次，一次是高權重更新，一次是低權重更新。使用 console 的時候會變得非常混亂，特別是兩個值不一樣。 這個情況下，一個問題自然就出現了，就是我們要如何知道我們是在高權重更新還是低權重更新，又怎麼知道是低權重更新。 好在，有些指標可以協助我們識別： 第一個是觀察 useDeferredValue 回傳的值， useDeferredValue 在第一次掛載渲染會回傳跟收到一樣的值，但之後，如果我們傳入不同資料它只會在低權重更新渲染時才變更。 因此我們可以 1234567// 我們在每次渲染都建立一個新的參考// 如此 probe 將會跟前一次的資料不同const probe = {}const deferredProbe = useDeferredValue(probe);// 如果不是第一次渲染的話const isLowPriority = probe === deferredProbe; 針對元件的第一次渲染，沒有什麼簡單的方式可以偵測是否是優先更新，因為第一次渲染也可能是低權重更新造成的。 1234567891011121314const App = () =&gt; { const [show, setShow] = useState(false); const deferredShow = useDeferredValue(show); return ( &lt;&gt; &lt;button onClick={() =&gt; setShow(true)}&gt;Show&lt;/button&gt; {/* 下面元件第一次渲染是基於 deferredShow 這個低權重更新觸發的 */} {deferredShow &amp;&amp; &lt;Component /&gt;} &lt;/&gt; );} 因為所有的 Effect useInsertionEffect，useLayoutEffect，useEffect只會在渲染階段之後觸發，意思是當它們開始執行的時候，不僅元件將要完成渲染也 commit 了，等於整個元件樹狀結構已經完成渲染了。 有了這些指標，我們可以建置 Hook 來協助我們為併發功能除錯 12345678910111213141516171819202122232425262728293031323334353637const useDebugConcurrent = ({ onFirstRenderStart, onFirstRenderEnd, onLowPriorityStart, onLowPriorityEnd, onHighPriorityStart, onHighPriorityEnd}) =&gt; { const probe = {}; const deferredProbe = useDeferredValue(probe); const isFirstRenderRef = useRef(true); const isFirstRender = isFirstRenderRef.current; const isLowPriority = probe === deferredProbe; if (isFirstRender) { isFirstRenderRef.current = false; onFirstRenderStart?.(); } else { if (isLowPriority) { onLowPriorityStart?.(); } else { onHighPriorityStart?(); } } useLayoutEffect(() =&gt; { if (isFirstRender) { onFirstRenderEnd?.(); } else { if (isLowPriority) { onLowPriorityEnd?.(); } else { onHighPriorityEnd?.(); } } });} 上面範例是之前使用 useDebug 的改版，差別只是這個 Hook 更適用於一般情況下。此外我們並無法正確精準的偵測中斷，只能知道一個非優先渲染開始和結束不匹配，也無法正確的偵查第一次渲染的優先或非優先。 結論React 的併發功能讓我們可以處理長久以來的問題提升更好的使用者體驗，而本文的介紹是希望您能正確的理解和使用這個功能。 資源 Everything you need to know about Concurrent React (with a little bit of Suspense) React 渲染 理解 JavaScript 中的事件循環、堆疊、佇列和併發模式（Learn event loop, stack, queue, and concurrency mode of JavaScript in depth） 理解 Javascript 中的執行環境與堆疊","link":"/2023/01/21/all-you-need-to-know-about-react-concurrent/"},{"title":"防禦 DDoS - 限制 IP 時間內大量請求 Nginx + fail2ban","text":"Nginx 如有使用 LB 或其他 Proxy 服務，測試規則請注意來源 IP是否為同一個 IP。 123456789101112131415161718192021222324252627282930313233http { # limit_conn_zone 限制併發連線數量 limit_conn_zone $binary_remote_addr zone=zone1:10m; # 前面有檔 LB 或 Proxy IP 來源可以換成 $http_x_forwarded_for # limit_conn_zone $http_x_forwarded_for zone=one1:10m; # limit_req_zone 限制請求頻率 # binary_remote_addr 使用客戶端 IP 進行限制 # zone=one:10m：建立 IP 儲存區 10MB，用於儲存請求頻率資料 # rate=10r/s：表示該 IP 每秒請求次數 10 表示 10 次 limit_req_zone $binary_remote_addr zone=zone2:10m rate=10r/s;}server { # ... location / { # 套用 zone1 規則，限制併發連線數量為 2 limit_conn zone1 2; # 套用 zone2 規則，限制請求頻率 # brust 如果請求超過規則，則延遲，可被延遲的數量上限 # nodelay 超過頻率的話請求被延遲，延遲超過數量則終止，預設返回 503 # 若要變更狀態可以使用 limit_req_status 419: Too Many Requests limit_req zone=zone2 burst=10 nodelay; limit_req_status 419; # ... }} fail2ban1234567891011$ sudo apt install fail2ban# 建立設定，例如：套用 filter，掃描的 log 路徑，限制時間等# 不要直接變更 jail.conf 因為更新會調整該檔案$ touch /etc/fail2ban/jail.local# 建立過濾 regex 條件$ touch /etc/fail2ban/filter.d/http-atk.conf# 查詢被 ban 狀態, http-atk 為設定名稱$ sudo fail2ban-client status http-atk 下面設定範例為針對 Nginx 存取日誌進行限制。 jail.local123456789[http-atk]enabled = trueport = http,httpsfilter = http-atklogpath = /var/log/nginx/access.logmaxretry = 10findtime = 1bantime = 20action = iptables[name=http-atk, port=http, protocol=tcp] [http-atk] CLI 調用規則時的名稱，慣例都小寫。 enabled 限制規則是否啟用 port filter 過濾條件檔案名稱。（filter 看檔名，cli 看 conf [] 名稱） logpath 掃描日誌路徑 maxretry 容許次數 findtime 容許次數的限制時間，預設不加單位為秒。例如 findtime 為 1，maxretry 為 5。1 秒允許 5 次。 bantime 鎖定時間（秒） action 使用 iptables 鎖 IP http-atk.conf過濾條件檔名可自訂。 123[Definition]failregex = ^&lt;HOST&gt; - - .*\\&quot;(GET|POST).*ignoreregex = 資源 Gist 與 DDoS 奮戰：nginx, iptables 與 fail2ban Linux 遇到 nf_conntrack: table full, dropping packet 解法 nginx单个ip访问频率限制 Per-IP rate limiting with iptables - Making Pusher Fail2ban 限定登入錯誤次數","link":"/2023/04/12/fail2ban-quick-guide/"},{"title":"使用 Callback Refs 取代 useEffect 避免問題產生","text":"雖然 ref 是一個可變更 (mutable 物件在建立後可被修改) 的容器，我們理論上可以儲存任何資料。通常我們會拿來處理存取 DOM 節點: 123const ref = React.useRef(null);return &lt;input ref={ref} defaultValue='Hello world' /&gt;; ref 是一個內建的屬性，React 會在渲染後儲存 DOM 節點，當元件卸載後也會設為 null。 使用 refs 互動對於大多數操作互動，您不需要直接存取 DOM ，因為 React 會自動幫我們處理更新。一個最好的使用範例就是當您需要處理 focus 行為的時候。 Devon Govett 雖然提出了相關的 RFC 旨在加入 FocusManagement 到 react-dom，但目前沒有內建的機制協助處理。 使用 Effect 來處理 focus那麼目前我們要如何處理渲染後 focus 呢? 當然我們都知道 autofocus 但如果您希望加入一些動畫或複雜的行為。 好, 我見過大多數的人都嘗試下面的做法: 1234567const ref = React.useRef(null);React.useEffect(() =&gt; { ref.current?.focus();}, []);return &lt;input ref={ref} defaultValue='Hello world' /&gt;; 這種做法在多數情況下沒啥問題。Effect 的第二個參數為空沒有問題，因為裡面的 ref 是可變更的，linter 不會警告，並且 ref 在渲染時期也不會被讀取(不過這對 React Concurrent 功能可能會有問題)。 Effect 只會在掛載時執行一次。此時，React 已經把 DOM 設到 ref，因此可以 focus。 然而這並不是最好的做法，並且在一些複雜的情況下會有問題。 具體來說，我們假設 ref 在 Effect 執行時設定完成。但如果不是呢? 例如你把 ref 傳入自訂的元件，這個元件會延後渲染或只有在某些操作之後才出現，這個情況下 ref 就會是 null 即便執行了 Effect 還是不會有 focus 效果。 123456789101112131415161718192021222324function App() { const ref = React.useRef(null); React.useEffect(() =&gt; { // ref.current 永遠是 null ref.current?.focus(); }, []); return &lt;Form ref={ref} /&gt;;}const Form = React.forwardRef((props, ref) =&gt; { const [show, setShow] = React.useState(false); return ( &lt;form&gt; &lt;button type='button' onClick={() =&gt; setShow(true)}&gt; Show &lt;/button&gt; // ref 掛載到 input 但需要符合條件才會渲染 // 因此在 Effect 執行的時候未被設定 {show &amp;&amp; &lt;input ref={ref} /&gt;} &lt;/form&gt; );}); 下面是流程說明: Form 渲染 &lt;input&gt; 沒有渲染，ref 依舊是 null Effect 執行，什麼都沒發生 &lt;input&gt; 顯示，ref 設定完成，但不會 focus 因為 Effect 不會執行 問題在於 Effect 是因為 Form 渲染才執行的關係，而我們實際上需要的是當 input 渲染完成執行 focus，並非當表單掛載時。 Callback Refs這就是 Callback Refs 派上用場的地方了。如果您曾經看過 ref 的型別宣告，您可以看到我們不只可以傳入 ref 物件，也可以用 function: 1type Ref&lt;T&gt; = RefCallback&lt;T&gt; | RefObject&lt;T&gt; | null; 概念上，我喜歡 React 元素的 ref 當作函式，它會在元件渲染完成之後執行。這個函式會取得渲染的 DOM 節點作為參數。如果 React 元素卸載，也會再次執行並傳入 null。 將 useRef (一個 RefObject) 傳入 ref 到 React 元素只是語法糖: 123456&lt;input ref={(node) =&gt; { ref.current = node; }} defaultValue='Hello world'/&gt; 讓我們在強調一次 所有 ref props 只是函式! 並且這些函式會在渲染之後執行，執行包含副作用的程式完全是可以的。如果 ref 叫做 onAfterRender 或許更直覺。 有了這個知識，我們是否可以直接存取 node? 123456&lt;input ref={(node) =&gt; { node?.focus(); }} defaultValue='Hello world'/&gt; 另外一個小細節: React 在每次渲染之後都會 focus。因此除非您可以接受每次都 focus ，否則我們需要告訴 React 只需要在我們希望的時候執行一次。 使用 useCallback 解決幸運的是 React 會檢查參考是否相同來決定是否應該要執行。意思是如果我們傳入相同參考就會忽略執行。 此時， useCallback 就可以派上用場，因為這就是我們確保不會反覆重新建立函式的方法。這也是為什麼成為 Callback Refs 因為你需要將他們包在 useCallback 裡面。 12345const ref = React.useCallback((node) =&gt; { node?.focus();}, []);return &lt;input ref={ref} defaultValue='Hello world' /&gt;; 相較於第一個 Effect 版本，更少的程式，而且只用一個 Hook。同時也滿足所有情況。外加即使在開發環境 strict mode 也不會執行兩次。 如同隱藏在舊版文件的段落所介紹，您可以在其中使用任何副作用的操作，執行 setState。 12345678910111213141516function MeasureExample() { const [height, setHeight] = React.useState(0); const measureRef = React.useCallback((node) =&gt; { if (node !== null) { setHeight(node.getBoundingClientRect().height); } }, []); return ( &lt;&gt; &lt;h1 ref={measuredRef}&gt;Hello, world&lt;/h1&gt; &lt;h2&gt;The above header is {Math.round(height)}px tall&lt;/h2&gt; &lt;/&gt; );} 因此，如果您需要在渲染之後直接操作 DOM ，試著不要直接用 useRef + useEffect，嘗試 Callback Refs 取代。 參考 Avoiding useEffect with callback refs","link":"/2022/08/17/avoiding-use-effect-with-callback-refs/"},{"title":"[譯]部署應用程式到 GKE 叢集","text":"本篇快速入門，我們將部署一個簡單容器化的 Web 應用程式到 Google Kubernetes Engine 叢集。您將學習如何建立一個叢集以及部署應用程式到叢集。 本文旨在讓您可以快速實作感受一下 K8S 的用法。 在開始之前遵循下列步驟啟動 Kubernetes Engine API 在 Google Cloud Console 介面，選擇或建立專案 確認專案的帳單功能已連結 啟用 Artifact Registry 和 Google Kubernetes Engine API. 搭配原文的連結可以快速找到設定連結 這裡我們將使用 Cloud Shell 簡化相關前置作業。它是一個 Shell 指令環境，支援管理在 Google Cloud 上的資源服務。Cloud Shell 預先安裝了 Google Cloud CLI 和 kubectl 指令。 gcloud 指令主要針對 Google Cloud ，而 kubectl 指令則針對 Kubernetes 叢集。 登入 Google Cloud Console 在右上角點擊 Active Cloud Shell 按鈕12$ gcloud projects list$ gcloud config set project [PROJECT_ID] 一個叢集至少由一個 Cluster Control Plane machine (叢集控制面板機器) 和多個 Node (工作者機器) 組成。Node 就是 Compute Engine 虛擬機器，其執行 Kubernetes 程序使其成為叢集的一部分。 Node 是 K8S 中的一台實體機或 VM。Pod 是 K8S 的基本單位即容器。而容器就例如我們 Dockerized 的應用程式，資料庫服務，Redis 服務等等。這裡我們先有個觀念即可，後續操作完在閱讀相關文件您會更容易理解。 然後我們可以部署程式到叢集，程式具體會在 Node 中執行。 12$ gcloud container clusters create-auto hello-cluster \\ --region=asia-east1 建立叢集之後我們需要取得憑證好讓我們可以操作叢集 1$ gcloud container clusters get-credentials hello-cluster --region asia-east1 這個指令設定好可以使用 kubectl 操作叢集。現在我們已經建立好叢集，可以部署容器化的應用程式了。為了聚焦在 K8S 我們部署一個簡單的範例 hello-appGKE 使用 Kubernetes 物件來建立和管理叢集的資源。Kubernetes 提供了 Deployment 物件來部署。Service 物件則為我們的網頁程式定義從網路存取的規則和負載平衡器。 要在叢集內執行 hello-app，我們需要利用下面指令部署應用程式 12$ kubectl create deployment hello-server \\--image=us-docker.pkg.dev/google-samples/containers/gke/hello-app:1.0 kubectl create deployment 建立了一個名為 hello-server 的部署物件。然後 Deployment 的 Pod 會執行 hello-app 的映象檔。在上面的指令中 --image 指定部署容器的 Image。在這個例子中指令會從 Artifact Registry 檔案庫讀取指定版本的 Image。 在部署之後，您需要公開到網路上，那麼使用者才能夠存取。您可以通過建立一個 Service 來公開我們的應用程式。 1$ kubectl expose deployment hello-server --type LoadBalancer --port 80 --target-port 8080 --type LoadBalancer 參數會建立一個 Compute Engine 的負載平衡器。--port 參數則是公開 Port 80 到目標 8080。 建立完成之後我們就可以利用下面的指令取得 IP 和相關資訊或刪除 1234567$ kubectl get pods$ kubectl get services$ kubectl get service hello-server$ kubectl delete service hello-server$ gcloud container clusters delete hello-cluster --region asia-east1","link":"/2023/04/12/gke-quick-guide/"},{"title":"React + Google Map 模仿 Airbnb 效果","text":"如過您希望製作像 Airbnb 那樣自訂標記的樣式，動態顯示一些資訊並且當用戶和其互動時可以渲染自訂的 React 元件，那麼您來對地方了。 本範例嘗試使用 Google 官方的 React Wrapper 函式庫實作 Google Map 功能，目標為自訂 MapOverView 達成在 Map 上加入複雜的 Marker。 例如像 Airbnb 點擊房源時可以展開。這個範例我們會支援 Marker Clustering。 完整教學與範例請參考 Github","link":"/2023/06/15/react-google-map-with-cluster/"},{"title":"認識 for await","text":"首先，參考以下的實務範例： 1234567891011async function main() { const stream = await opeanai.chat.completions.create({ model: 'gpt-4', messages: [ { role: 'user', content: '測試回答' }, ], }); for await(const part of stream) { process.stdout.write(part.choices[0]?.delta?.content || ''); }} 這是一段 OpenAI Node SDK 的範例，使用 GPT-4 搭配串流的方式。 目標理解 for await 這個神奇的語法。 Generator讓我們從 Generator 開始，為什麼要使用 Generator? 這是因為 Generator 有以下的特性： 逐一訪問元素。 優化效能，採用 Lazy Evaluation, 假設我們有一個超大的集合，陣列會在讀取時就將所有的值計算並放入記憶體，而 Generator 只有在呼叫 next() 時才會計算出下一個值。 統一不同資料結構（陣列、字串、集合（Set））遍歷的方式。 Generator Function 的另一個使用情境就是可以暫停函式，再恢復執行。 簡單說，一個 Generator Funciton 會回傳 Generator 物件。 且這個物件必須符合可迭代協議和迭代器協議。 可迭代協議：指的是物件必須實作 Symbol.iterator 方法，然後就可以使用 for ... of 迴圈。陣列、字串、集合（Set）都是可迭代的，因為它們都實作了。 迭代器協議：則是物件必須要包含 next() 方法。 讓我們使用一個例子來看看 Generator 的使用方式： 1234567891011121314151617181920212223const go = function* () { yield '1'; yield '2'; yield '3';}for (const n of go()) { console.log(n);}// 逐步展示 Generator 運作function* missions() { console.log('任務開始'); const afterY1 = yield &quot;A&quot;; console.log('接收', afterY1);}const g = missions(); // 第一次呼叫回傳一個 Generator 物件const y1 = g.next(); // 執行到第一個 yield 函式暫停執行，回傳一個物件console.log(y1.value); // value 為剛剛暫停 yield 右側的 expression 執行結果 Aconsole.log(y1.done); // false;const y2 = g.next('B');// 傳入值 Bconsole.log(y2.done); // true;g.next(); // 再呼叫會拋出例外。 Async Generator + for await了解了 Generator，您大概已經想到一個常見的使用情境 - 依序發送 API 請求。 您大概想要在 yield 右邊的 expression 呼叫 API 並取得資料，甚至使用 await。yield 的右邊確實可以使用 Promise ，但問題是它不會等 Promise 執行完成。 因此我們需要 Async Generator。 123456789101112async function* missions() { yield await Promise.resolve('1'); // 這裡可以替換成您的 API request yield await Promise.resolve('2'); yield await Promise.resolve('3');}const cb = async () =&gt; { // await 須在 async 裡面。 for await (const v of missions()) { console.log(v); }} 現在您已經了解 OpenAI SDK 的範例了。 補充：Mobx flow 不太一樣如果您曾經使用過 Mobx 對於上面說的一般 Generator 不會等 Promise 完成有點疑問。因為您確實看過如下的例子： 123456789101112131415161718192021222324252627import { observable, flow } form 'mobx';class UserStore { @observable user = null; @observable isLoading = false; @observable error = null; fetchUser = flow(function* (id) { this.isLoading = true; this.error = null; try { const response = yield fetch('/your/api/${id}'); if (resposne.ok) { this.user = yield response.json(); } else { this.error = 'Failed'; } } catch (error) { this.error = error; } finally { this.isLoading = false; } });}const userStore = new UserStore();userStore.fetchUser(1); 原因是雖然 MobX 基於 Generator，但使用 flow 包住 Generator 時，其行為有所不同。當遇到 yield，flow 會暫停並等待 Promise 完成，再繼續執行。這讓非同步操作在 action 中不會違反 MobX 的反應性原則。","link":"/2023/09/01/async-generator-for-await/"}],"tags":[{"name":"ruby","slug":"ruby","link":"/tags/ruby/"},{"name":"RoR","slug":"RoR","link":"/tags/RoR/"},{"name":"rack server","slug":"rack-server","link":"/tags/rack-server/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"osx","slug":"osx","link":"/tags/osx/"},{"name":"aws","slug":"aws","link":"/tags/aws/"},{"name":".net mvc","slug":"net-mvc","link":"/tags/net-mvc/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"sass","slug":"sass","link":"/tags/sass/"},{"name":"grunt","slug":"grunt","link":"/tags/grunt/"},{"name":"package manager","slug":"package-manager","link":"/tags/package-manager/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"entity framework","slug":"entity-framework","link":"/tags/entity-framework/"},{"name":"framework","slug":"framework","link":"/tags/framework/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"mongodb","slug":"mongodb","link":"/tags/mongodb/"},{"name":"reactjs","slug":"reactjs","link":"/tags/reactjs/"},{"name":"gulp","slug":"gulp","link":"/tags/gulp/"},{"name":"task runner","slug":"task-runner","link":"/tags/task-runner/"},{"name":"ios","slug":"ios","link":"/tags/ios/"},{"name":"flux","slug":"flux","link":"/tags/flux/"},{"name":"azure","slug":"azure","link":"/tags/azure/"},{"name":"selenium","slug":"selenium","link":"/tags/selenium/"},{"name":"compass","slug":"compass","link":"/tags/compass/"},{"name":"jekyll","slug":"jekyll","link":"/tags/jekyll/"},{"name":"carrier wave","slug":"carrier-wave","link":"/tags/carrier-wave/"},{"name":"devise","slug":"devise","link":"/tags/devise/"},{"name":"centos","slug":"centos","link":"/tags/centos/"},{"name":"postgresql","slug":"postgresql","link":"/tags/postgresql/"},{"name":"heroku","slug":"heroku","link":"/tags/heroku/"},{"name":"xml","slug":"xml","link":"/tags/xml/"},{"name":"windows","slug":"windows","link":"/tags/windows/"},{"name":"iisexpress","slug":"iisexpress","link":"/tags/iisexpress/"},{"name":"es6","slug":"es6","link":"/tags/es6/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"bundler","slug":"bundler","link":"/tags/bundler/"},{"name":"oocss","slug":"oocss","link":"/tags/oocss/"},{"name":"jspm","slug":"jspm","link":"/tags/jspm/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"chrome","slug":"chrome","link":"/tags/chrome/"},{"name":"react native","slug":"react-native","link":"/tags/react-native/"},{"name":"redux","slug":"redux","link":"/tags/redux/"},{"name":"vuejs","slug":"vuejs","link":"/tags/vuejs/"},{"name":"slim","slug":"slim","link":"/tags/slim/"},{"name":"cache","slug":"cache","link":"/tags/cache/"},{"name":"mechanism","slug":"mechanism","link":"/tags/mechanism/"},{"name":"raspberry-pi","slug":"raspberry-pi","link":"/tags/raspberry-pi/"},{"name":"ssl","slug":"ssl","link":"/tags/ssl/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"jwt","slug":"jwt","link":"/tags/jwt/"},{"name":"api","slug":"api","link":"/tags/api/"},{"name":"bot","slug":"bot","link":"/tags/bot/"},{"name":"facebook","slug":"facebook","link":"/tags/facebook/"},{"name":"cloudflare","slug":"cloudflare","link":"/tags/cloudflare/"},{"name":"svg javascript","slug":"svg-javascript","link":"/tags/svg-javascript/"},{"name":"javascript express passport","slug":"javascript-express-passport","link":"/tags/javascript-express-passport/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"queue","slug":"queue","link":"/tags/queue/"},{"name":"rabbitmq","slug":"rabbitmq","link":"/tags/rabbitmq/"},{"name":"e-invoice","slug":"e-invoice","link":"/tags/e-invoice/"},{"name":"ubuntu","slug":"ubuntu","link":"/tags/ubuntu/"},{"name":"rails","slug":"rails","link":"/tags/rails/"},{"name":"javascript nodejs","slug":"javascript-nodejs","link":"/tags/javascript-nodejs/"},{"name":"tools","slug":"tools","link":"/tags/tools/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"rails webpack stimulus javascript bootstrap","slug":"rails-webpack-stimulus-javascript-bootstrap","link":"/tags/rails-webpack-stimulus-javascript-bootstrap/"},{"name":"tmux","slug":"tmux","link":"/tags/tmux/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"},{"name":"postgres","slug":"postgres","link":"/tags/postgres/"},{"name":"stimulus","slug":"stimulus","link":"/tags/stimulus/"},{"name":"vm","slug":"vm","link":"/tags/vm/"},{"name":"letsencrypt","slug":"letsencrypt","link":"/tags/letsencrypt/"},{"name":"go","slug":"go","link":"/tags/go/"},{"name":"gcp","slug":"gcp","link":"/tags/gcp/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"dnd","slug":"dnd","link":"/tags/dnd/"},{"name":"laravel","slug":"laravel","link":"/tags/laravel/"},{"name":"jetstream","slug":"jetstream","link":"/tags/jetstream/"},{"name":"zoom","slug":"zoom","link":"/tags/zoom/"},{"name":"ux","slug":"ux","link":"/tags/ux/"},{"name":"wsl","slug":"wsl","link":"/tags/wsl/"},{"name":"cve","slug":"cve","link":"/tags/cve/"},{"name":"serial-port","slug":"serial-port","link":"/tags/serial-port/"},{"name":"gitlab","slug":"gitlab","link":"/tags/gitlab/"},{"name":"envoy","slug":"envoy","link":"/tags/envoy/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"k8s","slug":"k8s","link":"/tags/k8s/"}],"categories":[{"name":"Program","slug":"Program","link":"/categories/Program/"},{"name":"Tools","slug":"Tools","link":"/categories/Tools/"},{"name":"Cloud","slug":"Cloud","link":"/categories/Cloud/"},{"name":"System","slug":"System","link":"/categories/System/"},{"name":"Database","slug":"Database","link":"/categories/Database/"},{"name":"Fun","slug":"Fun","link":"/categories/Fun/"},{"name":"Mobile","slug":"Mobile","link":"/categories/Mobile/"},{"name":"UX","slug":"UX","link":"/categories/UX/"}]}