<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>[譯] React: 您可能不需要一個 Effect - DEVLOG of andyyou</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="DEVLOG of andyyou"><meta name="msapplication-TileImage" content="/img/faicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="DEVLOG of andyyou"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Effect 是讓您可以脫離典型 React 設計模型的一個方式。它讓您可以跳脫到 React 之外並讓您的 React 元件同步外部系統，比如使用非 React 的套件，網路，瀏覽器 DOM 。假如沒有涉及外部，例如您想要在某些 props 或 state 發生變更時更新元件的 state ，那麼您不應該使用 Effect。移除不必要的 Effect 可以讓您的程式碼更容易維護，執行效率更好，減"><meta property="og:type" content="article"><meta property="og:title" content="DEVLOG of andyyou"><meta property="og:url" content="https://andyyou.github.io/2022/08/10/you-might-not-need-an-effect/"><meta property="og:site_name" content="DEVLOG of andyyou"><meta property="og:description" content="Effect 是讓您可以脫離典型 React 設計模型的一個方式。它讓您可以跳脫到 React 之外並讓您的 React 元件同步外部系統，比如使用非 React 的套件，網路，瀏覽器 DOM 。假如沒有涉及外部，例如您想要在某些 props 或 state 發生變更時更新元件的 state ，那麼您不應該使用 Effect。移除不必要的 Effect 可以讓您的程式碼更容易維護，執行效率更好，減"><meta property="og:locale" content="zh_TW"><meta property="og:image" content="https://andyyou.github.io/img/og_image.png"><meta property="article:published_time" content="2022-08-10T06:08:31.000Z"><meta property="article:modified_time" content="2023-05-12T00:48:25.317Z"><meta property="article:author" content="andyyou"><meta property="article:tag" content="javascript"><meta property="article:tag" content="react"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><meta property="fb:app_id" content="450470251782295"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://andyyou.github.io/2022/08/10/you-might-not-need-an-effect/"},"headline":"[譯] React: 您可能不需要一個 Effect","image":["https://andyyou.github.io/img/og_image.png"],"datePublished":"2022-08-10T06:08:31.000Z","dateModified":"2023-05-12T00:48:25.317Z","author":{"@type":"Person","name":"https://avatars2.githubusercontent.com/u/665690?v=3&s=466"},"publisher":{"@type":"Organization","name":"DEVLOG of andyyou","logo":{"@type":"ImageObject","url":"https://andyyou.github.io/img/logo.png"}},"description":"Effect 是讓您可以脫離典型 React 設計模型的一個方式。它讓您可以跳脫到 React 之外並讓您的 React 元件同步外部系統，比如使用非 React 的套件，網路，瀏覽器 DOM 。假如沒有涉及外部，例如您想要在某些 props 或 state 發生變更時更新元件的 state ，那麼您不應該使用 Effect。移除不必要的 Effect 可以讓您的程式碼更容易維護，執行效率更好，減"}</script><link rel="canonical" href="https://andyyou.github.io/2022/08/10/you-might-not-need-an-effect/"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-C93NK5NEGP" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-C93NK5NEGP');</script><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><script data-ad-client="ca-pub-3038600205998182" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="DEVLOG of andyyou" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/andyyou"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜尋" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-08-10T06:08:31.000Z" title="8/10/2022, 2:08:31 PM">2022-08-10</time>發表</span><span class="level-item"><time dateTime="2023-05-12T00:48:25.317Z" title="5/12/2023, 8:48:25 AM">2023-05-12</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Program/">Program</a></span><span class="level-item">43 分鐘讀完 (大約6489個字)</span></div></div><h1 class="title is-3 is-size-4-mobile">[譯] React: 您可能不需要一個 Effect</h1><div class="content"><p>Effect 是讓您可以脫離典型 React 設計模型的一個方式。它讓您可以跳脫到 React 之外並讓您的 React 元件同步外部系統，比如使用非 React 的套件，網路，瀏覽器 DOM 。假如沒有涉及外部，例如您想要在某些 <code>props</code> 或 <code>state</code> 發生變更時更新元件的 <code>state</code> ，<strong>那麼您不應該使用 Effect</strong>。移除不必要的 Effect 可以讓您的程式碼更容易維護，執行效率更好，減少錯誤的產生。</p>
<blockquote>
<p>本文您將學習</p>
<ul>
<li>為什麼以及如何移除不必要的 Effect</li>
<li>如何快取耗費效能的計算而不使用 Effect</li>
<li>如何重置和調整元件 State 而不使用 Effect</li>
<li>如何在多個事件處理函式共享邏輯</li>
<li>哪些邏輯應該移到事件處理函式中</li>
<li>如何通知上層元件狀態變更</li>
</ul>
</blockquote>
<span id="more"></span>

<h2 id="為什麼以及如何移除不必要的-Effect"><a href="#為什麼以及如何移除不必要的-Effect" class="headerlink" title="為什麼以及如何移除不必要的 Effect"></a>為什麼以及如何移除不必要的 Effect</h2><p>有兩種常見的案例，您不應該使用 Effect:</p>
<ul>
<li><strong>您不需要 Effect 來轉換整理渲染呈現需要的資料</strong>。舉例來說，您希望在顯示之前過濾一個列表。您可能會覺得寫一個 Effect 在列表變更的時候更新一個狀態變數。然而這很沒效率。當您更新狀態時，React 會先呼叫您的元件函式來計算應該呈現在畫面的東西。接著 React 會 “commit” 變更到 DOM 更新畫面。接著 React 會執行 Effect，如果 Effect 也同時立刻更新狀態，則會重啟整個流程! 為了避免不必要的渲染，直接在元件頂部轉換資料則可。每當 <code>props</code> 或 <code>state</code> 變更，那些程式都會自動重新執行。</li>
<li><strong>您不需要 Effect 來處理互動事件</strong>。例如您想要發送一個 POST 請求給 <code>/api/buy</code> ，然後當完成購買時顯示提示視窗。在購買按鈕的點擊事件，你可以確實知道是使用者點擊了。而 Effect 執行時，你不會知道使用者做了什麼，例如哪個按鈕被點擊。這也是為什麼通常直接在對應的事件處理函式處理對應的互動。</li>
</ul>
<p>您確實需要 Effect 來同步外部系統。例如您可以使用 Effect 來保持同步 jQuery 套件的資料到 React 狀態。您也可以使用 Effect 來 fetch 資料，例如同步一個查詢的搜尋結果。注意，主流的一些框架支援更有效率的做法來讀取資料，而不是單純使用 Effect。</p>
<p>為了協助您獲得正確的觀念和直覺想法，讓我們看一些常見的具體範例！</p>
<h3 id="基於-props-或-state-更新狀態"><a href="#基於-props-或-state-更新狀態" class="headerlink" title="基於 props 或 state 更新狀態"></a>基於 props 或 state 更新狀態</h3><p>假設您一個元件有兩個狀態: <code>firstName</code> 和 <code>lastName</code> 。您希望使用這兩個資料組合出 <code>fullName</code> 。同時您希望 <code>fullName</code> 會隨著 <code>firstName</code> 或 <code>lastName</code> 更新而更新。您第一個想法可能是增加一個 <code>fullName</code> 狀態然後使用 Effect 更新。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Form</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [firstName, setFirstName] = useState(<span class="string">&#x27;Taylor&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> [lastName, setLastName] = useState(<span class="string">&#x27;Swift&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 避免多餘的狀態和 Effect</span></span><br><span class="line">  <span class="keyword">const</span> [fullName, setFullName] = useState(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setFullName(firstName + <span class="string">&#x27; &#x27;</span> + lastName);</span><br><span class="line">  &#125;, [firstName, lastName]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這是複雜化需求。同時也沒效率; 導致先渲染了一次 <code>fullName</code> 舊資料的狀況，然後又立刻重新渲染。這種情況是不需要多一個狀態變數和 Effect</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Form</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [firstName, setFirstName] = useState(<span class="string">&#x27;Taylor&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> [lastName, setLastName] = useState(<span class="string">&#x27;Swift&#x27;</span>);</span><br><span class="line">  <span class="comment">// 正確作法: 渲染時會立刻計算新值</span></span><br><span class="line">  <span class="keyword">const</span> fullName = firstName + <span class="string">&#x27; &#x27;</span> + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>當某些需要的資料可以用 <code>props</code> 或 <code>state</code> 計算出來的時候，不要放到 <code>state</code>，直接計算即可。這能優化您的程式碼，避免額外關聯連續的更新，程式碼會更精簡，且減少錯誤的發生。您可以避免一些因為狀態同步造成的 Bug。如果這個方式您感覺很陌生可以參考 <a target="_blank" rel="noopener" href="https://beta.reactjs.org/learn/thinking-in-react#step-3-find-the-minimal-but-complete-representation-of-ui-state">Thinking in React</a></p>
<h3 id="快取耗效能的計算"><a href="#快取耗效能的計算" class="headerlink" title="快取耗效能的計算"></a>快取耗效能的計算</h3><p>元件使用從 <code>props</code> 取得的 <code>todos</code> 和 <code>filter</code> 計算 <code>visibleTodos</code>。您可能直覺想要把計算結果放到 <code>state</code> 然後利用 Effect 更新。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodoList</span>(<span class="params">&#123; todos, filter &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [newTodo, setNewTodo] = useState(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 避免多餘的狀態和 Effect</span></span><br><span class="line">  <span class="keyword">const</span> [visibleTodos, setVisibleTodos] = useState([]);</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setVisibleTodos(getFilteredTodos(todos, filter));</span><br><span class="line">  &#125;, [todos, filter]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如同稍早的範例，<code>state</code> 和 Effect 都是不必要的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodoList</span>(<span class="params">&#123; todos, filter &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [newTodo, setNewTodo] = useState(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="comment">// 正確作法, 如果 getFilteredTodos() 計算不複雜直接計算即可</span></span><br><span class="line">  <span class="keyword">const</span> visibleTodos = getFilteredTodos(todos, filter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在大部分的狀況，上面的程式碼是 ok 的。但 <code>getFilteredTodos()</code> 計算可能非常耗效能，或者 <code>todos</code> 資料很多。</p>
<p>在這種情況，您不希望因為其他不相關的狀態更新重新計算 <code>getFilteredTodos()</code> ，例如 <code>newTodo</code> 更新的時候。</p>
<p>此時，您可以使用 <code>useMemo</code> 快取耗效能的計算</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useMemo, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodoList</span>(<span class="params">&#123; todos, filter &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [newTodo, setNewTodo] = useState(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="comment">// 正確作法</span></span><br><span class="line">  <span class="keyword">const</span> visibleTodos = useMemo(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getFilteredTodos(todos, filter);</span><br><span class="line">  &#125;, [todos, filter]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者單行的形式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useMemo, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodoList</span>(<span class="params">&#123; todos, filter &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [newTodo, setNewTodo] = useState(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> visibleTodos = useMemo(</span><br><span class="line">    <span class="function">() =&gt;</span> getFilteredTodos(todos, fitler),</span><br><span class="line">    [todos, filter]</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這樣 React 就會知道 useMemo 裡面的函式只有在 <code>todos</code> 或 <code>filter</code> 變更的時候才重新計算。React 會記住 <code>getFilteredTodos()</code> 回傳的資料。後續的渲染如果 <code>todos</code> 和 <code>filter</code> 都一樣則是用上一次記住的資料，如果不同則會在執行一次計算。</p>
<p>包在 <code>useMemo</code> 的函式不要包含副作用的操作。</p>
<blockquote>
<p>如何判斷是否為耗效能的計算?</p>
<p>一般來說除非您的計算牽扯到上千個物件，否則都在合理範圍。您可以加入 <code>console</code> 測量花費的時間。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">&#x27;filter array&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> visibleTodos = getFilteredTodos(todos, filter);</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&#x27;filter array&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>執行測量您將會在開發者工具 Console 看到像是 <strong>filter array: 0.15ms</strong> 的訊息，如果紀錄的時間加總很大，例如 1ms 或更久。那麼快取就是合理的。您可以將計算的部分包在 <code>useMemo</code> 來驗證互動時的計算時間是否有減少。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">&#x27;filter array&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> visibleTodos = useMemo(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getFilteredTodos(todos, filter); <span class="comment">// Skipped if todos and filter haven&#x27;t changed</span></span><br><span class="line">&#125;, [todos, filter]);</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&#x27;filter array&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><code>useMemo</code> 並不會加速第一次渲染。它只能協助在後續更新時略過不必要的計算。</p>
<p>注意您的機器可能比使用者的快，因此建議模擬比較差的環境來測試效能。例如 Chrome 有提供 CPU Throttling 功能。</p>
<p>同時在開發環境測試效能並不能保證準確的結果。例如<strong>Strict Mode 開啟的情況下您會發現每個元件渲染了兩次。</strong></p>
<p>為了盡可能準確，您應該建置正式版然後測試。</p>
</blockquote>
<h3 id="當-props-變更時重新設定狀態"><a href="#當-props-變更時重新設定狀態" class="headerlink" title="當 props 變更時重新設定狀態"></a>當 props 變更時重新設定狀態</h3><p>下面 <code>ProfilePage</code> 元件可以從 props 取得 <code>userId</code>。頁面包含一個留言的輸入框，然後使用了一個 <code>comment</code> 狀態變數來儲存資料。某天您注意到一個問題: 當您從 A 個人資料頁到 B 時，<code>comment</code> 並沒有重置。其結果造成很容易發錯留言。要修正這個問題您希望當 <code>userId</code> 改變時可以清除 <code>comment</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">ProfilePage</span>(<span class="params">&#123; userId &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [comment, setComment] = useState(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 避免在 props 改變時在 Effect 重置狀態</span></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setComment(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  &#125;, [userId]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這種處理方式很沒效率，因為 <code>ProfilePage</code> 和子元素會先使用舊資料渲染，才又更新(多渲染一次)。要為每個在 <code>ProfilePage</code> 有用到狀態的元件都要對應處理會讓事情複雜化。例如；如果有個內嵌的留言介面您希望它的狀態也要因為切換 <code>userId</code> 清除。</p>
<p>事實上您可以利用 <code>key</code> 來讓 React 知道每個使用者資料元件概念上是不一樣的。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">ProfilePage</span>(<span class="params">&#123; userId &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Profile</span> <span class="attr">userId</span>=<span class="string">&#123;userId&#125;</span> <span class="attr">key</span>=<span class="string">&#123;userId&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Profile</span>(<span class="params">&#123; userId &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 元件內的狀態會自動重置</span></span><br><span class="line">  <span class="keyword">const</span> [comment, setComment] = useState(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般來說在渲染同一個位置的元件時，React 會保留狀態。利用傳入 <code>userId</code> 到 <code>key</code> 屬性，如果 <code>userId</code> 不同 React 會把 <code>Profile</code> 視為兩個不同的元件，並且不會共享狀態。</p>
<p>每當 <code>userId</code> 改變 React 會重新建立 DOM 和重置狀態。結果就是每當切換使用者資料則 <code>comment</code> 也會自動被清除。</p>
<p>注意到這個範例只匯出 <code>ProfilePage</code> 。渲染 <code>ProfilePage</code> 不需要使用 <code>key</code> 。<code>Profile</code> 使用 <code>key</code> 只是一個實作的細節。</p>
<h3 id="當-props-變更時調整狀態"><a href="#當-props-變更時調整狀態" class="headerlink" title="當 props 變更時調整狀態"></a>當 props 變更時調整狀態</h3><p>有時候您希望當 props 可以重置或調整局部狀態，但不是全部。</p>
<p><code>List</code> 元件會通過 props 收到 <code>items</code> 列表，然後被選取的項目會存放到 <code>selection</code> 狀態變數。當 props 收到不一樣的陣列時，您希望設定 <code>selection</code> 為 <code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">List</span>(<span class="params">&#123; items &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isReverse, setIsReverse] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> [selection, setSelection] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 避免當 props 變更時使用 Effect 調整狀態</span></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setSelection(<span class="literal">null</span>);</span><br><span class="line">  &#125;, [items]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這也一樣不理想。每次 <code>items</code> 改變，<code>List</code> 和子元素, 元件會用舊的 <code>selection</code> 渲染一次。然後執行 Effect 才更新。最後 <code>setSelection(null)</code> 會造成另一次重新渲染，然後 <code>List</code> 和其他內部元件再次一個循環。</p>
<p>移除 Effect，直接調整狀態即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">List</span>(<span class="params">&#123; items &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isReverse, setIsReverse] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> [selection, setSelection] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比較好的做法是直接調整狀態</span></span><br><span class="line">  <span class="keyword">const</span> [prevItems, setPrevItems] = useState(items);</span><br><span class="line">  <span class="keyword">if</span> (items !== prevItems) &#123;</span><br><span class="line">    setPrevItems(items);</span><br><span class="line">    setSelection(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>紀錄上一次渲染的資料確實有點難以理解，但這比在 Effect 更新狀態的處理方式好。上面範例 <code>setSelection</code> 在該次渲染期間直接被執行。React 會在執行到 <code>return</code> 時立刻重新渲染 <code>List</code> ，此時 React 還沒有渲染 <code>List</code> 的子元件和更新 DOM。因此 <code>List</code> 的子元件跳過了渲染 <code>selection</code> 舊資料的部分。</p>
<p>當您在渲染時期直接更新元件，React 會拋棄回傳的 JSX 並立刻重新嘗試渲染。為了避免緩慢的聯級重試，在渲染期間 React 只讓您更新同一個元件的 <code>state</code>。如果您在此元件渲染時期直接更新另外一個元件的狀態，將會看到錯誤訊息。而判斷條件像 <code>items !== prevItems</code> 是必要的，為了避免無限迴圈。您可以向上面那樣調整狀態，但任何副作用例如變更 DOM 或使用 timeout 應該維持放在事件處理函式或 Effect 以保證元件的可預測性。</p>
<p>雖然這樣的模式比起 Effect 比較有效率，但大多數的元件應該不需要這麼處理。不管您是如何處理，基於 props 或其他 state 調整狀態會讓您的資料流變的不容易理解。時時檢查看是否您可以利用 key 重置狀態或直接在渲染流程計算。例如取代儲存選取的項目，您可以直接儲存 ID</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">List</span>(<span class="params">&#123; items &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isReverse, setIsReverse] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> [selectedId, setSelectedId] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直接在渲染流程計算</span></span><br><span class="line">  <span class="keyword">const</span> selection = items.find(<span class="function">(<span class="params">item</span>) =&gt;</span> item.id === selectedId) ?? <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>現在我們根本不需要調整狀態。如果清單項目的 ID 被選取，<code>selection</code> 會在渲染時期計算，如果沒有選取因為沒有找到匹配的項目則為 <code>null</code> 。這個行為跟之前稍微有點不同，但可以說好很多，因為即便 <code>items</code> 變更我們還是可以維持正確的 <code>selection</code>。但你需要在使用 <code>selection</code> 的地方多一些邏輯處理，因為 <code>selectedId</code> 可能找不到項目。</p>
<h3 id="在事件處理函式間共享邏輯"><a href="#在事件處理函式間共享邏輯" class="headerlink" title="在事件處理函式間共享邏輯"></a>在事件處理函式間共享邏輯</h3><p>假如您有一個產品頁面有兩個按鈕 (購買和結帳) 他們都是購買產品的功能。您希望當使用者加入產品到購物車時顯示提示 <a target="_blank" rel="noopener" href="https://uxdesign.cc/toasts-or-snack-bars-design-organic-system-notifications-1236f2883023">toast</a>。</p>
<p>在兩個按鈕的 click 事件加入 <code>showToast()</code> 有點重複的感覺，因此您可能想在一個 Effect 處理:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProductPage</span>(<span class="params">&#123; product, addToCart &#125;</span>) </span>&#123;</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 避免在 Effect 處理特定事件邏輯</span></span><br><span class="line">    <span class="keyword">if</span> (product.isInCart) &#123;</span><br><span class="line">      showToast(<span class="string">`Added <span class="subst">$&#123;product.name&#125;</span> to the shopping cart!`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [product]);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleBuyClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    addToCart(product);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleCheckoutClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    addToCart(product);</span><br><span class="line">    navigateTo(<span class="string">&#x27;/checkout&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這邊 Effect 是不必要的。同時也很容易造成 Bug。例如您的應用程式在頁面切換重載時會記住購物車內容。如果您加入一個產品到購物車然後刷新頁面，提示會再次出現。每次您刷新頁面就會出現。因為 <code>product.isInCart</code> 是 <code>true</code> 然後 Effect 會執行 <code>showToast()</code>。</p>
<p>當您不確定程式碼應該要放在 Effect 或事件處理函式中時，問自己這段程式碼執行是為了什麼理由。只有在程式碼是因為元件顯示所以必須對應執行的時候才是用 Effect。上面這個例子，提示視窗是因為使用者點擊按鈕，不是因為頁面載入顯示。刪除 Effect 並將共享的邏輯放到兩個事件處理函式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProductPage</span>(<span class="params">&#123; product, addToCart &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 特定事件使用的邏輯應從對應事件處理函式呼叫</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">buyProduct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    addToCart(product);</span><br><span class="line">    showToast(<span class="string">`Added <span class="subst">$&#123;product.name&#125;</span> to the shopping cart!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleBuyClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    buyProduct();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleCheckoutClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    buyProduct();</span><br><span class="line">    navigateTo(<span class="string">&#x27;/checkout&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>移除不必要的 Effect 修復 Bug。</p>
<h3 id="發送-POST-請求"><a href="#發送-POST-請求" class="headerlink" title="發送 POST 請求"></a>發送 POST 請求</h3><p>下面 <code>Form</code> 元件會發送兩種類型的 POST 請求。當掛載的時候會發送統計分析的事件。當填完表單並點擊送出的時候，會發送 POST 到 <code>api/register</code> :</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Form</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [firstName, setFirstName] = useState(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> [lastName, setLastName] = useState(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 正確，每次元件顯示的時候需要執行</span></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    post(<span class="string">&#x27;/analytics/event&#x27;</span>, &#123; <span class="attr">eventName</span>: <span class="string">&#x27;visit_form&#x27;</span> &#125;);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 避免特定事件邏輯在 Effect 處理</span></span><br><span class="line">  <span class="keyword">const</span> [jsonToSubmit, setJsonToSubmit] = useState(<span class="literal">null</span>);</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (jsonToSubmit !== <span class="literal">null</span>) &#123;</span><br><span class="line">      post(<span class="string">&#x27;/api/register&#x27;</span>, jsonToSubmit);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [jsonToSubmit]);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleSubmit</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    setJsonToSubmit(&#123; firstName, lastName &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>讓我們套用之前的標準到這個範例。</p>
<p>分析統計的 POST 請求應該維持在 Effect 處理。因為送出請求的理由是因為表單載入顯示就要記錄。但這在開發時期會觸發兩次，可以參考<a target="_blank" rel="noopener" href="https://beta.reactjs.org/learn/synchronizing-with-effects#sending-analytics">這裡</a>解決這個問題。</p>
<p>然而， <code>/api/register</code> 請求並不是每次元件顯示就要送出。我們只希望在特定時間發送; 當時用者點擊按鈕時。它應該只發生在特定互動情況。請刪除第二個 Effect 並將邏輯移到事件處理函式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Form</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [firstName, setFirstName] = useState(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> [lastName, setLastName] = useState(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 正確，每次元件顯示的時候需要執行</span></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    post(<span class="string">&#x27;/analytics/event&#x27;</span>, &#123; <span class="attr">eventName</span>: <span class="string">&#x27;visit_form&#x27;</span> &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleSubmit</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    <span class="comment">// 特定事件的邏輯應移至事件處理函式</span></span><br><span class="line">    post(<span class="string">&#x27;/api/register&#x27;</span>, &#123; firstName, lastName &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>當您在抉擇否將邏輯放到事件中或 Effect，您該問的是; 從使用者的角度來看邏輯是什麼。如果是特定操作那就放在事件處理函式。如果是每當使用者看到元件出現在畫面都需要執行則放到 Effect。</p>
<h3 id="初始化應用程式"><a href="#初始化應用程式" class="headerlink" title="初始化應用程式"></a>初始化應用程式</h3><p>某些邏輯只需要在程式載入的時候執行一次。您可能將它們放到 Effect</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 避免將只執行一次的邏輯單純放到 Effect</span></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    loadDataFromLocalStorage();</span><br><span class="line">    checkAuthToken();</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，您很快會發現在開發時期會執行 2 次。這會造成一些問題 - 舉例來說，這可能造成驗證 Token 無效，因為該函式並沒有設計成可以被執行兩次。一般來說，您的元件應該要保持能被重新掛載的彈性。包含頂層的 <code>App</code> 元件。雖然在實務上可能不會被重新掛載，但所有元件遵循相同的規則可以比較容易的組織和重複使用。如果部分邏輯必須在應用程式載入額時候執行一次，而不是每次掛載都執行，您可以在最上層加入變數追蹤其是否被執行:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> didInit = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!didInit) &#123;</span><br><span class="line">      didInit = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 正確實作每當應用程式載入時只執行一次的邏輯</span></span><br><span class="line">      loadDataFromLocalStorage();</span><br><span class="line">      checkAuthToken();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您也可以在模組初始化階段和應用程式渲染之前執行:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">  checkAuthToken();</span><br><span class="line">  loadDataFromLocalStorage();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>頂層的程式碼在元件載入的時候會執行一次，就算該元件沒有被渲染也會執行。為了避免匯入元件導致效能變差或非預期的行為，請不要過度使用此模式。將應用程式層級的初始化邏輯應放在 <code>App.js</code> 或是進入點的模組。</p>
<h3 id="通知上層元件狀態變更"><a href="#通知上層元件狀態變更" class="headerlink" title="通知上層元件狀態變更"></a>通知上層元件狀態變更</h3><p>假如您寫了一個 <code>Toggle</code> 元件內部包含一個 <code>isOn</code> 狀態，它是一個布林值。有不同的方式可以觸發，點擊或拖拉。您可能希望當這個 <code>Toggle</code> 內部狀態改變的時候通知上層元件，因此您增加了 <code>onChange</code> 事件並在 Effect 呼叫</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Toggle</span>(<span class="params">&#123; onChange &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isOn, setIsOn] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 避免, onChange 太晚執行</span></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    onChange(isOn);</span><br><span class="line">  &#125;, [isOn, onChange]);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setIsOn(!isOn);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleDragEnd</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isCloserToRightEdge(e)) &#123;</span><br><span class="line">      setIsOn(<span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      setIsOn(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如之前提到的，這不是理想的處理方式。<code>Toggle</code> 會先更新自己的狀態，然後 React 更新畫面。然後 React 執行 Effect，執行 <code>onChange</code> 把狀態值交給上層元件。現在上層元件會更新自己的狀態，開始另一回合的渲染。任何時候一次完成所有事情會比較好。</p>
<p>刪除 Effect 並在事件裡同時更新兩者的狀態:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Toggle</span>(<span class="params">&#123; onChange &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isOn, setIsOn] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">updateToggle</span>(<span class="params">nextIsOn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在事件直徑更新狀態</span></span><br><span class="line">    setIsOn(nextIsOn);</span><br><span class="line">    onChange(nextIsOn);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    updateToggle(!isOn);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleDragEnd</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isCloserToRightEdge(e)) &#123;</span><br><span class="line">      updateToggle(<span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      updateToggle(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用這個方式，<code>Toggle</code> 元件和上層元件會在同一個事件更新狀態。React 基於 <a target="_blank" rel="noopener" href="https://beta.reactjs.org/learn/queueing-a-series-of-state-updates">batches updates</a> 的機制一起更新，因此只會渲染一回。</p>
<p>您也許還可以刪除狀態，單純從上層元件接收 <code>isOn</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Toggle</span>(<span class="params">&#123; isOn, onChange &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    onChange(!isOn);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleDragEnd</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isCloserToRightEdge(e)) &#123;</span><br><span class="line">      onChange(<span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      onChange(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://beta.reactjs.org/learn/sharing-state-between-components">將狀態往上搬</a> 讓上層元件可以利用自己的狀態完整控制 <code>Toggle</code>。這意味著上層元件必須包含更多邏輯，但整體來說可以有較少的狀態。每當您需要去維持兩個不同的狀態變數同步時，這就是您應該嘗試將狀態往上搬的訊號。</p>
<h3 id="將資料傳入上層"><a href="#將資料傳入上層" class="headerlink" title="將資料傳入上層"></a>將資料傳入上層</h3><p>下面範例 <code>Child</code> 元件會讀取一些資料然後傳給 <code>Parent</code> 元件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">onFetched</span>=<span class="string">&#123;setData&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">&#123; onFetched &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = useSomeAPI();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 避免在 Effect 把資料傳入 parent</span></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">      onFetched(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [onFetched, data]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 React，資料流是從上層元件流向子元件。當你發現錯誤的時候，您可以沿著元件向上追蹤資料來源，直到找到某個元件傳錯 props 或錯誤的狀態。當子元件在 Effect 更新上層元件的狀態。資料流會變更非常難以追蹤。如果子元件和上層元件都需要相同的資料，建議讓上層元件來讀取資料。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = useSomeAPI();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 較佳: 由上而下傳遞資料</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">data</span>=<span class="string">&#123;data&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>如此一來並刻意保持資料流的可預測性; 資料是由上而下傳遞。</p>
<h3 id="訂閱外部儲存"><a href="#訂閱外部儲存" class="headerlink" title="訂閱外部儲存"></a>訂閱外部儲存</h3><p>有時候，您的元件會需要訂閱一些外部資料。這些資料可能來自第三方函式庫或瀏覽器內建 API。由於這些資料可能在 React 不知情的情況下變更，您會需要手動訂閱。這種情況很常使用 Effect 處理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useOnlineStatus</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不夠理想: 在 Effect 手動儲存訂閱</span></span><br><span class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = useState(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">updateState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      setIsOnline(navigator.onLine);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    updateState();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;online&#x27;</span>, updateState);</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;offline&#x27;</span>, updateState);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.removeEventListener(<span class="string">&#x27;online&#x27;</span>, updateState);</span><br><span class="line">      <span class="built_in">window</span>.removeEventListener(<span class="string">&#x27;offline&#x27;</span>, updateState);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isOnline;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ChatIndicator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isOnline = useOnlineStatus();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這裡元件訂閱一個外部資料，這個範例是瀏覽器的 API <code>navigator.onLine</code>。初始狀態為 <code>true</code>。每當瀏覽器的資料改變，元件會更新狀態。</p>
<p>雖然使用 Effect 處理這種狀況非常常見，但 React 有專門的 Hook ，在遇到訂閱外部資料的狀況時應優先選擇。刪除 Effect 使用 <code>useSyncExternalStore</code> 取代。</p>
<blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/6bce0355c3e4bf23c16e82317094230908ee7560/packages/use-sync-external-store/src/useSyncExternalStoreShimClient.js">useSyncExternalStore 原始碼</a></li>
<li><a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-reference.html#usesyncexternalstore">官方文件</a></li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;online&#x27;</span>, callback);</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;offline&#x27;</span>, callback);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">&#x27;online&#x27;</span>, callback);</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">&#x27;offline&#x27;</span>, callback);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useOnlineStatus</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 較佳; 使用內建 Hook 處理訂閱外部資料</span></span><br><span class="line">  <span class="keyword">return</span> useSyncExternalStore(</span><br><span class="line">    subscribe,</span><br><span class="line">    <span class="function">() =&gt;</span> navigator.onLine,</span><br><span class="line">    <span class="function">() =&gt;</span> <span class="literal">true</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ChatIndicator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isOnline = useOnlineStatus();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比起使用 Effect 手動同步資料到 React 狀態，這種方式比較不會發生錯誤。一般來說您會寫一個自訂的 Hook 像上面的 <code>useOnlineStatus()</code> ，如此在個別的元件就可以重複使用。更多關於訂閱外部儲存的資訊可以參考官方文件。</p>
<h3 id="讀取資料"><a href="#讀取資料" class="headerlink" title="讀取資料"></a>讀取資料</h3><p>很多應用程式會使用 Effect 實作 fetch 資料。使用這種方式讀取資料十分常見:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SearchResults</span>(<span class="params">&#123; query &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [results, setResults] = useState([]);</span><br><span class="line">  <span class="keyword">const</span> [page, setPage] = useState(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 避免讀取資料而沒有清除的邏輯</span></span><br><span class="line">    fetchResults(query, page).then(<span class="function">(<span class="params">json</span>) =&gt;</span> &#123;</span><br><span class="line">      setResults(json);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, [query, page]);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleNextPageClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setPage(page + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這邊不需要把 fetch 搬到事件處理函式。</p>
<p>不過這裡似乎和之前的範例有些矛盾，不是說需要基於用戶角度的理由，那這裡應該要放到事件處理函式。考慮到不只是單純打字輸入或換頁才讀取。搜尋條件通常可能預先由 URL 取得，使用者可能回上一頁或下頁操作而沒有打字或切換頁面。不管 <code>page</code> 和 <code>query</code> 從哪來。當這個元件顯示的時候，您會希望 <code>results</code> 會根據當前的 <code>page</code> 和 <code>query</code> 保持同步網路取得的資料。這就是為什麼這裡使用 Effect。</p>
<p>不過上面的程式碼有 Bug。想像您快速輸入 “hello” 然後 <code>query</code> 的變化會是 “h” 到 “he”，”hel”，”hell”，”hello”。每次變更都會觸發讀取，但回應並不會保證照順序返回。例如 “hell” 回應比 “hello” 返回的還慢。因為會執行 <code>setResults()</code> 如此將會顯示錯誤的搜尋資料。這就是所謂的 “race condition”: 兩個不同的請求相互競爭並且產生跟預期不一樣的順序。</p>
<p>要修正 race condition 的問題，您需要加入清除的功能用來忽略過期的回應</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SearchResults</span>(<span class="params">&#123; query &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [results, setResults] = useState([]);</span><br><span class="line">  <span class="keyword">const</span> [page, setPage] = useState(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> ignore = <span class="literal">false</span>;</span><br><span class="line">    fetchResults(query, page).then(<span class="function">(<span class="params">json</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!ignore) &#123;</span><br><span class="line">        setResults(json);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      ignore = <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [query, page]);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleNextPageClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setPage(page + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這確保當 Effect 讀取資料時，除了最後的請求，其他的會被忽略。</p>
<p>處理 race condition 並不是讀取資料會遭遇的唯一問題。你也需要思考如何快取回應(如此使用回上一頁會立刻看到之前的畫面，而不是重新讀取)，如何從伺服器讀取(初始化的 server-side 渲染的 HTML 包含讀取的資料)，如何避免連續階層請求(子元件讀取資料不需要等上層讀取完畢)。這些問題任何 UI 函式庫都會遇到，不是只有 React。處理這些問題非常繁瑣，這也是為什麼最新的主流框架提供更有效率內建的讀取機制，而不是直接使用 Effect。</p>
<p>如果您沒有使用框架，可以考慮下面的範例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SearchResults</span>(<span class="params">&#123; query &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [page, setPage] = useState(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> params = <span class="keyword">new</span> URLSearchParams(&#123; query, page &#125;);</span><br><span class="line">  <span class="keyword">const</span> results = useData(<span class="string">`/api/search?<span class="subst">$&#123;params&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleNextPageClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setPage(page + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useData</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [result, setResult] = useState(<span class="literal">null</span>);</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> ignore = <span class="literal">false</span>;</span><br><span class="line">    fetch(url)</span><br><span class="line">      .then(<span class="function">(<span class="params">response</span>) =&gt;</span> response.json())</span><br><span class="line">      .then(<span class="function">(<span class="params">json</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ignore) &#123;</span><br><span class="line">          setResult(json);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      ignore = <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [url]);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可能還想加入一些錯誤處理以及追蹤資料是否正確載入的邏輯。可以自訂 Hook 或者使用社群中許多的解決方案。雖然跟框架內建功能相比可能效能差一點，但將讀取邏輯獨立到一個自訂 Hook 後續採用其他策略或增加其他處理機制會比較方便。</p>
<p>一般來說，每當您必須使用 Effect ，留意是否可以將片段功能擷取到一個更具語意自訂的 Hook ，或專門針對某個 API 就像上面 <code>useData</code> 一樣。在元件中越少 <code>useEffect</code> 會更好維護。</p>
<h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><ul>
<li>如果您能在渲染時期計算出值，就不要使用 Effect</li>
<li>快取耗費效能的計算可以使用 <code>useMemo</code> 而不是 <code>useEffect</code></li>
<li>重置元件狀態可以使用 <code>key</code></li>
<li>要根據 props 的變更調整狀態，請在渲染期間設定</li>
<li>如果程式碼是因為元件顯示就要執行的理由就放在 Effect，其他應該放在對應事件</li>
<li>如果您需要更新一些元件的狀態，最好在單一事件處理</li>
<li>每當你嘗試同步狀態時，請考慮將狀態往上層搬</li>
<li>你可以在 Effect 讀取資料，但記得清除的部分，避免 Race condition</li>
</ul>
<h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://beta.reactjs.org/learn/you-might-not-need-an-effect#how-to-remove-unnecessary-effects">You Might Not Need an Effect</a></li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>[譯] React: 您可能不需要一個 Effect</p><p><a href="https://andyyou.github.io/2022/08/10/you-might-not-need-an-effect/">https://andyyou.github.io/2022/08/10/you-might-not-need-an-effect/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>andyyou(YOU,ZONGYAN)</p></div></div><div class="level-item is-narrow"><div><h6>發表於</h6><p>2022-08-10</p></div></div><div class="level-item is-narrow"><div><h6>更新於</h6><p>2023-05-12</p></div></div><div class="level-item is-narrow"><div><h6>許可協議</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/javascript/">javascript</a><a class="link-muted mr-2" rel="tag" href="/tags/react/">react</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜歡這篇文章嗎? 贊助一下作者吧!</h3><div class="buttons is-centered"><a class="button donate" href="https://www.buymeacoffee.com/andyyou" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/08/17/avoiding-use-effect-with-callback-refs/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">使用 Callback Refs 取代 useEffect 避免問題產生</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/07/15/how-to-override-login-redirects-in-jetstream-or-fortify/"><span class="level-item">Laravel 如何在 Jetstream 或 Fortify 覆寫登入後導向</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://avatars2.githubusercontent.com/u/665690?v=3&amp;s=466" alt="andyou"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">andyou</p><p class="is-size-6 is-block">DEVLOG of andyyou</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Taipei</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">231</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分類</p><a href="/categories"><p class="title">11</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">標籤</p><a href="/tags"><p class="title">94</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/andyyou" target="_blank" rel="noopener">追蹤</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/andyyou"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="/"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="/"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="/"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分類</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/AI/"><span class="level-start"><span class="level-item">AI</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Cloud/"><span class="level-start"><span class="level-item">Cloud</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/categories/Database/"><span class="level-start"><span class="level-item">Database</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/DevOps/"><span class="level-start"><span class="level-item">DevOps</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Fun/"><span class="level-start"><span class="level-item">Fun</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Management/"><span class="level-start"><span class="level-item">Management</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Mobile/"><span class="level-start"><span class="level-item">Mobile</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Program/"><span class="level-start"><span class="level-item">Program</span></span><span class="level-end"><span class="level-item tag">161</span></span></a></li><li><a class="level is-mobile" href="/categories/System/"><span class="level-start"><span class="level-item">System</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/categories/Tools/"><span class="level-start"><span class="level-item">Tools</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/categories/UX/"><span class="level-start"><span class="level-item">UX</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-10-16T02:07:15.000Z">2025-10-16</time></p><p class="title"><a href="/2025/10/16/laravel-sanctum/">Laravel Sanctum 筆記</a></p><p class="categories"><a href="/categories/Program/">Program</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-08-29T22:32:32.000Z">2025-08-30</time></p><p class="title"><a href="/2025/08/30/gh-ost/">gh-ost 無鎖編輯資料結構</a></p><p class="categories"><a href="/categories/Database/">Database</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-02-16T05:47:22.000Z">2025-02-16</time></p><p class="title"><a href="/2025/02/16/2025-devops-gitops/">2025 DevOps 工具整理</a></p><p class="categories"><a href="/categories/DevOps/">DevOps</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-10-28T09:04:56.000Z">2024-10-28</time></p><p class="title"><a href="/2024/10/28/implement-live-activity-for-rn/">React Native 實作 iOS Live Activity</a></p><p class="categories"><a href="/categories/Program/">Program</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-07-08T08:07:15.000Z">2024-07-08</time></p><p class="title"><a href="/2024/07/08/laravel-interface/">[譯]Laravel 介面最佳實作</a></p><p class="categories"><a href="/categories/Program/">Program</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">彙整</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/10/"><span class="level-start"><span class="level-item">十月 2025</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/08/"><span class="level-start"><span class="level-item">八月 2025</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/02/"><span class="level-start"><span class="level-item">二月 2025</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/10/"><span class="level-start"><span class="level-item">十月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/07/"><span class="level-start"><span class="level-item">七月 2024</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/02/"><span class="level-start"><span class="level-item">二月 2024</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/01/"><span class="level-start"><span class="level-item">一月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/12/"><span class="level-start"><span class="level-item">十二月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/11/"><span class="level-start"><span class="level-item">十一月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/10/"><span class="level-start"><span class="level-item">十月 2023</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/09/"><span class="level-start"><span class="level-item">九月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/06/"><span class="level-start"><span class="level-item">六月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/04/"><span class="level-start"><span class="level-item">四月 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/01/"><span class="level-start"><span class="level-item">一月 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/08/"><span class="level-start"><span class="level-item">八月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/07/"><span class="level-start"><span class="level-item">七月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/06/"><span class="level-start"><span class="level-item">六月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">五月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">四月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">二月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">一月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">十二月 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">十一月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/10/"><span class="level-start"><span class="level-item">十月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">九月 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/10/"><span class="level-start"><span class="level-item">十月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/08/"><span class="level-start"><span class="level-item">八月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/07/"><span class="level-start"><span class="level-item">七月 2019</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/06/"><span class="level-start"><span class="level-item">六月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/05/"><span class="level-start"><span class="level-item">五月 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/04/"><span class="level-start"><span class="level-item">四月 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/11/"><span class="level-start"><span class="level-item">十一月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/06/"><span class="level-start"><span class="level-item">六月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/05/"><span class="level-start"><span class="level-item">五月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/03/"><span class="level-start"><span class="level-item">三月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/12/"><span class="level-start"><span class="level-item">十二月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/11/"><span class="level-start"><span class="level-item">十一月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/10/"><span class="level-start"><span class="level-item">十月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/09/"><span class="level-start"><span class="level-item">九月 2017</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/08/"><span class="level-start"><span class="level-item">八月 2017</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/07/"><span class="level-start"><span class="level-item">七月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/06/"><span class="level-start"><span class="level-item">六月 2017</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/05/"><span class="level-start"><span class="level-item">五月 2017</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/04/"><span class="level-start"><span class="level-item">四月 2017</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/03/"><span class="level-start"><span class="level-item">三月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/02/"><span class="level-start"><span class="level-item">二月 2017</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/01/"><span class="level-start"><span class="level-item">一月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/12/"><span class="level-start"><span class="level-item">十二月 2016</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/11/"><span class="level-start"><span class="level-item">十一月 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/10/"><span class="level-start"><span class="level-item">十月 2016</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/09/"><span class="level-start"><span class="level-item">九月 2016</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/08/"><span class="level-start"><span class="level-item">八月 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/06/"><span class="level-start"><span class="level-item">六月 2016</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/05/"><span class="level-start"><span class="level-item">五月 2016</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/04/"><span class="level-start"><span class="level-item">四月 2016</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/03/"><span class="level-start"><span class="level-item">三月 2016</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/02/"><span class="level-start"><span class="level-item">二月 2016</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/01/"><span class="level-start"><span class="level-item">一月 2016</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/12/"><span class="level-start"><span class="level-item">十二月 2015</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/11/"><span class="level-start"><span class="level-item">十一月 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/10/"><span class="level-start"><span class="level-item">十月 2015</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/09/"><span class="level-start"><span class="level-item">九月 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/08/"><span class="level-start"><span class="level-item">八月 2015</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/07/"><span class="level-start"><span class="level-item">七月 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/05/"><span class="level-start"><span class="level-item">五月 2015</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/04/"><span class="level-start"><span class="level-item">四月 2015</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/archives/2014/12/"><span class="level-start"><span class="level-item">十二月 2014</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2014/11/"><span class="level-start"><span class="level-item">十一月 2014</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2014/10/"><span class="level-start"><span class="level-item">十月 2014</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2014/09/"><span class="level-start"><span class="level-item">九月 2014</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/archives/2014/08/"><span class="level-start"><span class="level-item">八月 2014</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2014/02/"><span class="level-start"><span class="level-item">二月 2014</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/archives/2014/01/"><span class="level-start"><span class="level-item">一月 2014</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2013/11/"><span class="level-start"><span class="level-item">十一月 2013</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2013/10/"><span class="level-start"><span class="level-item">十月 2013</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2013/09/"><span class="level-start"><span class="level-item">九月 2013</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2013/08/"><span class="level-start"><span class="level-item">八月 2013</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2013/03/"><span class="level-start"><span class="level-item">三月 2013</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2012/03/"><span class="level-start"><span class="level-item">三月 2012</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2012/01/"><span class="level-start"><span class="level-item">一月 2012</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2011/11/"><span class="level-start"><span class="level-item">十一月 2011</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">標籤</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/net-mvc/"><span class="tag">.net mvc</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RoR/"><span class="tag">RoR</span><span class="tag">15</span></a></div><div class="control"><a class="tags has-addons" href="/tags/api/"><span class="tag">api</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/aws/"><span class="tag">aws</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/azure/"><span class="tag">azure</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bot/"><span class="tag">bot</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bundler/"><span class="tag">bundler</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cache/"><span class="tag">cache</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/carrier-wave/"><span class="tag">carrier wave</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/centos/"><span class="tag">centos</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/chrome/"><span class="tag">chrome</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cloudflare/"><span class="tag">cloudflare</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/compass/"><span class="tag">compass</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/css/"><span class="tag">css</span><span class="tag">19</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cve/"><span class="tag">cve</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/devise/"><span class="tag">devise</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/devops/"><span class="tag">devops</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dnd/"><span class="tag">dnd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/e-invoice/"><span class="tag">e-invoice</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/entity-framework/"><span class="tag">entity framework</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/envoy/"><span class="tag">envoy</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/es6/"><span class="tag">es6</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/facebook/"><span class="tag">facebook</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/flux/"><span class="tag">flux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/framework/"><span class="tag">framework</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/gcp/"><span class="tag">gcp</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/gitlab/"><span class="tag">gitlab</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/gitops/"><span class="tag">gitops</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/go/"><span class="tag">go</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/grunt/"><span class="tag">grunt</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/gulp/"><span class="tag">gulp</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/heroku/"><span class="tag">heroku</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/html/"><span class="tag">html</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/iisexpress/"><span class="tag">iisexpress</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ios/"><span class="tag">ios</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/javascript/"><span class="tag">javascript</span><span class="tag">88</span></a></div><div class="control"><a class="tags has-addons" href="/tags/javascript-express-passport/"><span class="tag">javascript express passport</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/javascript-nodejs/"><span class="tag">javascript nodejs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/jekyll/"><span class="tag">jekyll</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/jetstream/"><span class="tag">jetstream</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/jspm/"><span class="tag">jspm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/jwt/"><span class="tag">jwt</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/k8s/"><span class="tag">k8s</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/laravel/"><span class="tag">laravel</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/letsencrypt/"><span class="tag">letsencrypt</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux/"><span class="tag">linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mechanism/"><span class="tag">mechanism</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mongodb/"><span class="tag">mongodb</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mysql/"><span class="tag">mysql</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nextjs/"><span class="tag">nextjs</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nginx/"><span class="tag">nginx</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/node/"><span class="tag">node</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nodejs/"><span class="tag">nodejs</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/oocss/"><span class="tag">oocss</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/osx/"><span class="tag">osx</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/package-manager/"><span class="tag">package manager</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/php/"><span class="tag">php</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/postgres/"><span class="tag">postgres</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/postgresql/"><span class="tag">postgresql</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/queue/"><span class="tag">queue</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rabbitmq/"><span class="tag">rabbitmq</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rack-server/"><span class="tag">rack server</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rails/"><span class="tag">rails</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rails-webpack-stimulus-javascript-bootstrap/"><span class="tag">rails webpack stimulus javascript bootstrap</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/raspberry-pi/"><span class="tag">raspberry-pi</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/react/"><span class="tag">react</span><span class="tag">22</span></a></div><div class="control"><a class="tags has-addons" href="/tags/react-native/"><span class="tag">react native</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/react-native/"><span class="tag">react-native</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/reactjs/"><span class="tag">reactjs</span><span class="tag">32</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redux/"><span class="tag">redux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ruby/"><span class="tag">ruby</span><span class="tag">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sass/"><span class="tag">sass</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/selenium/"><span class="tag">selenium</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/serial-port/"><span class="tag">serial-port</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/slim/"><span class="tag">slim</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ssh/"><span class="tag">ssh</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ssl/"><span class="tag">ssl</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/stimulus/"><span class="tag">stimulus</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/svg-javascript/"><span class="tag">svg javascript</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/task-runner/"><span class="tag">task runner</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tmux/"><span class="tag">tmux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tools/"><span class="tag">tools</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ubuntu/"><span class="tag">ubuntu</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ux/"><span class="tag">ux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vm/"><span class="tag">vm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue/"><span class="tag">vue</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vuejs/"><span class="tag">vuejs</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/webpack/"><span class="tag">webpack</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/windows/"><span class="tag">windows</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/wsl/"><span class="tag">wsl</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/xml/"><span class="tag">xml</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/zoom/"><span class="tag">zoom</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label">廣告</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-3038600205998182" data-ad-slot="6442659171" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="DEVLOG of andyyou" height="28"></a><p class="is-size-7"><span>&copy; 2025 andyyou(YOU,ZONGYAN)</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/andyyou/"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-TW");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到頁首" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="請輸入關鍵字..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"請輸入關鍵字...","untitled":"(無標題)","posts":"文章","pages":"頁面","categories":"分類","tags":"標籤"});
        });</script></body></html>