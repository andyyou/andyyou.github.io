---
layout: post
title: 'Concurrently Javascript'
date: 2015-11-30 05:30:00
categories: Javascript
---

# 前言

Javascript 易學難精!? 每個踏入 JS 領域的開發者隨著時間推移，心中增加的不是信心自己對於這門語言的掌握度，反而會越來越質疑自己是否真的懂 JS。
由於這門語言快速的進化，加上時至今日豐富的語法，底層詭異的行為讓人難以捉模。

而今天要探討的一系列問題又幾乎是寫 JS 肯定會碰到的。下面就讓我們進入主題。

什麼是併發？它和平行有什麼不同？Javascript 在其事件輪詢(Event loop)所採用的是單一執行緒，所以它又是如何實現非同步的機制？
上面這些都是好問題，不過不幸的是我覺得大部分的 JS 開發者包含我在內對這些問題並沒有足夠的了解。
這個概念對於要撰寫並發狀況的程式碼非常重要，不過我們往往傾向於只專注在函式庫或框架的 API 提供給我們的功能，只看文件該怎麼用。

這些 API 往往影響我們對於底層功能的認知與概念，而且也常常遇到 API 本身並沒有採用最有效率或最正確的做法，進而導致我們也無法精確的掌握這些觀念。
這一系列的觀念由於包含著太多環環相扣的術語所以理解起來並不容易。所以需要循序漸進一個一個介紹相關術語的概念並且盡量不使用太過艱深的用詞。

> 這是一篇彙整了從 StackOverflow 和網路上找到不錯的文章所組成的一篇筆記。

# 同步與非同步的概念

進入到 JS 的世界你很難不遇到這個詞 `非同步`。

想像一個情景，晚餐時刻你想要吃個披薩，接著從冰箱拿出了披薩的材料。所以你必須要先暫停玩 LOL ，去廚房先揉麵團，加上一些起司，培根，番茄醬。
你已經花了 20 分鐘做了披薩，但最後你還需要再花 10 分鐘放進烤箱去烤。烤完之後你取出了披薩然後回到電腦前繼續玩遊戲。

另外一個情景，一樣你想要吃披薩當晚餐，然後也一樣你正在玩 LOL。不過不同的是現在你用另外一個螢幕打開了瀏覽器找到必勝客的網站選擇你要的口味。
接著你繼續回去玩遊戲，過了 20 分鐘後門鈴響了，你拿到披薩繼續回到電腦前玩遊戲。

同步跟非同步的概念就如上面兩個情景，第一個情景就是同步的概念，你必須要花上 30 分鐘去做這件事並且`等`它完成才能再繼續回來玩遊戲。
而非同步就是你把任務交給了其他人。你不用在那邊等。

對應到程式，當你在寫 Java, C#, Ruby, Python 時，一般來說你寫的每一行程式都必須等待上一行完成才繼續，他們就是屬於同步的類型。
而 Javascript 不會卡在那邊等待屬於非同步。

# 執行緒(Thread)和程序(Process)

接下來我們會遭遇到更多根本聽不懂在說啥的名詞，在這之前我們必須要先對其有個概念。首先就是 Thread 和 Process。

![](http://image.beekka.com/blog/201304/bg2013042401.jpg)

我們知道電腦的 CPU 是所有計算任務的核心，把它比喻成一座工廠時時刻刻在生產。

![](http://image.beekka.com/blog/201304/bg2013042402.png)

假設說工廠的電力有限，一次只能供應一條產線使用，也就是說一條產線開工的時候其他產線都必須停止。
撇開多核心這件事，這表示一個 CPU 一次只能運行一個任務

![](http://image.beekka.com/blog/201304/bg2013042403.jpg)

而所謂的 Process 程序就好比是工廠的產線，代表著 CPU 所能夠處理的單一任務，任一時間點 CPU 永遠執行著一個程序，其他程序則進入非執行的狀態。

![](http://image.beekka.com/blog/201304/bg2013042404.jpg)

一條產線裡可以有很多工人，他們合作完成一個任務。

![](http://image.beekka.com/blog/201304/bg2013042405.jpg)

Thread 執行緒就好比產線裡的工人，所以一個程序 Process 可以有多個執行緒 Thread

![](http://image.beekka.com/blog/201304/bg2013042406.png)

產線裡面就是這間廠房內的空間是工人們共同使用的，例如有很多房間工人們可以自由進出。意味著程序中的記憶體是共享的，每個 Thread 執行緒都可以共享這些記憶體

![](http://image.beekka.com/blog/201304/bg2013042407.jpg)

可是每個房間大小不同，比如說廁所一間只能容納一個人，裡面有人的時候其他人就不能進去，代表說當一個執行緒使用某些共享記憶體的時候，其他執行緒要等它用完才能使用這塊記憶體

![](http://image.beekka.com/blog/201304/bg2013042408.jpg)

一個要防止他人進入的簡單方式就是上鎖。先進去的人先上鎖後面的人看到上鎖了就只能在門口排隊。等它用完了才進去。
這稱為 Mutual exclusion 互斥鎖，縮寫 Mutex。用來防止多個執行緒讀寫某一塊記憶體。

![](http://image.beekka.com/blog/201304/bg2013042409.jpg)

有些房間可以同時容納 N 個人，例如廚房，也就是說如果人數大於 N 的時候，多出來的人就只能在外面等。

![](http://image.beekka.com/blog/201304/bg2013042410.jpg)

這個時候對應的解決方案就是在門口掛著 N 把鑰匙。要進去的人就拿一把鑰匙開門進去鎖起來，出來的時候再掛回原位。後面來的人看到鑰匙沒了就知道他要在外面排隊等候
這種作法叫做 Semaphore，用來確保多執行緒不會互相衝突。

我們可以發現當 N = 1 的時候後面這種解決方案完全可以取代前者。但是因為 Mutex 較為簡單效率比較好，所以在確保獨佔資源的情況下還是會用 Mutex。

![](http://image.beekka.com/blog/201304/bg2013042411.png)

最後我們可以理解程序和執行緒之間概念上的差異:

1. 多個程序運行，意味著多個任務同時執行
2. 多執行緒則表示單一任務可以切割成不同部分執行。
3. 有一些協調機制可以使用以防止程序和執行緒之間在共享資源時產生的衝突。


# 非阻塞式 IO

理解了同步與非同的概念之後我們需要先對一些常遇到的術語有些瞭解，我們常聽到或看到在 Javascript 中所有的輸入輸出 IO 操作都是非阻塞式的，如果你曾使用過不管是 Java C# Ruby 等語言想像一種情形，當你要讀取某個檔案時這個讀取的動作因為通常會需要點時間，導致中斷後續該執行的程式碼，這就是阻塞了。
簡言之就是在做讀寫檔案，網路請求，資料庫讀取這些需要耗費時間的任務時程式不會停下來等結果。會停下的稱為 Synchronous 或者 Block，不會停下來的就是 Asynchronous 或 Non-Block。

在 Javascript 中包含 HTTP request, 資料庫的操作，硬碟的讀取和寫入，都是屬於非阻塞式的。
也就意味著 Javascript 並不會卡在那邊等待結果傳回，那 Javascript 該怎麼取得最後需要的資料呢？
執行緒會在執行時期要求該項操作傳入一個回呼函式，接著就繼續執行其他的任務。當該操作完成時一個訊息包含著剛剛提供的回呼函式就會被排進佇列中。
接著在適當的時間點這個訊息會被取出然後執行該回呼函式。

雖然對於那些前端工程師來說或許已經很習慣這種模式，例如撰寫在任何時間點當滑鼠點擊按鈕時執行任務的程式(滑鼠事件 mousedown 或者 click )。
這點不同於後端程式的同步機制。光看文字說明似乎有點難理解。讓我們先來看看 Ruby 搭配 Faraday 撰寫 HTTP 向 www.google.com 發送請求

```
response = Faraday.get 'http://www.google.com'
puts response
puts 'Done!'
```

執行的流程如下:

1. Faraday 的 get 方法被執行並且執行緒會在這邊等到 response 收到為止。
2. 這個 response 就是從 Google 那邊取得並且存放該變數裡
3. 透過 puts 將這個變數的內容輸出
4. 輸出 "Done!"

換成 Nodejs 搭配 request 函式的話一樣的任務

```
request('http://www.google.com', function (error, response, body) {
  console.log(body);
});
console.log('Done!');
```

語法看起來有點不同，但背後行為差異更大。

1. 執行 request 函式，傳入一個匿名函式，他就是我們上面說的 callback 會在完成回應時被執行。
2. 在結果還沒回來的時候 'Done!' 馬上就被執行了。
3. 在未來的某個時間點，當請求處理完成時，callback 就會被執行然後輸出 body 的內容。

這樣的運行機制讓執行函式不用去等待回應，也讓 Javascript 可以繼續去做其他事情，等到這件事處理完成 callback 就會觸發。
不過我們可能會好奇這些 callback 到底會被放在記憶體的何處，又是怎麼排列執行順序？是什麼去呼叫他們？

Javascript 執行時期包含著一個訊息佇列，裡面存著將要被運行的訊息列表，這個訊息會和屬於它的 callback 關聯起來，
這些訊息會排進佇列中以回應外部事件像是滑鼠點擊，HTTP 請求的回應

# 事件輪詢 Event Loop 

# 平行(Parallelism)

在計算機世界裡，平行指的是兩件或更多事情在同一時間發生。實際上這邊說的只會發生在當電腦 CPU 有兩個核心時，意味著在任何給定的時間，不同的電子訊號同時被觸發。
附帶一提，我們上面提到的平行發生的`事情`並不是一件複雜的任務例如網路請求(request)和回應(response)。
我們所指的是非常底層的行為，例如將兩個數字相加或者對一個數字做位元的操作移位等。通常我們會稱這些行為為操作(operations)而不是任務(tasks)

也許有點難具體的去描述或用圖片來表示，不過我們在程式世界裡所謂高階的`事情`指的是像排序，資料庫查詢，或者修改文字的樣式與字體，在這些背後電腦實際上會執行非常多底層的操作

# 併發(Concurrency)

併發的意思是兩件或更多的事情發生在同一個時段。不過注意這些`事情`指的是任務(tasks)並不是底層的操作
所以讓我們來比較一下兩者該怎麼區別:

併發的概念是有兩件高階的任務，比如說一個 Ajax request/response 和在捲動事件(scroll event)發生後重繪頁面，這兩個`高階任務`發生在同一個時間。
這兩件事底層的操作不一定是使用平行運算發生在確切的同一個時間。併發並不一定是平行，但包含平行的概念


# 執行緒

平行在程式中通常是透過不同的`執行緒`執行，大略來說我們可以把執行緒想像成一張操作指令的執行順序清單。
系統的執行緒將會去執行這個清單，通常指的就是 CPU 的核心 core。意思是說如果電腦是四核心的話那將會有 4 個系統執行緒可以執行 4 個分開的指令清單。
而所有的指令概念上可以被組合在一起，看起來像一個動作。
如果你的電腦只有四核心，那最多就只有 4 個執行緒可以在同一時間執行，這樣一來對程式而言那麼將會產生許多限制，所以作業系統通常會提供作業系統層級的虛擬執行緒給程式使用
所以在任何一個時間點可以有更多的操作，但主要要看作業系統如何去組織這些任務並交付給實際的執行緒(CPU Core)
作業系統非常擅長編排這些任務，雖然虛擬執行緒可能大於實際執行緒，但這些操作仍會依序執行就好像他們真的同時間發生一樣

# 非同步 Async

那麼關於非同步呢？Javascript 的工程師大部分都很熟悉這部分。因為 Javascript 大量使用非同步的機制有些開發者甚至也知道關於 JS 只使用單一執行緒。
沒錯！從語言的角度來看，Javascript 假設單一程式中一個時間點只會做一件事。
另外 Javascript 函式(function) 具有`一旦執行就需要跑完`的特性，意味著一旦某個 function 先執行了，就不可能被另外一個 function 中斷。
舉例來說 function A 可以呼叫 function B 但是 function B 不會和 A 一起同時開始執行的。

這也表示 A 不需要擔心在 B 產生的狀態異動，除非 A 呼叫 B 時 B 執行完畢了。

以簡單的寫出正確的程式來說，其背後的動機就是要簡化。Javascript 為了簡單的機制，捨棄了多執行緒。
不過因為事件輪詢的機制事實上非常有效率所以 JS 效能上表現得還不錯。
